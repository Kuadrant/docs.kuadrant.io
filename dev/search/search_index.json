{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Kuadrant combines Gateway API and Istio-based gateway controllers to enhance application connectivity. It enables platform engineers and application developers to easily connect, secure, and protect their services and infrastructure across multiple clusters with policies for TLS, DNS, application authentication &amp; authorization, and rate limiting. Additionally, Kuadrant offers observability templates to further support infrastructure management.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For a quick local setup of Kuadrant, see our Single Cluster or Multi Cluster guides. Explore the single and multi-cluster architecture in our Architectural Overview.</p>"},{"location":"getting-started-multi-cluster/","title":"Multi-Cluster","text":""},{"location":"getting-started-multi-cluster/#kuadrant-getting-started-multi-cluster","title":"Kuadrant Getting Started - Multi Cluster","text":""},{"location":"getting-started-multi-cluster/#overview","title":"Overview","text":"<p>In this quick start, we will cover the setup of Kuadrant in multiple local kind clusters. This document is intended as a follow on to the single cluster guide. It can be used for adding 1 or more clusters to your local setup.</p>"},{"location":"getting-started-multi-cluster/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed the Single-cluster Quick Start</li> </ul>"},{"location":"getting-started-multi-cluster/#environmental-variables","title":"Environmental Variables","text":"<p>The same environment variable requirements from the Single-cluster Quick Start apply to this document, including the <code>KUADRANT_REF</code> variable.</p>"},{"location":"getting-started-multi-cluster/#set-up-a-kind-cluster-and-install-kuadrant","title":"Set Up a kind cluster and install Kuadrant","text":"<p>Run the same quickstart script from the single cluster quick start:</p> <pre><code>curl \"https://raw.githubusercontent.com/kuadrant/kuadrant-operator/${KUADRANT_REF}/hack/quickstart-setup.sh\" | bash\n</code></pre> <p>The script will detect if you already have a cluster from the single cluster setup running, and prompt you for a multi cluster setup. This will setup an additional kind cluster, install Istio and install Kuadrant. You can re-run the script multiple times to add more clusters. Each cluster will have a number suffix in the name. For example: <code>kuadrant-local-1</code>, <code>kuadrant-local-2</code>, <code>kuadrant-local-3</code>. The original cluster from the single cluster setup will keep its name of just <code>kuadrant-local</code>.</p>"},{"location":"getting-started-multi-cluster/#clean-up","title":"Clean Up","text":"<p>To ensure that any DNS records are removed, you should remove any <code>DNSPolicy</code> and <code>TLSPolicy</code> resources before deleting the local cluster.</p>"},{"location":"getting-started-multi-cluster/#whats-next","title":"What's Next","text":"<p>The next step is to setup and use the policies provided by Kuadrant. </p> <p>Secure, Protect and Connect your Gateway</p>"},{"location":"getting-started-single-cluster/","title":"Single-Cluster","text":""},{"location":"getting-started-single-cluster/#kuadrant-getting-started-single-cluster","title":"Kuadrant Getting Started - Single Cluster","text":""},{"location":"getting-started-single-cluster/#overview","title":"Overview","text":"<p>In this quick start, we will cover: </p> <ul> <li>setup of Kuadrant in a singe local kind cluster</li> </ul>"},{"location":"getting-started-single-cluster/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker</li> <li>Kind</li> <li>Kubectl</li> <li>Helm</li> <li>OpenSSL &gt;= 3</li> <li>AWS account with Route 53 enabled or GCP with Cloud DNS enabled</li> <li>Docker Mac Net Connect (macOS users only)</li> </ul>"},{"location":"getting-started-single-cluster/#environmental-variables","title":"Environmental Variables","text":""},{"location":"getting-started-single-cluster/#general","title":"General","text":"Env Var Example Value Description <code>ISTIO_INSTALL_SAIL</code> <code>false</code> Whether to install istio through project sail, default <code>true</code> <code>SAIL_VERSION</code> <code>0.1.0</code> Version of the sail-operator to install, default <code>0.1.0</code> <p>If you want to make use of the Kuadrant <code>DNSPolicy</code> you should setup the following environmental variables depending on your DNS Provider:</p>"},{"location":"getting-started-single-cluster/#aws","title":"AWS","text":"Env Var Example Value Description <code>KUADRANT_ZONE_ROOT_DOMAIN</code> <code>jbloggs.hcpapps.net</code> Hostname for the root Domain <code>KUADRANT_AWS_DNS_PUBLIC_ZONE_ID</code> <code>Z01234567US0IQE3YLO00</code> AWS Route 53 Zone ID for specified <code>KUADRANT_ZONE_ROOT_DOMAIN</code> <code>KUADRANT_AWS_ACCESS_KEY_ID</code> <code>AKIA1234567890000000</code> Access Key ID, for user with permissions to Route 53 in the account where root domain is created <code>KUADRANT_AWS_SECRET_ACCESS_KEY</code> <code>Z01234567US0000000</code> Access Secret Access Key, for user with permissions to Route 53 in the account where root domain is created <code>KUADRANT_AWS_REGION</code> <code>eu-west-1</code> AWS Region"},{"location":"getting-started-single-cluster/#gcp","title":"GCP","text":"Env Var Example Value Description <code>GOOGLE</code> <code>{\"client_id\": \"00000000-00000000000000.apps.googleusercontent.com\",\"client_secret\": \"d-FL95Q00000000000000\",\"refresh_token\": \"00000aaaaa00000000-AAAAAAAAAAAAKFGJFJDFKDK\",\"type\": \"authorized_user\"}</code> This is the JSON created from either the JSON credentials created by the Google Cloud CLI or a Service account <code>PROJECT_ID</code> <code>my_project_id</code> ID to the google project <code>ZONE_NAME</code> <code>jbloggs-google</code> Zone name <code>ZONE_DNS_NAME</code> <code>jbloggs.google.hcpapps.net</code> DNS name <code>LOG_LEVEL</code> <code>1</code> Log level for the Controller <p>Alternatively, to set defaults, add the above environment variables to your <code>.zshrc</code> or <code>.bash_profile</code>.</p>"},{"location":"getting-started-single-cluster/#set-the-release-you-want-to-use","title":"Set the release you want to use","text":"<pre><code>export KUADRANT_REF=main\n</code></pre>"},{"location":"getting-started-single-cluster/#set-up-a-kind-cluster-and-install-kuadrant","title":"Set Up a kind cluster and install Kuadrant","text":"<p>Run the following:</p> <p><pre><code>curl \"https://raw.githubusercontent.com/kuadrant/kuadrant-operator/${KUADRANT_REF}/hack/quickstart-setup.sh\" | bash\n</code></pre> This will setup a single kind cluster, install Istio and install Kuadrant. Once this completes you should be able to move on to using the various policy apis offered by Kuadrant.</p>"},{"location":"getting-started-single-cluster/#clean-up","title":"Clean Up","text":"<p>To ensure that any DNS records are removed, you should remove any <code>DNSPolicy</code> and <code>TLSPolicy</code> resources before deleting the local cluster.</p>"},{"location":"getting-started-single-cluster/#whats-next","title":"What's Next","text":"<p>The next step is to setup and use the policies provided by Kuadrant. </p> <p>Secure, Protect and Connect your Gateway</p>"},{"location":"kuadrant-operator/","title":"Kuadrant Operator","text":"<p>The Operator to install and manage the lifecycle of the Kuadrant components deployments.</p>"},{"location":"kuadrant-operator/#overview","title":"Overview","text":"<p>Kuadrant is a re-architecture of API Management using Cloud Native concepts and separating the components to be less coupled, more reusable and leverage the underlying kubernetes platform. It aims to deliver a smooth experience to providers and consumers of applications &amp; services when it comes to rate limiting, authentication, authorization, discoverability, change management, usage contracts, insights, etc.</p> <p>Kuadrant aims to produce a set of loosely coupled functionalities built directly on top of Kubernetes. Furthermore, it only strives to provide what Kubernetes doesn\u2019t offer out of the box, i.e. Kuadrant won\u2019t be designing a new Gateway/proxy, instead it will opt to connect with what\u2019s there and what\u2019s being developed (think Envoy, Istio, GatewayAPI).</p> <p>Kuadrant is a system of cloud-native k8s components that grows as users\u2019 needs grow.</p> <ul> <li>From simple protection of a Service (via AuthN) that is used by teammates working on the same cluster, or \u201csibling\u201d services, up to AuthZ of users using OIDC plus custom policies.</li> <li>From no rate-limiting to rate-limiting for global service protection on to rate-limiting by users/plans</li> </ul>"},{"location":"kuadrant-operator/#architecture","title":"Architecture","text":"<p>Kuadrant relies on the Gateway API and one Gateway API provider being installed on the cluster. Currently only Istio and EnvoyGateway are supported to operate the cluster ingress gateway to provide API management with authentication (authN), authorization (authZ) and rate limiting capabilities.</p>"},{"location":"kuadrant-operator/#kuadrant-components","title":"Kuadrant components","text":"CRD Description Control Plane The control plane takes the customer desired configuration (declaratively as kubernetes custom resources) as input and ensures all components are configured to obey customer's desired behavior. This repository contains the source code of the kuadrant control plane Kuadrant Operator A Kubernetes Operator to manage the lifecycle of the kuadrant deployment Authorino The AuthN/AuthZ enforcer. As the external istio authorizer (envoy external authorization serving gRPC service) Limitador The external rate limiting service. It exposes a gRPC service implementing the Envoy Rate Limit protocol (v3) Authorino Operator A Kubernetes Operator to manage Authorino instances Limitador Operator A Kubernetes Operator to manage Limitador instances DNS Operator A Kubernetes Operator to manage DNS records in external providers"},{"location":"kuadrant-operator/#provided-apis","title":"Provided APIs","text":"<p>The kuadrant control plane owns the following Custom Resource Definitions, CRDs:</p> CRD Description Example AuthPolicy CRD [doc] [reference] Enable AuthN and AuthZ based access control on workloads AuthPolicy CR RateLimitPolicy CRD [doc] [reference] Enable access control on workloads based on HTTP rate limiting RateLimitPolicy CR DNSPolicy CRD [doc] [reference] Enable DNS management DNSPolicy CR TLSPolicy CRD [doc] [reference] Enable TLS management TLSPolicy CR <p>Additionally, Kuadrant provides the following CRDs</p> CRD Owner Description Example Kuadrant CRD Kuadrant Operator Represents an instance of kuadrant Kuadrant CR Limitador CRD Limitador Operator Represents an instance of Limitador Limitador CR Authorino CRD Authorino Operator Represents an instance of Authorino Authorino CR <p></p>"},{"location":"kuadrant-operator/#getting-started","title":"Getting started","text":""},{"location":"kuadrant-operator/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Istio or Envoy Gateway is installed in the cluster. Otherwise, refer to the   Istio getting started guide   or EnvoyGateway getting started guide.</li> <li>Kubernetes Gateway API is installed in the cluster.</li> <li>cert-manager is installed in the cluster. Otherwise, refer to the   cert-manager installation guide.</li> </ul>"},{"location":"kuadrant-operator/#installing-kuadrant","title":"Installing Kuadrant","text":"<p>Installing Kuadrant is a two-step procedure. Firstly, install the Kuadrant Operator and secondly, request a Kuadrant instance by creating a Kuadrant custom resource.</p>"},{"location":"kuadrant-operator/#1-install-the-kuadrant-operator","title":"1. Install the Kuadrant Operator","text":"<p>The Kuadrant Operator is available in public community operator catalogs, such as the Kubernetes OperatorHub.io and the Openshift Container Platform and OKD OperatorHub.</p> <p>Kubernetes</p> <p>The operator is available from OperatorHub.io. Just go to the linked page and follow installation steps (or just run these two commands):</p> <pre><code># Install Operator Lifecycle Manager (OLM), a tool to help manage the operators running on your cluster.\n\ncurl -sL https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.23.1/install.sh | bash -s v0.23.1\n\n# Install the operator by running the following command:\n\nkubectl create -f https://operatorhub.io/install/kuadrant-operator.yaml\n</code></pre> <p>Openshift</p> <p>The operator is available from the Openshift Console OperatorHub. Just follow installation steps choosing the \"Kuadrant Operator\" from the catalog:</p> <p></p>"},{"location":"kuadrant-operator/#2-request-a-kuadrant-instance","title":"2. Request a Kuadrant instance","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace kuadrant\n</code></pre> <p>Apply the <code>Kuadrant</code> custom resource:</p> <pre><code>kubectl -n kuadrant apply -f - &lt;&lt;EOF\n---\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant-sample\nspec: {}\nEOF\n</code></pre>"},{"location":"kuadrant-operator/#protect-your-service","title":"Protect your service","text":""},{"location":"kuadrant-operator/#if-you-are-an-api-provider","title":"If you are an API Provider","text":"<ul> <li>Deploy the service/API to be protected (\"Upstream\")</li> <li>Expose the service/API using the kubernetes Gateway API, ie   HTTPRoute object.</li> <li>Write and apply the Kuadrant's RateLimitPolicy and/or   AuthPolicy custom resources targeting the HTTPRoute resource   to have your API protected.</li> </ul>"},{"location":"kuadrant-operator/#if-you-are-a-cluster-operator","title":"If you are a Cluster Operator","text":"<ul> <li>(Optionally) deploy ingress gateway using the   Gateway resource.</li> <li>Write and apply the Kuadrant's RateLimitPolicy and/or   AuthPolicy custom resources targeting the Gateway resource   to have your gateway traffic protected.</li> </ul>"},{"location":"kuadrant-operator/#user-guides","title":"User guides","text":"<p>The user guides section of the docs gathers several use-cases as well as the instructions to implement them using kuadrant.</p> <ul> <li>Simple Rate Limiting for Application Developers</li> <li>Authenticated Rate Limiting for Application Developers</li> <li>Gateway Rate Limiting for Cluster Operators</li> <li>Authenticated Rate Limiting with JWTs and Kubernetes RBAC</li> </ul>"},{"location":"kuadrant-operator/#kuadrant-rate-limiting","title":"Kuadrant Rate Limiting","text":""},{"location":"kuadrant-operator/#documentation","title":"Documentation","text":"<p>Docs can be found on the Kuadrant website.</p>"},{"location":"kuadrant-operator/#contributing","title":"Contributing","text":"<p>The Development guide describes how to build the kuadrant operator and how to test your changes before submitting a patch or opening a PR.</p> <p>Join us on the #kuadrant channel in the Kubernetes Slack workspace, for live discussions about the roadmap and more.</p>"},{"location":"kuadrant-operator/#licensing","title":"Licensing","text":"<p>This software is licensed under the Apache 2.0 license.</p> <p>See the LICENSE and NOTICE files that should have been provided along with this software for details.</p> <p></p>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/","title":"Install Kuadrant on a Kubernetes cluster","text":"<p>Note</p> <p>You must perform these steps on each Kubernetes cluster where you want to use Kuadrant.</p> <p>Warning</p> <p>Kuadrant uses a number of labels to search and filter resources on the cluster. All required labels are formatted as <code>kuadrant.io/*</code>. Removal of any labels with the prefix may cause unexpected behaviour and degradation of the product.</p>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#prerequisites","title":"Prerequisites","text":"<ul> <li>Access to a Kubernetes cluster, with <code>kubeadmin</code> or an account with similar permissions</li> <li><code>cert-manager</code> installed</li> </ul>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#procedure","title":"Procedure","text":"<p>This guide will show you how to install Kuadrant onto a bare Kubernetes cluster.</p> <p>Alternatively, if you are looking instead for a way to set up Kuadrant locally to evaluate or develop, consider running the kind &amp; Kubernetes quickstart script.</p>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#install-gateway-api","title":"Install Gateway API","text":"<pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.1.0/standard-install.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#install-olm","title":"Install OLM","text":"<p>Note</p> <p>Currently, we recommend installing our operator via OLM. We plan to support Helm soon.</p> <pre><code>curl -sL https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.28.0/install.sh | bash -s v0.28.0\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#optional-install-istio-as-a-gateway-api-provider","title":"(Optional) Install Istio as a Gateway API provider","text":"<p>Note</p> <p>Skip this step if planing to use Envoy Gateway as Gateway API provider</p> <p>There are several ways to install Istio (via <code>istioctl</code>, Helm chart or Operator) - this is just an example for starting from a bare Kubernetes cluster.</p> <pre><code>curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.22.5 sh -\n./istio-1.22.5/bin/istioctl install --set profile=minimal\n./istio-1.22.5/bin/istioctl operator init\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/main/config/dependencies/istio/istio-operator.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#optional-install-envoy-gateway-as-a-gateway-api-provider","title":"(Optional) Install Envoy Gateway as a Gateway API provider","text":"<p>Note</p> <p>Skip this step if planing to use Istio as Gateway API provider</p> <p>There are several ways to install Envoy Gateway (via <code>egctl</code>, Helm chart or Kubernetes yaml) - this is just an example for starting from a bare Kubernetes cluster.</p> <pre><code>helm install eg oci://docker.io/envoyproxy/gateway-helm --version v1.1.0 -n envoy-gateway-system --create-namespace\n</code></pre> <p>Kuadrant relies on the Envoy Gateway patch policy feature to function correctly - enable the EnvoyPatchPolicy feature like so:</p> <pre><code>TMP=$(mktemp -d)\nkubectl get configmap -n envoy-gateway-system envoy-gateway-config -o jsonpath='{.data.envoy-gateway\\.yaml}' &gt; ${TMP}/envoy-gateway.yaml\nyq e '.extensionApis.enableEnvoyPatchPolicy = true' -i ${TMP}/envoy-gateway.yaml\nkubectl create configmap -n envoy-gateway-system envoy-gateway-config --from-file=envoy-gateway.yaml=${TMP}/envoy-gateway.yaml -o yaml --dry-run=client | kubectl replace -f -\nkubectl rollout restart deployment envoy-gateway -n envoy-gateway-system\n</code></pre> <p>Wait for Envoy Gateway to become available:</p> <pre><code>kubectl wait --timeout=5m -n envoy-gateway-system deployment/envoy-gateway --for=condition=Available\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#install-kuadrant","title":"Install Kuadrant","text":"<pre><code>kubectl create -f https://operatorhub.io/install/kuadrant-operator.yaml\nkubectl get crd --watch | grep -m 1 \"kuadrants.kuadrant.io\"\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#request-a-kuadrant-instance","title":"Request a Kuadrant instance","text":"<pre><code>kubectl create namespace kuadrant-system\nkubectl -n kuadrant-system apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\nspec: {}\nEOF\n</code></pre> <p>Kuadrant should now install. You can check the operator's install status with:</p> <pre><code>kubectl wait --for=jsonpath='{.status.state}'=AtLatestKnown subscription/my-kuadrant-operator -n operators --timeout=600s\n</code></pre> <p>Kuadrant is now ready to use.</p>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#optional-observability-setup-istio-only","title":"(Optional) Observability setup (Istio only)","text":"<p>There is a set of example dashboards and alerts in the kuadrant-operator repo that can be used for obserability of the Kuadrant components and gateway. To make use of these, first install the example monitoring stack and configuration:</p> <pre><code>kubectl apply -k github.com/Kuadrant/kuadrant-operator/config/observability?ref=main --dry-run=client -o yaml | docker run --rm -i docker.io/ryane/kfilt -i kind=CustomResourceDefinition | kubectl apply --server-side -f -\nkubectl apply -k github.com/Kuadrant/kuadrant-operator/config/observability?ref=main --dry-run=client -o yaml | docker run --rm -i docker.io/ryane/kfilt -x kind=CustomResourceDefinition | kubectl apply -f -\nkubectl apply -k github.com/Kuadrant/kuadrant-operator/config/thanos?ref=main\nkubectl apply -k github.com/Kuadrant/kuadrant-operator/examples/dashboards?ref=main\nkubectl apply -k github.com/Kuadrant/kuadrant-operator/examples/alerts?ref=main\nTHANOS_RECEIVE_ROUTER_IP=$(kubectl -n monitoring get svc thanos-receive-router-lb -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\nkubectl -n monitoring patch prometheus k8s --type='merge' -p '{\"spec\":{\"remoteWrite\":[{\"url\":\"http://'\"$THANOS_RECEIVE_ROUTER_IP\"':19291/api/v1/receive\", \"writeRelabelConfigs\":[{\"action\":\"replace\", \"replacement\":\"'\"$KUADRANT_CLUSTER_NAME\"'\", \"targetLabel\":\"cluster_id\"}]}]}}'\nkubectl apply -k github.com/Kuadrant/kuadrant-operator/config/observability/prometheus/monitors/istio?ref=main\n</code></pre> <p>This will deploy prometheus, alertmanager and Grafana into the monitoring namespace, along with metrics scrape configuration for Istio and Envoy Proxy. Thanos will also be deployed with prometheus configured to remote write to it.</p> <p>To access Grafana and Prometheus, you can port forward to the services:</p> <pre><code>kubectl -n monitoring port-forward service/grafana 3000:3000\n</code></pre> <p>The Grafana UI can then be found at http://127.0.0.1:3000/ (default user/pass of admin &amp; admin).</p> <pre><code>kubectl -n monitoring port-forward service/prometheus-k8s 9090:9090\n</code></pre> <p>The Prometheus UI can then be found at http://127.0.0.1:9090.</p>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#optional-dnspolicy-setup","title":"(Optional) <code>DNSPolicy</code> setup","text":"<p>If you plan to use <code>DNSPolicy</code>, this doc uses an AWS Account with access to Route 53. There are other providers that you can also use for DNS integration: </p> <p>DNS Providers</p> <p>Export the following environment variables for setup:</p> <pre><code>export AWS_ACCESS_KEY_ID=xxxxxxx # Key ID from AWS with Route 53 access\nexport AWS_SECRET_ACCESS_KEY=xxxxxxx # Access key from AWS with Route 53 access\n</code></pre> <p>Create an AWS credentials secret:</p> <pre><code>kubectl -n kuadrant-system create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#optional-multi-cluster-ratelimitpolicy","title":"(Optional) Multi-cluster <code>RateLimitPolicy</code>","text":"<p>To enable <code>RateLimitPolicy</code> to use shared, multi-cluster counters for Kuadrant's Limitador component, you need to configure Kuadrant with a Redis cluster URL. Redis URIs can be either <code>redis://</code> for standard connections or <code>rediss://</code> for secure connections.</p> <p>Follow these steps to create the necessary secret:</p> <ol> <li> <p>Replace <code>some-redis.com:6379</code> with the URL of your accessible Redis cluster. Ensure you include the appropriate URI scheme (<code>redis://</code> or <code>rediss://</code>).</p> </li> <li> <p>Execute the following commands:</p> <pre><code># Replace this with an accessible Redis cluster URL\nexport REDIS_URL=redis://user:xxxxxx@some-redis.com:6379\n</code></pre> </li> <li> <p>Create the secret:</p> <pre><code>kubectl -n kuadrant-system create secret generic redis-config \\\n  --from-literal=URL=$REDIS_URL\n</code></pre> </li> </ol> <p>This will create a secret named <code>redis-config</code> in the <code>kuadrant-system</code> namespace containing your Redis cluster URL, which Kuadrant will use for multi-cluster rate limiting.</p> <p>You'll also need to update the <code>Limitador</code> instance (the component that handles rate limiting) to reconfigure Kuadrant to use Redis:</p> <pre><code>kubectl patch limitador limitador --type=merge -n kuadrant-system -p '\nspec:\n  storage:\n    redis:\n      configSecretRef:\n        name: redis-config\n'\n\nkubectl wait limitador/limitador -n kuadrant-system --for=\"condition=Ready=true\"\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#metal-lb-local-setup","title":"Metal LB (local setup)","text":"<p>If you are using a local kind cluster, we recommend using metallb to allow the service type loadbalancer to be used with your gateways and an IP to be assigned to your gateway address rather than an internal service name.</p>"},{"location":"kuadrant-operator/doc/install/install-kubernetes/#next-steps","title":"Next Steps","text":"<ul> <li>Secure, protect, and connect APIs with Kuadrant on Kubernetes</li> </ul>"},{"location":"kuadrant-operator/doc/install/install-make/","title":"Installing Kuadrant via make targets","text":""},{"location":"kuadrant-operator/doc/install/install-make/#overview","title":"Overview","text":"<p>The following doc will show you how to install the Kuadrant Operator using make targets in the Kuadrant operator repo. What will be installed is Istio, Kubernetes Gateway API and Kuadrant itself.</p> <p>For other methods of installation see</p> <ul> <li>k8s</li> <li>Openshift</li> </ul> <p>Note: In production environment, these steps are usually performed by a cluster operator with administrator privileges over the Kubernetes cluster.</p>"},{"location":"kuadrant-operator/doc/install/install-make/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>Kind</li> <li>Docker or Podman</li> </ul>"},{"location":"kuadrant-operator/doc/install/install-make/#setup","title":"Setup","text":"<p>Clone the project: <pre><code>git clone https://github.com/Kuadrant/kuadrant-operator &amp;&amp; cd kuadrant-operator\n</code></pre></p> <p>Setup the environment (This will also create a kind cluster. If your using Pod man use the env var CONTAINER_ENGINE=podman with the make target below.): <pre><code>make local-setup\n</code></pre></p> <p>Request an instance of Kuadrant: <pre><code>kubectl -n kuadrant-system apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\nspec: {}\nEOF\n</code></pre></p>"},{"location":"kuadrant-operator/doc/install/install-openshift/","title":"Install Kuadrant on an OpenShift cluster","text":"<p>Note</p> <p>You must perform these steps on each OpenShift cluster that you want to use Kuadrant on.</p> <p>In this document we use AWS route 53 as the example setup.</p> <p>Warning</p> <p>Kuadrant uses a number of labels to search and filter resources on the cluster. All required labels are formatted as <code>kuadrant.io/*</code>. Removal of any labels with the prefix may cause unexpected behaviour and degradation of the product.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#prerequisites","title":"Prerequisites","text":"<ul> <li>OpenShift Container Platform 4.16.x or later with community Operator catalog available.</li> <li>AWS/Azure or GCP with DNS capabilities.</li> <li>Accessible Redis instance.</li> </ul>"},{"location":"kuadrant-operator/doc/install/install-openshift/#procedure","title":"Procedure","text":""},{"location":"kuadrant-operator/doc/install/install-openshift/#step-1-set-up-your-environment","title":"Step 1 - Set up your environment","text":"<p>We use env vars for convenience only here. If you know these values you can setup the required yaml files in anyway that suites your needs.</p> <pre><code>export AWS_ACCESS_KEY_ID=xxxxxxx # Key ID from AWS with Route 53 access\nexport AWS_SECRET_ACCESS_KEY=xxxxxxx # Access key from AWS with Route 53 access\nexport REDIS_URL=redis://user:xxxxxx@some-redis.com:10340 # A Redis cluster URL\n</code></pre> <p>Set the version of Kuadrant to the latest released version: https://github.com/Kuadrant/kuadrant-operator/releases/</p> <pre><code>export KUADRANT_VERSION='vX.Y.Z'\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-2-install-gateway-api-v1","title":"Step 2 - Install Gateway API v1","text":"<p>Before you can use Kuadrant, you must install Gateway API v1 as follows:</p> <pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.1.0/standard-install.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-3-install-cert-manager","title":"Step 3 - Install cert-manager","text":"<p>Before you can use Kuadrant, you must install cert-manager. Cert-Manager is used by kuadrant to manage TLS certificates for your gateways.</p> <p>The minimum supported version of cert-manager is v1.14.0.</p> <p>Install one of the different flavours of the Cert-Manager.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#install-community-version-of-the-cert-manager","title":"Install community version of the cert-manager","text":"<p>Consider installing cert-manager via OperatorHub, which you can do from the OpenShift web console.</p> <p>More installation options at cert-manager.io</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#install-cert-manager-operator-for-red-hat-openshift","title":"Install cert-manager Operator for Red Hat OpenShift","text":"<p>You can install the cert-manager Operator for Red Hat OpenShift by using the web console.</p> <p>Note: Before using Kuadrant's <code>TLSPolicy</code> you will need to setup a certificate issuer refer to the cert-manager docs for more details</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-4-optional-install-and-configure-istio-with-the-sail-operator","title":"Step 4 - (Optional) Install and configure Istio with the Sail Operator","text":"<p>Note</p> <p>Skip this step if planing to use Envoy Gateway as Gateway API provider</p> <p>Kuadrant integrates with Istio as a Gateway API provider. You can set up an Istio-based Gateway API provider by using the Sail Operator.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#install-istio","title":"Install Istio","text":"<p>To install the Istio Gateway provider, run the following commands:</p> <pre><code>kubectl create ns gateway-system\n</code></pre> <pre><code>kubectl  apply -f - &lt;&lt;EOF\nkind: OperatorGroup\napiVersion: operators.coreos.com/v1\nmetadata:\n  name: sail\n  namespace: gateway-system\nspec:\n  upgradeStrategy: Default\n---\napiVersion: operators.coreos.com/v1alpha1\nkind: Subscription\nmetadata:\n  name: sailoperator\n  namespace: gateway-system\nspec:\n  channel: candidates\n  installPlanApproval: Automatic\n  name: sailoperator\n  source: community-operators\n  sourceNamespace: openshift-marketplace\nEOF\n</code></pre> <p>Check the status of the installation as follows:</p> <pre><code>kubectl get installplan -n gateway-system -o=jsonpath='{.items[0].status.phase}'\n</code></pre> <p>When ready, the status will change from <code>installing</code> to <code>complete</code>.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#configure-istio","title":"Configure Istio","text":"<p>To configure the Istio Gateway API provider, run the following command:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: sailoperator.io/v1alpha1\nkind: Istio\nmetadata:\n  name: default\nspec:\n  namespace: gateway-system\n  updateStrategy:\n    type: InPlace\n    inactiveRevisionDeletionGracePeriodSeconds: 30\n  version: v1.23.0\n  values:\n    pilot:\n      autoscaleEnabled: false\nEOF\n</code></pre> <p>More details on what can be configured can be found by executing</p> <pre><code> kubectl explain istio.spec.values\n</code></pre> <p>And in documention : Istio Config</p> <p>Wait for Istio to be ready as follows:</p> <pre><code>kubectl wait istio.sailoperator.io/default -n gateway-system --for=\"condition=Ready=true\"\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-5-optional-install-envoy-gateway-as-a-gateway-api-provider","title":"Step 5 - (Optional) Install Envoy Gateway as a Gateway API provider","text":"<p>Note</p> <p>Skip this step if planing to use Istio as Gateway API provider</p> <p>Note</p> <p>There are several ways to install Envoy Gateway (via <code>egctl</code>, Helm chart or Kubernetes yaml) - this is just an example for starting from a bare Kubernetes cluster.</p> <pre><code>helm install eg oci://docker.io/envoyproxy/gateway-helm --version v1.1.0 -n envoy-gateway-system --create-namespace\n</code></pre> <p>Enable EnvoyPatchPolicy feature:</p> <pre><code>TMP=$(mktemp -d)\nkubectl get configmap -n envoy-gateway-system envoy-gateway-config -o jsonpath='{.data.envoy-gateway\\.yaml}' &gt; ${TMP}/envoy-gateway.yaml\nyq e '.extensionApis.enableEnvoyPatchPolicy = true' -i ${TMP}/envoy-gateway.yaml\nkubectl create configmap -n envoy-gateway-system envoy-gateway-config --from-file=envoy-gateway.yaml=${TMP}/envoy-gateway.yaml -o yaml --dry-run=client | kubectl replace -f -\nkubectl rollout restart deployment envoy-gateway -n envoy-gateway-system\n</code></pre> <p>Wait for Envoy Gateway to become available::</p> <pre><code>kubectl wait --timeout=5m -n envoy-gateway-system deployment/envoy-gateway --for=condition=Available\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-6-optional-configure-observability-and-metrics-istio-only","title":"Step 6 - Optional: Configure observability and metrics (Istio only)","text":"<p>Kuadrant provides a set of example dashboards that use known metrics exported by Kuadrant and Gateway components to provide insight into different components of your APIs and Gateways. While not essential, it is recommended to set these up. First, enable monitoring for user-defined projects. This will allow the scraping of metrics from the gateway and Kuadrant components. The example dashboards and alerts for observing Kuadrant functionality use low-level CPU metrics and network metrics available from the user monitoring stack in OpenShift. They also use resource state metrics from Gateway API and Kuadrant resources.</p> <p>To scrape these additional metrics, you can install a <code>kube-state-metrics</code> instance, with a custom resource configuration as follows:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/main/config/observability/openshift/kube-state-metrics.yaml\nkubectl apply -k https://github.com/Kuadrant/gateway-api-state-metrics/config/kuadrant?ref=0.6.0\n</code></pre> <p>To enable request metrics in Istio and scrape them, create the following resource:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/refs/heads/main/config/observability/prometheus/monitors/istio/service-monitor-istiod.yaml\n</code></pre> <p>Some example dashboards show aggregations based on the path of requests. By default, Istio metrics don't include labels for request paths. However, you can enable them with the below Telemetry resource. Note that this may lead to a high cardinality label where multiple time-series are generated, which can have an impact on performance and resource usage.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/main/config/observability/openshift/telemetry.yaml\n</code></pre> <p>You can configure scraping of metrics from the various Kuadrant operators with the below resources.</p> <pre><code>kubectl create ns kuadrant-system\nkubectl apply -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/refs/heads/main/config/observability/prometheus/monitors/operators.yaml\n</code></pre> <p>Note</p> <p>There is 1 more metrics configuration that needs to be applied so that all relevant metrics are being scraped. That configuration depends on where you deploy your Gateway later. The steps to configure that are detailed in the follow on Secure, protect, and connect guide.</p> <p>The example Grafana dashboards and alerts for observing Kuadrant functionality use low-level CPU metrics and network metrics available from the user monitoring stack in OpenShift. They also use resource state metrics from Gateway API and Kuadrant resources.</p> <p>For Grafana installation details, see installing Grafana on OpenShift. That guide also explains how to set up a data source for the Thanos Query instance in OpenShift. For more detailed information about accessing the Thanos Query endpoint, see the OpenShift documentation.</p> <p>Note</p> <p>For some dashboard panels to work correctly, HTTPRoutes must include a \"service\" and \"deployment\" label with a value that matches the name of the service &amp; deployment being routed to. eg. \"service=myapp, deployment=myapp\". This allows low level Istio &amp; envoy metrics to be joined with Gateway API state metrics.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-7-setup-the-catalogsource","title":"Step 7 - Setup the catalogsource","text":"<p>Before installing the Kuadrant Operator, you must enter the following commands to set up secrets that you will use later. If you haven't aleady created the <code>kuadrant-system</code> namespace during the optional observability setup, do that first:</p> <pre><code>kubectl create ns kuadrant-system\n</code></pre> <p>Set up a <code>CatalogSource</code> as follows:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: operators.coreos.com/v1alpha1\nkind: CatalogSource\nmetadata:\n  name: kuadrant-operator-catalog\n  namespace: kuadrant-system\nspec:\n  sourceType: grpc\n  image: quay.io/kuadrant/kuadrant-operator-catalog:${KUADRANT_VERSION}\n  displayName: Kuadrant Operators\n  publisher: grpc\n  updateStrategy:\n    registryPoll:\n      interval: 45m\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-8-install-the-kuadrant-operator","title":"Step 8 - Install the Kuadrant Operator","text":"<p>To install the Kuadrant Operator, enter the following command:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: operators.coreos.com/v1alpha1\nkind: Subscription\nmetadata:\n  name: kuadrant-operator\n  namespace: kuadrant-system\nspec:\n  channel: stable\n  installPlanApproval: Automatic\n  name: kuadrant-operator\n  source: kuadrant-operator-catalog\n  sourceNamespace: kuadrant-system\n---\nkind: OperatorGroup\napiVersion: operators.coreos.com/v1\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\nspec:\n  upgradeStrategy: Default\nEOF\n</code></pre> <p>Wait for the Kuadrant Operators to be installed as follows:</p> <pre><code>kubectl get installplan -n kuadrant-system -o=jsonpath='{.items[0].status.phase}'\n</code></pre> <p>After some time, this command should return <code>complete</code>.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#set-up-a-dnsprovider","title":"Set up a DNSProvider","text":"<p>The example here is for AWS Route 53. It is important the secret for the DNSProvider is setup in the same namespace as the gateway.</p> <pre><code># note ingress-gateway is just an example\n\nkubectl create ns ingress-gateway\n</code></pre> <pre><code>kubectl -n ingress-gateway create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\n</code></pre> <p>For more details on other providers take a look at DNS Providers</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#setup-tls-dns-verification-credential","title":"Setup TLS DNS verification credential","text":"<p>When setting up TLS certs via provider like lets-encrypt, cert-manager will do a DNS based verification. To allow it do this, it will need a similar credential to that one set up for the DNSProvider, but it needs to be created in the cert-manager namespace where the operator is installed.</p> <pre><code>kubectl -n cert-manager create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-9-install-kuadrant-components","title":"Step 9 - Install Kuadrant Components","text":"<p>To trigger your Kuadrant deployment, enter the following command:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\n\nEOF\n</code></pre> <p>Wait for Kuadrant to be ready as follows:</p> <pre><code>kubectl wait kuadrant/kuadrant --for=\"condition=Ready=true\" -n kuadrant-system --timeout=300s\n</code></pre> <p>This will setup and configure a number of Kuadrant subcomponents. Some of these can also take additional configuration:</p> <ul> <li>Authorino (Enforcement Component for AuthPolicy)</li> <li>Learn More: (Authorino CRD)[https://docs.kuadrant.io/latest/authorino-operator/#the-authorino-custom-resource-definition-crd]</li> <li>Limitador (Enforcement Component for RateLimitPolicy)</li> <li>Learn More:(Limitador CRD)[https://docs.kuadrant.io/latest/limitador-operator/#features]</li> <li>DNS Operator (Enforcement Component for DNSPOlicy)</li> </ul>"},{"location":"kuadrant-operator/doc/install/install-openshift/#configuring-redis-storage-for-limitador","title":"Configuring Redis Storage for Limitador","text":""},{"location":"kuadrant-operator/doc/install/install-openshift/#redis-credentials-for-storage-of-rate-limiting-counters","title":"Redis credentials for storage of rate limiting counters","text":"<p>In this installation we will show how to configure ratelimiting counters to be stored in redis. Before we go further we need to setup a redis secret to use later:</p> <pre><code>kubectl -n kuadrant-system create secret generic redis-credential --from-literal=\"URL\"=$REDIS_URL\n</code></pre>"},{"location":"kuadrant-operator/doc/install/install-openshift/#update-limitador-config","title":"Update limitador config","text":"<p>To configure redis storage for Limatador, we must update the Limitador custom resource to use the secret we created:</p> <p>You can run a command like the one below to add this configuration:</p> <pre><code>kubectl patch limitador limitador --type=merge -n kuadrant-system -p '\nspec:\n  storage:\n    redis:\n      configSecretRef:\n        name: redis-credential\n'\n</code></pre> <p>Check that limitador is back to ready:</p> <pre><code>kubectl wait limitador/limitador -n kuadrant-system --for=\"condition=Ready=true\"\n</code></pre> <p>Kuadrant is now ready to use.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#step-10-configure-the-kuadrant-console-plugin","title":"Step 10 - Configure the Kuadrant Console Plugin","text":"<p>When running on OpenShift, the Kuadrant Operator will automatically install and configure the Kuadrant dynamic console plugin.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#enable-the-console-plugin","title":"Enable the Console Plugin","text":"<p>To enable the Kuadrant console plugin:</p> <ol> <li>Log in to OpenShift or OKD as an administrator.</li> <li>Switch to the Admin perspective.</li> <li>Navigate to Home &gt; Overview.</li> <li>In the Dynamic Plugins section of the status box, click View all.</li> <li>In the Console plugins area, find the <code>kuadrant-console-plugin</code> plugin. It should be listed but disabled.</li> <li>Click the Disabled button next to the <code>kuadrant-console-plugin</code> plugin.</li> <li>Select the Enabled radio button, and then click Save.</li> <li>Wait for the plugin status to change to Loaded.</li> </ol> <p>Once the plugin is loaded, refresh the console. You should see a new Kuadrant section in the navigation sidebar.</p>"},{"location":"kuadrant-operator/doc/install/install-openshift/#next-steps","title":"Next steps","text":"<ul> <li>Secure, protect, and connect APIs with Kuadrant on OpenShift</li> </ul>"},{"location":"kuadrant-operator/doc/observability/examples/","title":"Example Dashboards and Alerts","text":"<p>Explore a variety of starting points for monitoring your Kuadrant installation with our examples folder. These dashboards and alerts are ready-to-use and easily customizable to fit your environment.</p> <p>There are some example dashboards uploaded to Grafana.com . You can use the ID's listed below to import these dashboards into Grafana:</p> Name ID App Developer Dashboard <code>21538</code> Business User Dashboard <code>20981</code> Platform Engineer Dashboard <code>20982</code>"},{"location":"kuadrant-operator/doc/observability/examples/#dashboards","title":"Dashboards","text":""},{"location":"kuadrant-operator/doc/observability/examples/#importing-dashboards-into-grafana","title":"Importing Dashboards into Grafana","text":"<p>For more details on how to import dashboards into Grafana, visit the import dashboards page. </p> <ul> <li>UI Method:<ul> <li>JSON -  Use the 'Import' feature in the Grafana UI to upload dashboard JSON files directly.</li> <li>ID - Use the 'Import' feature in the Grafana UI to import via Grafana.com using a Dashboard ID. </li> </ul> </li> <li>ConfigMap Method: Automate dashboard provisioning by adding files to a ConfigMap, which should be mounted at <code>/etc/grafana/provisioning/dashboards</code>.</li> </ul> <p>Datasources are configured as template variables, automatically integrating with your existing data sources. Metrics for these dashboards are sourced from Prometheus. For more details on the metrics used, visit the metrics documentation page.</p>"},{"location":"kuadrant-operator/doc/observability/examples/#alerts","title":"Alerts","text":""},{"location":"kuadrant-operator/doc/observability/examples/#setting-up-alerts-in-prometheus","title":"Setting Up Alerts in Prometheus","text":"<p>You can integrate the example alerts into Prometheus as <code>PrometheusRule</code> resources. Feel free to adjust alert thresholds to suit your specific operational needs.</p> <p>Additionally, Service Level Objective (SLO) alerts generated with Sloth are included. A benefit of these alerts is the ability to integrate them with this SLO dashboard, which utilizes generated labels to comprehensively overview your SLOs.</p> <p>Further information on the metrics used for these alerts can be found on the metrics page.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/","title":"Metrics","text":"<p>This is a reference page for some of the different metrics used in example dashboards and alerts. It is not an exhaustive list. The documentation for each component may provide more details on a per-component basis. Some of the metrics are sourced from components outside the Kuadrant project, for example, Envoy. The value of this reference is showing some of the more widely desired metrics, and how to join the metrics from different sources together in a meaningful way.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#metrics-sources","title":"Metrics sources","text":"<ul> <li>Kuadrant components</li> <li>Istio</li> <li>Envoy</li> <li>Kube State Metrics</li> <li>Gateway API State Metrics</li> <li>Kubernetes metrics</li> </ul>"},{"location":"kuadrant-operator/doc/observability/metrics/#resource-usage-metrics","title":"Resource usage metrics","text":"<p>Resource metrics, like CPU, memory and disk usage, primarily come from the Kubernetes metrics components. These include <code>container_cpu_usage_seconds_total</code>, <code>container_memory_working_set_bytes</code> and <code>kubelet_volume_stats_used_bytes</code>. A stable list of metrics is maintained in the Kubernetes repository. These low-level metrics typically have a set of recording rules that aggregate values by labels and time ranges. For example, <code>node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate</code> or <code>namespace_workload_pod:kube_pod_owner:relabel</code>. If you have deployed the kube-prometheus project, you should have the majority of  these metrics being scraped.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#networking-metrics","title":"Networking metrics","text":"<p>Low-level networking metrics like <code>container_network_receive_bytes_total</code> are also available from the Kubernetes metrics components. HTTP &amp; GRPC traffic metrics with higher level labels are available from Istio. One of the main metrics would be <code>istio_requests_total</code>, which is a counter incremented for every request handled by an Istio proxy. Latency metrics are available via the <code>istio_request_duration_milliseconds</code> metric, with buckets for varying response times.</p> <p>Some example dashboards have panels that make use of the request URL path. The path is not added as a label to Istio metrics by default, as it has the potential to increase metric cardinality, and thus storage requirements. If you want to make use of the path in your queries or visualisations, you can enable the request path metric via the Telemetry resource in istio:</p> <pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: namespace-metrics\n  namespace: gateway-system\nspec:\n  metrics:\n\n  - providers:\n    - name: prometheus\n    overrides:\n    - match:\n        metric: REQUEST_COUNT\n      tagOverrides:\n        request_url_path:\n          value: \"request.url_path\"\n    - match:      \n        metric: REQUEST_DURATION\n      tagOverrides:\n        request_url_path:\n          value: \"request.url_path\"\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/metrics/#state-metrics","title":"State metrics","text":"<p>The kube-state-metrics project exposes the state of various kuberenetes resources as metrics and labels. For example, the ready <code>status</code> of a <code>Pod</code> is available as <code>kube_pod_status_ready</code>, with labels for the pod <code>name</code> and <code>namespace</code>. This can be useful for linking lower level container metrics back to a meaningful resource in the Kubernetes world.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#joining-metrics","title":"Joining metrics","text":"<p>Metric queries can be as simple as just the name of the metric, or can be complex with joining &amp; grouping. A lot of the time it can be useful to tie back low level metrics to more meaningful Kubernetes resources. For example, if the memory usage is maxed out on a container and that container is constantly being OOMKilled, it can be useful to get the Deployment and Namespace of that container for debugging. Prometheus query language (or promql) allows vector matching or results (sometimes called joining).</p> <p>When using Gateway API and Kuadrant resources like HTTPRoute and RateLimitPolicy, the state metrics can be joined to Istio metrics to give a meaningful result set. Here's an example that queries the number of requests per second, and includes the name of the HTTPRoute that the traffic is for.</p> <pre><code>sum(\n    rate(\n        istio_requests_total{}[5m]\n    )\n) by (destination_service_name)\n\n\n* on(destination_service_name) group_right \n    label_replace(gatewayapi_httproute_labels{}, \\\"destination_service_name\\\", \\\"$1\\\",\\\"service\\\", \\\"(.+)\\\")\n</code></pre> <p>Breaking this query down, there are 2 parts. The first part is getting the rate of requests hitting the Istio gateway, aggregated to 5m intervals:</p> <pre><code>sum(\n    rate(\n        destination_service_name{}[5m]\n    )\n) by (destination_service_name)\n</code></pre> <p>The result set here will include a label for the destination service name (i.e. the Service in Kubernetes). This label is key to looking up the HTTPRoute this traffic belongs to.</p> <p>The 2nd part of the query uses the <code>gatewayapi_httproute_labels</code> metric and the <code>label_replace</code> function. The <code>gatewayapi_httproute_labels</code> metric gives a list of all httproutes, including any labels on them. The HTTPRoute in this example has a label called 'service', set to be the same as the Istio service name. This allows us to join the 2 results set. However, because the label doesn't match exactly (<code>destination_service_name</code> and <code>service</code>), we can replace the label so that it does match. That's what the <code>label_replace</code> does.</p> <pre><code>    label_replace(gatewayapi_httproute_labels{}, \\\"destination_service_name\\\", \\\"$1\\\",\\\"service\\\", \\\"(.+)\\\")\n</code></pre> <p>The 2 parts are joined together using vector matching.</p> <pre><code>* on(destination_service_name) group_right \n</code></pre> <ul> <li><code>*</code> is the binary operator i.e. multiplication (gives join like behaviour)</li> <li><code>on()</code> specifies which labels to \"join\" the 2 results with</li> <li><code>group_right</code> enables a one to many matching.</li> </ul> <p>See the Prometheus documentation for further details on matching.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/","title":"Enabling tracing with a central collector","text":""},{"location":"kuadrant-operator/doc/observability/tracing/#introduction","title":"Introduction","text":"<p>This guide outlines the steps to enable tracing in Istio and Kuadrant components (Authorino and Limitador), directing traces to a central collector for improved observability and troubleshooting. We'll also explore a typical troubleshooting flow using traces and logs.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kubernetes cluster with Istio and Kuadrant installed.</li> <li>A trace collector (e.g., Jaeger or Tempo) configured to support OpenTelemetry (OTel).</li> </ul>"},{"location":"kuadrant-operator/doc/observability/tracing/#configuration-steps","title":"Configuration Steps","text":""},{"location":"kuadrant-operator/doc/observability/tracing/#istio-tracing-configuration","title":"Istio Tracing Configuration","text":"<p>Enable tracing in Istio by using the Telemetry API. Depending on your method for installing Istio, you will need to configure a tracing <code>extensionProvider</code> in your MeshConfig, Istio or IstioOperator resource as well. Here is an example Telemetry and Istio config to sample 100% of requests, if using the Istio Sail Operator.</p> <pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: gateway-system\nspec:\n  tracing:\n\n  - providers:\n    - name: tempo-otlp\n    randomSamplingPercentage: 100\n---\napiVersion: operator.istio.io/v1alpha1\nkind: Istio\nmetadata:\n  name: default\nspec:\n  namespace: gateway-system\n  values:\n    meshConfig:\n      defaultConfig:\n        tracing: {}\n      enableTracing: true\n      extensionProviders:\n      - name: tempo-otlp\n        opentelemetry:\n          port: 4317\n          service: tempo.tempo.svc.cluster.local\n</code></pre> <p>Important:</p> <p>The OpenTelemetry collector protocol should be explicitly set in the service port <code>name</code> or <code>appProtocol</code> fields as per the Istio documentation. For example, when using gRPC, the port <code>name</code> should begin with <code>grpc-</code> or the <code>appProtocol</code> should be <code>grpc</code>.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#kuadrant-tracing-configuration","title":"Kuadrant Tracing Configuration","text":"<p>The Authorino and Limitador components have request tracing capabilities. Here is an example configuration to enable and send traces to a central collector. Ensure the collector is the same one that Istio is sending traces so that they can be correlated later.</p> <pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  tracing:\n    endpoint: rpc://tempo.tempo.svc.cluster.local:4317\n    insecure: true\n---\napiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador\nspec:\n  tracing:\n    endpoint: rpc://tempo.tempo.svc.cluster.local:4317\n</code></pre> <p>Once the changes are applied, the authorino and limitador components will be redeployed tracing enabled.</p> <p>Note:</p> <p>There are plans to consolidate the tracing configuration to a single location i.e. the Kuadrant CR. This will eventually eliminate the need to configure tracing in both the Authorino and Limitador CRs.</p> <p>Important:</p> <p>Currently, trace IDs do not propagate to wasm modules in Istio/Envoy, affecting trace continuity in Limitador. This means that requests passed to limitador will not have the relavant 'parent' trace ID in its trace information. If however the trace initiation point is outside of Envoy/Istio, the 'parent' trace ID will be available to limitador and included in traces passed to the collector. This has an impact on correlating traces from limitador with traces from authorino, the gateway and any other components in the path of requests.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#troubleshooting-flow-using-traces-and-logs","title":"Troubleshooting Flow Using Traces and Logs","text":"<p>Using a tracing interface like the Jaeger UI or Grafana, you can search for trace information by the trace ID. You may get the trace ID from logs, or from a header in a sample request you want to troubleshoot. You can also search for recent traces, filtering by the service you want to focus on.</p> <p>Here is an example trace in the Grafana UI showing the total request time from the gateway (Istio), the time to check the curent rate limit count (and update it) in limitador and the time to check auth in Authorino:</p> <p></p> <p>In limitador, it is possible to enable request logging with trace IDs to get more information on requests. This requires the log level to be increased to at least debug, so the verbosity must be set to 3 or higher in the Limitador CR. For example:</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador\nspec:\n  verbosity: 3\n</code></pre> <p>A log entry will look something like this, with the <code>traceparent</code> field holding the trace ID:</p> <pre><code>\"Request received: Request { metadata: MetadataMap { headers: {\"te\": \"trailers\", \"grpc-timeout\": \"5000m\", \"content-type\": \"application/grpc\", \"traceparent\": \"00-4a2a933a23df267aed612f4694b32141-00f067aa0ba902b7-01\", \"x-envoy-internal\": \"true\", \"x-envoy-expected-rq-timeout-ms\": \"5000\"} }, message: RateLimitRequest { domain: \"default/toystore\", descriptors: [RateLimitDescriptor { entries: [Entry { key: \"limit.general_user__f5646550\", value: \"1\" }, Entry { key: \"metadata.filter_metadata.envoy\\\\.filters\\\\.http\\\\.ext_authz.identity.userid\", value: \"alice\" }], limit: None }], hits_addend: 1 }, extensions: Extensions }\"\n</code></pre> <p>If you centrally aggregate logs using something like promtail and loki, you can jump between trace information and the relevant logs for that service:</p> <p></p> <p>Using a combination of tracing and logs, you can visualise and troubleshoot reuqest timing issues and drill down to specific services. This method becomes even more powerful when combined with metrics and dashboards to get a more complete picture of your users traffic.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/","title":"Kuadrant Auth","text":"<p>A Kuadrant AuthPolicy custom resource:</p> <ol> <li>Targets Gateway API networking resources such as HTTPRoutes and Gateways, using these resources to obtain additional context, i.e., which traffic workload (HTTP attributes, hostnames, user attributes, etc) to enforce auth.</li> <li>Supports targeting subsets (sections) of a network resource to apply the auth rules to.</li> <li>Abstracts the details of the underlying external authorization protocol and configuration resources, that have a much broader remit and surface area.</li> <li>Enables cluster operators to set defaults that govern behavior at the lower levels of the network, until a more specific policy is applied.</li> </ol>"},{"location":"kuadrant-operator/doc/overviews/auth/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#envoys-external-authorization-protocol","title":"Envoy's External Authorization Protocol","text":"<p>Kuadrant's Auth implementation relies on the Envoy's External Authorization protocol. The workflow per request goes:</p> <ol> <li>On incoming request, the gateway checks the matching rules for enforcing the auth rules, as stated in the AuthPolicy custom resources and targeted Gateway API networking objects</li> <li>If the request matches, the gateway sends one CheckRequest to the external auth service (\"Authorino\").</li> <li>The external auth service responds with a CheckResponse back to the gateway with either an <code>OK</code> or <code>DENIED</code> response code.</li> </ol> <p>An AuthPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external auth service.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#the-authpolicy-custom-resource","title":"The AuthPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#overview","title":"Overview","text":"<p>The <code>AuthPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>Authentication/authorization scheme (<code>spec.rules</code>)</li> <li>Top-level additional conditions (<code>spec.when</code>)</li> <li>List of named patterns (<code>spec.patterns</code>)</li> </ul> <p>The auth scheme specify rules for:</p> <ul> <li>Authentication (<code>spec.rules.authentication</code>)</li> <li>External auth metadata fetching (<code>spec.rules.metadata</code>)</li> <li>Authorization (<code>spec.rules.authorization</code>)</li> <li>Custom response items (<code>spec.rules.response</code>)</li> <li>Callbacks (<code>spec.rules.callbacks</code>)</li> </ul> <p>Each auth rule can declare specific <code>when</code> conditions for the rule to apply.</p> <p>The auth scheme (<code>rules</code>), as well as conditions and named patterns can be declared at the top-level level of the spec (with the semantics of defaults) or alternatively within explicit <code>defaults</code> or <code>overrides</code> blocks.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#high-level-example-and-field-definition","title":"High-level example and field definition","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-auth-policy\nspec:\n  # Reference to an existing networking resource to attach the policy to. REQUIRED.\n  # It can be a Gateway API HTTPRoute or Gateway resource.\n  # It can only refer to objects in the same namespace as the AuthPolicy.\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute / Gateway\n    name: myroute / mygateway\n\n  # Additional dynamic conditions to trigger the AuthPolicy.\n  # Use it for filtering attributes not supported by HTTPRouteRule or with AuthPolicies that target a Gateway.\n  # Check out https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md to learn more\n  # about the Well-known Attributes that can be used in this field.\n  # Equivalent to if otherwise declared within `defaults`.\n  when: [\u2026]\n\n  # Sets of common patterns of selector-operator-value triples, to be referred by name in `when` conditions\n  # and pattern-matching rules. Often employed to avoid repetition in the policy.\n  # Equivalent to if otherwise declared within `defaults`.\n  patterns: { \u2026 }\n\n  # The auth rules to apply to the network traffic routed through the targeted resource.\n  # Equivalent to if otherwise declared within `defaults`.\n  rules:\n    # Authentication rules to enforce.\n    # At least one config must evaluate to a valid identity object for the auth request to be successful.\n    # If omitted or empty, anonymous access is assumed.\n    authentication:\n      \"my-authn-rule\":\n        # The authentication method of this rule.\n        # One-of: apiKey, jwt, oauth2Introspection, kubernetesTokenReview, x509, plain, anonymous.\n        apiKey: { \u2026 }\n\n        # Where credentials are required to be passed in the request for authentication based on this rule.\n        # One-of: authorizationHeader, customHeader, queryString, cookie.\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n\n        # Rule-level additional conditions.\n        when: [\u2026]\n\n        # Configs for caching the resolved object returned out of evaluating this auth rule.\n        cache: { \u2026 }\n\n    # Rules for fetching auth metadata from external sources.\n    metadata:\n      \"my-external-source\":\n        # The method for fetching metadata from the external source.\n        # One-of: http: userInfo, uma.\n        http: { \u2026 }\n\n    # Authorization rules to enforce.\n    # All policies must allow access for the auth request be successful.\n    authorization:\n      \"my-authz-rule\":\n        # The authorization method of this rule.\n        # One-of: patternMatching, opa, kubernetesSubjectAccessReview, spicedb.\n        opa: { \u2026 }\n\n    # Customizations to the authorization response.\n    response:\n      # Custom denial status and other HTTP attributes for unauthenticated requests.\n      unauthenticated: { \u2026 }\n\n      # Custom denial status and other HTTP attributes for unauhtorized requests.\n      unauthorized: { \u2026 }\n\n      # Custom response items when access is granted.\n      success:\n        # Custom response items wrapped as HTTP headers to be injected in the request\n        headers:\n          \"my-custom-header\":\n            # One-of: plain, json, wristband.\n            plain: { \u2026 }\n\n        # Custom response items wrapped as envoy dynamic metadata.\n        dynamicMetadata:\n          # One-of: plain, json, wristband.\n          \"my-custom-dyn-metadata\":\n            json: { \u2026 }\n\n    # Rules for post-authorization callback requests to external services.\n    # Triggered regardless of the result of the authorization request.\n    callbacks:\n      \"my-webhook\":\n        http: { \u2026 }\n\n    # Explicit defaults. Used in policies that target a Gateway object to express default rules to be enforced on\n    # routes that lack a more specific policy attached to.\n    # Mutually exclusive with `overrides` and with declaring the `rules`, `when` and `patterns` at the top-level of\n    # the spec.\n    defaults:\n      rules:\n        authentication: { \u2026 }\n        metadata: { \u2026 }\n        authorization: { \u2026 }\n        response: { \u2026 }\n        callbacks: { \u2026 }\n      when: [\u2026]\n      patterns: { \u2026 }\n\n    # Overrides. Used in policies that target a Gateway object to be enforced on all routes linked to the gateway,\n    # thus also overriding any more specific policy occasionally attached to any of those routes.\n    # Mutually exclusive with `defaults` and with declaring `rules`, `when` and `patterns` at the top-level of\n    # the spec.\n    overrides:\n      rules:\n        authentication: { \u2026 }\n        metadata: { \u2026 }\n        authorization: { \u2026 }\n        response: { \u2026 }\n        callbacks: { \u2026 }\n      when: [\u2026]\n      patterns: { \u2026 }\n</code></pre> <p>Check out the API reference for a full specification of the AuthPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#using-the-authpolicy","title":"Using the AuthPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#targeting-a-httproute-networking-resource","title":"Targeting a HTTPRoute networking resource","text":"<p>When an AuthPolicy targets a HTTPRoute, the policy is enforced to all traffic routed according to the rules and hostnames specified in the HTTPRoute, across all Gateways referenced in the <code>spec.parentRefs</code> field of the HTTPRoute.</p> <p>The targeted HTTPRoute's rules and/or hostnames to which the policy must be enforced can be filtered to specific subsets.</p> <p>Target a HTTPRoute by setting the <code>spec.targetRef</code> field of the AuthPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-route-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: &lt;HTTPRoute Name&gt;\n  rules: { \u2026 }\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (Infra namespace) \u2502             \u2502   (App namespace)  \u2502\n\u2502                   \u2502             \u2502                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502  parentRefs \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Gateway \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 HTTPRoute \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                   \u2502             \u2502        \u25b2           \u2502\n\u2502                   \u2502             \u2502        \u2502           \u2502\n\u2502                   \u2502             \u2502        \u2502           \u2502\n\u2502                   \u2502             \u2502        \u2502 targetRef \u2502\n\u2502                   \u2502             \u2502        \u2502           \u2502\n\u2502                   \u2502             \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502                   \u2502             \u2502  \u2502 AuthPolicy \u2502    \u2502\n\u2502                   \u2502             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                   \u2502             \u2502                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/auth/#hostnames-and-wildcards","title":"Hostnames and wildcards","text":"<p>If an AuthPolicy targets a route defined for <code>*.com</code> and another AuthPolicy targets another route for <code>api.com</code>, the Kuadrant control plane will not merge these two AuthPolicies. Rather, it will mimic the behavior of gateway implementation by which the \"most specific hostname wins\", thus enforcing only the corresponding applicable policies and auth rules.</p> <p>E.g., a request coming for <code>api.com</code> will be protected according to the rules from the AuthPolicy that targets the route for <code>api.com</code>; while a request for <code>other.com</code> will be protected with the rules from the AuthPolicy targeting the route for <code>*.com</code>.</p> <p>Example with 3 AuthPolicies and 3 HTTPRoutes:</p> <ul> <li>AuthPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>)</li> <li>AuthPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>)</li> <li>AuthPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 AuthPolicy A will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 AuthPolicy B will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 AuthPolicy W will be enforced</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/auth/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>An AuthPolicy that targets a Gateway can declare a block of defaults (<code>spec.defaults</code>) or a block of overrides (<code>spec.overrides</code>). As a standard, gateway policies that do not specify neither defaults nor overrides, act as defaults.</p> <p>When declaring defaults, an AuthPolicy which targets a Gateway will be enforced to all HTTP traffic hitting the gateway, unless a more specific AuthPolicy targeting a matching HTTPRoute exists. Any new HTTPRoute referrencing the gateway as parent will be automatically covered by the default AuthPolicy, as well as changes in the existing HTTPRoutes.</p> <p>Defaults provide cluster operators with the ability to protect the infrastructure against unplanned and malicious network traffic attempt, such as by setting preemptive \"deny-all\" policies on hostnames and hostname wildcards.</p> <p>Inversely, a gateway policy that specify overrides declares a set of rules to be enforced on all routes attached to the gateway, thus atomically replacing any more specific policy occasionally attached to any of those routes.</p> <p>Target a Gateway HTTPRoute by setting the <code>spec.targetRef</code> field of the AuthPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-gw-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n  defaults: # alternatively: `overrides`\n    rules: { \u2026 }\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (Infra namespace) \u2502             \u2502   (App namespace)  \u2502\n\u2502                   \u2502             \u2502                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502  parentRefs \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 Gateway \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 HTTPRoute \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502       \u25b2           \u2502             \u2502        \u25b2           \u2502\n\u2502       \u2502           \u2502             \u2502        \u2502           \u2502\n\u2502       \u2502           \u2502             \u2502        \u2502           \u2502\n\u2502       \u2502 targetRef \u2502             \u2502        \u2502 targetRef \u2502\n\u2502       \u2502           \u2502             \u2502        \u2502           \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502             \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502 \u2502 AuthPolicy \u2502    \u2502             \u2502  \u2502 AuthPolicy \u2502    \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                   \u2502             \u2502                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/auth/#overlapping-gateway-and-httproute-authpolicies","title":"Overlapping Gateway and HTTPRoute AuthPolicies","text":"<p>Two possible semantics are to be considered here \u2013 gateway policy defaults vs gateway policy overrides.</p> <p>Gateway AuthPolicies that declare defaults (or alternatively neither defaults nor overrides) protect all traffic routed through the gateway except where a more specific HTTPRoute AuthPolicy exists, in which case the HTTPRoute AuthPolicy prevails.</p> <p>Example with 4 AuthPolicies, 3 HTTPRoutes and 1 Gateway default (plus 2 HTTPRoute and 2 Gateways without AuthPolicies attached):</p> <ul> <li>AuthPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>AuthPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>AuthPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>AuthPolicy G (defaults) \u2192 Gateway G (<code>*.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 AuthPolicy A will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 AuthPolicy B will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 AuthPolicy W will be enforced</li> <li>Request to <code>other.com</code> (suppose a route exists) \u2192 AuthPolicy G will be enforced</li> <li>Request to <code>yet-another.net</code> (suppose a route and gateway exist) \u2192 No AuthPolicy will be enforced</li> </ul> <p>Gateway AuthPolicies that declare overrides protect all traffic routed through the gateway, regardless of existence of any more specific HTTPRoute AuthPolicy.</p> <p>Example with 4 AuthPolicies, 3 HTTPRoutes and 1 Gateway override (plus 2 HTTPRoute and 2 Gateways without AuthPolicies attached):</p> <ul> <li>AuthPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>AuthPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>AuthPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>AuthPolicy G (overrides) \u2192 Gateway G (<code>*.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 AuthPolicy G will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 AuthPolicy G will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 AuthPolicy G will be enforced</li> <li>Request to <code>other.com</code> (suppose a route exists) \u2192 AuthPolicy G will be enforced</li> <li>Request to <code>yet-another.net</code> (suppose a route and gateway exist) \u2192 No AuthPolicy will be enforced</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/auth/#when-conditions","title":"<code>when</code> conditions","text":"<p><code>when</code> conditions can be used to scope an AuthPolicy or auth rule within an AuthPolicy (i.e. to filter the traffic to which a policy or policy rule applies) without any coupling to the underlying network topology.</p> <p>Use <code>when</code> conditions to conditionally activate policies and policy rules based on attributes that cannot be expressed in the HTTPRoutes' <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or in general in AuthPolicies that target a Gateway.</p> <p><code>when</code> conditions in an AuthPolicy are compatible with Authorino conditions, thus supporting complex boolean expressions with AND and OR operators, as well as grouping.</p> <p>The selectors within the <code>when</code> conditions of an AuthPolicy are a subset of Kuadrant's Well-known Attributes (RFC 0002). Check out the reference for the full list of supported selectors.</p> <p>Authorino JSON path string modifiers can also be applied to the selectors within the <code>when</code> conditions of an AuthPolicy.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of protecting services with Kuadrant:</p> <ul> <li>Enforcing authentication &amp; authorization with Kuadrant AuthPolicy, for app developers and platform engineers</li> <li>Authenticated Rate Limiting for Application Developers</li> <li>Authenticated Rate Limiting with JWTs and Kubernetes RBAC</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/auth/#known-limitations","title":"Known limitations","text":"<ul> <li>One HTTPRoute can only be targeted by one AuthPolicy.</li> <li>One Gateway can only be targeted by one AuthPolicy.</li> <li>AuthPolicies can only target HTTPRoutes/Gateways defined within the same namespace of the AuthPolicy.</li> <li>2+ AuthPolicies cannot target network resources that define/inherit the same exact hostname.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/auth/#limitation-multiple-network-resources-with-identical-hostnames","title":"Limitation: Multiple network resources with identical hostnames","text":"<p>Kuadrant currently does not support multiple AuthPolicies simultaneously targeting network resources that declare identical hostnames. This includes multiple HTTPRoutes that specify the same hostnames in the <code>spec.hostnames</code> field, as well as HTTPRoutes that specify a hostname that is identical to a hostname specified in a listener of one of the route's parent gateways or HTTPRoutes that don't specify any hostname at all thus inheriting the hostnames from the parent gateways. In any of these cases, a maximum of one AuthPolicy targeting any of those resources that specify identical hostnames is allowed.</p> <p>Moreover, having multiple resources that declare identical hostnames may lead to unexpected behavior and therefore should be avoided.</p> <p>This limitation is rooted at the underlying components configured by Kuadrant for the implementation of its policies and the lack of information in the data plane regarding the exact route that is honored by the API gateway at each specific request, in cases of conflicting hostnames.</p> <p>To exemplify one way this limitation can impact deployments, consider the following topology:</p> <pre><code>                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                 \u2502   Gateway    \u2502\n                 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n          \u250c\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 listeners:   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502      \u2502 - host: *.io \u2502       \u2502\n          \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n          \u2502                             \u2502\n          \u2502                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     HTTPRoute     \u2502        \u2502     HTTPRoute     \u2502\n\u2502     (route-a)     \u2502        \u2502     (route-b)     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 hostnames:        \u2502        \u2502 hostnames:        \u2502\n\u2502 - app.io          \u2502        \u2502 - app.io          \u2502\n\u2502 rules:            \u2502        \u2502 rules:            \u2502\n\u2502 - matches:        \u2502        \u2502 - matches:        \u2502\n\u2502   - path:         \u2502        \u2502   - path:         \u2502\n\u2502       value: /foo \u2502        \u2502       value: /bar \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u25b2                            \u25b2\n          \u2502                            \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510               \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 AuthPolicy \u2502               \u2502 AuthPolicy \u2502\n    \u2502 (policy-1) \u2502               \u2502 (policy-2) \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>In the example above, with the <code>policy-1</code> resource created before <code>policy-2</code>, <code>policy-1</code> will be enforced on all requests to <code>app.io/foo</code> while <code>policy-2</code> will be rejected. I.e. <code>app.io/bar</code> will not be secured. In fact, the status conditions of <code>policy-2</code> shall reflect <code>Enforced=false</code> with message \"AuthPolicy has encountered some issues: AuthScheme is not ready yet\".</p> <p>Notice the enforcement of <code>policy-1</code> and no enforcement of <code>policy-2</code> is the opposite behavior as the analogous problem with the Kuadrant RateLimitPolicy.</p> <p>A slightly different way the limitation applies is when two or more routes of a gateway declare the exact same hostname and a gateway policy is defined with expectation to set default rules for the cases not covered by more specific policies. E.g.:</p> <pre><code>                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 AuthPolicy \u2502\n                         \u2502          \u2502 (policy-2) \u2502\n                         \u25bc          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                 \u2502   Gateway    \u2502\n                 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n          \u250c\u2500\u2500\u2500\u2500\u2500\u25ba\u2502 listeners:   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n          \u2502      \u2502 - host: *.io \u2502       \u2502\n          \u2502      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n          \u2502                             \u2502\n          \u2502                             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     HTTPRoute     \u2502        \u2502     HTTPRoute     \u2502\n\u2502     (route-a)     \u2502        \u2502     (route-b)     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 hostnames:        \u2502        \u2502 hostnames:        \u2502\n\u2502 - app.io          \u2502        \u2502 - app.io          \u2502\n\u2502 rules:            \u2502        \u2502 rules:            \u2502\n\u2502 - matches:        \u2502        \u2502 - matches:        \u2502\n\u2502   - path:         \u2502        \u2502   - path:         \u2502\n\u2502       value: /foo \u2502        \u2502       value: /bar \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u25b2\n          \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 AuthPolicy \u2502\n    \u2502 (policy-1) \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Once again, requests to <code>app.io/foo</code> will be protected under AuthPolicy <code>policy-1</code>, while requests to <code>app.io/bar</code> will not be protected under any policy at all, unlike expected gateway policy <code>policy-2</code> enforced as default. Both policies will report status condition as <code>Enforced</code> nonetheless.</p> <p>To avoid these problems, use different hostnames in each route.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#implementation-details","title":"Implementation details","text":"<p>Under the hood, for each AuthPolicy, Kuadrant creates an Istio <code>AuthorizationPolicy</code> and an Authorino <code>AuthConfig</code> custom resources.</p> <p>Only requests that matches the rules in the Istio <code>AuthorizationPolicy</code> cause an authorization request to be sent to the external authorization service (\"Authorino\"), i.e., only requests directed to the HTTPRouteRules targeted by the AuthPolicy (directly or indirectly), according to the declared top-level route selectors (if present), or all requests for which a matching HTTPRouteRule exists (otherwise).</p> <p>Authorino looks up for the auth scheme (<code>AuthConfig</code> custom resource) to enforce using the provided hostname of the original request as key. It then checks again if the request matches at least one of the selected HTTPRouteRules, in which case it enforces the auth scheme.</p> Exception to the rule  Due to limitations imposed by the Istio `AuthorizationPolicy`, there are a few patterns of HTTPRouteRules that cannot be translated to filters for the external authorization request. Therefore, the following patterns used in HTTPRouteMatches of top-level route selectors of an AuthPolicy will not be included in the Istio AuthorizationPolicy rules that trigger the check request with Authorino: `PathMatchRegularExpression`, `HeaderMatchRegularExpression`, and `HTTPQueryParamMatch`.  As a consequence to the above, requests that do not match these rules and otherwise would not be checked with Authorino will result in a request to the external authorization service. Authorino nonetheless will still verify those patterns and ensure the auth scheme is enforced only when it matches a selected HTTPRouteRule. Users of Kuadrant may observe an unnecessary call to the authorization service in those cases where the request is out of the scope of the AuthPolicy and therefore always authorized."},{"location":"kuadrant-operator/doc/overviews/auth/#internal-custom-resources-and-namespaces","title":"Internal custom resources and namespaces","text":"<p>While the Istio <code>AuthorizationPolicy</code> needs to be created in the same namespace as the gateway workload, the Authorino <code>AuthConfig</code> is created in the namespace of the <code>AuthPolicy</code> itself. This allows to simplify references such as to Kubernetes Secrets referred in the AuthPolicy, as well as the RBAC to support the architecture.</p>"},{"location":"kuadrant-operator/doc/overviews/development/","title":"Development Guide","text":""},{"location":"kuadrant-operator/doc/overviews/development/#technology-stack-required-for-development","title":"Technology stack required for development","text":"<ul> <li>operator-sdk version v1.32.0</li> <li>kind version v0.23.0</li> <li>git</li> <li>go version 1.22+</li> <li>kubernetes version v1.19+</li> <li>kubectl version v1.19+</li> <li>helm</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/development/#build","title":"Build","text":"<pre><code>make build\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/development/#deploy-on-local-kubernetes-cluster","title":"Deploy on local kubernetes cluster","text":"<p>Run local Kubernetes cluster using Docker container using Kind and deploy kuadrant operator (and all dependencies) in a single command.</p> <pre><code>make local-setup\n</code></pre> <p>The <code>make local-setup</code> target accepts the following variables:</p> Makefile Variable Description Default value <code>GATEWAYAPI_PROVIDER</code> GatewayAPI provider name. Accepted values: [istio | envoygateway] istio"},{"location":"kuadrant-operator/doc/overviews/development/#run-as-a-local-process","title":"Run as a local process","text":"<p>Run local Kubernetes cluster using Docker container using Kind and deploy all dependencies in a single command.</p> <pre><code>make local-env-setup\n</code></pre> <p>The <code>make local-env-setup</code> target accepts the following variables:</p> Makefile Variable Description Default value <code>GATEWAYAPI_PROVIDER</code> GatewayAPI provider name. Accepted values: [istio | envoygateway] istio <p>Then, run the operator locally</p> <pre><code>make run\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/development/#deploy-on-existing-kubernetes-cluster","title":"Deploy on existing kubernetes cluster","text":"<p>Requirements:</p> <ul> <li>Active session open to the kubernetes cluster.</li> <li>GatewayAPI installed</li> <li>GatewayAPI provider installed. Currently only Istio and EnvoyGateway supported.</li> <li>Cert Manager installed</li> </ul> <p>Before running the kuadrant operator, some dependencies needs to be deployed.</p> <pre><code>make install\nmake deploy-dependencies\n</code></pre> <p>Then, deploy the operator</p> <pre><code>make deploy\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/development/#deploy-kuadrant-operator-using-olm","title":"Deploy kuadrant operator using OLM","text":"<p>You can deploy kuadrant using OLM just running few commands. No need to build any image. Kuadrant engineering team provides <code>latest</code> and release version tagged images. They are available in the Quay.io/Kuadrant image repository.</p> <p>Create kind cluster</p> <pre><code>make kind-create-cluster\n</code></pre> <p>Deploy OLM system</p> <pre><code>make install-olm\n</code></pre> <p>Deploy kuadrant using OLM. The <code>make deploy-catalog</code> target accepts the following variables:</p> Makefile Variable Description Default value <code>CATALOG_IMG</code> Kuadrant operator catalog image URL <code>quay.io/kuadrant/kuadrant-operator-catalog:latest</code> <pre><code>make deploy-catalog [CATALOG_IMG=quay.io/kuadrant/kuadrant-operator-catalog:latest]\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/development/#build-custom-olm-catalog","title":"Build custom OLM catalog","text":"<p>If you want to deploy (using OLM) a custom kuadrant operator, you need to build your own catalog. Furthermore, if you want to deploy a custom limitador or authorino operator, you also need to build your own catalog. The kuadrant operator bundle includes the authorino or limtador operator dependency version, hence using other than <code>latest</code> version requires a custom kuadrant operator bundle and a custom catalog including the custom bundle.</p>"},{"location":"kuadrant-operator/doc/overviews/development/#build-kuadrant-operator-bundle-image","title":"Build kuadrant operator bundle image","text":"<p>The <code>make bundle</code> target accepts the following variables:</p> Makefile Variable Description Default value Notes <code>IMG</code> Kuadrant operator image URL <code>quay.io/kuadrant/kuadrant-operator:latest</code> <code>TAG</code> var could be use to build this URL, defaults to latest  if not provided <code>VERSION</code> Bundle version <code>0.0.0</code> <code>LIMITADOR_OPERATOR_BUNDLE_IMG</code> Limitador operator bundle URL <code>quay.io/kuadrant/limitador-operator-bundle:latest</code> <code>LIMITADOR_OPERATOR_VERSION</code> var could be used to build this, defaults to latest if not provided <code>AUTHORINO_OPERATOR_BUNDLE_IMG</code> Authorino operator bundle URL <code>quay.io/kuadrant/authorino-operator-bundle:latest</code> <code>AUTHORINO_OPERATOR_VERSION</code> var could be used to build this, defaults to latest if not provided <code>DNS_OPERATOR_BUNDLE_IMG</code> DNS operator bundle URL <code>quay.io/kuadrant/dns-operator-bundle:latest</code> <code>DNS_OPERATOR_BUNDLE_IMG</code> var could be used to build this, defaults to latest if not provided <code>RELATED_IMAGE_WASMSHIM</code> WASM shim image URL <code>oci://quay.io/kuadrant/wasm-shim:latest</code> <code>WASM_SHIM_VERSION</code> var could be used to build this, defaults to latest if not provided <code>RELATED_IMAGE_CONSOLEPLUGIN</code> ConsolePlugin image URL <code>quay.io/kuadrant/console-plugin:latest</code> <code>CHANNELS</code> Bundle channels used in the bundle, comma separated <code>alpha</code> <code>DEFAULT_CHANNEL</code> The default channel used in the bundle <code>alpha</code> <ul> <li>Build the bundle manifests</li> </ul> <pre><code>make bundle [IMG=quay.io/kuadrant/kuadrant-operator:latest] \\\n            [VERSION=0.0.0] \\\n            [LIMITADOR_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/limitador-operator-bundle:latest] \\\n            [AUTHORINO_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/authorino-operator-bundle:latest] \\\n            [DNS_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/dns-operator-bundle:latest] \\\n            [RELATED_IMAGE_WASMSHIM=oci://quay.io/kuadrant/wasm-shim:latest] \\\n            [RELATED_IMAGE_CONSOLEPLUGIN=quay.io/kuadrant/console-plugin:latest] \\\n            [CHANNELS=alpha] \\\n            [DEFAULT_CHANNEL=alpha]\n</code></pre> <ul> <li>Build the bundle image from the manifests</li> </ul> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Kuadrant operator bundle image URL <code>quay.io/kuadrant/kuadrant-operator-bundle:latest</code> <pre><code>make bundle-build [BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:latest]\n</code></pre> <ul> <li>Push the bundle image to a registry</li> </ul> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Kuadrant operator bundle image URL <code>quay.io/kuadrant/kuadrant-operator-bundle:latest</code> <pre><code>make bundle-push [BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:latest]\n</code></pre> <p>Frequently, you may need to build custom kuadrant bundle with the default (<code>latest</code>) Limitador and Authorino bundles. These are the example commands to build the manifests, build the bundle image and push to the registry.</p> <p>In the example, a new kuadrant operator bundle version <code>0.8.0</code> will be created that references the kuadrant operator image <code>quay.io/kuadrant/kuadrant-operator:v0.5.0</code> and latest Limitador and Authorino bundles.</p> <pre><code># manifests\nmake bundle IMG=quay.io/kuadrant/kuadrant-operator:v0.5.0 VERSION=0.8.0\n\n# bundle image\nmake bundle-build BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:my-bundle\n\n# push bundle image\nmake bundle-push BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:my-bundle\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/development/#build-custom-catalog","title":"Build custom catalog","text":"<p>The catalog's format will be File-based Catalog.</p> <p>Make sure all the required bundles are pushed to the registry. It is required by the <code>opm</code> tool.</p> <p>The <code>make catalog</code> target accepts the following variables:</p> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Kuadrant operator bundle image URL <code>quay.io/kuadrant/kuadrant-operator-bundle:latest</code> <code>LIMITADOR_OPERATOR_BUNDLE_IMG</code> Limitador operator bundle URL <code>quay.io/kuadrant/limitador-operator-bundle:latest</code> <code>AUTHORINO_OPERATOR_BUNDLE_IMG</code> Authorino operator bundle URL <code>quay.io/kuadrant/authorino-operator-bundle:latest</code> <code>DNS_OPERATOR_BUNDLE_IMG</code> DNS operator bundle URL <code>quay.io/kuadrant/dns-operator-bundle:latest</code> <code>DEFAULT_CHANNEL</code> Catalog default channel <code>alpha</code> <pre><code>make catalog [BUNDLE_IMG=quay.io/kuadrant/kuadrant-operator-bundle:latest] \\\n            [LIMITADOR_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/limitador-operator-bundle:latest] \\\n            [AUTHORINO_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/authorino-operator-bundle:latest] \\\n            [DNS_OPERATOR_BUNDLE_IMG=quay.io/kuadrant/dns-operator-bundle:latest] \\\n            [DEFAULT_CHANNEL=alpha]\n</code></pre> <ul> <li>Build the catalog image from the manifests</li> </ul> Makefile Variable Description Default value <code>CATALOG_IMG</code> Kuadrant operator catalog image URL <code>quay.io/kuadrant/kuadrant-operator-catalog:latest</code> <pre><code>make catalog-build [CATALOG_IMG=quay.io/kuadrant/kuadrant-operator-catalog:latest]\n</code></pre> <ul> <li>Push the catalog image to a registry</li> </ul> <pre><code>make catalog-push [CATALOG_IMG=quay.io/kuadrant/kuadrant-operator-bundle:latest]\n</code></pre> <p>You can try out your custom catalog image following the steps of the Deploy kuadrant operator using OLM section.</p>"},{"location":"kuadrant-operator/doc/overviews/development/#cleaning-up","title":"Cleaning up","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/development/#run-tests","title":"Run tests","text":""},{"location":"kuadrant-operator/doc/overviews/development/#unittests","title":"Unittests","text":"<pre><code>make test-unit\n</code></pre> <p>Optionally, add <code>TEST_NAME</code> makefile variable to run specific test</p> <pre><code>make test-unit TEST_NAME=TestLimitIndexEquals\n</code></pre> <p>or even subtest</p> <pre><code>make test-unit TEST_NAME=TestLimitIndexEquals/empty_indexes_are_equal\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/development/#integration-tests","title":"Integration tests","text":"<p>Multiple controller integration tests are defined</p> Golang package Required environment Makefile env setup target Makefile test run target <code>github.com/kuadrant/kuadrant-operator/tests/bare_k8s</code> no gateway provider, no GatewayAPI CRDs. Just Kuadrant API and Kuadrant dependencies. <code>make local-k8s-env-setup</code> <code>make test-bare-k8s-integration</code> <code>github.com/kuadrant/kuadrant-operator/tests/gatewayapi</code> no gateway provider. GatewayAPI CRDs, Kuadrant API and Kuadrant dependencies. <code>make local-gatewayapi-env-setup</code> <code>make test-gatewayapi-env-integration</code> <code>github.com/kuadrant/kuadrant-operator/controllers</code> at least one gatewayapi provider. It can be any: istio, envoygateway, ... <code>make local-env-setup GATEWAYAPI_PROVIDER=[istio \\| envoygateway] [ISTIO_INSTALL_SAIL=false]</code> (Default istio) <code>make test-integration GATEWAYAPI_PROVIDER=[istio \\| envoygateway]</code> (Default istio) <code>github.com/kuadrant/kuadrant-operator/tests/istio</code> GatewayAPI CRDs, Istio, Kuadrant API and Kuadrant dependencies. <code>make local-env-setup GATEWAYAPI_PROVIDER=istio [ISTIO_INSTALL_SAIL=false]</code> <code>make test-istio-env-integration</code> <code>github.com/kuadrant/kuadrant-operator/tests/envoygateway</code> GatewayAPI CRDs, EnvoyGateway, Kuadrant API and Kuadrant dependencies. <code>make local-env-setup GATEWAYAPI_PROVIDER=envoygateway</code> <code>make test-envoygateway-env-integration</code>"},{"location":"kuadrant-operator/doc/overviews/development/#lint-tests","title":"Lint tests","text":"<pre><code>make run-lint\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/development/#uninstall-kuadrant-crds","title":"(Un)Install Kuadrant CRDs","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Remove CRDs</p> <pre><code>make uninstall\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/","title":"Kuadrant DNS","text":"<p>A Kuadrant DNSPolicy custom resource:</p> <ol> <li>Targets Gateway API networking resources Gateways to provide dns management by managing the lifecycle of dns records in external dns providers such as AWS Route53 and Google DNS.</li> </ol>"},{"location":"kuadrant-operator/doc/overviews/dns/#how-it-works","title":"How it works","text":"<p>A DNSPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external DNS service.  The needed dns names are gathered from the listener definitions and the IPAdresses | CNAME hosts are gathered from the status block of the gateway resource.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#the-dnspolicy-custom-resource","title":"The DNSPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/dns/#overview","title":"Overview","text":"<p>The <code>DNSPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>LoadBalancing specification (<code>spec.loadBalancing</code>)</li> <li>HealthCheck specification (<code>spec.healthCheck</code>)</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/dns/#high-level-example-and-field-definition","title":"High-level example and field definition","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-dns-policy\nspec:\n  # reference to an existing networking resource to attach the policy to\n  # it can only be a Gateway API Gateway resource\n  # it can only refer to objects in the same namespace as the DNSPolicy\n  # it can target a specific listener using sectionName \n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mygateway\n    sectionName: api # (optional) if not set policy applies to all listeners that do not have a policy attached directly\n\n # reference to an existing secret resource containing provider credentials and configuration\n # it can only refer to Secrets in the same namespace as the DNSPolicy that have the type kuadrant.io/(provider) e.g kuadrant.io/aws\n  providerRefs:\n\n   - name: my-aws-credentials\n\n  # (optional) loadbalancing specification\n  # use it for providing the specification of how dns will be configured in order to provide balancing of requests across multiple clusters. If not configured, a simple A or CNAME record will be created. If you have a policy with no loadbalancing defined and want to move to a loadbalanced configuration, you will need to delete and re-create the policy.\n  loadBalancing:\n    # is this the default geo to be applied to records. It is important that you set the default geo flag to true **Only** for the GEO value you wish to act as the catchall GEO, you should not set multiple GEO values as default for a given targeted listener. Example: policy 1 targets listener 1 with a geo of US and sets default to true. Policy 2 targets a listener on another cluster and set the geo to EU and default to false. It is fine for policies in the same default GEO to set the value to true. The main thing is to have only one unique GEO set as the default for any shared listener hostname.\n    defaultGeo: true\n    # weighted specification. This will apply the given weight to the records created based on the targeted gateway listeners. If you have multiple gateways that share a listener host, you can set different weight values to influence how much traffic will be brought to a given gateway.\n    weight: 100\n    # This is the actual GEO location to set for records created by this policy. This can and should be different if you have multiple gateways across multiple geographic areas. \n\n    # AWS: To see all regions supported by AWS Route 53, please see the official (documentation)[https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values-geo.html]. With Route 53 when setting a continent code use a \"GEO-\" prefix otherwise it will be considered a country code. \n\n    # GCP: To see all regions supported by GCP Cloud DNS, please see the official (documentation)[https://cloud.google.com/compute/docs/regions-zones]\n\n    #To see the different values you can use for the geo based DNS with Azure take a look at the following (documentation)[https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-geographic-regions]\n    geo: IE\n\n  # (optional) health check specification\n  # health check probes with the following specification will be created for each DNS target, these probes constantly check that the endpoint can be reached. They will flag an unhealthy endpoint in the status. If no DNSRecord has yet been published and the endpoint is unhealthy, the record will not be published until the health check passes.\n  healthCheck:\n    # the path on the listener host(s) that you want to check. \n    path: /health\n    # how many times does the health check need to fail before unhealthy.\n    failureThreshold: 3\n    # how often should it be checked.\n    interval: 5min\n    # additionalHeadersRef is reference to a local secret with a set of key value pairs to be used as headers when sending the health check request.\n    additionalHeadersRef:\n      name: headers\n</code></pre> <p>Check out the API reference for a full specification of the DNSPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#using-the-dnspolicy","title":"Using the DNSPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/dns/#dns-provider-setup","title":"DNS Provider Setup","text":"<p>A DNSPolicy acts against a target Gateway by processing its listeners for hostnames that it can create dns records for.  In order for it to do this, it must know about the dns provider. This is done through the creation of dns provider secrets containing the credentials and configuration for the dns provider account.</p> <p>If for example a Gateway is created with a listener with a hostname of <code>echo.apps.hcpapps.net</code>: <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: my-gw\nspec:\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: echo.apps.hcpapps.net\n      port: 80\n      protocol: HTTP\n</code></pre></p> <p>In order for the DNSPolicy to act upon that listener, a DNS provider Secret must exist for that hostnames' domain.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: my-aws-credentials\n  namespace: &lt;Gateway Namespace&gt;\ndata:\n  AWS_ACCESS_KEY_ID: &lt;AWS_ACCESS_KEY_ID&gt;\n  AWS_REGION: &lt;AWS_REGION&gt;\n  AWS_SECRET_ACCESS_KEY: &lt;AWS_SECRET_ACCESS_KEY&gt;\ntype: kuadrant.io/aws\n</code></pre> <p>By default, Kuadrant will list the available zones and find the matching zone based on the listener host in the gateway listener. If it finds more than one matching zone for a given listener host, it will not update any of those zones.  When providing a credential you should limit that credential down to just have write access to the zones you want Kuadrant to manage. Below is an example of a an AWS policy for doing this type of thing:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListTagsForResources\",\n                \"route53:GetHealthCheckLastFailureReason\",\n                \"route53:GetHealthCheckStatus\",\n                \"route53:GetChange\",\n                \"route53:GetHostedZone\",\n                \"route53:ChangeResourceRecordSets\",\n                \"route53:ListResourceRecordSets\",\n                \"route53:GetHealthCheck\",\n                \"route53:UpdateHostedZoneComment\",\n                \"route53:UpdateHealthCheck\",\n                \"route53:CreateHealthCheck\",\n                \"route53:DeleteHealthCheck\",\n                \"route53:ListTagsForResource\",\n                \"route53:ListHealthChecks\",\n                \"route53:GetGeoLocation\",\n                \"route53:ListGeoLocations\",\n                \"route53:ListHostedZonesByName\",\n                \"route53:GetHealthCheckCount\"\n            ],\n            \"Resource\": [\n                \"arn:aws:route53:::hostedzone/Z08187901Y93585DDGM6K\",\n                \"arn:aws:route53:::healthcheck/*\",\n                \"arn:aws:route53:::change/*\"\n            ]\n        },\n        {\n            \"Sid\": \"VisualEditor1\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListHostedZones\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>When a DNSPolicy targets a Gateway, the policy will be enforced on all gateway listeners.</p> <p>Target a Gateway by setting the <code>spec.targetRef</code> field of the DNSPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1beta2\nkind: DNSPolicy\nmetadata:\n  name: &lt;DNSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#targeting-a-specific-listener-of-a-gateway","title":"Targeting a specific Listener of a gateway","text":"<p>A DNSPolicy can target a specific listener in a gateway using the <code>sectionName</code> property of the targetRef configuration. When you set the <code>sectionName</code>, the DNSPolicy will only affect that listener and no others. If you also have another DNSPolicy targeting the entire gateway, the more specific policy targeting the listerner will be the policy that is applied.</p> <pre><code>apiVersion: kuadrant.io/v1beta2\nkind: DNSPolicy\nmetadata:\n  name: &lt;DNSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n    sectionName: &lt;myListenerName&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#dnsrecord-resource","title":"DNSRecord Resource","text":"<p>The DNSPolicy will create a DNSRecord resource for each listener hostname. The DNSPolicy resource uses the status of the Gateway to determine what dns records need to be created based on the clusters it has been placed onto.</p> <p>Given the following multi cluster gateway status: <pre><code>status:\n  addresses:\n\n    - type: kuadrant.io/MultiClusterIPAddress\n      value: kind-mgc-workload-1/172.31.201.1\n    - type: kuadrant.io/MultiClusterIPAddress\n      value: kind-mgc-workload-2/172.31.202.1\n  listeners:\n    - attachedRoutes: 1\n      conditions: []\n      name: kind-mgc-workload-1.api\n      supportedKinds: []\n    - attachedRoutes: 1\n      conditions: []\n      name: kind-mgc-workload-2.api\n      supportedKinds: []        \n</code></pre></p> <p>A DNSPolicy targeting this gateway would create an appropriate DNSRecord based on the routing strategy selected.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#loadbalanced","title":"loadbalanced","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: echo.apps.hcpapps.net\n  namespace: &lt;Gateway Namespace&gt;\nspec:\n  endpoints:\n\n    - dnsName: 24osuu.lb-2903yb.echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.202.1\n    - dnsName: default.lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: weight\n          value: \"120\"\n      recordTTL: 60\n      recordType: CNAME\n      setIdentifier: 24osuu.lb-2903yb.echo.apps.hcpapps.net\n      targets:\n        - 24osuu.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: default.lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: weight\n          value: \"120\"\n      recordTTL: 60\n      recordType: CNAME\n      setIdentifier: lrnse3.lb-2903yb.echo.apps.hcpapps.net\n      targets:\n        - lrnse3.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: echo.apps.hcpapps.net\n      recordTTL: 300\n      recordType: CNAME\n      targets:\n        - lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: geo-country-code\n          value: '*'\n      recordTTL: 300\n      recordType: CNAME\n      setIdentifier: default\n      targets:\n        - default.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: lrnse3.lb-2903yb.echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.201.1\n  providerRefs:\n    - name: my-aws-credentials\n</code></pre> <p>After DNSRecord reconciliation the listener hostname should be resolvable through dns:</p> <pre><code>dig echo.apps.hcpapps.net +short\nlb-2903yb.echo.apps.hcpapps.net.\ndefault.lb-2903yb.echo.apps.hcpapps.net.\nlrnse3.lb-2903yb.echo.apps.hcpapps.net.\n172.31.201.1\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#simple","title":"simple","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: echo.apps.hcpapps.net\n  namespace: &lt;Gateway Namespace&gt;\nspec:\n  endpoints:\n\n    - dnsName: echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.201.1\n        - 172.31.202.1\n  providerRefs:\n   - name: my-aws-credentials \n</code></pre> <p>After DNSRecord reconciliation the listener hostname should be resolvable through dns:</p> <pre><code>dig echo.apps.hcpapps.net +short\n172.31.201.1\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#known-limitations","title":"Known limitations","text":"<ul> <li>One Gateway can only be targeted by one DNSPolicy unless subsequent DNSPolicies choose to specific a sectionName in their targetRef.</li> <li>DNSPolicies can only target Gateways defined within the same namespace of the DNSPolicy.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/logging/","title":"Logging","text":"<p>The kuadrant operator outputs 3 levels of log messages: (from lowest to highest level)</p> <ol> <li><code>debug</code></li> <li><code>info</code> (default)</li> <li><code>error</code></li> </ol> <p><code>info</code> logging is restricted to high-level information. Actions like creating, deleteing or updating kubernetes resources will be logged with reduced details about the corresponding objects, and without any further detailed logs of the steps in between, except for errors.</p> <p>Only <code>debug</code> logging will include processing details.</p> <p>To configure the desired log level, set the environment variable <code>LOG_LEVEL</code> to one of the supported values listed above. Default log level is <code>info</code>.</p> <p>Apart from log level, the operator can output messages to the logs in 2 different formats:</p> <ul> <li><code>production</code> (default): each line is a parseable JSON object with properties <code>{\"level\":string, \"ts\":int, \"msg\":string, \"logger\":string, extra values...}</code></li> <li><code>development</code>: more human-readable outputs, extra stack traces and logging info, plus extra values output as JSON, in the format: <code>&lt;timestamp-iso-8601&gt;\\t&lt;log-level&gt;\\t&lt;logger&gt;\\t&lt;message&gt;\\t{extra-values-as-json}</code></li> </ul> <p>To configure the desired log mode, set the environment variable <code>LOG_MODE</code> to one of the supported values listed above. Default log level is <code>production</code>.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/","title":"Kuadrant Rate Limiting","text":"<p>A Kuadrant RateLimitPolicy custom resource, often abbreviated \"RateLimitPolicy\":</p> <ol> <li>Targets Gateway API networking resources such as HTTPRoutes and Gateways, using these resources to obtain additional context, i.e., which traffic workload (HTTP attributes, hostnames, user attributes, etc) to rate limit.</li> <li>Supports targeting subsets (sections) of a network resource to apply the limits to.</li> <li>Abstracts the details of the underlying Rate Limit protocol and configuration resources, that have a much broader remit and surface area.</li> <li>Enables cluster operators to set defaults that govern behavior at the lower levels of the network, until a more specific policy is applied.</li> </ol>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#envoys-rate-limit-service-protocol","title":"Envoy's Rate Limit Service Protocol","text":"<p>Kuadrant's Rate Limit implementation relies on the Envoy's Rate Limit Service (RLS) protocol. The workflow per request goes:</p> <ol> <li>On incoming request, the gateway checks the matching rules for enforcing rate limits, as stated in the RateLimitPolicy custom resources and targeted Gateway API networking objects</li> <li>If the request matches, the gateway sends one RateLimitRequest to the external rate limiting service (\"Limitador\").</li> <li>The external rate limiting service responds with a RateLimitResponse back to the gateway with either an <code>OK</code> or <code>OVER_LIMIT</code> response code.</li> </ol> <p>A RateLimitPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external rate limiting service.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#the-ratelimitpolicy-custom-resource","title":"The RateLimitPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#overview","title":"Overview","text":"<p>The <code>RateLimitPolicy</code> spec includes, basically, two parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>Limit definitions (<code>spec.limits</code>)</li> </ul> <p>Each limit definition includes:</p> <ul> <li>A set of rate limits (<code>spec.limits.&lt;limit-name&gt;.rates[]</code>)</li> <li>(Optional) A set of dynamic counter qualifiers (<code>spec.limits.&lt;limit-name&gt;.counters[]</code>)</li> <li>(Optional) A set of additional dynamic conditions to activate the limit (<code>spec.limits.&lt;limit-name&gt;.when[]</code>)</li> </ul> <p>The limit definitions (<code>limits</code>) can be declared at the top-level level of the spec (with the semantics of defaults) or alternatively within explicit <code>defaults</code> or <code>overrides</code> blocks.</p> Check out Kuadrant RFC 0002 to learn more about the Well-known Attributes that can be used to define counter qualifiers (<code>counters</code>) and conditions (<code>when</code>)."},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#high-level-example-and-field-definition","title":"High-level example and field definition","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: my-rate-limit-policy\nspec:\n  # Reference to an existing networking resource to attach the policy to. REQUIRED.\n  # It can be a Gateway API HTTPRoute or Gateway resource.\n  # It can only refer to objects in the same namespace as the RateLimitPolicy.\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute / Gateway\n    name: myroute / mygateway\n\n  # The limits definitions to apply to the network traffic routed through the targeted resource.\n  # Equivalent to if otherwise declared within `defaults`.\n  limits:\n    \"my_limit\":\n      # The rate limits associated with this limit definition. REQUIRED.\n      # E.g., to specify a 50rps rate limit, add `{ limit: 50, duration: 1, unit: secod }`\n      rates: [\u2026]\n\n      # Counter qualifiers.\n      # Each dynamic value in the data plane starts a separate counter, combined with each rate limit.\n      # E.g., to define a separate rate limit for each user name detected by the auth layer, add `metadata.filter_metadata.envoy\\.filters\\.http\\.ext_authz.username`.\n      # Check out Kuadrant RFC 0002 (https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md) to learn more about the Well-known Attributes that can be used in this field.\n      counters: [\u2026]\n\n      # Additional dynamic conditions to trigger the limit.\n      # Use it for filtering attributes not supported by HTTPRouteRule or with RateLimitPolicies that target a Gateway.\n      # Check out Kuadrant RFC 0002 (https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md) to learn more about the Well-known Attributes that can be used in this field.\n      when: [\u2026]\n\n    # Explicit defaults. Used in policies that target a Gateway object to express default rules to be enforced on\n    # routes that lack a more specific policy attached to.\n    # Mutually exclusive with `overrides` and with declaring `limits` at the top-level of the spec.\n    defaults:\n      limits: { \u2026 }\n\n    # Overrides. Used in policies that target a Gateway object to be enforced on all routes linked to the gateway,\n    # thus also overriding any more specific policy occasionally attached to any of those routes.\n    # Mutually exclusive with `defaults` and with declaring `limits` at the top-level of the spec.\n    overrides:\n      limits: { \u2026 }\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#using-the-ratelimitpolicy","title":"Using the RateLimitPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#targeting-a-httproute-networking-resource","title":"Targeting a HTTPRoute networking resource","text":"<p>When a RateLimitPolicy targets a HTTPRoute, the policy is enforced to all traffic routed according to the rules and hostnames specified in the HTTPRoute, across all Gateways referenced in the <code>spec.parentRefs</code> field of the HTTPRoute.</p> <p>Target a HTTPRoute by setting the <code>spec.targetRef</code> field of the RateLimitPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: &lt;RateLimitPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: &lt;HTTPRoute Name&gt;\n  limits: { \u2026 }\n</code></pre> <p></p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#hostnames-and-wildcards","title":"Hostnames and wildcards","text":"<p>If a RateLimitPolicy targets a route defined for <code>*.com</code> and another RateLimitPolicy targets another route for <code>api.com</code>, the Kuadrant control plane will not merge these two RateLimitPolicies. Unless one of the policies declare an overrides set of limites, the control plane will configure to mimic the behavior of gateway implementation by which the \"most specific hostname wins\", thus enforcing only the corresponding applicable policies and limit definitions.</p> <p>E.g., by default, a request coming for <code>api.com</code> will be rate limited according to the rules from the RateLimitPolicy that targets the route for <code>api.com</code>; while a request for <code>other.com</code> will be rate limited with the rules from the RateLimitPolicy targeting the route for <code>*.com</code>.</p> <p>See more examples in Overlapping Gateway and HTTPRoute RateLimitPolicies.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>A RateLimitPolicy that targets a Gateway can declare a block of defaults (<code>spec.defaults</code>) or a block of overrides (<code>spec.overrides</code>). As a standard, gateway policies that do not specify neither defaults nor overrides, act as defaults.</p> <p>When declaring defaults, a RateLimitPolicy which targets a Gateway will be enforced to all HTTP traffic hitting the gateway, unless a more specific RateLimitPolicy targeting a matching HTTPRoute exists. Any new HTTPRoute referrencing the gateway as parent will be automatically covered by the default RateLimitPolicy, as well as changes in the existing HTTPRoutes.</p> <p>Defaults provide cluster operators with the ability to protect the infrastructure against unplanned and malicious network traffic attempt, such as by setting safe default limits on hostnames and hostname wildcards.</p> <p>Inversely, a gateway policy that specify overrides declares a set of rules to be enforced on all routes attached to the gateway, thus atomically replacing any more specific policy occasionally attached to any of those routes.</p> <p>Target a Gateway HTTPRoute by setting the <code>spec.targetRef</code> field of the RateLimitPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: &lt;RateLimitPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n  defaults: # alternatively: `overrides`\n    limits: { \u2026 }\n</code></pre> <p></p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#overlapping-gateway-and-httproute-ratelimitpolicies","title":"Overlapping Gateway and HTTPRoute RateLimitPolicies","text":"<p>Two possible semantics are to be considered here \u2013 gateway policy defaults vs gateway policy overrides.</p> <p>Gateway RateLimitPolicies that declare defaults (or alternatively neither defaults nor overrides) protect all traffic routed through the gateway except where a more specific HTTPRoute RateLimitPolicy exists, in which case the HTTPRoute RateLimitPolicy prevails.</p> <p>Example with 4 RateLimitPolicies, 3 HTTPRoutes and 1 Gateway default (plus 2 HTTPRoute and 2 Gateways without RateLimitPolicies attached):</p> <ul> <li>RateLimitPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy G (defaults) \u2192 Gateway G (<code>*.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 RateLimitPolicy A will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 RateLimitPolicy B will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 RateLimitPolicy W will be enforced</li> <li>Request to <code>other.com</code> (suppose a route exists) \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>yet-another.net</code> (suppose a route and gateway exist) \u2192 No RateLimitPolicy will be enforced</li> </ul> <p>Gateway RateLimitPolicies that declare overrides protect all traffic routed through the gateway, regardless of existence of any more specific HTTPRoute RateLimitPolicy.</p> <p>Example with 4 RateLimitPolicies, 3 HTTPRoutes and 1 Gateway override (plus 2 HTTPRoute and 2 Gateways without RateLimitPolicies attached):</p> <ul> <li>RateLimitPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy G (overrides) \u2192 Gateway G (<code>*.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>other.com</code> (suppose a route exists) \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>yet-another.net</code> (suppose a route and gateway exist) \u2192 No RateLimitPolicy will be enforced</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#limit-definition","title":"Limit definition","text":"<p>A limit will be activated whenever a request comes in and the request matches:</p> <ul> <li>all of the <code>when</code> conditions specified in the limit.</li> </ul> <p>A limit can define:</p> <ul> <li>counters that are qualified based on dynamic values fetched from the request, or</li> <li>global counters (implicitly, when no qualified counter is specified)</li> </ul> <p>A limit is composed of one or more rate limits.</p> <p>E.g.</p> <pre><code>spec:\n  limits:\n    \"toystore-all\":\n      rates:\n\n        - limit: 5000\n          window: 1s\n\n    \"toystore-api-per-username\":\n      rates:\n\n        - limit: 100\n          window: 1s\n        - limit: 1000\n          window: 1m\n      counters:\n        - expression: auth.identity.username\n      when:\n        - predicate: request.host == 'api.toystore.com'\n\n    \"toystore-admin-unverified-users\":\n      rates:\n\n        - limit: 250\n          window: 1s\n      when:\n        - predicate: request.host == 'admin.toystore.com'\n        - predicate: !auth.identity.email_verified\n</code></pre> Request to Rate limits enforced <code>api.toystore.com</code> 100rps/username or 1000rpm/username (whatever happens first) <code>admin.toystore.com</code> 250rps <code>other.toystore.com</code> 5000rps"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#when-conditions","title":"<code>when</code> conditions","text":"<p><code>when</code> conditions can be used to scope a limit (i.e. to filter the traffic to which a limit definition applies) without any coupling to the underlying network topology, i.e. without making direct references to HTTPRouteRules.</p> <p>Use <code>when</code> conditions to conditionally activate limits based on attributes that cannot be expressed in the HTTPRoutes' <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or in general in RateLimitPolicies that target a Gateway.</p> <p>The selectors within the <code>when</code> conditions of a RateLimitPolicy are a subset of Kuadrant's Well-known Attributes (RFC 0002). Check out the reference for the full list of supported selectors.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of rate limiting services with Kuadrant:</p> <ul> <li>Simple Rate Limiting for Applications</li> <li>Authenticated Rate Limiting for Application</li> <li>Gateway Rate Limiting for Cluster Operators</li> <li>Authenticated Rate Limiting with JWTs and Kubernetes RBAC</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#known-limitations","title":"Known limitations","text":"<ul> <li>RateLimitPolicies can only target HTTPRoutes/Gateways defined within the same namespace of the RateLimitPolicy.</li> <li>2+ RateLimitPolicies cannot target network resources that define/inherit the same exact hostname.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#implementation-details","title":"Implementation details","text":"<p>Driven by limitations related to how Istio injects configuration in the filter chains of the ingress gateways, Kuadrant relies on Envoy's Wasm Network filter in the data plane, to manage the integration with rate limiting service (\"Limitador\"), instead of the Rate Limit filter.</p> <p>Motivation: Multiple rate limit domains</p> <p>The first limitation comes from having only one filter chain per listener. This often leads to one single global rate limiting filter configuration per gateway, and therefore to a shared rate limit domain across applications and policies. Even though, in a rate limit filter, the triggering of rate limit calls, via actions to build so-called \"descriptors\", can be defined at the level of the virtual host and/or specific route rule, the overall rate limit configuration is only one, i.e., always the same rate limit domain for all calls to Limitador.</p> <p>On the other hand, the possibility to configure and invoke the rate limit service for multiple domains depending on the context allows to isolate groups of policy rules, as well as to optimize performance in the rate limit service, which can rely on the domain for indexation.</p> <p>Motivation: Fine-grained matching rules A second limitation of configuring the rate limit filter via Istio, particularly from Gateway API resources, is that rate limit descriptors at the level of a specific HTTP route rule require \"named routes\" \u2013 defined only in an Istio VirtualService resource and referred in an EnvoyFilter one. Because Gateway API HTTPRoute rules lack a \"name\" property<sup>1</sup>, as well as the Istio VirtualService resources are only ephemeral data structures handled by Istio in-memory in its implementation of gateway configuration for Gateway API, where the names of individual route rules are auto-generated and not referable by users in a policy<sup>2</sup><sup>3</sup>, rate limiting by attributes of the HTTP request (e.g., path, method, headers, etc) would be very limited while depending only on Envoy's Rate Limit filter.</p> <p>Motivated by the desire to support multiple rate limit domains per ingress gateway, as well as fine-grained HTTP route matching rules for rate limiting, Kuadrant implements a wasm-shim that handles the rules to invoke the rate limiting service, complying with Envoy's Rate Limit Service (RLS) protocol.</p> <p>The wasm module integrates with the gateway in the data plane via Wasm Network filter, and parses a configuration composed out of user-defined RateLimitPolicy resources by the Kuadrant control plane. Whereas the rate limiting service (\"Limitador\") remains an implementation of Envoy's RLS protocol, capable of being integrated directly via Rate Limit extension or by Kuadrant, via wasm module for the Istio Gateway API implementation.</p> <p>As a consequence of this design:</p> <ul> <li>Users can define fine-grained rate limit rules that match their Gateway and HTTPRoute definitions including for subsections of these.</li> <li>Rate limit definitions are insulated, not leaking across unrelated policies or applications.</li> <li>Conditions to activate limits are evaluated in the context of the gateway process, reducing the gRPC calls to the external rate limiting service only to the cases where rate limit counters are known in advance to have to be checked/incremented.</li> <li>The rate limiting service can rely on the indexation to look up for groups of limit definitions and counters.</li> <li>Components remain compliant with industry protocols and flexible for different integration options.</li> </ul> <p>A Kuadrant wasm-shim configuration for one RateLimitPolicy custom resources targeting a HTTPRoute looks like the following and it is generated automatically by the Kuadrant control plane:</p> <pre><code>apiVersion: extensions.istio.io/v1alpha1\nkind: WasmPlugin\nmetadata:\n  creationTimestamp: \"2024-10-01T16:59:40Z\"\n  generation: 1\n  name: kuadrant-kuadrant-ingressgateway\n  namespace: gateway-system\n  ownerReferences:\n\n    - apiVersion: gateway.networking.k8s.io/v1\n      blockOwnerDeletion: true\n      controller: true\n      kind: Gateway\n      name: kuadrant-ingressgateway\n      uid: 0298355b-fb30-4442-af2b-88d0c05bd2bd\n  resourceVersion: \"11253\"\n  uid: 36ef1fb7-9eca-46c7-af63-fe783f40148c\nspec:\n  phase: STATS\n  pluginConfig:\n    services:\n      ratelimit-service:\n        type: ratelimit\n        endpoint: ratelimit-cluster\n        failureMode: allow\n    actionSets:\n      - name: some_name_0\n        routeRuleConditions:\n          hostnames:\n            - \"*.toystore.website\"\n            - \"*.toystore.io\"\n          predicates:\n            - request.url_path.startsWith(\"/assets\")\n        actions:\n          - service: ratelimit-service\n            scope: gateway-system/app-rlp\n            predicates:\n              - request.host.endsWith('.toystore.website')\n            data:\n              - expression:\n                  key: limit.toystore_assets_all_domains__b61ee8e6\n                  value: \"1\"\n      - name: some_name_1\n        routeRuleConditions:\n          hostnames:\n            - \"*.toystore.website\"\n            - \"*.toystore.io\"\n          predicates:\n            - request.url_path.startsWith(\"/v1\")\n        actions:\n          - service: ratelimit-service\n            scope: gateway-system/app-rlp\n            predicates:\n              - request.host.endsWith('.toystore.website')\n              - auth.identity.username == \"\"\n            data:\n              - expression:\n                  key: limit.toystore_v1_website_unauthenticated__377837ee\n                  value: \"1\"\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: kuadrant-ingressgateway\n  url: oci://quay.io/kuadrant/wasm-shim:latest\n</code></pre> <ol> <li> <p>https://github.com/kubernetes-sigs/gateway-api/pull/996\u00a0\u21a9</p> </li> <li> <p>https://github.com/istio/istio/issues/36790\u00a0\u21a9</p> </li> <li> <p>https://github.com/istio/istio/issues/37346\u00a0\u21a9</p> </li> </ol>"},{"location":"kuadrant-operator/doc/overviews/tls/","title":"TLS","text":"<p>A Kuadrant TLSPolicy custom resource:</p> <p>Targets Gateway API networking resources Gateways to provide tls for gateway listeners by managing the lifecycle of tls certificates using <code>CertManager</code>.</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#the-tlspolicy-custom-resource","title":"The TLSPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#overview","title":"Overview","text":"<p>The <code>TLSPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/tls/#high-level-example-and-field-definition","title":"High-level example and field definition","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: my-tls-policy\nspec:\n  # reference to an existing networking resource to attach the policy to\n  # it can only be a Gateway API Gateway resource\n  # it can only refer to objects in the same namespace as the TLSPolicy\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mygateway\n</code></pre> <p>Check out the API reference for a full specification of the TLSPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#using-the-tlspolicy","title":"Using the TLSPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>When a TLSPolicy targets a Gateway, the policy will be enforced on all gateway listeners that have a valid TLS section.</p> <p>Target a Gateway by setting the <code>spec.targetRef</code> field of the TLSPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1beta2\nkind: TLSPolicy\nmetadata:\n  name: &lt;TLSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/tls/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of using the Kuadrant TLSPolicy:</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#known-limitations","title":"Known limitations","text":""},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/","title":"RLP can target a Gateway resource","text":"<p>Previous version: https://hackmd.io/IKEYD6NrSzuGQG1nVhwbcw</p> <p>Based on: https://hackmd.io/_1k6eLCNR2eb9RoSzOZetg</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#introduction","title":"Introduction","text":"<p>The current RateLimitPolicy CRD already implements a <code>targetRef</code> with a reference to Gateway API's HTTPRoute. This doc  captures the design and some implementation details of allowing the <code>targetRef</code> to reference a Gateway API's Gateway.</p> <p>Having in place this HTTPRoute - Gateway hierarchy, we are also considering to apply Policy Attachment's defaults/overrides approach to the RateLimitPolicy CRD. But for now, it will only be about targeting the Gateway resource.</p> <p></p> <p>On designing Kuadrant's rate limiting and considering Istio/Envoy's rate limiting offering, we hit two limitations (described here). Therefore, not giving up entirely in existing Envoy's RateLimit Filter, we decided to move on and leverage the Envoy's Wasm Network Filter and implement rate limiting wasm-shim module compliant with the Envoy's Rate Limit Service (RLS). This wasm-shim module accepts a PluginConfig struct object as input configuration object.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#use-cases-targeting-a-gateway","title":"Use Cases targeting a gateway","text":"<p>A key use case is being able to provide governance over what service providers can and cannot do when exposing a service via a shared ingress gateway. As well as providing certainty that no service is exposed without my ability as a cluster administrator to protect my infrastructure from unplanned load from badly behaving clients etc.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#goals","title":"Goals","text":"<p>The goal of this document is to define:</p> <ul> <li>The schema of this <code>PluginConfig</code> struct.</li> <li>The kuadrant-operator behavior filling the <code>PluginConfig</code> struct having as input the RateLimitPolicy k8s objects</li> <li>The behavior of the wasm-shim having the <code>PluginConfig</code> struct as input.</li> </ul>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#envoys-rate-limit-service-protocol","title":"Envoy's Rate Limit Service Protocol","text":"<p>Kuadrant's rate limit relies on the Rate Limit Service (RLS) protocol, hence the gateway generates, based on a set of actions, a set of descriptors (one descriptor is a set of descriptor entries). Those descriptors are send to the external rate limit service provider. When multiple descriptors are provided, the external service provider will limit on ALL of them and return an OVER_LIMIT response if any of them are over limit.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#schema-crd-of-the-ratelimitpolicy","title":"Schema (CRD) of the RateLimitPolicy","text":"<pre><code>---\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: my-rate-limit-policy\nspec:\n  # Reference to an existing networking resource to attach the policy to. REQUIRED.\n  # It can be a Gateway API HTTPRoute or Gateway resource.\n  # It can only refer to objects in the same namespace as the RateLimitPolicy.\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute / Gateway\n    name: myroute / mygateway\n\n  # The limits definitions to apply to the network traffic routed through the targeted resource.\n  # Equivalent to if otherwise declared within `defaults`.\n  limits:\n    \"my_limit\":\n      # The rate limits associated with this limit definition. REQUIRED.\n      # E.g., to specify a 50rps rate limit, add `{ limit: 50, duration: 1, unit: secod }`\n      rates: [\u2026]\n\n      # Counter qualifiers.\n      # Each dynamic value in the data plane starts a separate counter, combined with each rate limit.\n      # E.g., to define a separate rate limit for each user name detected by the auth layer, add `metadata.filter_metadata.envoy\\.filters\\.http\\.ext_authz.username`.\n      # Check out Kuadrant RFC 0002 (https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md) to learn more about the Well-known Attributes that can be used in this field.\n      counters: [\u2026]\n\n      # Additional dynamic conditions to trigger the limit.\n      # Use it for filtering attributes not supported by HTTPRouteRule or with RateLimitPolicies that target a Gateway.\n      # Check out Kuadrant RFC 0002 (https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md) to learn more about the Well-known Attributes that can be used in this field.\n      when: [\u2026]\n\n    # Explicit defaults. Used in policies that target a Gateway object to express default rules to be enforced on\n    # routes that lack a more specific policy attached to.\n    # Mutually exclusive with `overrides` and with declaring `limits` at the top-level of the spec.\n    defaults:\n      limits: {\u2026}\n\n    # Overrides. Used in policies that target a Gateway object to be enforced on all routes linked to the gateway,\n    # thus also overriding any more specific policy occasionally attached to any of those routes.\n    # Mutually exclusive with `defaults` and with declaring `limits` at the top-level of the spec.\n    overrides:\n      limits: {\u2026}\n</code></pre> <p><code>.spec.rateLimits</code> holds a list of rate limit configurations represented by the object <code>RateLimit</code>. Each <code>RateLimit</code> object represents a complete rate limit configuration. It contains three fields:</p> <ul> <li> <p><code>rules</code> (optional): Rules allow matching <code>hosts</code> and/or <code>methods</code> and/or <code>paths</code>. Matching occurs when at least one rule applies against the incoming request. If rules are not set, it is equivalent to matching all the requests.</p> </li> <li> <p><code>configurations</code> (required): Specifies a set of rate limit configurations that could be applied. The rate limit configuration object is the equivalent of the config.route.v3.RateLimit envoy object. One configuration is, in turn, a list of rate limit actions. Each action populates a descriptor entry. A vector of descriptor entries compose a descriptor. Each configuration produces, at most, one descriptor. Depending on the incoming request, one configuration may or may not produce a rate limit descriptor. These rate limiting configuration rules provide flexibility to produce multiple descriptors. For example, you may want to define one generic rate limit descriptor and another descriptor depending on some header. If the header does not exist, the second descriptor is not generated, but traffic keeps being rate limited based on the generic descriptor.</p> </li> </ul> <pre><code>configurations:\n\n  - actions:\n    - request_headers:\n        header_name: \"X-MY-CUSTOM-HEADER\"\n        descriptor_key: \"custom-header\"\n        skip_if_absent: true\n  - actions:\n    - generic_key:\n        descriptor_key: admin\n        descriptor_value: \"1\"\n</code></pre> <ul> <li><code>limits</code> (optional): configuration of the rate limiting service (Limitador). Check out limitador documentation for more information about the fields of each <code>Limit</code> object.</li> </ul> <p>Note: No <code>namespace</code>/<code>domain</code> defined. Kuadrant operator will figure out.</p> <p>Note: There is no <code>PREAUTH</code>, <code>POSTAUTH</code> stage defined. Ratelimiting filter should be placed after authorization filter to enable authenticated rate limiting. In the future, <code>stage</code> can be implemented.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#kuadrant-operators-behavior","title":"Kuadrant-operator's behavior","text":"<p>One HTTPRoute can only be targeted by one rate limit policy.</p> <p>Similarly, one Gateway can only be targeted by one rate limit policy.</p> <p>However, indirectly, one gateway will be affected by multiple rate limit policies. It is by design of the Gateway API, one gateway can be referenced by multiple HTTPRoute objects. Furthermore, one HTTPRoute can reference multiple gateways.</p> <p>The kuadrant operator will aggregate all the rate limit policies that apply for each gateway, including RLP targeting HTTPRoutes and Gateways.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#virtualhosting-ratelimitpolicies","title":"\"VirtualHosting\" RateLimitPolicies","text":"<p>Rate limit policies are scoped by the domains defined at the referenced HTTPRoute's hostnames and Gateway's Listener's Hostname.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#multiple-httproutes-with-the-same-hostname","title":"Multiple HTTPRoutes with the same hostname","text":"<p>When there are multiple HTTPRoutes with the same hostname, HTTPRoutes are all admitted and envoy merge the routing configuration in the same virtualhost. In these cases, the control plane has to \"merge\" the rate limit configuration into a single entry for the wasm filter.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#overlapping-httproutes","title":"Overlapping HTTPRoutes","text":"<p>If some RLP targets a route for <code>*.com</code> and other RLP targets another route for <code>api.com</code>, the control plane does not do any merging. A request coming for <code>api.com</code> will be rate limited with the rules from the RLP targeting the route <code>api.com</code>. Also, a request coming for <code>other.com</code> will be rate limited with the rules from the RLP targeting the route <code>*.com</code>.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#examples","title":"examples","text":"<p>RLP A -&gt; HTTPRoute A (<code>api.toystore.com</code>) -&gt; Gateway G (<code>*.com</code>)</p> <p>RLP B -&gt; HTTPRoute B (<code>other.toystore.com</code>) -&gt; Gateway G (<code>*.com</code>)</p> <p>RLP H -&gt; HTTPRoute H (<code>*.toystore.com</code>) -&gt; Gateway G (<code>*.com</code>)</p> <p>RLP G -&gt; Gateway G (<code>*.com</code>)</p> <p>Request 1 (<code>api.toystore.com</code>) -&gt; apply RLP A and RLP G</p> <p>Request 2 (<code>other.toystore.com</code>) -&gt; apply RLP B and RLP G</p> <p>Request 3 (<code>unknown.toystore.com</code>) -&gt; apply RLP H and RLP G</p> <p>Request 4 (<code>other.com</code>) -&gt; apply RLP G</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#rate-limit-domain-limitador-namespace","title":"rate limit domain / limitador namespace","text":"<p>The kuadrant operator will add <code>domain</code> attribute of the Envoy's Rate Limit Service (RLS). It will also add the <code>namespace</code> attribute of the Limitador's rate limit config. The operator will ensure that the associated actions and rate limits have a common domain/namespace.</p> <p>The value of this domain/namespace seems to be related to the virtualhost for which rate limit applies.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#schema-of-the-wasm-filter-configuration-object-the-pluginconfig","title":"Schema of the WASM filter configuration object: the <code>PluginConfig</code>","text":"<p>Currently the PluginConfig looks like this:</p> <pre><code>#  The filter\u2019s behaviour in case the rate limiting service does not respond back. When it is set to true, Envoy will not allow traffic in case of communication failure between rate limiting service and the proxy.\nfailure_mode_deny: true\nratelimitpolicies:\n  default/toystore: # rate limit policy {NAMESPACE/NAME}\n    hosts: # HTTPRoute hostnames\n\n      - '*.toystore.com'\n    rules: # route level actions\n      - operations:\n          - paths:\n              - /admin/toy\n            methods:\n              - POST\n              - DELETE\n        actions:\n          - generic_key:\n              descriptor_value: yes\n              descriptor_key: admin\n    global_actions: # virtualHost level actions\n      - generic_key:\n          descriptor_value: yes\n          descriptor_key: vhaction\n    upstream_cluster: rate-limit-cluster # Limitador address reference\n    domain: toystore-app # RLS protocol domain value\n</code></pre> <p>Proposed new design for the WASM filter configuration object (<code>PluginConfig</code> struct):</p> <pre><code>#  The filter\u2019s behaviour in case the rate limiting service does not respond back. When it is set to true, Envoy will not allow traffic in case of communication failure between rate limiting service and the proxy.\nfailure_mode_deny: true\nrate_limit_policies:\n\n  - name: toystore\n    rate_limit_domain: toystore-app\n    upstream_cluster: rate-limit-cluster\n    hostnames: [\"*.toystore.com\"]\n    gateway_actions:\n      - rules:\n          - paths: [\"/admin/toy\"]\n            methods: [\"GET\"]\n            hosts: [\"pets.toystore.com\"]\n        configurations:\n          - actions:\n            - generic_key:\n                descriptor_key: admin\n                descriptor_value: \"1\"\n</code></pre> <p>Update highlights:</p> <ul> <li>[minor] <code>rate_limit_policies</code> is a list instead of a map indexed by the name/namespace.</li> <li>[major] no distinction between \"rules\" and global actions</li> <li>[major] more aligned with RLS: multiple descriptors structured by \"rate limit configurations\" with matching rules</li> </ul>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#wasm-shim","title":"WASM-SHIM","text":"<p>WASM filter rate limit policies are not exactly the same as user managed RateLimitPolicy custom resources. The WASM filter rate limit policies is part of the  internal configuration and therefore not exposed to the end user.</p> <p>At the WASM filter level, there are no route level or gateway level rate limit policies. The rate limit policies in the wasm plugin configuration may not map 1:1 to user managed RateLimitPolicy custom resources. WASM rate limit policies have an internal logical name and a set of hostnames to activate it based on the incoming request\u2019s host header.</p> <p>The WASM filter builds a tree based data structure holding the rate limit policies. The longest (sub)domain match is used to select the policy to be applied. Only one policy is being applied per invocation.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#rate-limit-configurations","title":"rate limit configurations","text":"<p>The WASM filter configuration object contains a list of rate limit configurations to build a list of Envoy's RLS descriptors. These configurations are defined at</p> <pre><code>rate_limit_policies[*].gateway_actions[*].configurations\n</code></pre> <p>For example:</p> <pre><code>configurations:\n\n- actions:\n   - generic_key:\n        descriptor_key: admin\n        descriptor_value: \"1\"\n</code></pre> <p>How to read the policy:</p> <ul> <li> <p>Each configuration produces, at most, one descriptor. Depending on the incoming request, one configuration may or may not produce a rate limit descriptor.</p> </li> <li> <p>Each policy configuration has associated, optionally, a set of rules to match. Rules allow matching <code>hosts</code> and/or <code>methods</code> and/or <code>paths</code>. Matching occurs when at least one rule applies against the incoming request. If rules are not set, it is equivalent to matching all the requests.</p> </li> <li> <p>Each configuration object defines a list of actions. Each action may (or may not) produce a descriptor entry (descriptor list item). If an action cannot append a descriptor entry, no descriptor is generated for the configuration.</p> </li> </ul> <p>Note: The external rate limit service will be called when the <code>gateway_actions</code> object produces at least one not empty descriptor.</p>"},{"location":"kuadrant-operator/doc/proposals/rlp-target-gateway-resource/#example","title":"example","text":"<p>WASM filter rate limit policy for <code>*.toystore.com</code>. I want some rate limit descriptors configuration only for <code>api.toystore.com</code> and another set of descriptors for <code>admin.toystore.com</code>. The wasm filter config would look like this:</p> <pre><code>failure_mode_deny: true\nrate_limit_policies:\n\n  - name: toystore\n    rate_limit_domain: toystore-app\n    upstream_cluster: rate-limit-cluster\n    hostnames: [\"*.toystore.com\"]\n    gateway_actions:\n      - configurations:  # no rules. Applies to all *.toystore.com traffic\n          - actions:\n              - generic_key:\n                  descriptor_key: toystore-app\n                  descriptor_value: \"1\"\n      - rules:\n          - hosts: [\"api.toystore.com\"]\n        configurations:\n          - actions:\n              - generic_key:\n                  descriptor_key: api\n                  descriptor_value: \"1\"\n      - rules:\n          - hosts: [\"admin.toystore.com\"]\n        configurations:\n          - actions:\n              - generic_key:\n                  descriptor_key: admin\n                  descriptor_value: \"1\"\n</code></pre> <ul> <li>When a request for <code>api.toystore.com</code> hits the filter, the descriptors generated would be:</li> </ul> <p>descriptor 1 <pre><code>(\"toystore-app\", \"1\")\n</code></pre> descriptor 2 <pre><code>(\"api\", \"1\")\n</code></pre></p> <ul> <li>When a request for <code>admin.toystore.com</code> hits the filter, the descriptors generated would be:</li> </ul> <p>descriptor 1 <pre><code>(\"toystore-app\", \"1\")\n</code></pre> descriptor 2 <pre><code>(\"admin\", \"1\")\n</code></pre></p> <ul> <li>When a request for <code>other.toystore.com</code> hits the filter, the descriptors generated would be: descriptor 1 <pre><code>(\"toystore-app\", \"1\")\n</code></pre></li> </ul>"},{"location":"kuadrant-operator/doc/reference/authpolicy/","title":"The AuthPolicy Custom Resource Definition (CRD)","text":"<ul> <li>AuthPolicy</li> <li>AuthPolicySpec</li> <li>AuthScheme<ul> <li>AuthRuleCommon</li> <li>AuthenticationRule</li> <li>MetadataRule</li> <li>AuthorizationRule</li> <li>ResponseSpec</li> <li>SuccessResponseSpec<ul> <li>SuccessResponseItem</li> </ul> </li> <li>CallbackRule</li> </ul> </li> <li>NamedPattern</li> <li>AuthPolicyCommonSpec</li> <li>AuthPolicyStatus</li> <li>ConditionSpec</li> </ul>"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicy","title":"AuthPolicy","text":"Field Type Required Description <code>spec</code> AuthPolicySpec Yes The specification for AuthPolicy custom resource <code>status</code> AuthPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicyspec","title":"AuthPolicySpec","text":"Field Type Required Description <code>targetRef</code> LocalPolicyTargetReference Yes Reference to a Kubernetes resource that the policy attaches to <code>rules</code> AuthScheme No Implicit default authentication/authorization rules <code>patterns</code> MapNamedPattern&gt; No Implicit default named patterns of lists of <code>selector</code>, <code>operator</code> and <code>value</code> tuples, to be reused in <code>when</code> conditions and pattern-matching authorization rules. <code>when</code> []PatternExpressionOrRef No List of implicit default additional dynamic conditions (expressions) to activate the policy. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway. <code>defaults</code> AuthPolicyCommonSpec No Explicit default definitions. This field is mutually exclusive with any of the implicit default definitions: <code>spec.rules</code>, <code>spec.patterns</code>, <code>spec.when</code> <code>overrides</code> AuthPolicyCommonSpec No Atomic overrides definitions. This field is mutually exclusive with any of the implicit or explicit default definitions: <code>spec.rules</code>, <code>spec.patterns</code>, <code>spec.when</code>, <code>spec.default</code>"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicycommonspec","title":"AuthPolicyCommonSpec","text":"Field Type Required Description <code>rules</code> AuthScheme No Authentication/authorization rules <code>patterns</code> MapNamedPattern&gt; No Named patterns of lists of <code>selector</code>, <code>operator</code> and <code>value</code> tuples, to be reused in <code>when</code> conditions and pattern-matching authorization rules. <code>when</code> []PatternExpressionOrRef No List of additional dynamic conditions (expressions) to activate the policy. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authscheme","title":"AuthScheme","text":"Field Type Required Description <code>authentication</code> MapAuthenticationRule&gt; No Authentication rules. At least one config MUST evaluate to a valid identity object for the auth request to be successful. If omitted or empty, anonymous access is assumed. <code>metadata</code> MapMetadataRule&gt; No Rules for fetching auth metadata from external sources. <code>authorization</code> MapAuthorizationRule&gt; No Authorization rules. All policies MUST allow access for the auth request be successful. <code>response</code> ResponseSpec No Customizations to the response to the authorization request. Use it to set custom values for unauthenticated, unauthorized, and/or success access request. <code>callbacks</code> MapCallbackRule&gt; No Rules for post-authorization callback requests to external services. Triggered regardless of the result of the authorization request."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authrulecommon","title":"AuthRuleCommon","text":"Field Type Required Description <code>when</code> []PatternExpressionOrRef No List of additional dynamic conditions (expressions) to activate the auth rule. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway. <code>cache</code> Caching spec No Caching options for the resolved object returned when applying this auth rule. (Default: disabled) <code>priority</code> Integer No Priority group of the auth rule. All rules in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially. (Default: <code>0</code>) <code>metrics</code> Boolean No Whether the auth rule emits individual observability metrics. (Default: <code>false</code>)"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authenticationrule","title":"AuthenticationRule","text":"Field Type Required Description <code>apiKey</code> API Key authentication spec No Authentication based on API keys stored in Kubernetes secrets. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>kubernetesTokenReview</code> KubernetesTokenReview spec No Authentication by Kubernetes token review. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>jwt</code> JWT verification spec No Authentication based on JSON Web Tokens (JWT). Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>oauth2Introspection</code> OAuth2 Token Introscpection spec No Authentication by OAuth2 token introspection. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>x509</code> X.509 authentication spec No Authentication based on client X.509 certificates. The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>plain</code> Plain identity object spec No Identity object extracted from the context. Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>anonymous</code> Anonymous access No Anonymous access. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>credentials</code> Auth credentials spec No Customizations to where credentials are required to be passed in the request for authentication based on this auth rule. Defaults to HTTP Authorization header with prefix \"Bearer\". <code>overrides</code> Identity extension spec No JSON overrides to set to the resolved identity object. Do not use it with identity objects of other JSON types (array, string, etc). <code>defaults</code> Identity extension spec No JSON defaults to set to the resolved identity object. Do not use it with identity objects of other JSON types (array, string, etc). (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#metadatarule","title":"MetadataRule","text":"Field Type Required Description <code>http</code> HTTP GET/GET-by-POST external metadata spec No External source of auth metadata via HTTP request. Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. <code>userInfo</code> OIDC UserInfo spec No OpendID Connect UserInfo linked to an OIDC authentication rule declared in this same AuthPolicy. Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. <code>uma</code> UMA metadata spec No User-Managed Access (UMA) source of resource data.  Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authorizationrule","title":"AuthorizationRule","text":"Field Type Required Description <code>patternMatching</code> Pattern-matching authorization spec No Pattern-matching authorization rules. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>opa</code> OPA authorization spec No Open Policy Agent (OPA) Rego policy. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>kubernetesSubjectAccessReview</code> Kubernetes SubjectAccessReview spec No Authorization by Kubernetes SubjectAccessReview. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>spicedb</code> SpiceDB authorization spec No Authorization decision delegated to external Authzed/SpiceDB server. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#responsespec","title":"ResponseSpec","text":"Field Type Required Description <code>unauthenticated</code> Custom denial status spec No Customizations on the denial status and other HTTP attributes when the request is unauthenticated. (Default: <code>401 Unauthorized</code>) <code>unauthorized</code> Custom denial status spec No Customizations on the denial status and other HTTP attributes when the request is unauthorized. (Default: <code>403 Forbidden</code>) <code>success</code> SuccessResponseSpec No Response items to be included in the auth response when the request is authenticated and authorized."},{"location":"kuadrant-operator/doc/reference/authpolicy/#successresponsespec","title":"SuccessResponseSpec","text":"Field Type Required Description <code>headers</code> Map&lt;string:SuccessResponseItem&gt; No Custom success response items wrapped as HTTP headers to be injected in the request. <code>filters</code> Map&lt;string:SuccessResponseItem&gt; No Custom success response items made available to other filters managed by Kuadrant (i.e. Rate Limit)."},{"location":"kuadrant-operator/doc/reference/authpolicy/#successresponseitem","title":"SuccessResponseItem","text":"Field Type Required Description <code>plain</code> Plain text response item No Plain text content. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>json</code> JSON injection response item No Specification of a JSON object. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>wristband</code> Festival Wristband token response item No Specification of a JSON object. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>key</code> String No The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object). Defaults to the name of the response item if omitted."},{"location":"kuadrant-operator/doc/reference/authpolicy/#callbackrule","title":"CallbackRule","text":"Field Type Required Description <code>http</code> HTTP endpoints callback spec No HTTP endpoint settings to build the callback request (webhook). (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#namedpattern","title":"NamedPattern","text":"Field Type Required Description <code>selector</code> String Yes A valid Well-known attribute whose resolved value in the data plane will be compared to <code>value</code>, using the <code>operator</code>. <code>operator</code> String Yes The binary operator to be applied to the resolved value specified by the selector. One of: <code>eq</code> (equal to), <code>neq</code> (not equal to), <code>incl</code> (includes; for arrays), <code>excl</code> (excludes; for arrays), <code>matches</code> (regex). <code>value</code> String Yes The static value to be compared to the one resolved from the selector."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicystatus","title":"AuthPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/authpolicy/#conditionspec","title":"ConditionSpec","text":"<ul> <li>The lastTransitionTime field provides a timestamp for when the entity last transitioned from one status to another.</li> <li>The message field is a human-readable message indicating details about the transition.</li> <li>The reason field is a unique, one-word, CamelCase reason for the condition\u2019s last transition.</li> <li>The status field is a string, with possible values True, False, and Unknown.</li> <li>The type field is a string with the following possible values:</li> <li>Available: the resource has successfully configured;</li> </ul> Field Type Description <code>type</code> String Condition Type <code>status</code> String Status: True, False, Unknown <code>reason</code> String Condition state reason <code>message</code> String Condition state description <code>lastTransitionTime</code> Timestamp Last transition timestamp"},{"location":"kuadrant-operator/doc/reference/dnspolicy/","title":"The DNSPolicy Custom Resource Definition (CRD)","text":"<ul> <li>DNSPolicy</li> <li>DNSPolicySpec<ul> <li>excludeAddresses</li> <li>ProviderRefs</li> <li>HealthCheckSpec</li> <li>LoadBalancingSpec</li> <li>LoadBalancingWeighted<ul> <li>CustomWeight</li> </ul> </li> <li>LoadBalancingGeo</li> </ul> </li> <li>DNSPolicyStatus<ul> <li>HealthCheckStatus</li> </ul> </li> </ul>"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicy","title":"DNSPolicy","text":"Field Type Required Description <code>spec</code> DNSPolicySpec Yes The specification for DNSPolicy custom resource <code>status</code> DNSPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicyspec","title":"DNSPolicySpec","text":"Field Type Required Description <code>targetRef</code> Gateway API LocalPolicyTargetReferenceWithSectionName  Yes Reference to a Kubernetes resource that the policy attaches to <code>healthCheck</code> HealthCheckSpec No HealthCheck spec <code>loadBalancing</code> LoadBalancingSpec No LoadBalancing Spec <code>providerRefs</code> ProviderRefs Yes array of references to providers. (currently limited to max 1)"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#providerrefs","title":"ProviderRefs","text":"Field Type Required Description <code>providerRefs</code> []ProviderRef Yes max 1 reference. This is an array of providerRef that points to a local secret(s) that contains the required provider auth values"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#providerref","title":"ProviderRef","text":"Field Type Required Description <code>name</code> String Yes Name of the secret in the same namespace that contains the provider credentials"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#excludeaddresses","title":"ExcludeAddresses","text":"Field Type Required Description <code>excludeAddresses</code> []String No set of hostname, CIDR or IP Addresses to exclude from the DNS Provider"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#healthcheckspec","title":"HealthCheckSpec","text":"Field Type Required Description <code>name</code> String Yes Name of the secret in the same namespace that contains the provider credentials -------------------- ------------ :------------: ----------------------------------------------------------------------------------------------------------- <code>path</code> String Yes Path is the path to append to the host to reach the expected health check. Must start with \"?\" or \"/\", contain only valid URL characters and end with alphanumeric char or \"/\". For example \"/\" or \"/healthz\" are common <code>port</code> Number Yes Port to connect to the host on. Must be either 80, 443 or 1024-49151 <code>protocol</code> String Yes Protocol to use when connecting to the host, valid values are \"HTTP\" or \"HTTPS\" <code>failureThreshold</code> Number Yes FailureThreshold is a limit of consecutive failures that must occur for a host to be considered unhealthy <code>interval</code> Duration Yes Interval defines how frequently this probe should execute <code>additionalHeadersRef</code> String No AdditionalHeadersRef refers to a secret that contains extra headers to send in the probe request, this is primarily useful if an authentication token is required by the endpoint. <code>allowInsecureCertificate</code> Boolean No AllowInsecureCertificate will instruct the health check probe to not fail on a self-signed or otherwise invalid SSL certificate this is primarily used in development or testing environments"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#loadbalancingspec","title":"LoadBalancingSpec","text":"Field Type Required Description <code>defaultGeo</code> Boolean Yes Specifies if this is the default geo <code>geo</code> String Yes Geo value to apply to geo endpoints <code>weight</code> Number No Weight value to apply to weighted endpoints default: 120"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicystatus","title":"DNSPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource. <code>healthCheck</code> HealthCheckStatus HealthCheck status. <code>recordConditions</code> [String][]Kubernetes meta/v1.Condition Status of individual DNSRecords owned by this policy."},{"location":"kuadrant-operator/doc/reference/dnspolicy/#healthcheckstatus","title":"HealthCheckStatus","text":"Field Type Description <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/kuadrant/","title":"The Kuadrant Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrant","title":"kuadrant","text":"Field Type Required Description <code>spec</code> KuadrantSpec No Blank specification <code>status</code> KuadrantStatus No The status for the custom resources."},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrantspec","title":"KuadrantSpec","text":"<p>Currently blank specification.</p>"},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrantstatus","title":"KuadrantStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/","title":"The RateLimitPolicy Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicy","title":"RateLimitPolicy","text":"Field Type Required Description <code>spec</code> RateLimitPolicySpec Yes The specification for RateLimitPolicy custom resource <code>status</code> RateLimitPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicyspec","title":"RateLimitPolicySpec","text":"Field Type Required Description <code>targetRef</code> LocalPolicyTargetReferenceWithSectionName Yes Reference to a Kubernetes resource that the policy attaches to. For more info <code>defaults</code> RateLimitPolicyCommonSpec No Default limit definitions. This field is mutually exclusive with the <code>limits</code> field <code>overrides</code> RateLimitPolicyCommonSpec No Overrides limit definitions. This field is mutually exclusive with the <code>limits</code> field and <code>defaults</code> field. This field is only allowed for policies targeting <code>Gateway</code> in <code>targetRef.kind</code> <code>limits</code> MapLimit&gt; No Limit definitions. This field is mutually exclusive with the <code>defaults</code> field"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#localpolicytargetreferencewithsectionname","title":"LocalPolicyTargetReferenceWithSectionName","text":"Field Type Required Description <code>LocalPolicyTargetReference</code> LocalPolicyTargetReference Yes Reference to a local policy target. <code>sectionName</code> SectionName No Section name for further specificity (if needed)."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#localpolicytargetreference","title":"LocalPolicyTargetReference","text":"Field Type Required Description <code>group</code> <code>Group</code> Yes Group of the target resource. <code>kind</code> <code>Kind</code> Yes Kind of the target resource. <code>name</code> <code>ObjectName</code> Yes Name of the target resource."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#sectionname","title":"SectionName","text":"Field Type Required Description SectionName v1.SectionName (String) Yes SectionName is the name of a section in a Kubernetes resource. In the following resources, SectionName is interpreted as the following:  Gateway: Listener name HTTPRoute: HTTPRouteRule name* Service: Port name ### RateLimitPolicyCommonSpec Field Type Required Description <code>when</code> []Predicate No List of dynamic predicates to activate the policy. All expression must evaluate to true for the policy to be applied <code>limits</code> MapLimit&gt; No Explicit Limit definitions. This field is mutually exclusive with RateLimitPolicySpec <code>limits</code> field"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#predicate","title":"Predicate","text":"Field Type Required Description <code>predicate</code> String Yes Defines one CEL expression that must be evaluated to bool"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#counter","title":"Counter","text":"Field Type Required Description <code>expression</code> String Yes Defines one CEL expression that will be used as rate limiting counter"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#limit","title":"Limit","text":"Field Type Required Description <code>rates</code> []RateLimit No List of rate limits associated with the limit definition <code>counters</code> []Counter No List of rate limit counter qualifiers. Items must be a valid Well-known attribute. Each distinct value resolved in the data plane starts a separate counter for each rate limit. <code>when</code> []Predicate No List of dynamic predicates to activate the limit. All expression must evaluate to true for the limit to be applied"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimit","title":"RateLimit","text":"Field Type Required Description <code>limit</code> Number Yes Maximum value allowed within the given period of time (duration) <code>window</code> String Yes The period of time that the limit applies. Follows Gateway API Duration format"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicystatus","title":"RateLimitPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#conditionspec","title":"ConditionSpec","text":"<ul> <li>The lastTransitionTime field provides a timestamp for when the entity last transitioned from one status to another.</li> <li>The message field is a human-readable message indicating details about the transition.</li> <li>The reason field is a unique, one-word, CamelCase reason for the condition\u2019s last transition.</li> <li>The status field is a string, with possible values True, False, and Unknown.</li> <li>The type field is a string with the following possible values:<ul> <li>Available: the resource has successfully configured;</li> </ul> </li> </ul> Field Type Description <code>type</code> String Condition Type <code>status</code> String Status: True, False, Unknown <code>reason</code> String Condition state reason <code>message</code> String Condition state description <code>lastTransitionTime</code> Timestamp Last transition timestamp"},{"location":"kuadrant-operator/doc/reference/tlspolicy/","title":"The TLSPolicy Custom Resource Definition (CRD)","text":"<ul> <li>TLSPolicy</li> <li>TLSPolicySpec</li> <li>TLSPolicyStatus</li> </ul>"},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicy","title":"TLSPolicy","text":"Field Type Required Description <code>spec</code> TLSPolicySpec Yes The specification for TLSPolicy custom resource <code>status</code> TLSPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicyspec","title":"TLSPolicySpec","text":"Field Type Required Description <code>targetRef</code> Gateway API LocalPolicyTargetReference Yes Reference to a Kuberentes resource that the policy attaches to <code>issuerRef</code> CertManager meta/v1.ObjectReference Yes IssuerRef is a reference to the issuer for the created certificate <code>commonName</code> String No CommonName is a common name to be used on the created certificate <code>duration</code> Kubernetes meta/v1.Duration No The requested 'duration' (i.e. lifetime) of the created certificate. <code>renewBefore</code> Kubernetes meta/v1.Duration No How long before the currently issued certificate's expiry cert-manager should renew the certificate. <code>usages</code> []CertManager v1.KeyUsage No Usages is the set of x509 usages that are requested for the certificate. Defaults to <code>digital signature</code> and <code>key encipherment</code> if not specified <code>revisionHistoryLimit</code> Number No RevisionHistoryLimit is the maximum number of CertificateRequest revisions that are maintained in the Certificate's history <code>privateKey</code> CertManager meta/v1.CertificatePrivateKey No Options to control private keys used for the Certificate <p>IssuerRef certmanmetav1.ObjectReference</p>"},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicystatus","title":"TLSPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/","title":"Enforcing authentication &amp; authorization with Kuadrant AuthPolicy","text":"<p>This guide walks you through the process of setting up a local Kubernetes cluster with Kuadrant where you will protect Gateway API endpoints by declaring Kuadrant AuthPolicy custom resources.</p> <p>Three AuthPolicies will be declared:</p> Use case AuthPolicies App developer 2 AuthPolicies targeting a HTTPRoute that routes traffic to a sample \"Toy Store\" application \u2192 enforce API key authentication to all requests in this route; require API key owners to be mapped to <code>groups:admins</code> metadata to access a specific HTTPRouteRule of the route. Platform engineer use-case 1 AuthPolicy targeting the <code>kuadrant-ingressgateway</code> Gateway \u2192 enforces a trivial \"deny-all\" policy that locks down any other HTTPRoute attached to the Gateway. <p>Topology:</p> <pre><code>                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502        (Gateway)        \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502 kuadrant-ingressgateway \u2502\u25c4\u2500\u2500\u2502 (AuthPolicy)  \u2502\n                            \u2502                         \u2502   \u2502    gw-auth    \u2502\n                            \u2502            *            \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u25b2                      \u25b2\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502   (HTTPRoute)    \u2502   \u2502   (HTTPRoute)    \u2502\n\u2502  (AuthPolicy)  \u2502\u2500\u2500\u25ba\u2502    toystore      \u2502   \u2502      other       \u2502\n\u2502 toystore-authn \u2502   \u2502                  \u2502   \u2502                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502 api.toystore.com \u2502   \u2502 *.other-apps.com \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u25b2                \u25b2\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            | (HTTPRouteRule) | | (HTTPRouteRule) |   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            |     rule-1      | |     rule-2      |\u25c4\u2500\u2500\u2502   (AuthPolicy)  \u2502\n            |                 | |                 |   \u2502 toystore-admins \u2502\n            | - GET /cars*    | | - /admins*      |   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            | - GET /dolls*   | \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#setup-the-environment","title":"Setup the environment","text":"<p>Follow this setup doc to set up your environment before continuing with this doc.</p>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#deploy-the-toy-store-sample-application-persona-app-developer","title":"Deploy the Toy Store sample application (Persona: App developer)","text":"<pre><code>kubectl apply -f examples/toystore/toystore.yaml\n\nkubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: kuadrant-ingressgateway\n    namespace: gateway-system\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches: # rule-1\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/dolls\"\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches: # rule-2\n    - path:\n        type: PathPrefix\n        value: \"/admin\"\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Export the gateway hostname and port:</p> <pre><code>export INGRESS_HOST=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.status.addresses[0].value}')\nexport INGRESS_PORT=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT\n</code></pre> <p>Send requests to the application unprotected:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/cars -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/dolls -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/admin -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#protect-the-toy-store-application-persona-app-developer","title":"Protect the Toy Store application (Persona: App developer)","text":"<p>Create AuthPolicies to enforce the following auth rules:</p> <ul> <li>Authentication:</li> <li>All users must present a valid API key</li> <li>Authorization:</li> <li><code>/admin*</code> paths (2nd rule of the HTTPRoute) require user mapped to the <code>admins</code> group (<code>kuadrant.io/groups=admins</code> annotation added to the Kubernetes API key Secret)</li> </ul> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-authn\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  defaults:\n    strategy: merge\n    rules:\n      authentication:\n        \"api-key-authn\":\n          apiKey:\n            selector:\n              matchLabels:\n                app: toystore\n          credentials:\n            authorizationHeader:\n              prefix: APIKEY\n---\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-admins\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-2\n  rules:\n    authorization:\n      \"only-admins\":\n        opa:\n          rego: |\n            groups := split(object.get(input.auth.identity.metadata.annotations, \"kuadrant.io/groups\", \"\"), \",\")\n            allow { groups[_] == \"admins\" }\nEOF\n</code></pre> <p>Create the API keys (must be created in the same namespace as the Kuadrant CR):</p> <pre><code>kubectl apply -n kuadrant-system -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-regular-user\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\nstringData:\n  api_key: iamaregularuser\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-admin-user\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    kuadrant.io/groups: admins\nstringData:\n  api_key: iamanadmin\ntype: Opaque\nEOF\n</code></pre> <p>Send requests to the application protected by Kuadrant:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/cars -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-authn\"\n# x-ext-auth-reason: credential not found\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamaregularuser' http://$GATEWAY_URL/cars -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamaregularuser' http://$GATEWAY_URL/admin -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamanadmin' http://$GATEWAY_URL/admin -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#create-a-default-deny-all-policy-at-the-level-of-the-gateway-persona-platform-engineer","title":"Create a default \"deny-all\" policy at the level of the gateway (Persona: Platform engineer)","text":"<p>Create the policy:</p> <pre><code>kubectl -n gateway-system apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: gw-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: kuadrant-ingressgateway\n  defaults:\n    strategy: atomic\n    rules:\n      authorization:\n        deny-all:\n          opa:\n            rego: \"allow = false\"\n      response:\n        unauthorized:\n          headers:\n            \"content-type\":\n              value: application/json\n          body:\n            value: |\n              {\n                \"error\": \"Forbidden\",\n                \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n              }\nEOF\n</code></pre> <p>The policy won't be effective until there is at least one accepted route not yet protected by another more specific policy attached to it.</p> <p>Create a route that will inherit the default policy attached to the gateway:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: other\nspec:\n  parentRefs:\n\n  - name: kuadrant-ingressgateway\n    namespace: gateway-system\n  hostnames:\n  - \"*.other-apps.com\"\nEOF\n</code></pre> <p>Send requests to the route protected by the default policy set at the level of the gateway:</p> <pre><code>curl -H 'Host: foo.other-apps.com' http://$GATEWAY_URL/ -i\n# HTTP/1.1 403 Forbidden\n# content-type: application/json\n# x-ext-auth-reason: Unauthorized\n# [\u2026]\n#\n# {\n#   \"error\": \"Forbidden\",\n#   \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n# }\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/","title":"Basic dns configuration","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#basic-dns-setup","title":"Basic DNS setup","text":"<p>The document will cover the most basic DNS setup using the Kuadrant DNSPolicy API. In order to follow this guide, it is expected that you have a cluster setup with the latest version of Kuadrant installed. Also as we are using DNS, it is also important that the Gateways are accessible either via your local network or via the public internet. DNSPolicy will work with any Gateway provider so it is not essential that you have Istio or Envoy Gateway installed, but you do need a Gateway API provider installed. We would recommend using Istio or Envoy Gateway as this will allow you to use some of the other policies provided by Kuadrant.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#gateway-and-httproute-configuration","title":"Gateway and HTTPRoute configuration","text":"<p>With a Gateway provider installed, in order to configure DNS via <code>DNSPolicy</code>, you must first configure a Gateway with a listener that uses a specified hostname. You must also have a HTTPRoute resource attached to this gateway listener. Below are some simple examples of these resources (note we are not using a HTTPS listener for simplicity but that will also work):</p> <p><pre><code>---\nkind: Gateway\napiVersion: gateway.networking.k8s.io/v1\nmetadata:\n  name: external\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      port: 8080\n      hostname: test.example.com\n      protocol: HTTP\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  labels:\n    app: toystore\nspec:\n  parentRefs:\n    - name: external\n  hostnames: [\"test.example.com\"]\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \"/toy\"\n          method: GET\n        - path:\n            type: Exact\n            value: \"/admin/toy\"\n          method: POST\n        - path:\n            type: Exact\n            value: \"/admin/toy\"\n          method: DELETE\n      backendRefs:\n        - name: toystore\n          port: 80\n</code></pre> With these defined, we are ready to setup DNS via DNSPolicy.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#configure-a-dnsprovider","title":"Configure a DNSProvider","text":"<p>The first step is to configure a DNSProvider. This is a simple kubernetes secret with credentials to access the DNS provider. With Kuadrant we support using <code>AWS Route53, Azure and GCP</code> as DNS providers. It is important that this credential has access to write and read to your DNS zones.</p> <p>More info on the various DNS Providers</p> <p>In this example we will configure an AWS route53 DNS provider:</p> <pre><code>kubectl create secret generic aws-credentials \\\n  --namespace=my-gateway-namespace \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=XXXX \\\n  --from-literal=AWS_REGION=eu-west-1 \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=XXX\n</code></pre> <p>With this in place we can now define our DNSPolicy resource:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: basic-dnspolicy\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external\n  providerRefs:\n\n    - name: aws-credentials\n</code></pre> <p>This resource also needs to be created in the same namespace as your Gateway and the <code>targetRef</code> needs to reference your gateway. When this is done we can check the status of the DNSPolicy and the Gateway to check when it is ready.</p> <pre><code>kubectl wait dnspolicy/basic-dnspolicy -n my-gateway-namespace --for=\"condition=Ready=true\" --timeout=300s\n</code></pre> <p>If you look at the gateway status you should also see:</p> <pre><code>  - lastTransitionTime: \"2024-10-09T11:22:10Z\"\n    message: Object affected by DNSPolicy kuadrant-system/simple-dnspolicy\n    observedGeneration: 1\n    reason: Accepted\n    status: \"True\"\n    type: kuadrant.io/DNSPolicyAffected\n</code></pre> <p>DNS is now setup for your Gateway. After allowing a little time for the DNS propagate to the nameservers, you should be able to test the DNS using a dig command alternatively you can curl your endpoint.</p> <pre><code>dig test.example.com +short\n\ncurl -v test.example.com/toy\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#important-considerations","title":"Important Considerations","text":"<p>With this guide, you have learned how to setup the most basic DNSPolicy. DNSPolicy is also capable of setting up advanced DNS record structure to help balance traffic across multiple gateways. With the most basic policy outlined here, you should not apply it to more than one gateway that shares a listener with the same host name. There is one exception to this rule, which is if all your gateways are using IP addresses rather than hostname addresses; in this case DNSPolicy will merge the IPs into a multi-value response. However, if your Gateways are using hostnames, DNSPolicy will set up a simple CNAME record and as there is only one record and CNAMEs cannot have multiple values by definition, one of the DNSPolicies (the last one to attempt to update the provider) will report an error. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dns-excluding-specific-addresses/","title":"Dns excluding specific addresses","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/dns-excluding-specific-addresses/#excluding-specific-addresses-from-being-published","title":"Excluding specific addresses from being published","text":"<p>By default DNSPolicy takes all the addresses published in the status of the Gateway it is targeting and use these values in the DNSRecord it publishes to chosen DNS provider. </p> <p>There could be cases where you have an address assigned to a gateway that you do not want to publish to a DNS provider, but you still want DNSPolicy to publish records for other addresses.</p> <p>To prevent a gateway address being published to the DNS provider, you can set the <code>excludeAddresses</code> field in the DNSPolicy resource targeting the gateway. The <code>excludeAddresses</code> field can be set to a hostname, an IPAddress or a CIDR.</p> <p>Below is an example of a DNSPolicy excluding a hostname:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: ${DNSPOLICY_NAMESPACE}\nspec:\n  targetRef:\n    name: prod-web-istio\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:\n\n    - name: aws-credentials\n  loadBalancing:\n    weight: 120\n    geo: EU\n    defaultGeo: true\n  excludeAddresses:\n    - \"some.local.domain\"\n</code></pre> <p>In the above case <code>some.local.domain</code> will not be set up as a CNAME record in the DNS provider.</p> <p>Note: It is valid to exclude all addresses. However this will result in existing records being removed and no new ones being created.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/","title":"DNS Health Checks","text":"<p>The DNS health check feature allows you to define a HTTP based health check via the DNSPolicy API that will be executed against targeted gateway listener(s) that have specified none wildcard hostnames. These health checks will flag a published endpoint as healthy or unhealthy based on the defined configuration. When unhealthy an endpoint will not be published if it has not already been published to the DNS provider, will only be unpublished if it is part of a multi-value A record and in all cases can be observable via the DNSPolicy status.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#limitations","title":"Limitations","text":"<ul> <li>We do not currently support a health check being targeted to a <code>HTTPRoute</code> resource: DNSPolicy can only target Gateways. </li> <li>As mentioned above, when a record has been published using the load balancing options (GEO and Weighting) via DNSPolicy, a failing health check will not remove the endpoint record from the provider, this is to avoid an accidental NX-Domain response. If the policy is not using the load balancing options and results in a multiple value A record, then unhealthy IPs will be removed from this A record unless it would result in an empty value set. </li> <li>Health checks will not be added to listeners that define a wildcard hostname E.G (*.example.com) as we currently cannot know which host to use to for the health check.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#configuration-of-health-checks","title":"Configuration of Health Checks","text":"<p>To configure a DNS health check, you need to specify the <code>health check</code> section of the DNSPolicy.</p> <p>Below are some examples of DNSPolicy with health checks defined:</p> <p>1) DNSPolicy with a health check that will be applied to all listeners on a gateway that define a none wildcard hostname</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: gateway-dns\nspec:\n  healthCheck:\n    failureThreshold: 3\n    interval: 5m\n    path: /health\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n</code></pre> <p>2) DNSPolicy with health check  that will be applied for a specific listener with a none wildcard hostname</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-listener-dns\nspec:\n  healthCheck:\n    failureThreshold: 3\n    interval: 5m\n    path: /ok #different path for this listener\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n    sectionName: my-listener #notice the addition of section name here that must match the listener name\n</code></pre> <p>These policies can be combined on a single gateway. The policy with the section name defined will override the gateway policy including the health check.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#sending-additional-headers-with-the-health-check-request","title":"Sending additional headers with the health check request","text":"<p>Sometimes, it may be desirable to send some additional headers with the health check request. For example to send API key or service account token that can be defined in the request headers.</p> <p>To do this you will need to create a secret in the same namespace as the DNSPolicy with the keys and values you wish to send:</p> <pre><code>kubectl create secret generic healthheaders --from-literal=token=supersecret -n my-dns-policy-namespace\n</code></pre> <p>Next you will need to update the DNSPolicy to add a reference to this secret:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-listener-dns\nspec:\n  healthCheck:\n    additionalHeadersRef: #add the following\n      name: healthheaders\n    failureThreshold: 3\n    interval: 5m\n    path: /ok\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n    sectionName: my-listener\n</code></pre> <p>The health check requests will now send the key value pairs in the secret as headers when performing a health check request.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#health-check-status","title":"Health Check Status","text":"<p>When all health checks based on a DNSPolicy are passing you will see the following status:</p> <pre><code>    - lastTransitionTime: \"2024-11-14T12:33:13Z\"\n      message: All sub-resources are healthy\n      reason: SubResourcesHealthy\n      status: \"True\"\n      type: SubResourcesHealthy\n</code></pre> <p>If one or more of the health checks are failing you will see a status in the DNSPolicy simiar to the one shown below:</p> <pre><code>   - lastTransitionTime: \"2024-11-15T10:40:15Z\"\n      message: 'DNSPolicy has encountered some issues: not all sub-resources of policy\n        are passing the policy defined health check. Not healthy DNSRecords are: external-t1b '\n      reason: Unknown\n      status: \"False\"\n      type: SubResourcesHealthy\n    observedGeneration: 1\n    recordConditions:\n      t1b.cb.hcpapps.net:\n      - lastTransitionTime: \"2024-11-15T10:40:14Z\"\n        message: 'Not healthy addresses: [aeeba26642f1b47d9816297143e2d260-434484576.eu-west-1.elb.amazonaws.com]'\n        observedGeneration: 1\n        reason: health checksFailed\n        status: \"False\"\n        type: Healthy\n</code></pre> <p>Finally, you can also take a look at the underlying individual health check status by inspecting the <code>dnshealthcheckprobe</code> resource:</p> <p>Note: These resources are for view only interactions as they are controlled by the Kuadrant Operator based on the DNSPolicy API</p> <pre><code>kubectl get dnshealthcheckprobes n my-dns-policy-namespace -o=wide\n</code></pre> <p>If you look at the status of one of these you can see additional information:</p> <pre><code>status:\n  consecutiveFailures: 3\n  healthy: false\n  observedGeneration: 1\n  reason: 'Status code: 503'\n  status: 503\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#manually-removing-unhealthy-records","title":"Manually removing unhealthy records","text":"<p>If you have a failing health check for one of your gateway listeners and you would like to remove it from the DNS provider, you can do this by deleting the associated DNSRecord resource.</p> <p>Finding the correct record</p> <p>DNSRecord resources are kept in the same namespace as the DNSPolicy that configured and created them.</p> <pre><code>kubectl get dnsrecords.kuadrant.io -n &lt;dns-policy-namespace&gt;\n</code></pre> <p>As shown above, when a health check is failing, the DNSPolicy will show a status for that listener host to surface that failure:</p> <pre><code>recordConditions:\n    t1a.cb.hcpapps.net:\n\n    - lastTransitionTime: \"2024-11-27T14:00:52Z\"\n      message: 'Not healthy addresses: [ae4d131ee5d7b4fb098f4afabf4aba4c-513237325.us-east-1.elb.amazonaws.com]'\n      observedGeneration: 1\n      reason: HealthChecksFailed\n      status: \"False\"\n      type: Healthy\n</code></pre> <p>The DNSRecord resource is named after the gateway and the listener name. So if you have a gateway called <code>ingress</code> and a listener called <code>example</code> you will have a <code>DNSRecord</code> resource named <code>ingress-example</code> in the same namespace as your DNSPolicy. So from this status you can get the hostname and find the associated listener on your gateway. You can then delete the associated DNSRecord resource. </p> <pre><code>kubectl delete dnsrecord.kuadrant.io &lt;gateway-name&gt;-&lt;listener-name&gt; -n &lt;dns policy namespace&gt;\n</code></pre> <p>Removing this resource will remove all of the associated DNS records in the DNS provider and while the health check is failing, the dns operator will not re-publish these records. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/","title":"Gateway DNS configuration for routes attached to a ingress gateway","text":"<p>This user guide walks you through an example of how to configure DNS for all routes attached to an ingress gateway.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#requisites","title":"Requisites","text":"<ul> <li>Docker</li> <li>Rout53 Hosted Zone</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#setup-the-environment","title":"Setup the environment","text":"<p>Follow this setup doc to set up your environment before continuing with this doc.</p> <p>Create a namespace:</p> <pre><code>kubectl create namespace my-gateways\n</code></pre> <p>Export a root domain and hosted zone id:</p> <pre><code>export ROOT_DOMAIN=&lt;ROOT_DOMAIN&gt;\n</code></pre> <p>Note: ROOT_DOMAIN should be set to your AWS hosted zone name.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#create-a-dns-provider-secret","title":"Create a dns provider secret","text":"<p>Create AWS provider secret. You should limit the permissions of this credential to only the zones you want us to access.</p> <pre><code>export AWS_ACCESS_KEY_ID=&lt;AWS_ACCESS_KEY_ID&gt; AWS_SECRET_ACCESS_KEY=&lt;AWS_SECRET_ACCESS_KEY&gt;\n\nkubectl -n my-gateways create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#create-an-ingress-gateway","title":"Create an ingress gateway","text":"<p>Create a gateway using your ROOT_DOMAIN as part of a listener hostname:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: prod-web\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: \"*.$ROOT_DOMAIN\"\n      port: 80\n      protocol: HTTP\nEOF\n</code></pre> <p>Check gateway status:</p> <pre><code>kubectl get gateway prod-web -n my-gateways\n</code></pre> <p>Response:</p> <pre><code>NAME       CLASS   ADDRESS        PROGRAMMED   AGE\nprod-web   istio   172.18.200.1   True         25s\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#enable-dns-on-the-gateway","title":"Enable DNS on the gateway","text":"<p>Create a Kuadrant <code>DNSPolicy</code> to configure DNS:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\nEOF\n</code></pre> <p>Check policy status:</p> <pre><code>kubectl get dnspolicy -o wide -n my-gateways\n</code></pre> <p>Response:</p> <pre><code>NAME       STATUS     TARGETREFKIND   TARGETREFNAME   AGE\nprod-web   Accepted   Gateway         prod-web        26s\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#deploy-a-sample-api-to-test-dns","title":"Deploy a sample API to test DNS","text":"<p>Deploy the sample API:</p> <pre><code>kubectl -n my-gateways apply -f examples/toystore/toystore.yaml\nkubectl -n my-gateways wait --for=condition=Available deployments toystore --timeout=60s\n</code></pre> <p>Route traffic to the API from our gateway:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: prod-web\n    namespace: my-gateways\n  hostnames:\n  - \"*.$ROOT_DOMAIN\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Verify a DNSRecord resource is created:</p> <pre><code>kubectl get dnsrecords -n my-gateways\nNAME           READY\nprod-web-api   True\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#verify-dns-works-by-sending-requests","title":"Verify DNS works by sending requests","text":"<p>Verify DNS using dig:</p> <pre><code>dig foo.$ROOT_DOMAIN +short\n</code></pre> <p>Response:</p> <pre><code>172.18.200.1\n</code></pre> <p>Verify DNS using curl:</p> <pre><code>curl http://api.$ROOT_DOMAIN\n</code></pre> <p>Response:</p> <pre><code>{\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"query_string\": null,\n  \"body\": \"\",\n  \"headers\": {\n    \"HTTP_HOST\": \"api.$ROOT_DOMAIN\",\n    \"HTTP_USER_AGENT\": \"curl/7.85.0\",\n    \"HTTP_ACCEPT\": \"*/*\",\n    \"HTTP_X_FORWARDED_FOR\": \"10.244.0.1\",\n    \"HTTP_X_FORWARDED_PROTO\": \"http\",\n    \"HTTP_X_ENVOY_INTERNAL\": \"true\",\n    \"HTTP_X_REQUEST_ID\": \"9353dd3d-0fe5-4404-86f4-a9732a9c119c\",\n    \"HTTP_X_ENVOY_DECORATOR_OPERATION\": \"toystore.my-gateways.svc.cluster.local:80/*\",\n    \"HTTP_X_ENVOY_PEER_METADATA\": \"ChQKDkFQUF9DT05UQUlORVJTEgIaAAoaCgpDTFVTVEVSX0lEEgwaCkt1YmVybmV0ZXMKHQoMSU5TVEFOQ0VfSVBTEg0aCzEwLjI0NC4wLjIyChkKDUlTVElPX1ZFUlNJT04SCBoGMS4xNy4yCtcBCgZMQUJFTFMSzAEqyQEKIwoVaXN0aW8uaW8vZ2F0ZXdheS1uYW1lEgoaCHByb2Qtd2ViChkKDGlzdGlvLmlvL3JldhIJGgdkZWZhdWx0CjMKH3NlcnZpY2UuaXN0aW8uaW8vY2Fub25pY2FsLW5hbWUSEBoOcHJvZC13ZWItaXN0aW8KLwojc2VydmljZS5pc3Rpby5pby9jYW5vbmljYWwtcmV2aXNpb24SCBoGbGF0ZXN0CiEKF3NpZGVjYXIuaXN0aW8uaW8vaW5qZWN0EgYaBHRydWUKGgoHTUVTSF9JRBIPGg1jbHVzdGVyLmxvY2FsCigKBE5BTUUSIBoecHJvZC13ZWItaXN0aW8tYzU0NWQ4ZjY4LTdjcjg2ChoKCU5BTUVTUEFDRRINGgtteS1nYXRld2F5cwpWCgVPV05FUhJNGktrdWJlcm5ldGVzOi8vYXBpcy9hcHBzL3YxL25hbWVzcGFjZXMvbXktZ2F0ZXdheXMvZGVwbG95bWVudHMvcHJvZC13ZWItaXN0aW8KFwoRUExBVEZPUk1fTUVUQURBVEESAioACiEKDVdPUktMT0FEX05BTUUSEBoOcHJvZC13ZWItaXN0aW8=\",\n    \"HTTP_X_ENVOY_PEER_METADATA_ID\": \"router~10.244.0.22~prod-web-istio-c545d8f68-7cr86.my-gateways~my-gateways.svc.cluster.local\",\n    \"HTTP_X_ENVOY_ATTEMPT_COUNT\": \"1\",\n    \"HTTP_X_B3_TRACEID\": \"d65f580db9c6a50c471cdb534771c61a\",\n    \"HTTP_X_B3_SPANID\": \"471cdb534771c61a\",\n    \"HTTP_X_B3_SAMPLED\": \"0\",\n    \"HTTP_VERSION\": \"HTTP/1.1\"\n  },\n  \"uuid\": \"0ecb9f84-db30-4289-a3b8-e22d4021122f\"\n}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/","title":"Load Balanced DNS","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#overview","title":"Overview","text":"<p>This document will show you how to setup a load balanced DNS configuration using the (DNSPolicy)[https://docs.kuadrant.io/latest/kuadrant-operator/doc/reference/dnspolicy/] API. When we say \"load balanced\", this means we configure the DNS provider (AWS, GCP etc) to return different gateway/loadbalancer addresses to queries from DNS clients based on specific weighting and geo location configuration.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#when-should-i-use-a-load-balanced-dns-policy","title":"When should I use a load balanced DNS policy?","text":"<p>It is most useful to use the load balancing options when targeting multiple gateways that share a listener host E.G (api.example.com). It is also perfectly valid to use it when you only have a single gateway; this provides the benefit of allowing you to easily expand beyond this single gateway for a given shared hostname. It is worth knowing that the load balanced DNSpolicy comes with a relatively small additional cost of some added records and lookups during DNS resolution vs a \"simple\" DNSPolicy with no load balancing specified as the latter only sets up a simple A or CNAME record. So in summary if you expect to need multiple gateways for a given listener host then you should take advantage of the load balanced option.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#important-considerations","title":"Important Considerations","text":"<ul> <li>When using a DNSPolicy with a load balanced configuration, all DNSPolicies effecting a listener with the same hostname should have load balanced options set. Without the load balanced configuration, Kuadrant's dns controller will try to set up only a simple A or CNAME record.</li> <li>When setting geographic configuration, only ever set one unique GEO as the default GEO across all instances of DNSPolicy targeting a listener with the same hostname. If you set different defaults for a single listener hostname, the dns controllers will constantly attempt to bring the default into the state they each feel is correct. </li> <li>If you want different load balancing options for a particular listener in a gateway, you can target that listener directly with DNSPolicy via the targetRef sectionName property.</li> <li>If you do not use the load balanced configuration, a simple single A or CNAME record is set up. Later if you need to move to load balanced, you will need to delete and recreate your policy.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#dns-provider-setup","title":"DNS Provider Setup","text":"<p>A DNSPolicy acts against a target Gateway or a target listener within a gateway by processing the hostnames on the targeted listeners. Using these it can create dns records using the address exposed in the Gateway's status block. In order for Kuadrant's DNS component to do this, it must be able to access and know which DNS provider to use. This is done through the creation of a dns provider secret containing the needed credentials and the provider identifier.</p> <p>(Learn more about how to setup a DNS Provider)[https://docs.kuadrant.io/latest/dns-operator/docs/provider/]</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#loadbalanced-dnspolicy-creation-and-attachment","title":"LoadBalanced DNSPolicy creation and attachment","text":"<p>Once an appropriate provider credential is configured, we can now create and attach a DNSPolicy to start managing DNS for the listeners on our Gateway. Below is an example.</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: ingress-gateway\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    sectionName: listenerName \n  providerRef:\n    name: my-aws-credentials \n  loadBalancing:\n    weight: 120 \n    geo: GEO-EU \n    defaultGeo: true\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#load-balancing-section","title":"Load Balancing section","text":"<p>This section must be filled out and indicates to the dns component that the targets of this policy should be setup to handle more than one gateway. It is required to define values for the weighted and geo options. These values are used for the records created by the policy controller based on the target gateway. To read more detail about each of the fields in the loadbalanced section take a look at DNS Overview</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#locations-supported-per-dns-provider","title":"Locations supported per DNS provider","text":"Supported AWS GCP Continents Country codes States Regions"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#continents-and-country-codes-supported-by-aws-route-53","title":"Continents and country codes supported by AWS Route 53","text":"<p>:Note:  For more information please the official AWS documentation </p> <p>To see all regions supported by AWS Route 53, please see the official (documentation)[https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values-geo.html]. With Route 53 when setting a continent code use a \"GEO-\" prefix otherwise it will be considered a country code. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#regions-supported-by-gcp-cloud-dns","title":"Regions supported by GCP Cloud DNS","text":"<p>To see all regions supported by GCP Cloud DNS, please see the official (documentation)[https://cloud.google.com/compute/docs/regions-zones]</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#regions-and-countries-supported-by-azure-cloud-dns","title":"Regions and Countries supported by Azure Cloud DNS","text":"<p>To see the different values you can use for the geo based DNS with Azure take a look at the following (documentation)[https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-geographic-regions]</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#moving-from-non-load-balanced-to-load-balanced-or-vice-versa","title":"Moving from non load balanced to load balanced or vice versa","text":"<p>It is possible to update a DNSPolicy that has no load balancing options set to one that has these options set and vice versa. Underneath, the DNS Operator will remove the existing records and replace them with the correct set of records based on your configuration. It is important however that when using DNSPolicy across multiple Gateways that share a hostname, the DNSPolicies targeting a listener with a shared hostname all use a load balancing configuration (or absence thereof). It is invalid to have two DNSPolcies targeting a listener with a shared hostname that use different dns <code>strategies</code>. Doing so will cause one of the DNSPolicies to fail to be enforced and report an error caused by an inability to bring the DNS records into a consistent state.</p> <p>Example:</p> <p>If you have <code>gateway1</code> with listener <code>example</code> with a hostname of <code>example.com</code> and you have a separate gateway <code>gateway2</code> with the same listener definition as <code>gateway1</code> (perhaps on a different cluster in a different region), you should ensure that the DNSPolcies targeting these listeners are both using a <code>loadbalanced</code> configuration. Below is an example of valid and invalid configuration. </p> <p>Valid Config</p> <p>Given a gateway deployed on two different cluster in two different locations:</p> <pre><code># example gateway\nkind: Gateway\napiVersion: gateway.networking.k8s.io/v1\nmetadata:\n  name: api-gateway\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: example\n      port: 80\n      hostname: 'api.example.com'\n      protocol: HTTP\n</code></pre> <pre><code># gateway 1\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway1\nspec:\n  loadBalancing:\n    weight: 130\n    geo: GEO-EU\n    defaultGeo: true\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n\n# gateway 2\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway2\nspec:\n  loadBalancing:\n    weight: 130\n    geo: GEO-US\n    defaultGeo: false\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n</code></pre> <p>Invalid Config</p> <pre><code># gateway 1\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway1\nspec:\n  loadBalancing:\n    weight: 130\n    geo: GEO-EU\n    defaultGeo: true\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n\n# gateway 2\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway2\nspec: #notice no loadbalancing defined\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/orphan-dns-records/","title":"Orphan dns records","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/orphan-dns-records/#orphan-dns-records","title":"Orphan DNS Records","text":"<p>This document is focused around multi-cluster DNS where you have more than one instance of a gateway that shares a common hostname with other gateways and assumes you have the observability stack set up.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/orphan-dns-records/#what-is-an-orphan-record","title":"What is an orphan record?","text":"<p>An orphan DNS record is a record or set of records that are owned by an instance of the DNS operator that no longer has a representation of those records on its cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/orphan-dns-records/#how-do-orphan-records-occur","title":"How do orphan records occur?","text":"<p>Orphan records can occur when a <code>DNSRecord</code> resource (a resource that is created in response to a <code>DNSPolicy</code>) is deleted without allowing the owning controller time to clean up the associated records in the DNS provider. Generally in order for this to happen, you would need to force remove a <code>finalizer</code> from the <code>DNSRecord</code> resource, delete the kuadrant-system namespace directly or un-install kuadrant (delete the subscription if using OLM) without first cleaning up existing policies or delete a cluster entirely without first cleaning up the associated DNSPolicies. These are not common scenarios but when they do occur they can leave behind records in your DNS Provider which may point to IPs / Hosts that are no longer valid. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/orphan-dns-records/#how-do-you-spot-an-orphan-records-exist","title":"How do you spot an orphan record(s) exist?","text":"<p>There is a prometheus based alert that uses some metrics exposed from the DNS components to spot this situation. If you have installed the alerts for Kuadrant under the examples folder, you will see in the alerts tab an alert called <code>PossibleOrphanedDNSRecords</code>. When this is firing it means there are likely to be orphaned records in your provider.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/orphan-dns-records/#how-do-you-get-rid-of-an-orphan-record","title":"How do you get rid of an orphan record?","text":"<p>To remove an Orphan Record we must first identify the owner that is no longer aware of the record. To do this we need an existing DNSRecord in another cluster.</p> <p>Example: You have 2 clusters that each have a gateway and share a host <code>apps.example.com</code> and have setup a DNSPolicy for each gateway. On cluster 1 you remove the <code>kuadrant-system</code> namespace without first cleaning up existing DNSPolicies targeting the gateway in your <code>ingress-gateway</code> namespace. Now there are a set of records that were being managed for that gateway that have not been removed.  On cluster 2 the DNS Operator managing the existing DNSRecord in that cluster has a record of all owners of that dns name.  In prometheus alerts, it spots that the number of owners does not correlate to the number of DNSRecord resources and triggers an alert.  To remedy this rather than going to the DNS provider directly and trying to figure out which records to remove, you can instead follow the steps below.</p> <p>Get the owner id of the DNSRecord on cluster 2 for the shared host </p> <pre><code>kubectl get dnsrecord somerecord -n my-gateway-ns -o=jsonpath='{.status.ownerID}'\n</code></pre> <p>Get all the owner ids</p> <pre><code>kubectl get dnsrecord.kuadrant.io somerecord -n my-gateway-ns -o=jsonpath='{.status.domainOwners}'\n\n# output\n# [\"26aacm1z\",\"49qn0wp7\"]\n</code></pre> <p>Create a placeholder DNSRecord with none active ownerID</p> <p>For each owner id returned that isn't the owner id of the record that we want to remove records for, we need to create a dnsrecord resource and delete it. This will trigger the running operator in this cluster to clean up those records.</p> <p>This is one of the owner id not in the existing dnsrecord on cluster <pre><code>export ownerID=26aacm1z  \n\nexport rootHost=$(kubectl get dnsrecord.kuadrant.io somerecord -n  my-gateway-ns -o=jsonpath='{.spec.rootHost}')\n</code></pre></p> <p>Export a namespace with the aws credentials in it <pre><code>export targetNS=kuadrant-system \n\nkubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: delete-old-loadbalanced-dnsrecord\n  namespace: ${targetNS}\nspec:\n  providerRef:\n    name: my-aws-credentials\n  ownerID: ${ownerID}\n  rootHost: ${rootHost}\n  endpoints:\n\n    - dnsName: ${rootHost}\n      recordTTL: 60\n      recordType: CNAME\n      targets:\n        - klb.doesnt-exist.${rootHost}\nEOF\n</code></pre></p> <p>Delete the DNSrecord</p> <pre><code>kubectl delete dnsrecord.kuadrant.io delete-old-loadbalanced-dnsrecord -n ${targetNS} \n</code></pre> <p>Verification </p> <p>We can verify that the steps worked correctly, by checking the DNSRecord again. Note it may take a several minutes for the other record to update. We can force it by adding a label to the record</p> <pre><code>kubectl label dnsrecord.kuadrant.io somerecord test=test -n ${targetNS}\n\nkubectl get dnsrecord.kuadrant.io somerecord -n my-gateway-ns -o=jsonpath='{.status.domainOwners}'\n</code></pre> <p>You should also see your alert eventually stop triggering.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/","title":"Secure, protect, and connect services with Kuadrant on Kubernetes","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have completed the Single-cluster Quick Start or Multi-cluster Quick Start.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#local-cluster-metallb","title":"Local Cluster (metallb)","text":"<p>Note: If you are running on a local kind cluster, it is also recommended you use metallb to setup an IP address pool to use with loadbalancer services for your gateways. An example script for configuring metallb based on the docker network once installed can be found here.</p> <pre><code>./utils/docker-network-ipaddresspool.sh kind yq 1 | kubectl apply -n metallb-system -f -\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#overview","title":"Overview","text":"<p>In this guide, we will cover the different policies from Kuadrant and how you can use them to secure, protect and connect an Istio-controlled gateway in a single cluster, and how you can set more refined protection on the HTTPRoutes exposed by that gateway.</p> <p>Here are the steps we will go through:</p> <ol> <li> <p>Deploy a sample application</p> </li> <li> <p>Define a new Gateway</p> </li> <li> <p>Ensure TLS-based secure connectivity to the gateway with a TLSPolicy</p> </li> <li> <p>Define a default RateLimitPolicy to set some infrastructure limits on your gateway</p> </li> <li> <p>Define a default AuthPolicy to deny all access to the gateway</p> </li> <li> <p>Define a DNSPolicy to bring traffic to the gateway</p> </li> <li> <p>Override the Gateway's deny-all AuthPolicy with an endpoint-specific policy</p> </li> <li> <p>Override the Gateway rate limits with an endpoint-specific policy</p> </li> </ol> <p>You will need to set the <code>KUBECTL_CONTEXT</code> environment variable for the kubectl context of the cluster you are targeting.</p> <p>If you have followed the single cluster setup, it should be something like below. Adjust the name of the cluster accordingly to match the kubernetes cluster you are targeting. You can get the current context with <code>kubectl config current-context</code></p> <p>We use the namespace <code>kuadrant-system</code> in this tutorial so ensure that namespace exists before continuing</p> <pre><code># Typical single cluster context\nexport KUBECTL_CONTEXT=kind-kuadrant-local\n\n# Example context for additional 'multi cluster' clusters\n# export KUBECTL_CONTEXT=kind-kuadrant-local-1\n</code></pre> <p>To help with this walk through, you should also set a <code>KUADRANT_ZONE_ROOT_DOMAIN</code> environment variable to a domain you want to use. If you want to try DNSPolicy, this should also be a domain you have access to the DNS for in AWS Route53 or GCP. E.g.:</p> <pre><code>export KUADRANT_ZONE_ROOT_DOMAIN=my.domain.iown\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#deploy-the-example-app-we-will-serve-via-our-gateway","title":"Deploy the example app we will serve via our gateway","text":"<pre><code>kubectl --context $KUBECTL_CONTEXT apply -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#define-a-new-istio-managed-gateway","title":"Define a new Istio-managed gateway","text":"<pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: api-gateway\n  namespace: kuadrant-system\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - allowedRoutes:\n      namespaces:\n        from: All\n    name: api\n    hostname: \"*.$KUADRANT_ZONE_ROOT_DOMAIN\"\n    port: 443\n    protocol: HTTPS\n    tls:\n      mode: Terminate\n      certificateRefs:\n        - name: apps-hcpapps-tls\n          kind: Secret\nEOF\n</code></pre> <p>If you take a look at the gateway status, you will see a TLS status error similar to the following:</p> <pre><code>message: invalid certificate reference /Secret/apps-hcpapps-tls. secret kuadrant-system/apps-hcpapps-tls not found\n</code></pre> <p>This is because currently there is not a TLS secret in place. Let's fix that by creating a TLSPolicy.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#define-the-tlspolicy","title":"Define the TLSPolicy","text":"<pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: api-gateway-tls\n  namespace: kuadrant-system\nspec:\n  targetRef:\n    name: api-gateway\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  issuerRef:\n    group: cert-manager.io\n    kind: ClusterIssuer\n    name: kuadrant-operator-glbc-ca\nEOF\n</code></pre> <p>Note: You may have to create a cluster issuer in the Kubernetes cluster, depending on if one was created during your initial cluster setup or not. Here is an example of how to create a self-signed CA as a cluster issuer. This is a self signed issuer for simplicity, but you can use other issuers such as letsencrypt. Refer to the cert-manager docs</p> <pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: kuadrant-operator-glbc-ca\nspec:\n  selfSigned: {}\nEOF\n</code></pre> <p>The TLSPolicy should eventually have an <code>Accepted</code>  and <code>Enforced</code> condition.</p> <pre><code>kubectl --context $KUBECTL_CONTEXT wait tlspolicy api-gateway-tls -n kuadrant-system --for=condition=accepted\nkubectl --context $KUBECTL_CONTEXT wait tlspolicy api-gateway-tls -n kuadrant-system --for=condition=enforced\n</code></pre> <p>Now, if you look at the status of the gateway, you will see the error is gone, and the status of the policy will report the listener as now secured with a TLS certificate and the gateway as affected by the TLS policy.</p> <p>Our communication with our gateway is now secured via TLS. Note that any new listeners will also be handled by the TLSPolicy.</p> <p>Let's define a HTTPRoute and test our policy. We will re-use this later on with some of the other policies as well.</p> <pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  labels:\n    deployment: toystore\n    service: toystore\nspec:\n  parentRefs:\n\n  - name: api-gateway\n    namespace: kuadrant-system\n  hostnames:\n  - \"api.$KUADRANT_ZONE_ROOT_DOMAIN\"\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/dolls\"\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/admin\"\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>With this HTTPRoute in place, the service we deployed is exposed via the gateway. We should be able to access our endpoint via HTTPS:</p> <pre><code>export INGRESS_HOST=$(kubectl --context $KUBECTL_CONTEXT get gtw api-gateway -o jsonpath='{.status.addresses[0].value}' -n kuadrant-system)\n\ncurl -k --resolve api.${KUADRANT_ZONE_ROOT_DOMAIN}:443:${INGRESS_HOST} \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\"\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#define-infrastructure-rate-limiting","title":"Define Infrastructure Rate Limiting","text":"<p>We have a secure communication in place. However, there is nothing limiting users from overloading our infrastructure and service components that will sit behind this gateway. Let's add a rate limiting layer to protect our services and infrastructure.</p> <pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: infra-ratelimit\n  namespace: kuadrant-system\nspec:\n  targetRef:\n    name: api-gateway\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  limits:\n    \"global\":\n      rates:\n\n      - limit: 5\n        window: 10s\nEOF\n\nkubectl --context $KUBECTL_CONTEXT wait ratelimitpolicy infra-ratelimit -n kuadrant-system --for=condition=accepted\nkubectl --context $KUBECTL_CONTEXT wait ratelimitpolicy infra-ratelimit -n kuadrant-system --for=condition=enforced\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>The limit here is artificially low in order for us to show it working easily. Let's test it with our endpoint:</p> <pre><code>for i in {1..10}; do curl -k --resolve api.${KUADRANT_ZONE_ROOT_DOMAIN}:443:${INGRESS_HOST} \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" &amp;&amp; sleep 1; done\n</code></pre> <p>We should see <code>409 Too Many Requests</code>s start returning after the 5th request.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#define-the-gateway-authpolicy","title":"Define the Gateway AuthPolicy","text":"<p>Communication is secured and we have some protection for our infrastructure, but we do not trust any client to access our endpoints. By default, we want to allow only authenticated access. To protect our gateway, we will add a deny-all AuthPolicy. Later, we will override this with a more specific AuthPolicy for the API.</p> <pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: deny-all\n  namespace: kuadrant-system\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n  rules:\n    authorization:\n      deny-all:\n        opa:\n          rego: \"allow = false\"\n    response:\n      unauthorized:\n        headers:\n          \"content-type\":\n            value: application/json\n        body:\n          value: |\n            {\n              \"error\": \"Forbidden\",\n              \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n            }\nEOF\n</code></pre> <p>Let's test it again. This time we expect a <code>403 Forbidden</code>.</p> <pre><code>curl -k --resolve api.${KUADRANT_ZONE_ROOT_DOMAIN}:443:${INGRESS_HOST}  \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\"\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#define-the-dnspolicy","title":"Define the DNSPolicy","text":"<p>(Skip this step if you did not configure a DNS provider during the setup.)</p> <p>Now, we have our gateway protected and communications secured. We are ready to configure DNS, so it is easy for clients to connect and access the APIs we intend to expose via this gateway.</p> <p>Note: You may need to create a DNS Provider Secret resource depending on if one was created during your initial cluster setup or not. You should have an <code>aws-credentials</code> Secret already created in the <code>kuadrant-system</code> namespace. However, if it doesn't exist, you can follow these commands to create one:</p> <pre><code>export AWS_ACCESS_KEY_ID=xxxxxxx # Key ID from AWS with Route 53 access\nexport AWS_SECRET_ACCESS_KEY=xxxxxxx # Access key from AWS with Route 53 access\n\nkubectl -n kuadrant-system create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\n</code></pre> <p>Next, create the DNSPolicy. There are two options here.</p> <p>Single gateway with no shared hostnames:</p> <p><pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: simple-dnspolicy\n  namespace: kuadrant-system\nspec:\n  targetRef:\n    name: api-gateway\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:\n\n  - name: aws-credentials\nEOF\n</code></pre> Multiple gateways with shared hostnames:</p> <p>If you want to use a gateway with a shared listener host (IE the same hostname on more than one gateway instance). Then you should use the following configuration:</p> <p>Note: This configuration will work fine for a single gateway also, but does create some additional records.</p> <pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: simple-dnspolicy\n  namespace: kuadrant-system\nspec:\n  targetRef:\n    name: api-gateway\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:\n\n    - name: aws-credentials\n  loadBalancing:\n    weight: 120\n    geo: EU\n    defaultGeo: true\nEOF\n</code></pre> <p>The loadbalancing section here has the following attributes:</p> <ul> <li>Weight: This will be the weighting used for records created for hosts defined by this gateway. It will decide how often the records for this gateway are returned. If you have 2 gateways and each DNSPolicy specifies the same weight, then you will get an even distribution. If you define one weight as larger than the other, the gateway with the larger weight will receive more traffic (record weight / sum of all records).</li> <li>geo: This will be the geo used to decide whether to return records defined for this gateway based on the requesting client's location. This should be set even if you have one gateway in a single geo.</li> <li>defaultGeo: For Azure and AWS, this will decide, if there should be a default geo. A default geo acts as a \"catch-all\" (GCP always sets a catch-all) for clients outside of the defined geo locations. There can only be one default value and so it is important you set <code>defaultGeo</code> as true for one and only one geo code for each of the gateways in that geo.</li> </ul> <p>Wait for the DNSPolicy to marked as accepted and enforced:</p> <pre><code>kubectl --context $KUBECTL_CONTEXT wait dnspolicy simple-dnspolicy -n kuadrant-system --for=condition=accepted\nkubectl --context $KUBECTL_CONTEXT wait dnspolicy simple-dnspolicy -n kuadrant-system --for=condition=enforced\n</code></pre> <p>If you want to see the actual DNSRecord created by the this policy, execute the following command:</p> <p>Note: This resource is managed by kuadrant and so shouldn't be changed directly.</p> <pre><code>kubectl --context $KUBECTL_CONTEXT get dnsrecord.kuadrant.io api-gateway-api -n kuadrant-system -o=yaml\n</code></pre> <p>With DNS in place, let's test it again. This time we expect a <code>403</code> still as the deny-all policy is still in effect. Notice we no longer need to set the Host header directly.</p> <p>Note: If you have followed through this guide on more than 1 cluster, the DNS record for the HTTPRoute hostname will have multiple IP addresses. This means that requests will be made in a round robin pattern across clusters as your DNS provider sends different responses to lookups. You may need to send multiple requests before one hits the cluster you are currently configuring.</p> <pre><code>curl -k \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" -i\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#override-the-gateways-deny-all-authpolicy","title":"Override the Gateway's deny-all AuthPolicy","text":"<p>Next, we are going to allow authenticated access to our Toystore API. To do this, we will define an AuthPolicy that targets the HTTPRoute. Note that any new HTTPRoutes will still be affected by the gateway-level policy, but as we want users to now access this API, we need to override that policy. For simplicity, we will use API keys to authenticate the requests, though many other options are available.</p> <p>Let's define an API Key for users bob and alice.</p> <pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  namespace: kuadrant-system\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  namespace: kuadrant-system\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre> <p>Now, we will override the AuthPolicy to start accepting the API keys:</p> <pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre> <p>Ensure the new policy is enforced:</p> <pre><code>kubectl --context $KUBECTL_CONTEXT wait authpolicy toystore --for=condition=enforced\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-k8s/#override-the-gateways-ratelimitpolicy","title":"Override the Gateway's RateLimitPolicy","text":"<p>The gateway limits are a good set of limits for the general case, but as the developers of this API we know that we only want to allow a certain number of requests to specific users, and a general limit for all other users.</p> <pre><code>kubectl --context $KUBECTL_CONTEXT apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"general-user\":\n      rates:\n\n      - limit: 1\n        window: 3s\n      counters:\n      - expression: auth.identity.userid\n      when:\n      - predicate: \"auth.identity.userid != 'bob'\"\n    \"bob-limit\":\n      rates:\n      - limit: 2\n        window: 3s\n      when:\n      - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>As just another example, we have given bob twice as many requests to use compared to everyone else.</p> <p>Let's test this new setup.</p> <p>By sending requests as alice:</p> <pre><code>while :; do curl -k --resolve api.${KUADRANT_ZONE_ROOT_DOMAIN}:443:${INGRESS_HOST} --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>By sending requests as bob:</p> <pre><code>while :; do curl -k --resolve api.${KUADRANT_ZONE_ROOT_DOMAIN}:443:${INGRESS_HOST} --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Note: If you configured a DNS provider during the setup and defined the DNSPolicy as described in one of the previous chapters you can omit the <code>--resolve api.${KUADRANT_ZONE_ROOT_DOMAIN}:443:${INGRESS_HOST}</code> flag.</p> <p>Note: If you have followed through this guide on more than 1 cluster, the DNS record for the HTTPRoute hostname will have multiple IP addresses. This means that requests will be made in a round robin pattern across clusters as your DNS provider sends different responses to lookups.</p> <pre><code>while :; do curl -k --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <pre><code>while :; do curl -k --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/","title":"Secure, protect, and connect APIs with Kuadrant on OpenShift","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#overview","title":"Overview","text":"<p>This guide walks you through using Kuadrant on OpenShift to secure, protect, and connect an API exposed by a Gateway that is based on Kubernetes Gateway API. You can use this walkthrough for a Gateway deployed on a single OpenShift cluster or a Gateway distributed across multiple OpenShift clusters with a shared listener hostname. This guide shows how the platform engineer and application developer user roles can each use Kuadrant to achieve their goals.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#what-kuadrant-can-do-for-you-in-a-multicluster-environment","title":"What Kuadrant can do for you in a multicluster environment","text":"<p>You can leverage Kuadrant's capabilities in single or multiple clusters. The following features are designed to work across multiple clusters as well as in a single-cluster environment.</p> <ul> <li>Multicluster ingress: Kuadrant provides multicluster ingress connectivity using DNS to bring traffic to your Gateways by using a strategy defined in a <code>DNSPolicy</code>. </li> <li>Global rate limiting: Kuadrant can enable global rate limiting use cases when configured to use a shared Redis store for counters based on limits defined by a <code>RateLimitPolicy</code>.</li> <li>Global auth: You can configure a Kuadrant <code>AuthPolicy</code> to leverage external auth providers to ensure that different clusters exposing the same API authenticate and authorize in the same way. </li> <li>Integration with federated metrics stores: Kuadrant has example dashboards and metrics for visualizing your Gateways and observing traffic hitting those Gateways across multiple clusters. </li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#user-roles","title":"User roles","text":"<ul> <li> <p>Platform engineer: This guide walks you through deploying a Gateway that provides secure communication and is protected and ready for use by application development teams to deploy an API. It then walks through using this Gateway in clusters in different geographic regions, leveraging Kuadrant to bring specific traffic to your geo-located Gateways to reduce latency and distribute load, while still being protected and secured with global rate limiting and auth. </p> </li> <li> <p>Application developer: This guide walks through how you can use the Kuadrant OpenAPI Specification (OAS) extensions and <code>kuadrantctl</code> CLI to generate an <code>HTTPRoute</code> for your API and to add specific auth and rate limiting requirements.</p> </li> </ul> <p>As an optional extra, this guide highlights how both user roles can observe and monitor these Gateways when the OpenShift user workload monitoring and observability stack is deployed. </p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#deployment-management-tooling","title":"Deployment management tooling","text":"<p>While this document uses <code>kubectl</code> commands for simplicity, working with multiple clusters is complex, and it is best to use a tool such as Argo CD to manage the deployment of resources to multiple clusters.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#prerequisites","title":"Prerequisites","text":"<p>This guide expects that you have successfully installed Kuadrant on at least one OpenShift cluster:</p> <ul> <li>You have completed the steps in Install Kuadrant on an OpenShift cluster for one or more clusters.</li> <li>For multicluster scenarios, you have installed Kuadrant on at least two different OpenShift clusters, and have a shared accessible Redis store.</li> <li>You have the <code>kubectl</code> command line installed.</li> <li>Optional: User workload monitoring is configured to remote write to a central storage system such as Thanos, as described in Install Kuadrant on an OpenShift cluster.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#platform-engineer-workflow","title":"Platform engineer workflow","text":"<p>NOTE: You must perform the following steps in each cluster individually, unless specifically excluded. </p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-1-set-your-environment-variables","title":"Step 1 - Set your environment variables","text":"<p>Set the following environment variables used for convenience in this guide: <pre><code>export zid=change-this-to-your-zone-id\nexport rootDomain=example.com\nexport gatewayNS=api-gateway\nexport gatewayName=external\nexport devNS=toystore\nexport AWS_ACCESS_KEY_ID=xxxx\nexport AWS_SECRET_ACCESS_KEY=xxxx\nexport AWS_REGION=us-east-1\nexport clusterIssuerName=lets-encrypt\nexport EMAIL=foo@example.com\n</code></pre></p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-2-set-up-a-dns-provider","title":"Step 2 - Set up a DNS Provider","text":"<p>The DNS provider declares a credential to access the zone(s) that Kuadrant can use to set up DNS configuration. You should ensure that this credential only has access to the zones you want managed.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#create-the-dns-provider-secret-resource","title":"Create the DNS Provider Secret resource","text":"<p>Apply the following <code>Secret</code> resource to each cluster. Alternatively, if you are adding an additional cluster, add it to the new cluster:</p> <pre><code>kubectl create ns ${gatewayNS}\n</code></pre> <p>Create the secret credentials as follows:</p> <pre><code>kubectl -n ${gatewayNS} create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-3-add-a-tls-issuer","title":"Step 3 - Add a TLS issuer","text":"<p>To secure communication to the Gateways, you will define a TLS issuer for TLS certificates. This example uses Let's Encrypt, but you can use any issuer supported by <code>cert-manager</code>.</p> <p>The following example uses Let's Encrypt staging, which you must also apply to all clusters:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: ${clusterIssuerName}\nspec:\n  acme:\n    email: ${EMAIL} \n    privateKeySecretRef:\n      name: le-secret\n    server: https://acme-staging-v02.api.letsencrypt.org/directory\n    solvers:\n\n      - dns01:\n          route53:\n            hostedZoneID: ${zid}\n            region: ${AWS_REGION}\n            accessKeyIDSecretRef:\n              key: AWS_ACCESS_KEY_ID\n              name: aws-credentials\n            secretAccessKeySecretRef:\n              key: AWS_SECRET_ACCESS_KEY\n              name: aws-credentials\nEOF\n</code></pre> <p>Then wait for the <code>ClusterIssuer</code> to become ready as follows:</p> <pre><code>kubectl wait clusterissuer/${clusterIssuerName} --for=condition=ready=true\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-4-set-up-a-gateway","title":"Step 4 - Set up a Gateway","text":"<p>For Kuadrant to balance traffic using DNS across two or more clusters, you must define a Gateway with a shared host. You will define this by using an HTTPS listener with a wildcard hostname based on the root domain. As mentioned earlier, you must apply these resources to all clusters. </p> <p>NOTE: For now, the Gateway is set to accept an <code>HTTPRoute</code> from the same namespace only. This allows you to restrict who can use the Gateway until it is ready for general use.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${gatewayName}\n  namespace: ${gatewayNS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n    gatewayClassName: istio\n    listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: Same\n      hostname: \"*.${rootDomain}\"\n      name: api\n      port: 443\n      protocol: HTTPS\n      tls:\n        certificateRefs:\n        - group: \"\"\n          kind: Secret\n          name: api-${gatewayName}-tls\n        mode: Terminate\nEOF\n</code></pre> <p>Check the status of your Gateway as follows:</p> <pre><code>kubectl get gateway ${gatewayName} -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\nkubectl get gateway ${gatewayName} -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Programmed\")].message}'\n</code></pre> <p>Your Gateway should be accepted and programmed (valid and assigned an external address). However, if you check your listener status as follows, you will see that it is not yet programmed or ready to accept traffic due to bad TLS configuration:</p> <pre><code>kubectl get gateway ${gatewayName} -n ${gatewayNS} -o=jsonpath='{.status.listeners[0].conditions[?(@.type==\"Programmed\")].message}'\n</code></pre> <p>Kuadrant can help with this by using a TLSPolicy.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-4a-optional-configure-metrics-to-be-scraped-from-the-gateway-instance","title":"Step 4a - (Optional) Configure metrics to be scraped from the Gateway instance","text":"<p>If you have prometheus in your cluster, set up a PodMonitor to configure it to scrape metrics directly from the Gateway pod. This must be done in the namespace where the Gateway is running. This configuration is required for metrics such as <code>istio_requests_total</code>.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: monitoring.coreos.com/v1\nkind: PodMonitor\nmetadata:\n  name: istio-proxies-monitor\n  namespace: ${gatewayNS}\nspec:\n  selector:\n    matchExpressions:\n\n      - key: istio-prometheus-ignore\n        operator: DoesNotExist\n  podMetricsEndpoints:\n    - path: /stats/prometheus\n      interval: 30s\n      relabelings:\n        - action: keep\n          sourceLabels: [\"__meta_kubernetes_pod_container_name\"]\n          regex: \"istio-proxy\"\n        - action: keep\n          sourceLabels:\n            [\"__meta_kubernetes_pod_annotationpresent_prometheus_io_scrape\"]\n        - action: replace\n          regex: (\\d+);(([A-Fa-f0-9]{1,4}::?){1,7}[A-Fa-f0-9]{1,4})\n          replacement: \"[\\$2]:\\$1\"\n          sourceLabels:\n            [\n              \"__meta_kubernetes_pod_annotation_prometheus_io_port\",\n              \"__meta_kubernetes_pod_ip\",\n            ]\n          targetLabel: \"__address__\"\n        - action: replace\n          regex: (\\d+);((([0-9]+?)(\\.|$)){4})\n          replacement: \"\\$2:\\$1\"\n          sourceLabels:\n            [\n              \"__meta_kubernetes_pod_annotation_prometheus_io_port\",\n              \"__meta_kubernetes_pod_ip\",\n            ]\n          targetLabel: \"__address__\"\n        - action: labeldrop\n          regex: \"__meta_kubernetes_pod_label_(.+)\"\n        - sourceLabels: [\"__meta_kubernetes_namespace\"]\n          action: replace\n          targetLabel: namespace\n        - sourceLabels: [\"__meta_kubernetes_pod_name\"]\n          action: replace\n          targetLabel: pod_name\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-5-secure-and-protect-the-gateway-with-auth-tls-rate-limit-and-dns-policies","title":"Step 5 - Secure and protect the Gateway with auth, TLS, rate limit, and DNS policies","text":"<p>While your Gateway is now deployed, it has no exposed endpoints and your listener is not programmed. Next, you can set up a <code>TLSPolicy</code> that leverages your CertificateIssuer to set up your listener certificates. </p> <p>You will also define an <code>AuthPolicy</code> that will set up a default <code>403</code> response for any unprotected endpoints, as well as a <code>RateLimitPolicy</code> that will set up a default artificially low global limit to further protect any endpoints exposed by this Gateway.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#set-the-auth-policy","title":"Set the Auth policy","text":"<p>Set a default, deny-all <code>AuthPolicy</code> for your Gateway as follows:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: ${gatewayName}-auth\n  namespace: ${gatewayNS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${gatewayName}\n  defaults:\n    rules:\n      authorization:\n        \"deny\":\n          opa:\n            rego: \"allow = false\"\nEOF\n</code></pre> <p>Check that your auth policy was accepted by the controller as follows:</p> <pre><code>kubectl get authpolicy ${gatewayName}-auth -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#set-the-tls-policy","title":"Set the TLS policy","text":"<p>Set the <code>TLSPolicy</code> for your Gateway as follows:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: ${gatewayName}-tls\n  namespace: ${gatewayNS}\nspec:\n  targetRef:\n    name: ${gatewayName}\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  issuerRef:\n    group: cert-manager.io\n    kind: ClusterIssuer\n    name: ${clusterIssuerName}\nEOF\n</code></pre> <p>Check that your TLS policy was accepted by the controller as follows:</p> <pre><code>kubectl get tlspolicy ${gatewayName}-tls -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#set-the-rate-limit-policy","title":"Set the rate limit policy","text":"<p>Set the default <code>RateLimitPolicy</code> for your Gateway as follows:</p> <pre><code>kubectl apply -f  - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: ${gatewayName}-rlp\n  namespace: ${gatewayNS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${gatewayName}\n  defaults:\n    limits:\n      \"low-limit\":\n        rates:\n\n        - limit: 2\n          window: 10s\nEOF\n</code></pre> <p>To check your rate limits have been accepted, enter the following command:</p> <pre><code>kubectl get ratelimitpolicy ${gatewayName}-rlp -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#set-the-dns-policy","title":"Set the DNS policy","text":"<p>Set the <code>DNSPolicy</code> for your Gateway as follows:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: ${gatewayName}-dnspolicy\n  namespace: ${gatewayNS}\nspec:\n  loadBalancing:\n    defaultGeo: true\n    geo: US\n    weight: 120\n  targetRef:\n    name: ${gatewayName}\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:\n\n  - name: aws-credentials\nEOF\n</code></pre> <p>NOTE:  The <code>DNSPolicy</code> will use the DNS Provider <code>Secret</code> that you defined earlier.</p> <p>Check that your <code>DNSPolicy</code> has been accepted as follows:</p> <pre><code>kubectl get dnspolicy ${gatewayName}-dnspolicy -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#create-an-http-route","title":"Create an HTTP route","text":"<p>Create an <code>HTTPRoute</code> for your Gateway as follows:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: test\n  namespace: ${gatewayNS}\n  labels:\n    service: toystore\nspec:\n  parentRefs:\n\n  - name: ${gatewayName}\n    namespace: ${gatewayNS}\n  hostnames:\n  - \"test.${rootDomain}\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Check your Gateway policies are enforced as follows:</p> <pre><code>kubectl get dnspolicy ${gatewayName}-dnspolicy -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Enforced\")].message}'\nkubectl get authpolicy ${gatewayName}-auth -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Enforced\")].message}'\nkubectl get ratelimitpolicy ${gatewayName}-rlp -n ${gatewayNS} -o=jsonpath='{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre> <p>Check your listener is ready as follows:</p> <pre><code>kubectl get gateway ${gatewayName} -n ${gatewayNS} -o=jsonpath='{.status.listeners[0].conditions[?(@.type==\"Programmed\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-6-test-connectivity-and-deny-all-auth","title":"Step 6 - Test connectivity and deny all auth","text":"<p>You can use <code>curl</code> to hit your endpoint. You should see a <code>403</code>. Because this example uses Let's Encrypt staging, you can pass the <code>-k</code> flag:</p> <pre><code>curl -k -w \"%{http_code}\" https://$(kubectl get httproute test -n ${gatewayNS} -o=jsonpath='{.spec.hostnames[0]}')\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-7-opening-up-the-gateway-for-other-namespaces","title":"Step 7 - Opening up the Gateway for other namespaces","text":"<p>Because you have configured the Gateway, secured it with Kuadrant policies, and tested it, you can now open it up for use by other teams in other namespaces:</p> <pre><code>kubectl patch gateway ${gatewayName} -n ${gatewayNS} --type='json' -p='[{\"op\": \"replace\", \"path\": \"/spec/listeners/0/allowedRoutes/namespaces/from\", \"value\":\"All\"}]'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-8-extending-this-gateway-to-multiple-clusters-and-configuring-geo-based-routing","title":"Step 8 - Extending this Gateway to multiple clusters and configuring geo-based routing","text":"<p>To distribute this Gateway across multiple clusters, repeat this setup process for each cluster. By default, this will implement a round-robin DNS strategy to distribute traffic evenly across the different clusters. Setting up your Gateways to serve clients based on their geographic location is straightforward with your current configuration.</p> <p>Assuming that you have deployed Gateway instances across multiple clusters as per this guide, the next step involves updating the DNS controller with the geographic regions of the visible Gateways.</p> <p>For instance, if you have one cluster in North America and another in the EU, you can direct traffic to these Gateways based on their location by applying the appropriate labels:</p> <p>For your North American cluster, enter the following command:</p> <pre><code>kubectl label --overwrite gateway ${gatewayName} kuadrant.io/lb-attribute-geo-code=US -n ${gatewayNS}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#application-developer-workflow","title":"Application developer workflow","text":"<p>This section of the walkthrough focuses on using an OpenAPI Specification (OAS) to define an API. You will use Kuadrant OAS extensions to specify the routing, authentication, and rate limiting requirements. Next, you will use the <code>kuadrantctl</code> tool to generate an <code>AuthPolicy</code>, an <code>HTTPRoute</code>, and a <code>RateLimitPolicy</code>, which you will then apply to your cluster to enforce the settings defined in your OAS.</p> <p>NOTE: While this section uses the <code>kuadrantctl</code> tool, this is not essential. You can also create and apply an <code>AuthPolicy</code>, <code>RateLimitPolicy</code>, and <code>HTTPRoute</code> by using the <code>oc</code> or <code>kubectl</code> commands.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#prerequisites_1","title":"Prerequisites","text":"<ul> <li>You have installed <code>kuadrantctl</code>. You can find a compatible binary and download it from the kuadrantctl releases page.</li> <li>You have the ability to distribute resources generated by <code>kuadrantctl</code> to multiple clusters, as though you are a platform engineer.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-1-deploy-the-toystore-app","title":"Step 1 - Deploy the toystore app","text":"<p>To begin, deploy a new version of the <code>toystore</code> app to a developer namespace as follows:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${devNS}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-2-set-up-httproute-and-backend","title":"Step 2 - Set up HTTPRoute and backend","text":"<p>Copy at least one of the following example OAS to a local location:</p> <ul> <li> <p>Sample OAS for rate limiting with API key</p> </li> <li> <p>Sample OAS for rate limiting with OIDC</p> </li> </ul> <p>Set up some new environment variables as follows:</p> <pre><code>export oasPath=examples/oas-apikey.yaml\n# Ensure you still have these environment variables setup from the start of this guide:\nexport rootDomain=example.com\nexport gatewayNS=api-gateway\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-3-use-oas-to-define-your-httproute-rules","title":"Step 3 - Use OAS to define your HTTPRoute rules","text":"<p>You can generate Kuadrant and Gateway API resources directly from OAS documents by using an <code>x-kuadrant</code> extension.</p> <p>NOTE: For a more in-depth look at the OAS extension, see the kuadrantctl documentation.</p> <p>You will use <code>kuadrantctl</code> to generate your <code>HTTPRoute</code>.</p> <p>NOTE: The sample OAS has some placeholders for namespaces and domains. You will inject valid values into these placeholders based on your previous environment variables.</p> <p>Generate the resource from your OAS as follows, (<code>envsubst</code> will replace the placeholders):</p> <pre><code>cat $oasPath | envsubst | kuadrantctl generate gatewayapi httproute --oas - | kubectl apply -f -\n</code></pre> <pre><code>kubectl get httproute toystore -n ${devNS} -o=yaml\n</code></pre> <p>You should see that this route is affected by the <code>AuthPolicy</code> and <code>RateLimitPolicy</code> defined as defaults on the Gateway in the Gateway namespace.</p> <pre><code>- lastTransitionTime: \"2024-04-26T13:37:43Z\"\n        message: Object affected by AuthPolicy demo/external\n        observedGeneration: 2\n        reason: Accepted\n        status: \"True\"\n        type: kuadrant.io/AuthPolicyAffected\n- lastTransitionTime: \"2024-04-26T14:07:28Z\"\n        message: Object affected by RateLimitPolicy demo/external\n        observedGeneration: 1\n        reason: Accepted\n        status: \"True\"\n        type: kuadrant.io/RateLimitPolicyAffected        \n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-4-test-connectivity-and-deny-all-auth","title":"Step 4 - Test connectivity and deny-all auth","text":"<p>You can use <code>curl</code> to hit an endpoint in the toystore app. Because you are using Let's Encrypt staging in this example, you can pass the <code>-k</code> flag as follows:</p> <pre><code>curl -s -k -o /dev/null -w \"%{http_code}\" \"https://$(kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.spec.hostnames[0]}')/v1/toys\"\n</code></pre> <p>You are getting a <code>403</code> because of the existing default, deny-all <code>AuthPolicy</code> applied at the Gateway. You can override this for your <code>HTTPRoute</code>.</p> <p>Choose one of the following options:</p> <ul> <li>API key auth flow</li> <li>OpenID Connect auth flow </li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-5-set-up-api-key-auth-flow","title":"Step 5 - Set up API key auth flow","text":"<p>Set up an example API key in each cluster as follows:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: toystore-api-key\n  namespace: ${devNS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    kuadrant.io/apikeys-by: api_key\nstringData:\n  api_key: secret\ntype: Opaque\nEOF\n</code></pre> <p>Next, generate an <code>AuthPolicy</code> that uses secrets in your cluster as API keys as follows:</p> <pre><code>cat $oasPath | envsubst | kuadrantctl generate kuadrant authpolicy --oas -\n</code></pre> <p>From this, you can see an <code>AuthPolicy</code> generated based on your OAS that will look for API keys in secrets labeled <code>api_key</code> and look for that key in the header <code>api_key</code>. You can now apply this to the Gateway as follows:</p> <pre><code>cat $oasPath | envsubst | kuadrantctl generate kuadrant authpolicy --oas -  | kubectl apply -f -\n</code></pre> <p>You should get a <code>200</code> from the following <code>GET</code> because it has no auth requirement:</p> <pre><code>curl -s -k -o /dev/null -w \"%{http_code}\" \"https://$(kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.spec.hostnames[0]}')/v1/toys\"\n</code></pre> <p>You should get a <code>401</code> for the following <code>POST</code> request because it does not have any auth requirements:</p> <pre><code>curl -XPOST -s -k -o /dev/null -w \"%{http_code}\" \"https://$(kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.spec.hostnames[0]}')/v1/toys\"\n</code></pre> <p>Finally, if you add your API key header, with a valid key as follows, you should get a <code>200</code> response:</p> <pre><code>curl -XPOST -H 'api_key: secret' -s -k -o /dev/null -w \"%{http_code}\" \"https://$(kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.spec.hostnames[0]}')/v1/toys\"\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#optional-step-6-set-up-openid-connect-auth-flow-skip-if-using-api-key-only","title":"Optional: Step 6 - Set up OpenID Connect auth flow (skip if using API key only)","text":"<p>This section of the walkthrough uses the <code>kuadrantctl</code> tool to create an <code>AuthPolicy</code> that integrates with an OpenID provider and a <code>RateLimitPolicy</code> that leverages JWT values for per-user rate limiting. It is important to note that OpenID requires an external provider. Therefore, you should adapt the following example to suit your specific needs and provider.</p> <p>The platform engineer workflow established default policies for authentication and rate limiting at your Gateway. The new developer-defined policies, which you will create, are intended to target your HTTPRoute and will supersede the existing policies for requests to your API endpoints, similar to your previous API key example.</p> <p>The example OAS uses Kuadrant-based extensions. These extensions enable you to define routing and service protection requirements. For more details, see OpenAPI Kuadrant extensions.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#prerequisites_2","title":"Prerequisites","text":"<ul> <li>You have installed and configured an OpenID Connect provider, such as https://www.keycloak.org/. </li> <li>You have a realm, client, and users set up. This example assumes a realm in a Keycloak instance called <code>toystore</code>.</li> <li>Copy the OAS from sample OAS for rate-limiting and OIDC to a local location.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#set-up-an-openid-authpolicy","title":"Set up an OpenID AuthPolicy","text":"<p>Set the following environment variables:</p> <pre><code>export openIDHost=some.keycloak.com\nexport oasPath=examples/oas-oidc.yaml\n</code></pre> <p>NOTE: The sample OAS has some placeholders for namespaces and domains. You will inject valid values into these placeholders based on your previous environment variables.</p> <p>You can use your OAS and <code>kuadrantctl</code> to generate an <code>AuthPolicy</code> to replace the default on the Gateway as follows:</p> <pre><code>cat $oasPath | envsubst | kuadrantctl generate kuadrant authpolicy --oas -\n</code></pre> <p>If you are happy with the generated resource, you can apply it to the cluster as follows:</p> <pre><code>cat $oasPath | envsubst | kuadrantctl generate kuadrant authpolicy --oas - | kubectl apply -f -\n</code></pre> <p>You should see in the status of the <code>AuthPolicy</code> that it has been accepted and enforced:</p> <pre><code>kubectl get authpolicy -n ${devNS} toystore -o=jsonpath='{.status.conditions}'\n</code></pre> <p>On your <code>HTTPRoute</code>, you should also see it now affected by this <code>AuthPolicy</code> in the toystore namespace:</p> <pre><code>kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.status.parents[0].conditions[?(@.type==\"kuadrant.io/AuthPolicyAffected\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#test-your-openid-authpolicy","title":"Test your OpenID AuthPolicy","text":"<p>You can test your <code>AuthPolicy</code> as follows:</p> <pre><code>export ACCESS_TOKEN=$(curl -k -H \"Content-Type: application/x-www-form-urlencoded\" \\\n        -d 'grant_type=password' \\\n        -d 'client_id=toystore' \\\n        -d 'scope=openid' \\\n        -d 'username=bob' \\\n        -d 'password=p' \"https://${openIDHost}/auth/realms/toystore/protocol/openid-connect/token\" | jq -r '.access_token')\n</code></pre> <pre><code>curl -k -XPOST --write-out '%{http_code}\\n' --silent --output /dev/null \"https://$(kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.spec.hostnames[0]}')/v1/toys\"\n</code></pre> <p>You should see a <code>401</code> response code. Make a request with a valid bearer token as follows:</p> <pre><code>curl -k -XPOST --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Authorization: Bearer $ACCESS_TOKEN\" \"https://$(kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.spec.hostnames[0]}')/v1/toys\"\n</code></pre> <p>You should see a <code>200</code> response code.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#step-7-set-up-rate-limiting","title":"Step 7 - Set up rate limiting","text":"<p>Lastly, you can generate your <code>RateLimitPolicy</code> to add your rate limits, based on your OAS file. Rate limiting is simplified for this walkthrough and is based on either the bearer token or the API key value. There are more advanced examples in the How-to guides on the Kuadrant documentation site, for example: Authenticated rate limiting with JWTs and Kubernetes RBAC.</p> <p>You can continue to use this sample OAS document, which includes both authentication and a rate limit:</p> <pre><code>export oasPath=examples/oas-oidc.yaml\n</code></pre> <p>Again, you should see the rate limit policy accepted and enforced:</p> <pre><code>kubectl get ratelimitpolicy -n ${devNS} toystore -o=jsonpath='{.status.conditions}'\n</code></pre> <p>On your <code>HTTRoute</code>, you should now see it is affected by the <code>RateLimitPolicy</code> in the same namespace:</p> <pre><code>kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.status.parents[0].conditions[?(@.type==\"kuadrant.io/RateLimitPolicyAffected\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#test-your-ratelimitpolicy","title":"Test your RateLimitPolicy","text":"<p>You can now test your rate limiting as follows:</p> <p>NOTE: You might need to wait a minute for the new rate limits to be applied. With the following requests, you should see a number of 429 responses.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#api-key-auth","title":"API Key auth","text":"<pre><code>for i in {1..3}\ndo\nprintf \"request $i \"\ncurl -XPOST -H 'api_key:secret' -s -k -o /dev/null -w \"%{http_code}\"  \"https://$(kubectl get httproute toystore -n ${devNS} -o=jsonpath='{.spec.hostnames[0]}')/v1/toys\"\nprintf \"\\n -- \\n\"\ndone \n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#openid-connect-auth","title":"OpenID Connect auth","text":"<pre><code>export ACCESS_TOKEN=$(curl -k -H \"Content-Type: application/x-www-form-urlencoded\" \\\n        -d 'grant_type=password' \\\n        -d 'client_id=toystore' \\\n        -d 'scope=openid' \\\n        -d 'username=bob' \\\n        -d 'password=p' \"https://${openIDHost}/auth/realms/toystore/protocol/openid-connect/token\" | jq -r '.access_token')\n</code></pre> <pre><code>for i in {1..3}\ndo\ncurl -k -XPOST --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Authorization: Bearer $ACCESS_TOKEN\" https://$(kubectl get httproute toystore -n ${devNS}-o=jsonpath='{.spec.hostnames[0]}')/v1/toys\ndone\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect-openshift/#conclusion","title":"Conclusion","text":"<p>You have completed the secure, protect, and connect walkthrough. To learn more about Kuadrant, visit https://docs.kuadrant.io.</p>"},{"location":"kuadrant-operator/doc/user-guides/misc/external-api/","title":"Using Gateway API and Kuadrant with APIs outside of the cluster","text":""},{"location":"kuadrant-operator/doc/user-guides/misc/external-api/#overview","title":"Overview","text":"<p>In some cases, the application and API endpoints are exposed in a host external to the cluster where you are a running Gateway API and Kuadrant but you do not want it accessible directly via the public internet. If you want to have external traffic come into a Gateway API defined Gateway and protected by Kuadrant policies first being proxied to the existing legacy endpoints, this guide will give you some example of how to achieve this.</p>"},{"location":"kuadrant-operator/doc/user-guides/misc/external-api/#what-we-will-do","title":"What we will do","text":"<ul> <li>Have an API in a private location become accessible via a public hostname</li> <li>Setup a gateway and HTTPRoute to expose this private API via our new Gateway on a (public) domain.</li> <li>proxy valid requests through to our back-end API service</li> <li>Add auth and rate limiting and TLS to our public Gateway to protect it</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/misc/external-api/#pre-requisites","title":"Pre Requisites","text":"<ul> <li>Kuadrant and Gateway API installed (with Istio as the gateway provider)</li> <li>Existing API on separate cluster accessible via HTTP from the Gateway cluster</li> </ul> <p>What we want to achieve:</p> <pre><code>                                ------------------- DMZ -----------------|\n                                                                         |\n                               |-------------------------------- internal network -----------------------------------| \n                    load balancer                                        |                                            |           \n                        | - |  |      |----------k8s cluster-----------| |   |----- Legacy API Location --------|     |\n                        |   |  |      |  Gateway  Kuadrant             | |   |                                  |     |       \n                        |   |  |      |   -----    -----               | |   |                                  |     |                     \n---public traffic--my.api.com--------&gt;|   |    |&lt;--|   |               | |   |  HTTP (my.api.local)   Backend   |     |\n                        |   |  |      |   |    |   -----               | |   |      -----             -----     |     | \n                        |   |  |      |   ----- -----------proxy---(my.api.local)--&gt;|   | ----------&gt; |   |     |     | \n                        |   |  |      |                                | |   |      -----             -----     |     | \n                        | - |  |      |--------------------------------| |   |----------------------------------|     | \n                               |                                         |                                            |   \n                               |-----------------------------------------|--------------------------------------------| \n                                                                         |\n                                ------------------- DMZ -----------------|       \n</code></pre> <p>Note for all of the resources defined here there is a copy of them under the examples folder</p> <p>1) Deploy a Gateway into the K8s cluster that will act as the main Ingress Gateway</p> <p>Define your external API hostname and Internal API hostname</p> <pre><code>export EXTERNAL_HOST=my.api.com\nexport INTERNAL_HOST=my.api.local\n</code></pre> <pre><code>kubectl apply -n gateway-system -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  labels:\n    istio: ingress\n  name: ingress\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: ingress-tls\n      port: 443\n      hostname: '${EXTERNAL_HOST}'\n      protocol: HTTPS\n      allowedRoutes:\n        namespaces:\n          from: All\n      tls:\n        mode: Terminate\n        certificateRefs:\n          - name: ingress-tls  #you can use TLSPolicy to provide this certificate or provide it manually\n            kind: Secret\nEOF            \n</code></pre> <p>2) Optional: Use TLSPolicy to configure TLS certificates for your listeners</p> <p>TLSPolicy Guide</p> <p>3) Optional: Use DNSPolicy to bring external traffic to the external hostname</p> <p>DNSPolicy Guide</p> <p>4) Ensure the Gateway has the status of <code>Programmed</code> set to <code>True</code> meaning it is ready. </p> <pre><code>kubectl get gateway ingress -n gateway-system -o=jsonpath='{.status.conditions[?(@.type==\"Programmed\")].status}'\n</code></pre> <p>5) Let Istio know about the external hostname and the rules it should use when sending traffic to that destination.</p> <p>Create a <code>ServiceEntry</code></p> <pre><code>kubectl apply -n gateway-system -f - &lt;&lt;EOF\napiVersion: networking.istio.io/v1beta1\nkind: ServiceEntry\nmetadata:\n  name: internal-api\nspec:\n  hosts:\n\n    - ${INTERNAL_HOST} # your internal http endpoint\n  location: MESH_EXTERNAL\n  resolution: DNS\n  ports:\n    - number: 80\n      name: http\n      protocol: HTTP\n    - number: 443\n      name: https\n      protocol: TLS\nEOF\n</code></pre> <p>Create a <code>DestionationRule</code> to configure how to handle traffic to this endpoint.</p> <pre><code>kubectl apply -n gateway-system -f - &lt;&lt;EOF\napiVersion: networking.istio.io/v1\nkind: DestinationRule\nmetadata:\n  name: internal-api\nspec:\n  host: ${INTERNAL_HOST}\n  trafficPolicy:\n    tls:\n      mode: SIMPLE\n      sni: ${INTERNAL_HOST}\nEOF\n</code></pre> <p>6) Create a <code>HTTPRoute</code> that will route traffic for the Gateway and re-write the host</p> <pre><code>kubectl apply -n gateway-system -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: external-host\nspec:\n  parentRefs:\n\n    - name: ingress\n  hostnames:\n    - ${EXTERNAL_HOST}\n  rules:\n    - backendRefs:\n        - name: ${INTERNAL_HOST}\n          kind: Hostname\n          group: networking.istio.io\n          port: 443\n      filters:\n        - type: URLRewrite\n          urlRewrite:\n            hostname: ${INTERNAL_HOST}\nEOF\n</code></pre> <p>We should now be able to send requests to our external host and have the Gateway proxy requests and responses to and from the internal host.</p> <p>7) (optional) Add Auth and RateLimiting to protect your public endpoint</p> <p>As we are using Gateway API to define the Gateway and HTTPRoutes, we can now also apply RateLimiting and Auth to protect our public endpoints</p> <p>AuthPolicy Guide</p> <p>RateLimiting Guide</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/","title":"Authenticated Rate Limiting for Application developers","text":"<p>For more info on the different personas see Gateway API </p> <p>This user guide walks you through an example of how to configure authenticated rate limiting for an application using Kuadrant.</p> <p>Authenticated rate limiting rate limits the traffic directed to an application based on attributes of the client user, who is authenticated by some authentication method. A few examples of authenticated rate limiting use cases are:</p> <ul> <li>User A can send up to 50rps (\"requests per second\"), while User B can send up to 100rps.</li> <li>Each user can send up to 20rpm (\"request per minute\").</li> <li>Admin users (members of the 'admin' group) can send up to 100rps, while regular users (non-admins) can send up to 20rpm and no more than 5rps.</li> </ul> <p>In this guide, we will rate limit a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request. The API exposes an endpoint at <code>GET http://api.toystore.com/toy</code>, to mimic an operation of reading toy records.</p> <p>We will define 2 users of the API, which can send requests to the API at different rates, based on their user IDs. The authentication method used is API key.</p> User ID Rate limit alice 5rp10s (\"5 requests every 10 seconds\") bob 2rp10s (\"2 requests every 10 seconds\")"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#setup-the-environment","title":"Setup the environment","text":"<p>Follow this setup doc to set up your environment before continuing with this doc.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<p>Create the deployment:</p> <pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre> <p>Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: kuadrant-ingressgateway\n    namespace: gateway-system\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Export the gateway hostname and port:</p> <pre><code>export INGRESS_HOST=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.status.addresses[0].value}')\nexport INGRESS_PORT=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT\n</code></pre> <p>Verify the route works:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n gateway-system service/kuadrant-ingressgateway-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#enforce-authentication-on-requests-to-the-toy-store-api","title":"Enforce authentication on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure the authentication:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre> <p>Verify the authentication works by sending a request to the Toy Store API without API key:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-users\"\n# x-ext-auth-reason: \"credential not found\"\n</code></pre> <p>Create API keys for users <code>alice</code> and <code>bob</code> to authenticate:</p> <p>Note: Kuadrant stores API keys as Kubernetes Secret resources. User metadata can be stored in the annotations of the resource.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#enforce-authenticated-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce authenticated rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"alice-limit\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'alice'\"\n    \"bob-limit\":\n      rates:\n      - limit: 2\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests as Alice and Bob.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds allowed for Alice, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Up to 2 successful (<code>200 OK</code>) requests every 10 seconds allowed for Bob, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/","title":"Authenticated Rate Limiting with JWTs and Kubernetes RBAC","text":"<p>This user guide walks you through an example of how to use Kuadrant to protect an application with policies to enforce:</p> <ul> <li>authentication based OpenId Connect (OIDC) ID tokens (signed JWTs), issued by a Keycloak server;</li> <li>alternative authentication method by Kubernetes Service Account tokens;</li> <li>authorization delegated to Kubernetes RBAC system;</li> <li>rate limiting by user ID.</li> </ul> <p>In this example, we will protect a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request.</p> <p>The API listens to requests at the hostnames <code>*.toystore.com</code>, where it exposes the endpoints <code>GET /toy*</code>, <code>POST /admin/toy</code> and <code>DELETE /amind/toy</code>, respectively, to mimic operations of reading, creating, and deleting toy records.</p> <p>Any authenticated user/service account can send requests to the Toy Store API, by providing either a valid Keycloak-issued access token or Kubernetes token.</p> <p>Privileges to execute the requested operation (read, create or delete) will be granted according to the following RBAC rules, stored in the Kubernetes authorization system:</p> Operation Endpoint Required role Read <code>GET /toy*</code> <code>toystore-reader</code> Create <code>POST /admin/toy</code> <code>toystore-write</code> Delete <code>DELETE /admin/toy</code> <code>toystore-write</code> <p>Each user will be entitled to a maximum of 5rp10s (5 requests every 10 seconds).</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#setup-the-environment","title":"Setup the environment","text":"<p>Follow this setup doc to set up your environment before continuing with this doc.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#deploy-the-toystore-example-api","title":"Deploy the Toystore example API:","text":"<pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#api-lifecycle","title":"API lifecycle","text":""},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-unprotected","title":"Try the API unprotected","text":"<p>Export the gateway hostname and port:</p> <pre><code>export INGRESS_HOST=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.status.addresses[0].value}')\nexport INGRESS_PORT=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>It should return <code>200 OK</code>.</p> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n gateway-system service/kuadrant-ingressgateway-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#deploy-keycloak","title":"Deploy Keycloak","text":"<p>Create the namesapce:</p> <pre><code>kubectl create namespace keycloak\n</code></pre> <p>Deploy Keycloak with a bootstrap realm, users, and clients:</p> <pre><code>kubectl apply -n keycloak -f https://raw.githubusercontent.com/Kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Note: The Keycloak server may take a couple of minutes to be ready.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#enforce-authentication-and-authorization-for-the-toy-store-api","title":"Enforce authentication and authorization for the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure authentication and authorization:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-protection\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"keycloak-users\":\n        jwt:\n          issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      \"k8s-service-accounts\":\n        kubernetesTokenReview:\n          audiences:\n\n          - https://kubernetes.default.svc.cluster.local\n        overrides:\n          \"sub\":\n            selector: auth.identity.user.username\n    authorization:\n      \"k8s-rbac\":\n        kubernetesSubjectAccessReview:\n          user:\n            selector: auth.identity.sub\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.sub\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-missing-authentication","title":"Try the API missing authentication","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak-users\"\n# www-authenticate: Bearer realm=\"k8s-service-accounts\"\n# x-ext-auth-reason: {\"k8s-service-accounts\":\"credential not found\",\"keycloak-users\":\"credential not found\"}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-without-permission","title":"Try the API without permission","text":"<p>Obtain an access token with the Keycloak server:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>Send a request to the API as the Keycloak-authenticated user while still missing permissions:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>Create a Kubernetes Service Account to represent a consumer of the API associated with the alternative source of identities <code>k8s-service-accounts</code>:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: client-app-1\nEOF\n</code></pre> <p>Obtain an access token for the <code>client-app-1</code> service account:</p> <pre><code>SA_TOKEN=$(kubectl create token client-app-1)\n</code></pre> <p>Send a request to the API as the service account while still missing permissions:</p> <pre><code>curl -H \"Authorization: Bearer $SA_TOKEN\" -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#grant-access-to-the-toy-store-api-for-user-and-service-account","title":"Grant access to the Toy Store API for user and service account","text":"<p>Create the <code>toystore-reader</code> and <code>toystore-writer</code> roles:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: toystore-reader\nrules:\n\n- nonResourceURLs: [\"/toy*\"]\n  verbs: [\"get\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: toystore-writer\nrules:\n- nonResourceURLs: [\"/admin/toy\"]\n  verbs: [\"post\", \"delete\"]\nEOF\n</code></pre> <p>Add permissions to the user and service account:</p> User Kind Roles john User registered in Keycloak <code>toystore-reader</code>, <code>toystore-writer</code> client-app-1 Kuberentes Service Account <code>toystore-reader</code> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: toystore-readers\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: toystore-reader\nsubjects:\n\n- kind: User\n  name: $(jq -R -r 'split(\".\") | .[1] | @base64d | fromjson | .sub' &lt;&lt;&lt; \"$ACCESS_TOKEN\")\n- kind: ServiceAccount\n  name: client-app-1\n  namespace: default\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: toystore-writers\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: toystore-writer\nsubjects:\n- kind: User\n  name: $(jq -R -r 'split(\".\") | .[1] | @base64d | fromjson | .sub' &lt;&lt;&lt; \"$ACCESS_TOKEN\")\nEOF\n</code></pre> Q: Can I use <code>Roles</code> and <code>RoleBindings</code> instead of <code>ClusterRoles</code> and <code>ClusterRoleBindings</code>? <p>Yes, you can.</p> <p>The example above is for non-resource URL Kubernetes roles. For using <code>Roles</code> and <code>RoleBindings</code> instead of <code>ClusterRoles</code> and <code>ClusterRoleBindings</code>, thus more flexible resource-based permissions to protect the API, see the spec for Kubernetes SubjectAccessReview authorization in the Authorino docs.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-with-permission","title":"Try the API with permission","text":"<p>Send requests to the API as the Keycloak-authenticated user:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: api.toystore.com' -X POST http://$GATEWAY_URL/admin/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Send requests to the API as the Kubernetes service account:</p> <pre><code>curl -H \"Authorization: Bearer $SA_TOKEN\" -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $SA_TOKEN\" -H 'Host: api.toystore.com' -X POST http://$GATEWAY_URL/admin/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#enforce-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"per-user\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      counters:\n      - expression: auth.identity.userid\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-rate-limited","title":"Try the API rate limited","text":"<p>Each user should be entitled to a maximum of 5 requests every 10 seconds.</p> <p>Note: If the tokens have expired, you may need to refresh them first.</p> <p>Send requests as the Keycloak-authenticated user:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Send requests as the Kubernetes service account:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Authorization: Bearer $SA_TOKEN\" -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/","title":"Gateway Rate Limiting for Cluster Operators","text":"<p>For more info on the different personas see Gateway API </p> <p>This user guide walks you through an example of how to configure rate limiting for all routes attached to a specific ingress gateway.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#setup-the-environment","title":"Setup the environment","text":"<p>Follow this setup doc to set up your environment before continuing with this doc.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#deploy-the-toystore-example-api","title":"Deploy the Toystore example API:","text":"<pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#create-the-ingress-gateways","title":"Create the ingress gateways","text":"<pre><code>kubectl -n gateway-system apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: external\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - name: external\n    port: 80\n    protocol: HTTP\n    hostname: '*.io'\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: internal\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: local\n    port: 80\n    protocol: HTTP\n    hostname: '*.local'\n    allowedRoutes:\n      namespaces:\n        from: All\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#enforce-rate-limiting-on-requests-incoming-through-the-external-gateway","title":"Enforce rate limiting on requests incoming through the <code>external</code> gateway","text":"<pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 (Gateway) \u2502      \u2502 (Gateway) \u2502\n    \u2502  external \u2502      \u2502  internal \u2502\n    \u2502           \u2502      \u2502           \u2502\n    \u2502   *.io    \u2502      \u2502  *.local  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u25b2\n          \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (RateLimitPolicy) \u2502\n\u2502       gw-rlp      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <pre><code>kubectl apply -n gateway-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external\n  limits:\n    \"global\":\n      rates:\n\n      - limit: 5\n        window: 10s\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#deploy-a-sample-api-to-test-rate-limiting-enforced-at-the-level-of-the-gateway","title":"Deploy a sample API to test rate limiting enforced at the level of the gateway","text":"<pre><code>                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502 (Gateway) \u2502      \u2502 (Gateway) \u2502\n\u2502 (RateLimitPolicy) \u2502      \u2502  external \u2502      \u2502  internal \u2502\n\u2502       gw-rlp      \u251c\u2500\u2500\u2500\u2500\u2500\u25ba\u2502           \u2502      \u2502           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502   *.io    \u2502      \u2502  *.local  \u2502\n                           \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502                  \u2502\n                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                           \u2502\n                                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                 \u2502   (HTTPRoute)    \u2502\n                                 \u2502     toystore     \u2502\n                                 \u2502                  \u2502\n                                 \u2502 *.toystore.io    \u2502\n                                 \u2502 *.toystore.local \u2502\n                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                          \u2502\n                                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                   \u2502   (Service)  \u2502\n                                   \u2502   toystore   \u2502\n                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#route-traffic-to-the-api-from-both-gateways","title":"Route traffic to the API from both gateways:","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: external\n    namespace: gateway-system\n  - name: internal\n    namespace: gateway-system\n  hostnames:\n  - \"*.toystore.io\"\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#verify-the-rate-limiting-works-by-sending-requests-in-a-loop","title":"Verify the rate limiting works by sending requests in a loop","text":"<p>Expose the gateways, respectively at the port numbers <code>9081</code> and <code>9082</code> of the local host:</p> <pre><code>kubectl port-forward -n gateway-system service/external-istio 9081:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nkubectl port-forward -n gateway-system service/internal-istio 9082:80 &gt;/dev/null 2&gt;&amp;1 &amp;\n</code></pre> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds through the <code>external</code> ingress gateway (<code>*.io</code>), then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.io' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) through the <code>internal</code> ingress gateway (<code>*.local</code>):</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.local' http://localhost:9082 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/","title":"Gateway Rate Limiting","text":"<p>This user guide walks you through an example of how to configure multiple rate limit polices for different listeners in an ingress gateway.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#setup-the-environment","title":"Setup the environment","text":"<p>Follow this setup doc to set up your environment before continuing with this doc.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#deploy-the-sample-api","title":"Deploy the sample API:","text":"<pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-the-ingress-gateways","title":"Create the ingress gateways","text":"<pre><code>kubectl -n kuadrant-system apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: environment\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - name: external\n    port: 80\n    protocol: HTTP\n    hostname: '*.io'\n    allowedRoutes:\n      namespaces:\n        from: All\n  - name: local\n    port: 80\n    protocol: HTTP\n    hostname: '*.local'\n    allowedRoutes:\n      namespaces:\n        from: All\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#route-traffic-to-the-api-from-both-gateways-listeners","title":"Route traffic to the API from both gateways listeners","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: environment\n    namespace: kuadrant-system\n  hostnames:\n  - \"*.toystore.io\"\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-a-kuadrant-ratelimitpolicy-to-configure-rate-limiting-for-the-external-listener","title":"Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting for the external listener:","text":"<pre><code>kubectl apply -n kuadrant-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp-external\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: environment\n    sectionName: external\n  defaults:\n    strategy: merge  \n    limits:\n      \"external\":\n        rates:\n\n        - limit: 2\n          window: 10s\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-a-kuadrant-ratelimitpolicy-to-configure-rate-limiting-for-the-local-listener","title":"Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting for the local listener:","text":"<pre><code>kubectl apply -n kuadrant-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp-local\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: environment\n    sectionName: local\n  defaults:\n    strategy: merge    \n    limits:\n      \"local\":\n        rates:\n\n        - limit: 5\n          window: 10s\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#verify-the-rate-limiting-works-by-sending-requests-in-a-loop","title":"Verify the rate limiting works by sending requests in a loop","text":"<p>Expose the gateways, respectively at the port numbers <code>9081</code> and <code>9082</code> of the local host:</p> <pre><code>kubectl port-forward -n gateway-system service/environment-istio 9081:80 &gt;/dev/null 2&gt;&amp;1 &amp;\n</code></pre> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds through the <code>external</code> ingress gateway (<code>*.io</code>), then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.io' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) through the <code>internal</code> ingress gateway (<code>*.local</code>):</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.local' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/","title":"Multi authenticated Rate Limiting for an Application","text":"<p>This user guide walks you through an example of how to configure multiple authenticated rate limiting for an application using Kuadrant.</p> <p>Authenticated rate limiting, rate limits the traffic directed to an application based on attributes of the client user, who is authenticated by some authentication method. A few examples of authenticated rate limiting use cases are:</p> <ul> <li>User A can send up to 50rps (\"requests per second\"), while User B can send up to 100rps.</li> <li>Each user can send up to 20rpm (\"request per minute\").</li> <li>Admin users (members of the 'admin' group) can send up to 100rps, while regular users (non-admins) can send up to 20rpm and no more than 5rps.</li> </ul> <p>In this guide, we will rate limit a sample REST API called Toy Store, an echo service that echoes back to the user whatever attributes it gets in the request. The API exposes an endpoint at <code>GET http://api.toystore.com/toy</code>, to mimic an operation of reading toy records.</p> <p>We will define 2 users of the API, which can send requests to the API at different rates, based on their user IDs. The authentication method used is API key.</p> User ID Rate limit alice 5rp10s (\"5 requests every 10 seconds\") bob 2rp10s (\"2 requests every 10 seconds\")"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#setup-the-environment","title":"Setup the environment","text":"<p>Follow this setup doc to set up your environment before continuing with this doc.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#create-a-httproute-to-route-traffic-to-the-service-via-istio-ingress-gateway","title":"Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: kuadrant-ingressgateway\n    namespace: gateway-system\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    - path:\n        type: Exact\n        value: \"/car\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80     \nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#export-the-gateway-hostname-and-port","title":"Export the gateway hostname and port:","text":"<pre><code>export INGRESS_HOST=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.status.addresses[0].value}')\nexport INGRESS_PORT=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#verify-the-route-works","title":"Verify the route works:","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n gateway-system service/kuadrant-ingressgateway-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#enforce-authentication-on-requests-to-the-toy-store-api","title":"Enforce authentication on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure the authentication:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: AuthPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#verify-the-authentication-works-by-sending-a-request-to-the-toy-store-api-without-api-key","title":"Verify the authentication works by sending a request to the Toy Store API without API key:","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-users\"\n# x-ext-auth-reason: \"credential not found\"\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#create-api-keys-for-users-alice-and-bob-to-authenticate","title":"Create API keys for users <code>alice</code> and <code>bob</code> to authenticate:","text":"<p>Note: Kuadrant stores API keys as Kubernetes Secret resources. User metadata can be stored in the annotations of the resource.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#enforce-authenticated-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce authenticated rate limiting on requests to the Toy Store API","text":"<p>Create  Kuadrant <code>RateLimitPolicy's</code> to configure rate limiting for Bob and Alice:</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#bob","title":"Bob","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-1\n  defaults:\n    strategy: merge\n    limits:\n      \"bob-limit\":\n        rates:\n\n        - limit: 2\n          window: 10s\n        when:\n        - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#alice","title":"Alice","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-alice\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-1\n  defaults:\n    strategy: merge\n    limits:\n      \"alice-limit\":\n        rates:\n\n        - limit: 5\n          window: 10s\n        when:\n        - predicate: \"auth.identity.userid == 'alice'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests as Alice and Bob.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds allowed for Alice, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Up to 2 successful (<code>200 OK</code>) requests every 10 seconds allowed for Bob, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' -H 'Host: api.toystore.com' http://$GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/","title":"Simple Rate Limiting for Application developers","text":"<p>For more info on the different personas see Gateway API </p> <p>This user guide walks you through an example of how to configure rate limiting for an endpoint of an application using Kuadrant.</p> <p>In this guide, we will rate limit a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request. The API listens to requests at the hostname <code>api.toystore.com</code>, where it exposes the endpoints <code>GET /toys*</code> and <code>POST /toys</code>, respectively, to mimic operations of reading and writing toy records.</p> <p>We will rate limit the <code>POST /toys</code> endpoint to a maximum of 5rp10s (\"5 requests every 10 seconds\").</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#setup-the-environment","title":"Setup the environment","text":"<p>Follow this setup doc to set up your environment before continuing with this doc.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<p>Create the deployment:</p> <pre><code>kubectl apply -f examples/toystore/toystore.yaml\n</code></pre> <p>Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: kuadrant-ingressgateway\n    namespace: gateway-system\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/toys\"\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches: # it has to be a separate HTTPRouteRule so we do not rate limit other endpoints\n    - method: POST\n      path:\n        type: Exact\n        value: \"/toys\"\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Export the gateway hostname and port:</p> <pre><code>export INGRESS_HOST=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.status.addresses[0].value}')\nexport INGRESS_PORT=$(kubectl get gtw kuadrant-ingressgateway -n gateway-system -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport GATEWAY_URL=$INGRESS_HOST:$INGRESS_PORT\n</code></pre> <p>Verify the route works:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toys -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n gateway-system service/kuadrant-ingressgateway-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$GATEWAY_URL/toys -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#enforce-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-2\n  limits:\n    \"create-toy\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      when:\n      - predicate: \"request.method == 'POST'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests in a loop.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds to <code>POST /toys</code>, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.com' http://$GATEWAY_URL/toys -X POST | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) to <code>GET /toys</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.com' http://$GATEWAY_URL/toys | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/","title":"Gateway TLS for Cluster Operators","text":"<p>This user guide walks you through an example of how to configure TLS for all routes attached to an ingress gateway.</p>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#requisites","title":"Requisites","text":"<ul> <li>Docker</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#setup","title":"Setup","text":"<p>This step uses tooling from the Kuadrant Operator component to create a containerized Kubernetes server locally using Kind, where it installs Istio, Kubernetes Gateway API, CertManager and Kuadrant itself.</p> <p>Clone the project:</p> <pre><code>git clone https://github.com/Kuadrant/kuadrant-operator &amp;&amp; cd kuadrant-operator\n</code></pre> <p>Setup the environment:</p> <pre><code>make local-setup\n</code></pre> <p>Create a namespace:</p> <pre><code>kubectl create namespace my-gateways\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#create-an-ingress-gateway","title":"Create an ingress gateway","text":"<p>Create a gateway:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: prod-web\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: \"*.toystore.local\"\n      port: 443\n      protocol: HTTPS\n      tls:\n        mode: Terminate\n        certificateRefs:\n          - name: toystore-local-tls\n            kind: Secret\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#enable-tls-on-the-gateway","title":"Enable TLS on the gateway","text":"<p>The TLSPolicy requires a reference to an existing CertManager Issuer.</p> <p>Create a CertManager Issuer:</p> <pre><code>kubectl apply -n my-gateways -f - &lt;&lt;EOF\napiVersion: cert-manager.io/v1\nkind: Issuer\nmetadata:\n  name: selfsigned-issuer\nspec:\n  selfSigned: {}\nEOF\n</code></pre> <p>Note: We are using a self-signed issuer here but any supported CerManager issuer or cluster issuer can be used.</p> <pre><code>kubectl get issuer selfsigned-issuer -n my-gateways\n</code></pre> <p>Response:</p> <pre><code>NAME                        READY   AGE\nselfsigned-issuer   True    18s\n</code></pre> <p>Create a Kuadrant <code>TLSPolicy</code> to configure TLS:</p> <pre><code>kubectl apply -n my-gateways -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: prod-web\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  issuerRef:\n    group: cert-manager.io\n    kind: Issuer\n    name: selfsigned-issuer\nEOF\n</code></pre> <p>Check policy status:</p> <pre><code>kubectl get tlspolicy -o wide -n my-gateways\n</code></pre> <p>Response:</p> <pre><code>NAME       STATUS     TARGETREFKIND   TARGETREFNAME   AGE\nprod-web   Accepted   Gateway         prod-web        13s\n</code></pre> <p>Check a Certificate resource was created:</p> <pre><code>kubectl get certificates -n my-gateways\n</code></pre> <p>Response</p> <pre><code>NAME                 READY   SECRET               AGE\ntoystore-local-tls   True    toystore-local-tls   7m30s\n</code></pre> <p>Check a TLS Secret resource was created:</p> <pre><code>kubectl get secrets -n my-gateways --field-selector=\"type=kubernetes.io/tls\"\n</code></pre> <p>Response:</p> <pre><code>NAME                 TYPE                DATA   AGE\ntoystore-local-tls   kubernetes.io/tls   3      7m42s\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#deploy-a-sample-api-to-test-tls","title":"Deploy a sample API to test TLS","text":"<p>Deploy the sample API:</p> <pre><code>kubectl -n my-gateways apply -f examples/toystore/toystore.yaml\nkubectl -n my-gateways wait --for=condition=Available deployments toystore --timeout=60s\n</code></pre> <p>Route traffic to the API from our gateway:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: prod-web\n    namespace: my-gateways\n  hostnames:\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#verify-tls-works-by-sending-requests","title":"Verify TLS works by sending requests","text":"<p>Get the gateway address@</p> <pre><code>GWADDRESS=`kubectl get gateway/prod-web -n my-gateways -o=jsonpath='{.status.addresses[?(@.type==\"IPAddress\")].value}'`\necho $GWADDRESS\n</code></pre> <p>Response:</p> <pre><code>172.18.200.1\n</code></pre> <p>Verify we can access the service via TLS:</p> <pre><code>curl -vkI https://api.toystore.local --resolve \"api.toystore.local:443:$GWADDRESS\"\n</code></pre> <p>Response:</p> <pre><code>* Added api.toystore.local:443:172.18.200.1 to DNS cache\n* Hostname api.toystore.local was found in DNS cache\n*   Trying 172.18.200.1:443...\n* Connected to api.toystore.local (172.18.200.1) port 443 (#0)\n* ALPN: offers h2\n* ALPN: offers http/1.1\n* TLSv1.0 (OUT), TLS header, Certificate Status (22):\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\n* TLSv1.2 (IN), TLS header, Certificate Status (22):\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS header, Finished (20):\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):\n* TLSv1.3 (IN), TLS handshake, Certificate (11):\n* TLSv1.3 (IN), TLS handshake, CERT verify (15):\n* TLSv1.3 (IN), TLS handshake, Finished (20):\n* TLSv1.2 (OUT), TLS header, Finished (20):\n* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.3 (OUT), TLS handshake, Finished (20):\n* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384\n* ALPN: server accepted h2\n* Server certificate:\n*  subject: [NONE]\n*  start date: Feb 15 11:46:50 2024 GMT\n*  expire date: May 15 11:46:50 2024 GMT\n* Using HTTP2, server supports multiplexing\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* h2h3 [:method: HEAD]\n* h2h3 [:path: /]\n* h2h3 [:scheme: https]\n* h2h3 [:authority: api.toystore.local]\n* h2h3 [user-agent: curl/7.85.0]\n* h2h3 [accept: */*]\n* Using Stream ID: 1 (easy handle 0x5623e4fe5bf0)\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n&gt; HEAD / HTTP/2\n&gt; Host: api.toystore.local\n&gt; user-agent: curl/7.85.0\n&gt; accept: */*\n&gt;\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\n* old SSL session ID is stale, removing\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* Connection state changed (MAX_CONCURRENT_STREAMS == 2147483647)!\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n&lt; HTTP/2 200\nHTTP/2 200\n&lt; content-type: application/json\ncontent-type: application/json\n&lt; server: istio-envoy\nserver: istio-envoy\n&lt; date: Thu, 15 Feb 2024 12:13:27 GMT\ndate: Thu, 15 Feb 2024 12:13:27 GMT\n&lt; content-length: 1658\ncontent-length: 1658\n&lt; x-envoy-upstream-service-time: 1\nx-envoy-upstream-service-time: 1\n\n&lt;\n\n* Connection #0 to host api.toystore.local left intact\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#cleanup","title":"Cleanup","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"kuadrant-operator/examples/alerts/","title":"Index","text":""},{"location":"kuadrant-operator/examples/alerts/#slo-multi-burn-rate-multi-window-alerts","title":"SLO Multi burn rate multi window alerts","text":"<p>Kuadrant have created two example SLO alerts to help give ideas on the types of SLO alerts that could be used with the operator. We have created one alert for latency and one for availability, both are Multiwindow, Multi-Burn-Rate Alerts. The alerts show a scenario where a 28d rolling window is used and a uptime of 99.95% i.e only 0.05% error budget margin is desired. This in real world time would be downtime of around: </p> Time Frame Duration Daily: 43s Weekly: 5m 2.4s Monthly: 21m 44s Quarterly: 1h 5m 12s Yearly: 4h 20m 49s <p>These values can be changed to suit different scenarios</p>"},{"location":"kuadrant-operator/examples/alerts/#sloth","title":"Sloth","text":"<p>Sloth is a tool to aid in the creation of multi burn rate and multi window SLO alerts and was used to create both the availability and latency alerts. It follows the common standard set out by Google's SRE book. Sloth generates alerts based on specific specs given. The specs for our example alerts can be found in the example/sloth folder.</p>"},{"location":"kuadrant-operator/examples/alerts/#metrics-used-for-the-alerts","title":"Metrics used for the alerts","text":""},{"location":"kuadrant-operator/examples/alerts/#availability","title":"Availability","text":"<p>For the availability SLO alerts the Istio metric <code>istio_requests_total</code> was used as its a counter type metric meaning the values can only increase as well as it gives information on all requests handled by the Istio proxy.</p>"},{"location":"kuadrant-operator/examples/alerts/#latency","title":"Latency","text":"<p>For the availability SLO alerts the Istio metric <code>istio_request_duration_milliseconds</code> was used as its a Histogram.</p>"},{"location":"kuadrant-operator/examples/alerts/#sloth-generation","title":"Sloth generation","text":"<p>You can modify the examples Sloth specs we have and regenerate the prometheus rules using the Sloth CLI and the generate command. For more information please the Sloth website</p> <p><pre><code>sloth generate -i examples/alerts/sloth/latency.yaml --default-slo-period=28d\n</code></pre> You can also use the make target to generate the rules to.</p> <pre><code>make sloth-generate\n</code></pre>"},{"location":"kuadrant-operator/examples/alerts/#prometheus-unit-tests","title":"Prometheus unit tests","text":"<p>There are also two matching unit tests to verify and test the alerts that Sloth has generated. These can be run using the make target:</p> <pre><code>make test-alerts\n</code></pre> <p>Note: The prometheus unit tests will also run via Github actions when a change is made in the alerts file.</p>"},{"location":"authorino/","title":"Authorino","text":"<p>Kubernetes-native authorization service for tailor-made Zero Trust API security.</p> <p>A lightweight Envoy external authorization server fully manageable via Kubernetes Custom Resources. JWT authentication, API key, mTLS, pattern-matching authz, OPA, K8s SA tokens, K8s RBAC, external metadata fetching, and more, with minimum to no coding at all, no rebuilding of your applications.</p> <p>Authorino is not about inventing anything new. It's about making the best things about auth out there easy and simple to use. Authorino is multi-tenant, it's cloud-native and it's open source.</p> <p> </p>"},{"location":"authorino/#getting-started","title":"Getting started","text":"<ol> <li>Deploy with the Authorino Operator</li> <li>Setup Envoy proxy and the external authorization filter</li> <li>Apply an Authorino <code>AuthConfig</code> custom resource</li> <li>Obtain an authentication token and start sending requests</li> </ol> <p>The full Getting started page of the docs provides details for the steps above, as well as information about requirements and next steps.</p> <p>Or try out our Hello World example.</p> <p>For general information about protecting your service using Authorino, check out the docs.</p>"},{"location":"authorino/#use-cases","title":"Use-cases","text":"<p>The User guides section of the docs gathers several AuthN/AuthZ use-cases as well as the instructions to implement them using Authorino. A few examples are:</p> <ul> <li>Authentication with JWTs and OpenID Connect Discovery</li> <li>Authentication with API keys</li> <li>Authentication with Kubernetes SA tokens (TokenReview API)</li> <li>Authentication with X.509 certificates and mTLS</li> <li>Authorization with JSON pattern-matching rules (e.g. JWT claims, request attributes, etc)</li> <li>Authorization with Open Policy Agent (OPA) Rego policies</li> <li>Authorization using the Kubernetes RBAC (rules stated in K8s <code>Role</code> and <code>RoleBinding</code> resources)</li> <li>Authorization using auth metadata fetched from external sources</li> <li>OIDC authentication and RBAC with Keycloak JWTs</li> <li>Injecting auth data into the request (HTTP headers, Wristband tokens, rate-limit metadata, etc)</li> <li>Authorino for the Kubernetes control plane (aka Authorino as ValidatingWebhook service)</li> </ul>"},{"location":"authorino/#how-it-works","title":"How it works","text":"<p>Authorino enables hybrid API security, with usually no code changes required to your application, tailor-made for your own combination of authentication standards and protocols and authorization policies of choice.</p> <p>Authorino implements Envoy Proxy's external authorization gRPC protocol, and is a part of Red Hat Kuadrant architecture.</p> <p>Under the hood, Authorino is based on Kubernetes Custom Resource Definitions and the Operator pattern.</p> <p>Bootstrap and configuration:</p> <ol> <li>Deploy the service/API to be protected (\"Upstream\"), Authorino and Envoy</li> <li>Write and apply an Authorino <code>AuthConfig</code> Custom Resource associated to the public host of the service</li> </ol> <p>Request-time:</p> <p> </p> <ol> <li>A user or service account (\"Consumer\") obtains an access token to consume resources of the Upstream service, and sends a request to the Envoy ingress endpoint</li> <li>The Envoy proxy establishes fast gRPC connection with Authorino carrying data of the HTTP request (context info), which causes Authorino to lookup for an <code>AuthConfig</code> Custom Resource to enforce (pre-cached)</li> <li>Identity verification (authentication) phase - Authorino verifies the identity of the consumer, where at least one authentication method/identity provider must go through</li> <li>External metadata phase - Authorino fetches additional metadata for the authorization from external sources (optional)</li> <li>Policy enforcement (authorization) phase - Authorino takes as input a JSON composed out of context data, resolved identity object and fetched additional metadata from previous phases, and triggers the evaluation of user-defined authorization policies</li> <li>Response (metadata-out) phase \u2013 Authorino builds user-defined custom responses (dynamic JSON objects and/or Festival Wristband OIDC tokens), to be supplied back to the client and/or upstream service within added HTTP headers or as Envoy Dynamic Metadata (optional)</li> <li>Callbacks phase \u2013 Authorino sends callbacks to specified HTTP endpoints (optional)</li> <li>Authorino and Envoy settle the authorization protocol with either OK/NOK response</li> <li>If authorized, Envoy triggers other HTTP filters in the chain (if any), pre-injecting eventual dynamic metadata returned by Authorino, and ultimately redirects the request to the Upstream</li> <li>The Upstream serves the requested resource to the consumer</li> </ol> More <p>The Architecture section of the docs covers details of protecting your APIs with Envoy and Authorino, including information about topology (centralized gateway, centralized authorization service or sidecars), deployment modes (cluster-wide reconciliation vs. namespaced instances), an specification of Authorino's <code>AuthConfig</code> Custom Resource Definition (CRD) and more.</p> <p>You will also find in that section information about what happens in request-time (aka Authorino's Auth Pipeline) and how to leverage the Authorization JSON for writing policies, dynamic responses and other features of Authorino.</p>"},{"location":"authorino/#list-of-features","title":"List of features","text":"Feature Stage Identity verification &amp; authentication JOSE/JWT validation (OpenID Connect) Ready OAuth 2.0 Token Introspection (opaque tokens) Ready Kubernetes TokenReview (SA tokens) Ready OpenShift User-echo endpoint In analysis API key authentication Ready mTLS authentication Ready HMAC authentication Planned (#9) Plain (resolved beforehand and injected in the payload) Ready Anonymous access Ready Ad hoc external metadata fetching OpenID Connect User Info Ready UMA-protected resource attributes Ready HTTP GET/GET-by-POST Ready Policy enforcement/authorization JSON pattern matching (e.g. JWT claims, request attributes checking) Ready OPA/Rego policies (inline and pull from registry) Ready Kubernetes SubjectAccessReview (resource and non-resource attributes) Ready Authzed/SpiceDB Ready Keycloak Authorization Services (UMA-compliant Authorization API) In analysis Custom responses Festival Wristbands tokens (token normalization, Edge Authentication Architecture) Ready JSON injection (header injection, Envoy Dynamic Metadata) Ready Plain text value (header injection) Ready Custom response status code/messages (e.g. redirect) Ready Callbacks HTTP endpoints Ready Caching OpenID Connect and User-Managed Access configs Ready JSON Web Keys (JWKs) and JSON Web Key Sets (JWKS) Ready Access tokens Ready External metadata Ready Precompiled Rego policies Ready Policy evaluation Ready Sharding (lookup performance, multitenancy) Ready <p>For a detailed description of the features above, refer to the Features page.</p>"},{"location":"authorino/#faq","title":"FAQ","text":"Do I need to deploy Envoy? <p>Authorino is built from the ground up to work well with Envoy. It is strongly recommended that you leverage Envoy along side Authorino. That said, it is possible to use Authorino without Envoy.</p> <p>Authorino implements Envoy's external authorization gRPC protocol and therefore will accept any client request that complies.</p> <p>Authorino also provides a second interface for raw HTTP authorization, suitable for using with Kubernetes ValidatingWebhook and other integrations (e.g. other proxies).</p> <p>The only attribute of the authorization request that is strictly required is the host name. (See Host lookup for more information.) The other attributes, such as method, path, headers, etc, might as well be required, depending on each <code>AuthConfig</code>. In the case of the gRPC <code>CheckRequest</code> method, the host is supplied in <code>Attributes.Request.Http.Host</code> and alternatively in <code>Attributes.ContextExtensions[\"host\"]</code>. For raw HTTP authorization requests, the host must be supplied in <code>Host</code> HTTP header.</p> <p>Check out Kuadrant for easy-to-use Envoy and Authorino deployment &amp; configuration for API management use-cases, using Kubernetes Custom Resources.</p> Is Authorino an Identity Provider (IdP)? <p>No, Authorino is not an Identity Provider (IdP). Neither it is an auth server of any kind, such as an OAuth2 server, an OpenID Connect (OIDC) server, a Single Sign On (SSO) server.</p> <p>Authorino is not an identity broker either. It can verify access tokens from multiple trusted sources of identity and protocols, but it will not negotiate authentication flows for non-authenticated access requests. Some tricks nonetheless can be done, for example, to redirect unauthenticated users to a login page.</p> <p>For an excellent auth server that checks all the boxes above, check out Keycloak.</p> How does Authorino compare to Keycloak? <p>Keycloak is a proper auth server and identity provider (IdP). It offers a huge set of features for managing identities, identity sources with multiple user federation options, and a platform for authentication and authorization services.</p> <p>Keycloak exposes authenticators that implement protocols such as OpenID Connect. The is a one-time flow that establishes the delegation of power to a client, for a short period of time. To be consistent with Zero Trust security, you want a validator to verify the short-lived tokens in every request that tries to reach your protected service/resource. This step that will repeat everytime could save heavy looking up into big tables of tokens and leverage cached authorization policies for fast in-memory evaluation. This is where Authorino comes in.</p> <p>Authorino verifies and validates Keycloak-issued ID tokens. OpenID Connect Discovery is used to request and cache JSON Web Key Sets (JWKS), used to verify the signature of the tokens without having to contact again with the Keycloak server, or looking in a table of credentials. Moreover, user long-lived credentials are safe, rather than spread in hops across the network.</p> <p>You can also use Keycloak for storing auth-relevant resource metadata. These can be fetched by Authorino in request-time, to be combined into your authorization policies. See Keycloak Authorization Services and User-Managed Access (UMA) support, as well as Authorino UMA external metadata counter-part.</p> Why doesn't Authorino handle OAuth flows? <p>It has to do with trust. OAuth grants are supposed to be negotiated directly between whoever owns the long-lived credentials in one hand (user, service accounts), and the trustworthy auth server that receives those credentials \u2013 ideally with minimum number of hops in the middle \u2013 and exchanges them for short-lived access tokens, on the other end.</p> <p>There are use-cases for Authorino running in the edge (e.g. Edge Authentication Architecture and token normalization), but in most cases Authorino should be seen as a last-mile component that provides decoupled identity verification and authorization policy enforcement to protected services in request-time. In this sense, the OAuth grant is a pre-flight exchange that happens once and as direct and safe as possible, whereas auth enforcement is kept lightweight and efficient.</p> Where does Authorino store users and roles? <p>Authorino does not store users, roles, role bindings, access control lists, or any raw authorization data. Authorino handles policies, where even these policies can be stored elsewhere (as opposed to stated inline inside of an Authorino <code>AuthConfig</code> CR).</p> <p>Authorino evaluates policies for stateless authorization requests. Any additional context is either resolved from the provided payload or static definitions inside the policies. That includes extracting user information from a JWT or client TLS certificate, requesting user metadata from opaque authentication tokens (e.g. API keys) to the trusted sources actually storing that content, obtaining synchronous HTTP metadata from services, etc.</p> <p>In the case of authentication with API keys, as well as its derivative to model HTTP Basic Auth, user data are stored in Kubernetes <code>Secret</code>s. The secret's keys, annotations and labels are usually the structures used to organize the data that later a policy evaluated in Authorino may require. Strictly, those are not Authorino data structures.</p> Can't I just use Envoy JWT Authentication and RBAC filters? <p>Envoy's JWT Authentication works pretty much similar to Authorino's JOSE/JWT verification and validation for OpenID Connect. In both cases, the JSON Web Key Sets (JWKS) to verify the JWTs are auto-loaded and cached to be used in request-time. Moreover, you can configure for details such as where to extract the JWT from the HTTP request (header, param or cookie) and do some cool tricks regarding how dynamic metadata based on JWT claims can be injected to consecutive filters in the chain.</p> <p>However, in terms of authorization, while Envoy's implementation essentially allows to check for the list of audiences (<code>aud</code> JWT claim), Authorino opens up for a lot more options such as pattern-matching rules with operators and conditionals, built-in OPA and other methods of evaluating authorization policies.</p> <p>Authorino also allows to combine JWT authentication with other types of authentication to support different sources of identity and groups of users such as API keys, Kubernetes tokens, OAuth opaque tokens , etc.</p> <p>In summary, Envoy's JWT Authentication and Envoy RBAC filter are excellent solutions for simple use-cases where JWTs from one single issuer is the only authentication method you are planning to support and limited to no authorization rules suffice. On the other hand, if you need to integrate more identity sources, different types of authentication, authorization policies, etc, you might to consider Authorino.</p> Should I use Authorino if I already have Istio configured? <p>Istio is a great solution for managing service meshes. It delivers an excellent platform with an interesting layer of abstraction on top of Envoy proxy's virtual omnipresence within the mesh.</p> <p>There are lots of similarities, but also complementarity between Authorino and Istio and Istio Authorization in special.</p> <p>Istio provides a simple way to enable features that are, in many cases, features of Envoy, such as authorization based on JWTs, authorization based on attributes of the request, and activation of external authorization services, without having to deal with complex Envoy config files. See Kuadrant for a similar approach, nonetheless leveraging features of Istio as well.</p> <p>Authorino is an Envoy-compatible external authorization service. One can use Authorino with or without Istio.</p> <p>In particular, Istio Authorization Policies can be seen, in terms of functionality and expressiveness, as a subset of one type of authorization policies supported by Authorino, the pattern-matching authorization policies. While Istio, however, is heavily focused on specific use cases of API Management, offering a relatively limited list of supported attribute conditions, Authorino is more generic, allowing to express authorization rules for a wider spectrum of use cases \u2013 ACLs, RBAC, ABAC, etc, pretty much counting on any attribute of the Envoy payload, identity object and external metadata available.</p> <p>Authorino also provides built-in OPA authorization, several other methods of authentication and identity verification (e.g. Kubernetes token validation, API key-based authentication, OAuth token introspection, OIDC-discoverable JWT verification, etc), and features like fetching of external metadata (HTTP services, OIDC userinfo, UMA resource data), token normalization, wristband tokens and dynamic responses. These all can be used independently or combined, in a simple and straightforward Kubernetes-native fashion.</p> <p>In summary, one might value Authorino when looking for a policy enforcer that offers:</p> <ol> <li>multiple supported methods and protocols for rather hybrid authentication, encompassing future and legacy auth needs;</li> <li>broader expressiveness and more functionalities for the authorization rules;</li> <li>authentication and authorization in one single declarative manifest;</li> <li>capability to fetch auth metadata from external sources on-the-fly;</li> <li>built-in OPA module;</li> <li>easy token normalization and/or aiming for Edge Authentication Architecture (EAA).</li> </ol> <p>The good news is that, if you have Istio configured, then you have Envoy and the whole platform for wiring Authorino up if you want to. \ud83d\ude09</p> Do I have to learn OPA/Rego language to use Authorino? <p>No, you do not. However, if you are comfortable with Rego from Open Policy Agent (OPA), there are some quite interesting things you can do in Authorino, just as you would in any OPA server or OPA plugin, but leveraging Authorino's built-in OPA module instead. Authorino's OPA module is compiled as part of Authorino's code directly from the Golang packages, and imposes no extra latency to the evaluation of your authorization policies. Even the policies themselves are pre-compiled in reconciliation-time, for fast evaluation afterwards, in request-time.</p> <p>On the other hand, if you do not want to learn Rego or in any case would like to combine it with declarative and Kubernetes-native authN/authZ spec for your services, Authorino does complement OPA with at least two other methods for expressing authorization policies \u2013 i.e. pattern-matching authorization and Kubernetes SubjectAccessReview, the latter allowing to rely completely on the Kubernetes RBAC.</p> <p>You break down, mix and combine these methods and technolgies in as many authorization policies as you want, potentially applying them according to specific conditions. Authorino will trigger the evaluation of concurrent policies in parallel, aborting the context if any of the processes denies access.</p> <p>Authorino also packages well-established industry standards and protocols for identity verification (JOSE/JWT validation, OAuth token introspection, Kubernetes TokenReview) and ad-hoc request-time metadata fetching (OIDC userinfo, User-Managed Access (UMA)), and corresponding layers of caching, without which such functionalities would have to be implemented by code.</p> Can I use Authorino to protect non-REST APIs? <p>Yes, you can. In principle, the API format (REST, gRPC, GraphQL, etc) should not matter for the authN/authZ enforcer. There are a couple points to consider though.</p> <p>While REST APIs are designed in a way that, in most cases, information usually needed for the evaluation of authorization policies are available in the metadata of the HTTP request (method, path, headers), other API formats quite often will require processing of the HTTP body. By default, Envoy's external authorization HTTP filter will not forward the body of the request to Authorino; to change that, enable the <code>with_request_body</code> option in the Envoy configuration for the external authorization filter. E.g.:</p> <pre><code>with_request_body:\n  max_request_bytes: 1024\n  allow_partial_message: true\n  pack_as_bytes: true\n</code></pre> <p>Additionally, when enabling the request body passed in the payload to Authorino, parsing of the content should be of concern as well. Authorino provides easy access to attributes of the HTTP request, parsed as part of the Authorization JSON, however the body of the request is passed as string and should be parsed by the user according to each case.</p> <p>Check out Authorino OPA authorization and the Rego Encoding functions for options to parse serialized JSON, YAML and URL-encoded params. For XML transformation, an external parsing service connected via Authorino's HTTP GET/GET-by-POST external metadata might be required.</p> Can I run Authorino other than on Kubernetes? <p>As of today, no, you cannot, or at least it wouldn't suit production requirements.</p> Do I have to be admin of the cluster to install Authorino? <p>To install the Authorino Custom Resource Definition (CRD) and to define cluster roles required by the Authorino service, admin privilege to the Kubernetes cluster is required. This step happens only once per cluster and is usually equivalent to installing the Authorino Operator.</p> <p>Thereafter, deploying instances of the Authorino service and applying <code>AuthConfig</code> custom resources to a namespace depend on the permissions set by the cluster administrator \u2013 either directly by editing the bindings in the cluster's RBAC, or via options of the operator. In most cases, developers will be granted permissions to create and manage <code>AuthConfig</code>s, and sometimes to deploy their own instances of Authorino.</p> Is it OK to store AuthN/AuthZ configs as Kubernetes objects? <p>Authorino's API checks all the bullets to be aggregated to the Kubernetes cluster APIs, and therefore using Custom Resource Definition (CRD) and the Operator pattern has always been an easy design decision.</p> <p>By merging the definitions of service authN/authZ to the control plane, Authorino <code>AuthConfig</code> resources can be thought as extensions of the specs of the desired state of services regarding the data flow security. The Authorino custom controllers, built-in into the authorization service, are the agents that read from that desired state and reconcile the processes operating in the data plane.</p> <p>Authorino is declarative and seamless for developers and cluster administrators managing the state of security of the applications running in the server, used to tools such as <code>kubectl</code>, the Kubernetes UI and its dashboards. Instead of learning about yet another configuration API format, Authorino users can jump straight to applying and editing YAML or JSON structures they already know, in a way that things such as <code>spec</code>, <code>status</code>, <code>namespace</code> and <code>labels</code> have the meaning they are expected to have, and docs are as close as <code>kubectl explain</code>. Moreover, Authorino does not pile up any other redundant layers of APIs, event-processing, RBAC, transformation and validation webhooks, etc. It is Kubernetes in its best.</p> <p>In terms of scale, Authorino <code>AuthConfig</code>s should grow proportionally to the number of protected services, virtually limited by nothing but the Kubernetes API data storage, while namespace division and label selectors help adjust horizontally and keep distributed.</p> <p>In other words, there are lots of benefits of using Kubernetes custom resources and custom controllers, and unless you are planning on bursting your server with more services than it can keep record, it is totally \ud83d\udc4d to store your AuthN/AuthZ configs as cluster API objects.</p> Can I use Authorino for rate limiting? <p>You can, but you shouldn't. Check out instead Limitador, for simple and efficient global rate limiting. Combine it with Authorino and Authorino's support for Envoy Dynamic Metadata for authenticated rate limiting.</p>"},{"location":"authorino/#benchmarks","title":"Benchmarks","text":"<p>Configuration of the tests (Authorino features):</p> Performance test Identity Metadata Authorization Response <code>ReconcileAuthConfig</code> OIDC/JWT UserInfo, UMA OPA<sup>(inline Rego)</sup> - <code>AuthPipeline</code> OIDC/JWT - JSON pattern-matching<sup>(JWT claim check)</sup> - <code>APIKeyAuthn</code> API key N/A N/A N/A <code>JSONPatternMatchingAuthz</code> N/A N/A JSON pattern-matching N/A <code>OPAAuthz</code> N/A N/A OPA<sup>(inline Rego)</sup> N/A <p>Platform: linux/amd64 CPU: Intel\u00ae Xeon\u00ae Platinum 8370C 2.80GHz Cores: 1, 4, 10</p> <p>Results: <pre><code>ReconcileAuthConfig:\n\n        \u2502   sec/op    \u2502     B/op     \u2502  allocs/op  \u2502\n\n*         1.533m \u00b1 2%   264.4Ki \u00b1 0%   6.470k \u00b1 0%\n*-4       1.381m \u00b1 6%   264.5Ki \u00b1 0%   6.471k \u00b1 0%\n*-10      1.563m \u00b1 5%   270.2Ki \u00b1 0%   6.426k \u00b1 0%\ngeomean   1.491m        266.4Ki        6.456k\n\nAuthPipeline:\n\n        \u2502   sec/op    \u2502     B/op     \u2502 allocs/op  \u2502\n\n*         388.0\u00b5 \u00b1 2%   80.70Ki \u00b1 0%   894.0 \u00b1 0%\n*-4       348.4\u00b5 \u00b1 5%   80.67Ki \u00b1 2%   894.0 \u00b1 3%\n*-10      356.4\u00b5 \u00b1 2%   78.97Ki \u00b1 0%   860.0 \u00b1 0%\ngeomean   363.9\u00b5        80.11Ki        882.5\n\nAPIKeyAuthn:\n\n        \u2502   sec/op    \u2502    B/op      \u2502 allocs/op  \u2502\n\n*         3.246\u00b5 \u00b1 1%   480.0 \u00b1 0%     6.000 \u00b1 0%\n*-4       3.111\u00b5 \u00b1 0%   480.0 \u00b1 0%     6.000 \u00b1 0%\n*-10      3.091\u00b5 \u00b1 1%   480.0 \u00b1 0%     6.000 \u00b1 0%\ngeomean   3.148\u00b5        480.0          6.000\n\nOPAAuthz vs JSONPatternMatchingAuthz:\n\n        \u2502   OPAAuthz   \u2502      JSONPatternMatchingAuthz       \u2502\n        \u2502    sec/op    \u2502   sec/op     vs base                \u2502\n\n*         87.469\u00b5 \u00b1 1%   1.797\u00b5 \u00b1 1%  -97.95% (p=0.000 n=10)\n*-4       95.954\u00b5 \u00b1 3%   1.766\u00b5 \u00b1 0%  -98.16% (p=0.000 n=10)\n*-10      96.789\u00b5 \u00b1 4%   1.763\u00b5 \u00b1 0%  -98.18% (p=0.000 n=10)\ngeomean    93.31\u00b5        1.775\u00b5       -98.10%\n\n        \u2502   OPAAuthz    \u2502      JSONPatternMatchingAuthz      \u2502\n        \u2502     B/op      \u2502    B/op     vs base                \u2502\n\n*         28826.00 \u00b1 0%   64.00 \u00b1 0%  -99.78% (p=0.000 n=10)\n*-4       28844.00 \u00b1 0%   64.00 \u00b1 0%  -99.78% (p=0.000 n=10)\n*-10      28862.00 \u00b1 0%   64.00 \u00b1 0%  -99.78% (p=0.000 n=10)\ngeomean    28.17Ki        64.00       -99.78%\n\n        \u2502   OPAAuthz   \u2502      JSONPatternMatchingAuthz      \u2502\n        \u2502  allocs/op   \u2502 allocs/op   vs base                \u2502\n\n*         569.000 \u00b1 0%   2.000 \u00b1 0%  -99.65% (p=0.000 n=10)\n*-4       569.000 \u00b1 0%   2.000 \u00b1 0%  -99.65% (p=0.000 n=10)\n*-10      569.000 \u00b1 0%   2.000 \u00b1 0%  -99.65% (p=0.000 n=10)\ngeomean     569.0        2.000       -99.65%\n</code></pre></p>"},{"location":"authorino/#contributing","title":"Contributing","text":"<p>If you are interested in contributing to Authorino, please refer to the Developer's guide for info about the stack and requirements, workflow, policies and Code of Conduct.</p> <p>Join us on the #kuadrant channel in the Kubernetes Slack workspace, for live discussions about the roadmap and more.</p>"},{"location":"authorino/#license","title":"License","text":""},{"location":"authorino/docs/","title":"Documentation","text":""},{"location":"authorino/docs/#getting-started","title":"Getting started","text":""},{"location":"authorino/docs/#terminology","title":"Terminology","text":""},{"location":"authorino/docs/#architecture","title":"Architecture","text":""},{"location":"authorino/docs/#feature-description","title":"Feature description","text":""},{"location":"authorino/docs/#user-guides","title":"User guides","text":""},{"location":"authorino/docs/#developers-guide","title":"Developer\u2019s guide","text":""},{"location":"authorino/docs/architecture/","title":"Architecture","text":""},{"location":"authorino/docs/architecture/#overview","title":"Overview","text":"<p>There are a few concepts to understand Authorino's architecture. The main components are: Authorino, Envoy and the Upstream service to be protected. Envoy proxies requests to the configured virtual host upstream service, first contacting with Authorino to decide on authN/authZ.</p> <p>The topology can vary from centralized proxy and centralized authorization service, to dedicated sidecars, with the nuances in between. Read more about the topologies in the Topologies section below.</p> <p>Authorino is deployed using the Authorino Operator, from an <code>Authorino</code> Kubernetes custom resource. Then, from another kind of custom resource, the <code>AuthConfig</code> CRs, each Authorino instance reads and adds to the index the exact rules of authN/authZ to enforce for each protected host (\"index reconciliation\").</p> <p>Everything that the AuthConfig reconciler can fetch in reconciliation-time is stored in the index. This is the case of static parameters such as signing keys, authentication secrets and authorization policies from external policy registries.</p> <p><code>AuthConfig</code>s can refer to identity providers (IdP) and trusted auth servers whose access tokens will be accepted to authenticate to the protected host. Consumers obtain an authentication token (short-lived access token or long-lived API key) and send those in the requests to the protected service.</p> <p>When Authorino is triggered by Envoy via the gRPC interface, it starts evaluating the Auth Pipeline, i.e. it applies to the request the parameters to verify the identity and to enforce authorization, as found in the index for the requested host (See host lookup for details).</p> <p>Apart from static rules, these parameters can include instructions to contact online with external identity verifiers, external sources of metadata and policy decision points (PDPs).</p> <p>On every request, Authorino's \"working memory\" is called Authorization JSON, a data structure that holds information about the context (the HTTP request) and objects from each phase of the auth pipeline: i.e., authentication verification (phase i), ad-hoc metadata fetching (phase ii), authorization policy enforcement (phase iii), dynamic response (phase iv), and callbacks (phase v). The evaluators in each of these phases can both read and write from the Authorization JSON for dynamic steps and decisions of authN/authZ.</p>"},{"location":"authorino/docs/architecture/#topologies","title":"Topologies","text":"<p>Typically, upstream APIs are deployed to the same Kubernetes cluster and namespace where the Envoy proxy and Authorino is running (although not necessarily). Whatever is the case, Envoy must be proxying to the upstream API (see Envoy's HTTP route components and virtual hosts) and pointing to Authorino in the external authorization filter.</p> <p>This can be achieved with different topologies:</p> <ul> <li>Envoy can be a centralized gateway with one dedicated instance of Authorino, proxying to one or more upstream services</li> <li>Envoy can be deployed as a sidecar of each protected service, but still contacting from a centralized Authorino authorization service</li> <li>Both Envoy and Authorino deployed as sidecars of the protected service, restricting all communication between them to localhost</li> </ul> <p>Each topology above induces different measures for security.</p>"},{"location":"authorino/docs/architecture/#centralized-gateway","title":"Centralized gateway","text":"<p>Recommended in the protected services to validate the origin of the traffic. It must have been proxied by Envoy. See Authorino JSON injection for an extra validation option using a shared secret passed in HTTP header.</p>"},{"location":"authorino/docs/architecture/#centralized-authorization-service","title":"Centralized authorization service","text":"<p>Protected service should only listen on <code>localhost</code> and all traffic can be considered safe.</p>"},{"location":"authorino/docs/architecture/#sidecars","title":"Sidecars","text":"<p>Recommended <code>namespaced</code> instances of Authorino with fine-grained label selectors to avoid unnecessary caching of <code>AuthConfig</code>s.</p> <p>Apart from that, protected service should only listen on <code>localhost</code> and all traffic can be considered safe.</p>"},{"location":"authorino/docs/architecture/#cluster-wide-vs-namespaced-instances","title":"Cluster-wide vs. Namespaced instances","text":"<p>Authorino instances can run in either cluster-wide or namespaced mode.</p> <p>Namespace-scoped instances only watch resources (<code>AuthConfig</code>s and <code>Secret</code>s) created in a given namespace. This deployment mode does not require admin privileges over the Kubernetes cluster to deploy the instance of the service (given Authorino's CRDs have been installed beforehand, such as when Authorino is installed using the Authorino Operator).</p> <p>Cluster-wide deployment mode, in contraposition, deploys instances of Authorino that watch resources across the entire cluster, consolidating all resources into a multi-namespace index of auth configs. Admin privileges over the Kubernetes cluster is required to deploy Authorino in cluster-wide mode.</p> <p>Be careful to avoid superposition when combining multiple Authorino instances and instance modes in the same Kubernetes cluster. Apart from caching unnecessary auth config data in the instances depending on your routing settings, the leaders of each instance (set of replicas) may compete for updating the status of the custom resources that are reconciled. See Resource reconciliation and status update for more information.</p> <p>If necessary, use label selectors to narrow down the space of resources watched and reconciled by each Authorino instance. Check out the Sharding section below for details.</p>"},{"location":"authorino/docs/architecture/#the-authorino-authconfig-custom-resource-definition-crd","title":"The Authorino <code>AuthConfig</code> Custom Resource Definition (CRD)","text":"<p>The desired protection for a service is declaratively stated by applying an <code>AuthConfig</code> Custom Resource to the Kubernetes cluster running Authorino.</p> <p>An <code>AuthConfig</code> resource typically looks like the following:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n    # The list of public host names of the services protected by this AuthConfig resource.\n    # Authorino uses the host name provided in the payload of external authorization request to lookup for the corresponding AuthConfig to enforce.\n  # Hostname collisions are prevented by rejecting to index a hostname already taken by another AuthConfig.\n  # Format: hostname[:port]\n  hosts:\n\n  - my-api.io:443 # north-south traffic\n  - my-api.ns.svc.cluster.local # east-west traffic\n\n  # Set of stored named patterns to be reused in conditions and pattern-matching authorization rules\n  patterns: {\"name\" \u2192 {selector, operator, value}, \u2026}\n\n  # Top-level conditions for the AuthConfig to be enforced.\n  # If omitted, the AuthConfig will be enforced at all requests.\n  # If present, all conditions must match for the AuthConfig to be enforced; otherwise, Authorino skips the AuthConfig and returns to the auth request with status OK.\n  when: [{selector, operator, value | named pattern ref}, \u2026]\n\n  # List of one or more trusted sources of identity:\n  # - Configurations to verify JSON Web Tokens (JWTs) issued by an OpenID Connect (OIDC) server\n  # - Endpoints for OAuth 2.0 token introspection\n  # - Attributes for the Kubernetes `TokenReview` API\n  # - Label selectors for API keys (stored in Kubernetes `Secret`s)\n  # - Label selectors trusted x509 issuer certificates (stored in Kubernetes `Secret`s)\n  # - Selectors for plain identity objects supplied in the payload of the authorization request\n  # - Anonymous access configs\n  authentication: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # List of sources of external metadata for the authorization (optional):\n  # - Endpoints for HTTP GET or GET-by-POST requests\n  # - OIDC UserInfo endpoints (associated with an OIDC token issuer specified in the authentication configs)\n  # - User-Managed Access (UMA) resource registries\n  metadata: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # List of authorization policies to be enforced (optional):\n  # - Pattern-matching rules (e.g. `context.request.http.path eq '/pets'`)\n  # - Open Policy Agent (OPA) inline or external Rego policies\n  # - Attributes for the Kubernetes `SubjectAccessReview` API\n  # \u2013 Attributes for authorization with an external SpiceDB server\n  authorization: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # Customization to the response to the external authorization request (optional)\n  response:\n    # List of dynamic response elements into the request on success authoization (optional):\n    # - Plain text\n    # - JSON objects\n    # - Festival Wristbands (signed JWTs issued by Authorino)\n    success:\n      # List of HTTP headers to inject into the request post-authorization (optional):\n      headers: {\"name\" \u2192 {\u2026}, \u2026}\n\n      # List of Envoy Dynamic Metadata to inject into the request post-authorization (optional):\n      dynamicMetadata: {\"name\" \u2192 {\u2026}, \u2026}\n\n    # Custom HTTP status code, message and headers to replace the default `401 Unauthorized` response (optional)\n    unauthenticated:\n      code: 302\n      message: Redirecting to login\n      headers:\n        \"Location\":\n          value: https://my-app.io/login\n\n    # Custom HTTP status code, message and headers to replace the default `and `403 Forbidden` response (optional)\n    unauthorized: {code, message, headers, body}\n\n  # List of callback targets:\n  # - Endpoints for HTTP requests\n  callbacks: {\"name\" \u2192 {\u2026}, \u2026}\n</code></pre> <p>Check out the OAS of the <code>AuthConfig</code> CRD for a formal specification of the options for <code>authentication</code> verification, external <code>metadata</code> fetching, <code>authorization</code> policies, and dynamic <code>response</code>, as well as any other host protection capability implemented by Authorino.</p> <p>You can also read the specification from the CLI using the <code>kubectl explain</code> command. The Authorino CRD is required to have been installed in Kubernetes cluster. E.g. <code>kubectl explain authconfigs.spec.authentication.overrides</code>.</p> <p>A complete description of supported features and corresponding configuration options within an <code>AuthConfig</code> CR can be found in the Features page.</p> <p>More concrete examples of <code>AuthConfig</code>s for specific use-cases can be found in the User guides.</p>"},{"location":"authorino/docs/architecture/#resource-reconciliation-and-status-update","title":"Resource reconciliation and status update","text":"<p>The instances of the Authorino authorization service workload, following the Operator pattern, watch events related to the <code>AuthConfig</code> custom resources, to build and reconcile an in-memory index of configs. Whenever a replica receives traffic for authorization request, it looks up in the index of <code>AuthConfig</code>s and then triggers the \"Auth Pipeline\", i.e. enforces the associated auth spec onto the request.</p> <p>An instance can be a single authorization service workload or a set of replicas. All replicas watch and reconcile the same set of resources that match the <code>--auth-config-label-selector</code> and <code>--secret-label-selector</code> configuration options. (See both Cluster-wide vs. Namespaced instances and Sharding, for details about defining the reconciliation space of Authorino instances.)</p> <p>The above means that all replicas of an Authorino instance should be able to receive traffic for authorization requests.</p> <p>Among the multiple replicas of an instance, Authorino elects one replica to be leader. The leader is responsible for updating the status of reconciled <code>AuthConfig</code>s. If the leader eventually becomes unavailable, the instance will automatically elect another replica take its place as the new leader.</p> <p>The status of an <code>AuthConfig</code> tells whether the resource is \"ready\" (i.e. indexed). It also includes summary information regarding the numbers of authentication configs, metadata configs, authorization configs and response configs within the spec, as well as whether Festival Wristband tokens are being issued by the Authorino instance as by spec.</p> <p>Apart from watching events related to <code>AuthConfig</code> custom resources, Authorino also watches events related to Kubernetes <code>Secret</code>s, as part of Authorino's API key authentication feature. <code>Secret</code> resources that store API keys are linked to their corresponding <code>AuthConfig</code>s in the index. Whenever the Authorino instance detects a change in the set of API key <code>Secret</code>s linked to an <code>AuthConfig</code>s, the instance reconciles the index.</p> <p>Authorino only watches events related to <code>Secret</code>s whose <code>metadata.labels</code> match the label selector <code>--secret-label-selector</code> of the Authorino instance. The default values of the label selector for Kubernetes <code>Secret</code>s representing Authorino API keys is <code>authorino.kuadrant.io/managed-by=authorino</code>.</p>"},{"location":"authorino/docs/architecture/#the-auth-pipeline-aka-enforcing-protection-in-request-time","title":"The \"Auth Pipeline\" (aka: enforcing protection in request-time)","text":"<p>In each request to the protected API, Authorino triggers the so-called \"Auth Pipeline\", a set of configured evaluators that are organized in a 5-phase pipeline:</p> <ul> <li>(i) Authentication phase: at least one source of identity (i.e., one authentication config) must resolve the supplied credential in the request into a valid identity or Authorino will otherwise reject the request as unauthenticated (401 HTTP response status).</li> <li>(ii) Metadata phase: optional fetching of additional data from external sources, to add up to context and identity information, and used in authorization policies, dynamic responses and callback requests (phases iii to v).</li> <li>(iii) Authorization phase: all unskipped policies must evaluate to a positive result (\"authorized\"), or Authorino will otherwise reject the request as unauthorized (403 HTTP response code).</li> <li>(iv) Response phase \u2013 Authorino builds all user-defined response items (dynamic JSON objects and/or Festival Wristband OIDC tokens), which are supplied back to the external authorization client within added HTTP headers or as Envoy Dynamic Metadata</li> <li>(v) Callbacks phase \u2013 Authorino sends callbacks to specified HTTP endpoints.</li> </ul> <p>Each phase is sequential to the other, from (i) to (v), while the evaluators within each phase are triggered concurrently or as prioritized. The Authentication phase (i) is the only one required to list at least one evaluator (i.e. 1+ authentication configs); Metadata, Authorization and Response phases can have any number of evaluators (including zero, and even be omitted in this case).</p>"},{"location":"authorino/docs/architecture/#host-lookup","title":"Host lookup","text":"<p>Authorino reads the request host from <code>Attributes.Http.Host</code> of Envoy's <code>CheckRequest</code> type, and uses it as key to lookup in the index of <code>AuthConfig</code>s, matched against <code>spec.hosts</code>.</p> <p>Alternatively to <code>Attributes.Http.Host</code>, a <code>host</code> entry can be supplied in the <code>Attributes.ContextExtensions</code> map of the external authorino request. This will take precedence before the host attribute of the HTTP request.</p> <p>The <code>host</code> context extension is useful to support use cases such as of path prefix-based lookup and wildcard subdomains lookup with lookup strongly dictated by the external authorization client (e.g. Envoy), which often knows about routing and the expected <code>AuthConfig</code> to enforce beyond what Authorino can infer strictly based on the host name.</p> <p>Wildcards can also be used in the host names specified in the <code>AuthConfig</code>, resolved by Authorino. E.g. if <code>*.pets.com</code> is in <code>spec.hosts</code>, Authorino will match the concrete host names <code>dogs.pets.com</code>, <code>cats.pets.com</code>, etc. In case, of multiple possible matches, Authorino will try the longest match first (in terms of host name labels) and fall back to the closest wildcard upwards in the domain tree (if any).</p> <p>When more than one host name is specified in the <code>AuthConfig</code>, all of them can be used as key, i.e. all of them can be requested in the authorization request and will be mapped to the same config.</p> <p>Example. Host lookup with wildcards.</p> <p></p> <p>The domain tree above induces the following relation:</p> <ul> <li><code>foo.nip.io</code> \u2192 <code>authconfig-1</code> (matches <code>*.io</code>)</li> <li><code>talker-api.nip.io</code> \u2192 <code>authconfig-2</code> (matches <code>talker-api.nip.io</code>)</li> <li><code>dogs.pets.com</code> \u2192 <code>authconfig-2</code> (matches <code>*.pets.com</code>)</li> <li><code>api.acme.com</code> \u2192 <code>authconfig-3</code> (matches <code>api.acme.com</code>)</li> <li><code>www.acme.com</code> \u2192 <code>authconfig-4</code> (matches <code>*.acme.com</code>)</li> <li><code>foo.org</code> \u2192 <code>404 Not found</code></li> </ul> <p></p> <p>The host can include the port number (i.e. <code>hostname:port</code>) or it can be just the name of the host name. Authorino will first try finding in the index a config associated to <code>hostname:port</code>, as supplied in the authorization request; if the index misses an entry for <code>hostname:port</code>, Authorino will then remove the <code>:port</code> suffix and repeat the lookup using just <code>hostname</code> as key. This provides implicit support for multiple port numbers for a same host without having to list all combinations in the <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/architecture/#avoiding-host-name-collision","title":"Avoiding host name collision","text":"<p>Authorino tries to prevent host name collision between <code>AuthConfig</code>s by rejecting to link in the index any <code>AuthConfig</code> and host name if the host name is already linked to a different <code>AuthConfig</code> in the index. This was intentionally designed to prevent users from superseding each other's <code>AuthConfig</code>s, partially or fully, by just picking the same host names or overlapping host names as others.</p> <p>When wildcards are involved, a host name that matches a host wildcard already linked in the index to another <code>AuthConfig</code> will be considered taken, and therefore the newest <code>AuthConfig</code> will be rejected to be linked to that host.</p> <p>This behavior can be disabled to allow <code>AuthConfig</code>s to partially supersede each others' host names (limited to strict host subsets), by supplying the <code>--allow-superseding-host-subsets</code> command-line flag when running the Authorino instance.</p>"},{"location":"authorino/docs/architecture/#the-authorization-json","title":"The Authorization JSON","text":"<p>On every Auth Pipeline, Authorino builds the Authorization JSON, a \"working-memory\" data structure composed of <code>context</code> (information about the request, as supplied by the Envoy proxy to Authorino) and <code>auth</code> (objects resolved in phases (i) to (v) of the pipeline). The evaluators of each phase can read from the Authorization JSON and implement dynamic properties and decisions based on its values.</p> <p>At phase (iii), the authorization evaluators count on an Authorization JSON payload that looks like the following:</p> <pre><code>// The authorization JSON combined along Authorino's auth pipeline for each request\n{\n  \"context\": { // the input from the proxy\n    \"origin\": {\u2026},\n    \"request\": {\n      \"http\": {\n        \"method\": \"\u2026\",\n        \"headers\": {\u2026},\n        \"path\": \"/\u2026\",\n        \"host\": \"\u2026\",\n        \u2026\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      // the identity resolved, from the supplied credentials, by one of the evaluators of phase (i)\n    },\n    \"metadata\": {\n      // each metadata object/collection resolved by the evaluators of phase (ii), by name of the evaluator\n    }\n  }\n}\n</code></pre> <p>The policies evaluated can use any data from the authorization JSON to define authorization rules.</p> <p>After phase (iii), Authorino appends to the authorization JSON the results of this phase as well, and the payload available for phase (iv) becomes:</p> <pre><code>// The authorization JSON combined along Authorino's auth pipeline for each request\n{\n  \"context\": { // the input from the proxy\n    \"origin\": {\u2026},\n    \"request\": {\n      \"http\": {\n        \"method\": \"\u2026\",\n        \"headers\": {\u2026},\n        \"path\": \"/\u2026\",\n        \"host\": \"\u2026\",\n        \u2026\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      // the identity resolved, from the supplied credentials, by one of the evaluators of phase (i)\n    },\n    \"metadata\": {\n      // each metadata object/collection resolved by the evaluators of phase (ii), by name of the evaluator\n    },\n    \"authorization\": {\n      // each authorization policy result resolved by the evaluators of phase (iii), by name of the evaluator\n    }\n  }\n}\n</code></pre> <p>Festival Wristbands and Dynamic JSON responses can include dynamic values (custom claims/properties) fetched from the authorization JSON. These can be returned to the external authorization client in added HTTP headers or as Envoy Well Known Dynamic Metadata. Check out Custom response features for details.</p> <p>For information about reading and fetching data from the Authorization JSON (syntax, functions, etc), check out Common Expression Language (CEL).</p>"},{"location":"authorino/docs/architecture/#raw-http-authorization-interface","title":"Raw HTTP Authorization interface","text":"<p>Besides providing the gRPC authorization interface \u2013 that implements the Envoy gRPC authorization server \u2013, Authorino also provides another interface for raw HTTP authorization. This second interface responds to <code>GET</code> and <code>POST</code> HTTP requests sent to <code>:5001/check</code>, and is suitable for other forms of integration, such as:</p> <ul> <li>using Authorino as Kubernetes ValidatingWebhook service (example);</li> <li>other HTTP proxies and API gateways;</li> <li>old versions of Envoy incompatible with the latest version of gRPC external authorization protocol (Authorino is based on v3.19.1 of Envoy external authorization API)</li> </ul> <p>In the raw HTTP interface, the host used to lookup for an <code>AuthConfig</code> must be supplied in the <code>Host</code> HTTP header of the request. Other attributes of the HTTP request are also passed in the context to evaluate the <code>AuthConfig</code>, including the body of the request.</p>"},{"location":"authorino/docs/architecture/#caching","title":"Caching","text":""},{"location":"authorino/docs/architecture/#openid-connect-and-user-managed-access-configs","title":"OpenID Connect and User-Managed Access configs","text":"<p>OpenID Connect and User-Managed Access configurations, discovered usually at reconciliation-time from well-known discovery endpoints.</p> <p>Cached individual OpenID Connect configurations discovered by Authorino can be configured to be auto-refreshed, by setting the corresponding <code>spec.authentication.jwt.ttl</code> field in the AuthConfig (given in seconds, default: <code>0</code> \u2013 i.e. no cache update).</p>"},{"location":"authorino/docs/architecture/#json-web-keys-jwks-and-json-web-key-sets-jwks","title":"JSON Web Keys (JWKs) and JSON Web Key Sets (JWKS)","text":"<p>JSON signature verification certificates linked by discovered OpenID Connect configurations, fetched usually at reconciliation-time.</p>"},{"location":"authorino/docs/architecture/#revoked-access-tokens","title":"Revoked access tokens","text":"Not implemented - In analysis (#19) <p>Caching of access tokens identified and or notified as revoked prior to expiration.</p>"},{"location":"authorino/docs/architecture/#external-metadata","title":"External metadata","text":"Not implemented - Planned (#21) <p>Caching of resource data obtained in previous requests.</p>"},{"location":"authorino/docs/architecture/#compiled-rego-policies","title":"Compiled Rego policies","text":"<p>Performed automatically by Authorino at reconciliation-time for the authorization policies based on the built-in OPA module.</p> <p>Precompiled and cached individual Rego policies originally pulled by Authorino from external registries can be configured to be auto-refreshed, by setting the corresponding <code>spec.authorization.opa.externalRegistry.ttl</code> field in the AuthConfig (given in seconds, default: <code>0</code> \u2013 i.e. no cache update).</p>"},{"location":"authorino/docs/architecture/#repeated-requests","title":"Repeated requests","text":"Not implemented - In analysis (#20) <p>For consecutive requests performed, within a given period of time, by a same user that request for a same resource, such that the result of the auth pipeline can be proven that would not change.</p>"},{"location":"authorino/docs/architecture/#sharding","title":"Sharding","text":"<p>By default, Authorino instances will watch <code>AuthConfig</code> CRs in the entire space (namespace or entire cluster; see Cluster-wide vs. Namespaced instances for details). To support combining multiple Authorino instances and instance modes in the same Kubernetes cluster, and yet avoiding superposition between the instances (i.e. multiple instances reconciling the same <code>AuthConfig</code>s), Authorino offers support for data sharding, i.e. to horizontally narrow down the space of reconciliation of an Authorino instance to a subset of that space.</p> <p>The benefits of limiting the space of reconciliation of an Authorino instance include avoiding unnecessary caching and workload in instances that do not receive corresponding traffic (according to your routing settings) and preventing leaders of multiple instances (sets of replicas) to compete on resource status updates (see Resource reconciliation and status update for details).</p> <p>Use-cases for sharding of <code>AuthConfig</code>s:</p> <ul> <li>Horizontal load balancing of traffic of authorization requests</li> <li>Supporting for managed centralized instances of Authorino to API owners who create and maintain their own <code>AuthConfig</code>s within their own user namespaces.</li> </ul> <p>Authorino's custom controllers filter the <code>AuthConfig</code>-related events to be reconciled using Kubernetes label selectors, defined for the Authorino instance via <code>--auth-config-label-selector</code> command-line flag. By default, <code>--auth-config-label-selector</code> is empty, meaning all <code>AuthConfig</code>s in the space are watched; this variable can be set to any value parseable as a valid label selector, causing Authorino to then watch only events of <code>AuthConfig</code>s whose <code>metadata.labels</code> match the selector.</p> <p>The following are all valid examples of <code>AuthConfig</code> label selector filters:</p> <pre><code>--auth-config-label-selector=\"authorino.kuadrant.io/managed-by=authorino\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by=authorino,other-label=other-value\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by in (authorino,kuadrant)\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by!=authorino-v0.4\"\n--auth-config-label-selector=\"!disabled\"\n</code></pre>"},{"location":"authorino/docs/architecture/#rbac","title":"RBAC","text":"<p>The table below describes the roles and role bindings defined by the Authorino service:</p> Role Kind Scope(*) Description Permissions <code>authorino-manager-role</code> <code>ClusterRole</code> C/N Role of the Authorino manager service Watch and reconcile <code>AuthConfig</code>s and <code>Secret</code>s <code>authorino-manager-k8s-auth-role</code> <code>ClusterRole</code> C/N Role for the Kubernetes auth features Create <code>TokenReview</code>s and <code>SubjectAccessReview</code>s (Kubernetes auth) <code>authorino-leader-election-role</code> <code>Role</code> N Leader election role Create/update the <code>ConfigMap</code> used to coordinate which replica of Authorino is the leader <code>authorino-authconfig-editor-role</code> <code>ClusterRole</code> - <code>AuthConfig</code> editor R/W <code>AuthConfig</code>s; Read <code>AuthConfig/status</code> <code>authorino-authconfig-viewer-role</code> <code>ClusterRole</code> - <code>AuthConfig</code> viewer Read <code>AuthConfig</code>s and <code>AuthConfig/status</code> <code>authorino-proxy-role</code> <code>ClusterRole</code> C/N Kube-rbac-proxy-role (sidecar)'s role Create <code>TokenReview</code>s and <code>SubjectAccessReview</code>s to check permissions to the <code>/metrics</code> endpoint <code>authorino-metrics-reader</code> <code>ClusterRole</code> - Metrics reader <code>GET /metrics</code> <p>(*) C - Cluster-wide | N - Authorino namespace | C/N - Cluster-wide or Authorino namespace (depending on the deployment mode).</p>"},{"location":"authorino/docs/architecture/#observability","title":"Observability","text":"<p>Please refer to the Observability user guide for info on Prometheus metrics exported by Authorino, readiness probe, logging, tracing, etc.</p>"},{"location":"authorino/docs/code_of_conduct/","title":"Code of conduct","text":""},{"location":"authorino/docs/code_of_conduct/#code-of-conduct","title":"Code of Conduct","text":"<p>Autorino follows the Kuadrant Community Code of Conduct, which is based on the CNCF Code of Conduct.</p> <p>Please refer to this page for a description of the standards and values we stand for in our relationship with the community.</p>"},{"location":"authorino/docs/contributing/","title":"Developer's Guide","text":""},{"location":"authorino/docs/contributing/#technology-stack-for-developers","title":"Technology stack for developers","text":"<p>Minimum requirements to contribute to Authorino are:</p> <ul> <li>Golang v1.21+</li> <li>Docker</li> </ul> <p>Authorino's code was originally bundled using the Operator SDK (v1.9.0).</p> <p>The following tools can be installed as part of the development workflow:</p> <ul> <li> <p>Installed with <code>go install</code> to the <code>$PROJECT_DIR/bin</code> directory:</p> <ul> <li>controller-gen: for building custom types and manifests</li> <li>Kustomize: for assembling flavoured manifests and installing/deploying</li> <li>setup-envtest: for running the tests \u2013 extra tools installed to <code>./testbin</code></li> <li>benchstat: for human-friendly test benchmark reports</li> <li>mockgen: to generate mocks for tests \u2013 e.g. <code>./bin/mockgen -source=pkg/auth/auth.go -destination=pkg/auth/mocks/mock_auth.go</code></li> <li>Kind: for deploying a containerized Kubernetes cluster for integration testing purposes</li> </ul> </li> <li> <p>Other recommended tools to have installed:</p> <ul> <li>jq</li> <li>yq</li> <li>gnu-sed</li> </ul> </li> </ul>"},{"location":"authorino/docs/contributing/#workflow","title":"Workflow","text":""},{"location":"authorino/docs/contributing/#check-the-issues","title":"Check the issues","text":"<p>Start by checking the list of issues in GitHub.</p> <p>In case you want to contribute with an idea for enhancement, a bug fix, or question, please make sure to describe the issue so we can start a conversation together and help you find the best way to get your contribution merged.</p>"},{"location":"authorino/docs/contributing/#clone-the-repo-and-setup-the-local-environment","title":"Clone the repo and setup the local environment","text":"<p>Fork/clone the repo:</p> <pre><code>git clone git@github.com:kuadrant/authorino.git &amp;&amp; cd authorino\n</code></pre> <p>Download the Golang dependencies: <pre><code>make vendor\n</code></pre></p> <p>For additional automation provided, check:</p> <pre><code>make help\n</code></pre>"},{"location":"authorino/docs/contributing/#make-your-changes","title":"Make your changes","text":"<p>Good changes...</p> <ul> <li>follow the Golang conventions</li> <li>have proper test coverage</li> <li>address corresponding updates to the docs</li> <li>help us fix wherever we failed to do the above \ud83d\ude1c</li> </ul>"},{"location":"authorino/docs/contributing/#run-the-tests","title":"Run the tests","text":"<p>To run the tests:</p> <pre><code>make test\n</code></pre>"},{"location":"authorino/docs/contributing/#try-locally","title":"Try locally","text":""},{"location":"authorino/docs/contributing/#build-deploy-and-try-authorino-in-a-local-cluster","title":"Build, deploy and try Authorino in a local cluster","text":"<p>The following command will:</p> <ul> <li>Start a local Kubernetes cluster (using Kind)</li> <li>Install cert-manager in the cluster</li> <li>Install the Authorino Operator and Authorino CRDs</li> <li>Build an image of Authorino based on the current branch</li> <li>Push the freshly built image to the cluster's registry</li> <li>Generate TLS certificates for the Authorino service</li> <li>Deploy an instance of Authorino</li> <li>Deploy the example application Talker API, a simple HTTP API that echoes back whatever it gets in the request</li> <li>Setup Envoy for proxying to the Talker API and using Authorino for external authorization</li> </ul> <pre><code>make local-setup\n</code></pre> <p>You will be prompted to edit the <code>Authorino</code> custom resource.</p> <p>The main workload composed of Authorino instance and user apps (Envoy, Talker API) will be deployed to the <code>default</code> Kubernetes namespace.</p> <p>Once the deployment is ready, you can forward the requests on port 8000 to the Envoy service</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre> Pro tips <ol> <li>Change the default workload namespace by supplying the <code>NAMESPACE</code> argument to your <code>make local-setup</code> and other deployment, apps and local cluster related targets. If the namespace does not exist, it will be created.</li> <li>Switch to TLS disabled by default when deploying locally by supplying <code>TLS_ENABLED=0</code> to your <code>make local-setup</code> and <code>make deploy</code> commands. E.g. <code>make local-setup TLS_ENABLED=0</code>.</li> <li>Skip being prompted to edit the <code>Authorino</code> CR and default to an Authorino deployment with TLS enabled, debug/development log level/mode, and standard name 'authorino', by supplying <code>FF=1</code> to your <code>make local-setup</code> and <code>make deploy</code> commands. E.g. <code>make local-setup FF=1</code></li> <li>Supply <code>DEPLOY_IDPS=1</code> to <code>make local-setup</code> and <code>make user-apps</code> to deploy Keycloak and Dex to the cluster. <code>DEPLOY_KEYCLOAK</code> and <code>DEPLOY_DEX</code> are also available. Read more about additional tools for specific use cases in the section below.</li> <li>Saving the ID of the process (PID) of the port-forward command spawned in the background can be useful to later kill and restart the process. E.g. <code>kubectl port-forward deployment/envoy 8000:8000 &amp;;PID=$!</code>; then <code>kill $PID</code>.</li> </ol>"},{"location":"authorino/docs/contributing/#additional-tools-for-specific-use-cases","title":"Additional tools (for specific use-cases)","text":"Limitador <p>To deploy Limitador \u2013 pre-configured in Envoy for rate-limiting the Talker API to 5 hits per minute per <code>user_id</code> when available in the cluster workload \u2013, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre> Keycloak <p>Authorino examples include a bundle of Keycloak preloaded with the following realm setup:</p> <ul> <li>Admin console: http://localhost:8080/admin  (admin/p)</li> <li>Preloaded realm: kuadrant</li> <li>Preloaded clients:<ul> <li>demo: to which API consumers delegate access and therefore the one which access tokens are issued to</li> <li>authorino: used by Authorino to fetch additional user info with <code>client_credentials</code> grant type</li> <li>talker-api: used by Authorino to fetch UMA-protected resource data associated with the Talker API</li> </ul> </li> <li>Preloaded resources:<ul> <li><code>/hello</code></li> <li><code>/greetings/1</code> (owned by user john)</li> <li><code>/greetings/2</code> (owned by user jane)</li> <li><code>/goodbye</code></li> </ul> </li> <li>Realm roles:<ul> <li>member (default to all users)</li> <li>admin</li> </ul> </li> <li>Preloaded users:<ul> <li>john/p (member)</li> <li>jane/p (admin)</li> <li>peter/p (member, email not verified)</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre> Dex <p>Authorino examples include a bundle of Dex preloaded with the following setup:</p> <ul> <li>Preloaded clients:<ul> <li>demo: to which API consumers delegate access and therefore the one which access tokens are issued to (Client secret: aaf88e0e-d41d-4325-a068-57c4b0d61d8e)</li> </ul> </li> <li>Preloaded users:<ul> <li>marta@localhost/password</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/dex/dex-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Dex running in the cluster:</p> <pre><code>kubectl port-forward deployment/dex 5556:5556 &amp;\n</code></pre> a12n-server <p>Authorino examples include a bundle of a12n-server and corresponding MySQL database, preloaded with the following setup:</p> <ul> <li>Admin console: http://a12n-server:8531 (admin/123456)</li> <li>Preloaded clients:<ul> <li>service-account-1: to obtain access tokens via <code>client_credentials</code> OAuth2 grant type, to consume the Talker API (Client secret: DbgXROi3uhWYCxNUq_U1ZXjGfLHOIM8X3C2bJLpeEdE); includes metadata privilege: <code>{ \"talker-api\": [\"read\"] }</code> that can be used to write authorization policies</li> <li>talker-api: to authenticate to the token introspect endpoint (Client secret: V6g-2Eq2ALB1_WHAswzoeZofJ_e86RI4tdjClDDDb4g)</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/a12n-server/a12n-server-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of a12n-server running in the cluster:</p> <pre><code>kubectl port-forward deployment/a12n-server 8531:8531 &amp;\n</code></pre>"},{"location":"authorino/docs/contributing/#re-build-and-rollout-latest","title":"Re-build and rollout latest","text":"<p>Re-build and rollout latest Authorino image:</p> <pre><code>make local-rollout\n</code></pre> <p>If you made changes to the CRD between iterations, re-install by running:</p> <pre><code>make install\n</code></pre>"},{"location":"authorino/docs/contributing/#clean-up","title":"Clean-up","text":"<p>The following command deletes the entire Kubernetes cluster started with Kind:</p> <pre><code>make local-cleanup\n</code></pre>"},{"location":"authorino/docs/contributing/#sign-your-commits","title":"Sign your commits","text":"<p>All commits to be accepted to Authorino's code are required to be signed. Refer to this page about signing your commits.</p>"},{"location":"authorino/docs/contributing/#logging-policy","title":"Logging policy","text":"<p>A few guidelines for adding logging messages in your code:</p> <ol> <li>Make sure you understand Authorino's Logging architecture and policy regarding log levels, log modes, tracing IDs, etc.</li> <li>Respect controller-runtime's Logging Guidelines.</li> <li>Do not add sensitive data to your <code>info</code> log messages; instead, redact all sensitive data in your log messages or use <code>debug</code> log level by mutating the logger with <code>V(1)</code> before outputting the message.</li> </ol>"},{"location":"authorino/docs/contributing/#additional-resources","title":"Additional resources","text":"<p>Here in the repo:</p> <ul> <li>Getting started</li> <li>Terminology</li> <li>Architecture</li> <li>Feature description</li> </ul> <p>Other repos:</p> <ul> <li>Authorino Operator</li> <li>Authorino examples</li> </ul>"},{"location":"authorino/docs/contributing/#reach-out","title":"Reach out","text":"<p>#kuadrant channel on kubernetes.slack.com.</p>"},{"location":"authorino/docs/features/","title":"Features","text":""},{"location":"authorino/docs/features/#overview","title":"Overview","text":"<p>We call features of Authorino the different things one can do to enforce identity verification &amp; authentication and authorization on requests to protected services. These can be a specific identity verification method based on a supported authentication protocol, or a method to fetch additional auth metadata in request-time, etc.</p> <p>Most features of Authorino relate to the different phases of the Auth Pipeline and therefore are configured in the Authorino <code>AuthConfig</code>. An identity verification/authentication feature usually refers to a functionality of Authorino such as the API key-based authentication, the validation of JWTs/OIDC ID tokens, and authentication based on Kubernetes TokenReviews. Analogously, OPA, pattern-matching and Kubernetes SubjectAccessReview are examples of authorization features of Authorino.</p> <p>At a deeper level, a feature can also be an additional functionality within a bigger feature, usually applicable to the whole class the bigger feature belongs to. For instance, the configuration of how auth credentials expected to be carried in the request, which is broadly available for any identity verification method. Other examples are: Identity extension and Priorities.</p> <p>A full specification of all features of Authorino that can be configured in an <code>AuthConfig</code> can be found in the official spec of the custom resource definition.</p> <p>You can also learn about Authorino features by using the <code>kubectl explain</code> command in a Kubernetes cluster where the Authorino CRD has been installed. E.g. <code>kubectl explain authconfigs.spec.authentication.credentials</code>.</p>"},{"location":"authorino/docs/features/#common-feature-json-paths-selector","title":"Common feature: JSON paths (<code>selector</code>)","text":"<p>Deprecated: Prefer <code>predicate</code> and <code>expression</code>, based on Common Expression Language (CEL), instead.</p> <p>The first feature of Authorino to learn about is a common functionality used in the specification of many other features. JSON paths are selectors of data from the Authorization JSON used in parts of an AuthConfig for referring to dynamic values of each authorization request.</p> <p>Usage examples of JSON paths are: dynamic URLs and request parameters when fetching metadata from external sources, dynamic authorization policy rules, and dynamic authorization response attributes (e.g. injected HTTP headers, Festival Wristband token claims, etc).</p>"},{"location":"authorino/docs/features/#syntax","title":"Syntax","text":"<p>The syntax to fetch data from the Authorization JSON with JSON paths is based on GJSON. Refer to GJSON Path Syntax page for more information.</p>"},{"location":"authorino/docs/features/#string-modifiers","title":"String modifiers","text":"<p>On top of GJSON, Authorino defines a few string modifiers.</p> <p>Examples below provided for the following Authorization JSON:</p> <pre><code>{\n  \"context\": {\n    \"request\": {\n      \"http\": {\n        \"path\": \"/pets/123\",\n        \"headers\": {\n          \"authorization\": \"Basic amFuZTpzZWNyZXQK\" // jane:secret\n          \"baggage\": \"eyJrZXkxIjoidmFsdWUxIn0=\" // {\"key1\":\"value1\"}\n        }\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      \"username\": \"jane\",\n      \"fullname\": \"Jane Smith\",\n      \"email\": \"\\u0006jane\\u0012@petcorp.com\\n\"\n    },\n  },\n}\n</code></pre> <p><code>@strip</code> Strips out any non-printable characters such as carriage return. E.g. <code>auth.identity.email.@strip</code> \u2192 <code>\"jane@petcorp.com\"</code>.</p> <p><code>@case:upper|lower</code> Changes the case of a string. E.g. <code>auth.identity.username.@case:upper</code> \u2192 <code>\"JANE\"</code>.</p> <p><code>@replace:{\"old\":string,\"new\":string}</code> Replaces a substring within a string. E.g. <code>auth.identity.username.@replace:{\"old\":\"Smith\",\"new\":\"Doe\"}</code> \u2192 <code>\"Jane Doe\"</code>.</p> <p><code>@extract:{\"sep\":string,\"pos\":int}</code> Splits a string at occurrences of a separator (default: <code>\" \"</code>) and selects the substring at the <code>pos</code>-th position (default: <code>0</code>). E.g. <code>context.request.path.@extract:{\"sep\":\"/\",\"pos\":2}</code> \u2192 <code>123</code>.</p> <p><code>@base64:encode|decode</code> base64-encodes or decodes a string value. E.g. <code>auth.identity.username.decoded.@base64:encode</code> \u2192 <code>\"amFuZQo=\"</code>.</p> <p>In combination with <code>@extract</code>, <code>@base64</code> can be used to extract the username in an HTTP Basic Authentication request. E.g. <code>context.request.headers.authorization.@extract:{\"pos\":1}|@base64:decode|@extract:{\"sep\":\":\",\"pos\":1}</code> \u2192 <code>\"jane\"</code>.</p>"},{"location":"authorino/docs/features/#interpolation","title":"Interpolation","text":"<p>JSON paths can be interpolated into strings to build template-like dynamic values. E.g. <code>\"Hello, {auth.identity.name}!\"</code>.</p>"},{"location":"authorino/docs/features/#common-feature-common-expression-language-cel","title":"Common feature: Common Expression Language (CEL)","text":"<p>Similar to JSON Paths, Authorino supports Common Expression Language (CEL) for selecting data from the Authorization JSON and representing predicates. This is a more powerful, properly typed alternative to JSON Paths, with a well-documented syntax.</p> <p>String extension functions, such as <code>split</code>, <code>substring</code>, <code>indexOf</code>, etc, are also supported.</p> <p>Use the <code>expression</code> field for selecting values from the Authorization JSON. The type of the selected value will be converted to a JSON-compatible equivalent. Complex types without a direct JSON equivalent may be converted to objects (e.g. <code>google.golang.org/protobuf/types/known/timestamppb.Timestamp</code> gets converted to <code>{ \"seconds\": Number, \"nanos\": Number }</code>)</p> <p>The most common applications of <code>expression</code> are for building dynamic URLs and request parameters when fetching metadata from external sources, extending properties of identity objects, and dynamic authorization response attributes (e.g. injected HTTP headers, etc).</p> <p>Use <code>predicate</code> for expressions that return a boolean value, such as in <code>when</code> conditions and pattern-matching authorization rules.</p>"},{"location":"authorino/docs/features/#identity-verification-authentication-features-authentication","title":"Identity verification &amp; authentication features (<code>authentication</code>)","text":""},{"location":"authorino/docs/features/#api-key-authenticationapikey","title":"API key (<code>authentication.apiKey</code>)","text":"<p>Authorino relies on Kubernetes <code>Secret</code> resources to represent API keys.</p> <p>To define an API key, create a <code>Secret</code> in the cluster containing an <code>api_key</code> entry that holds the value of the API key.</p> <p>API key secrets must be created in the same namespace of the <code>AuthConfig</code> (default) or <code>spec.authentication.apiKey.allNamespaces</code> must be set to <code>true</code> (only works with cluster-wide Authorino instances).</p> <p>API key secrets must be labeled with the labels that match the selectors specified in <code>spec.authentication.apiKey.selector</code> in the <code>AuthConfig</code>.</p> <p>Whenever an <code>AuthConfig</code> is indexed, Authorino will also index all matching API key secrets. In order for Authorino to also watch events related to API key secrets individually (e.g. new <code>Secret</code> created, updates, deletion/revocation), <code>Secret</code>s must also include a label that matches Authorino's bootstrap configuration <code>--secret-label-selector</code> (default: <code>authorino.kuadrant.io/managed-by=authorino</code>). This label may or may not be present to <code>spec.authentication.apiKey.selector</code> in the <code>AuthConfig</code> without implications for the caching of the API keys when triggered by the reconciliation of the <code>AuthConfig</code>; however, if not present, individual changes related to the API key secret (i.e. without touching the <code>AuthConfig</code>) will be ignored by the reconciler.</p> <p>Example. For the following <code>AuthConfig</code>:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\n  namespace: authorino-system\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"api-key-users\":\n      apiKey:\n        selector:\n          matchLabels: # the key-value set used to select the matching `Secret`s; resources including these labels will be accepted as valid API keys to authenticate to this service\n            group: friends # some custom label\n        allNamespaces: true # only works with cluster-wide Authorino instances; otherwise, create the API key secrets in the same namespace of the AuthConfig\n</code></pre> <p>The following Kubernetes <code>Secret</code> represents a valid API key:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: user-1-api-key-1\n  namespace: default\n  labels:\n    authorino.kuadrant.io/managed-by: authorino # so the Authorino controller reconciles events related to this secret\n    group: friends\nstringData:\n  api_key: &lt;some-randomly-generated-api-key-value&gt;\ntype: Opaque\n</code></pre> <p>The resolved identity object, added to the authorization JSON following an API key identity source evaluation, is the Kubernetes <code>Secret</code> resource (as JSON).</p>"},{"location":"authorino/docs/features/#kubernetes-tokenreview-authenticationkubernetestokenreview","title":"Kubernetes TokenReview (<code>authentication.kubernetesTokenReview</code>)","text":"<p>Authorino can verify Kubernetes-valid access tokens (using Kubernetes TokenReview API).</p> <p>These tokens can be either <code>ServiceAccount</code> tokens such as the ones issued by kubelet as part of Kubernetes Service Account Token Volume Projection, or any valid user access tokens issued to users of the Kubernetes server API.</p> <p>The list of <code>audiences</code> of the token must include the requested host and port of the protected API (default), or all audiences specified in the Authorino <code>AuthConfig</code> custom resource. For example:</p> <p>For the following <code>AuthConfig</code> CR, the Kubernetes token must include the audience <code>my-api.io</code>:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"cluster-users\":\n      kubernetesTokenReview: {}\n</code></pre> <p>Whereas for the following <code>AuthConfig</code> CR, the Kubernetes token audiences must include foo and bar:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"cluster-users\":\n      kubernetesTokenReview:\n        audiences:\n        - foo\n        - bar\n</code></pre> <p>The resolved identity object added to the authorization JSON following a successful Kubernetes authentication identity evaluation is the <code>status</code> field of TokenReview response (see TokenReviewStatus for reference).</p>"},{"location":"authorino/docs/features/#jwt-verification-authenticationjwt","title":"JWT verification (<code>authentication.jwt</code>)","text":"<p>In reconciliation-time, using OpenID Connect Discovery well-known endpoint, Authorino automatically discovers and caches OpenID Connect configurations and associated JSON Web Key Sets (JWKS) for all OpenID Connect issuers declared in an <code>AuthConfig</code>. Then, in request-time, Authorino verifies the JSON Web Signature (JWS) and check the time validity of signed JSON Web Tokens (JWT) supplied on each request.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p></p> <p>The <code>kid</code> claim stated in the JWT header must match one of the keys cached by Authorino during OpenID Connect Discovery, therefore supporting JWK rotation.</p> <p>The decoded payload of the validated JWT is appended to the authorization JSON as the resolved identity.</p> <p>OpenID Connect configurations and linked JSON Web Key Sets can be configured to be automatically refreshed (pull again from the OpenID Connect Discovery well-known endpoints), by setting the <code>authentication.jwt.ttl</code> field (given in seconds, default: <code>0</code> \u2013 i.e. auto-refresh disabled).</p> <p>For an excellent summary of the underlying concepts and standards that relate OpenID Connect and JSON Object Signing and Encryption (JOSE), see this article by Jan Rusnacko. For official specification and RFCs, see OpenID Connect Core, OpenID Connect Discovery, JSON Web Token (JWT) (RFC7519), and JSON Object Signing and Encryption (JOSE).</p>"},{"location":"authorino/docs/features/#oauth-20-introspection-authenticationoauth2introspection","title":"OAuth 2.0 introspection (<code>authentication.oauth2Introspection</code>)","text":"<p>For bare OAuth 2.0 implementations, Authorino can perform token introspection on the access tokens supplied in the requests to protected APIs.</p> <p>Authorino does not implement any of OAuth 2.0 grants for the applications to obtain the token. However, it can verify supplied tokens with the OAuth server, including opaque tokens, as long as the server exposes the <code>token_introspect</code> endpoint (RFC 7662).</p> <p>Developers must set the token introspection endpoint in the <code>AuthConfig</code>, as well as a reference to the Kubernetes secret storing the credentials of the OAuth client to be used by Authorino when requesting the introspect.</p> <p></p> <p>The response returned by the OAuth2 server to the token introspection request is the resolved identity appended to the authorization JSON.</p>"},{"location":"authorino/docs/features/#x509-client-certificate-authentication-authenticationx509","title":"X.509 client certificate authentication (<code>authentication.x509</code>)","text":"<p>Authorino can verify X.509 certificates presented by clients for authentication on the request to the protected APIs, at application level.</p> <p>Trusted root Certificate Authorities (CA) are stored in Kubernetes Secrets labeled according to selectors specified in the AuthConfig, watched and indexed by Authorino. Make sure to create proper <code>kubernetes.io/tls</code>-typed Kubernetes Secrets, containing the public certificates of the CA stored in either a <code>tls.crt</code> or <code>ca.crt</code> entry inside the secret.</p> <p>Trusted root CA secrets must be created in the same namespace of the <code>AuthConfig</code> (default) or <code>spec.authentication.x509.allNamespaces</code> must be set to <code>true</code> (only works with cluster-wide Authorino instances).</p> <p>Client certificates must include x509 v3 extension specifying 'Client Authentication' extended key usage.</p> <p>The identity object resolved out of a client x509 certificate is equal to the subject field of the certificate, and it serializes as JSON within the Authorization JSON usually as follows:</p> <pre><code>{\n    \"auth\": {\n        \"identity\": {\n            \"CommonName\": \"aisha\",\n            \"Country\": [\"PK\"],\n            \"ExtraNames\": null,\n            \"Locality\": [\"Islamabad\"],\n            \"Names\": [\n                { \"Type\": [2, 5, 4, 3], \"Value\": \"aisha\" },\n                { \"Type\": [2, 5, 4, 6], \"Value\": \"PK\" },\n                { \"Type\": [2, 5, 4, 7], \"Value\": \"Islamabad\" },\n                { \"Type\": [2, 5, 4,10], \"Value\": \"ACME Inc.\" },\n                { \"Type\": [2, 5, 4,11], \"Value\": \"Engineering\" }\n            ],\n            \"Organization\": [\"ACME Inc.\"],\n            \"OrganizationalUnit\": [\"Engineering\"],\n            \"PostalCode\": null,\n            \"Province\": null,\n            \"SerialNumber\": \"\",\n            \"StreetAddress\": null\n        }\n  }\n}\n</code></pre>"},{"location":"authorino/docs/features/#plain-authenticationplain","title":"Plain (<code>authentication.plain</code>)","text":"<p>Authorino can read plain identity objects, based on authentication tokens provided and verified beforehand using other means (e.g. Envoy JWT Authentication filter, Kubernetes API server authentication), and injected into the payload to the external authorization service.</p> <p>The plain identity object is retrieved from the Authorization JSON. See Common Expression Language (CEL).</p> <p>This feature is particularly useful in cases where authentication/identity verification is handled before invoking the authorization service and its resolved value injected in the payload can be trusted. Examples of applications for this feature include:</p> <ul> <li>Authentication handled in Envoy leveraging the Envoy JWT Authentication filter (decoded JWT injected as 'metadata_context')</li> <li>Use of Authorino as Kubernetes ValidatingWebhook service (Kubernetes 'userInfo' injected in the body of the <code>AdmissionReview</code> request)</li> </ul> <p>Example of <code>AuthConfig</code> to retrieve plain identity object from the Authorization JSON.</p> <pre><code>spec:\n  authentication:\n    \"pre-validated-jwt\":\n      plain:\n        expression: metadata.filter_metadata['envoy.filters.http.jwt_authn'].verified_jwt\n</code></pre> <p>If the specified JSON path does not exist in the Authorization JSON or the value is <code>null</code>, the identity verification will fail and, unless other identity config succeeds, Authorino will halt the Auth Pipeline with the usual <code>401 Unauthorized</code>.</p>"},{"location":"authorino/docs/features/#anonymous-access-authenticationanonymous","title":"Anonymous access (<code>authentication.anonymous</code>)","text":"<p>Literally a no-op evaluator for the identity verification phase that returns a static identity object <code>{\"anonymous\":true}</code>.</p> <p>It allows to implement <code>AuthConfigs</code> that bypasses the identity verification phase of Authorino, to such as:</p> <ul> <li>enable anonymous access to protected services (always or combined with Priorities)</li> <li>postpone authentication in the Auth Pipeline to be resolved as part of an OPA policy</li> </ul> <p>Example of <code>AuthConfig</code> spec that falls back to anonymous access when OIDC authentication fails, enforcing read-only access to the protected service in such cases:</p> <pre><code>spec:\n  authentication:\n    \"jwt\":\n      jwt:\n        issuerUrl: \"\u2026\"\n    \"anonymous\":\n      priority: 1 # expired oidc token, missing creds, etc. default to anonymous access\n      anonymous: {}\n  authorization:\n    \"read-only-access-if-authn-fails\":\n      when:\n\n      - predicate: has(auth.identity.anonymous) &amp;&amp; auth.identity.anonymous\n      patternMatching:\n        patterns:\n        - predicate: request.method == 'GET'\n</code></pre>"},{"location":"authorino/docs/features/#festival-wristband-authentication","title":"Festival Wristband authentication","text":"<p>Authorino-issued Festival Wristband tokens can be validated as any other signed JWT using Authorino's JWT verification.</p> <p>The value of the issuer must be the same issuer specified in the custom resource for the protected API originally issuing wristband. Eventually, this can be the same custom resource where the wristband is configured as a valid source of identity, but not necessarily.</p>"},{"location":"authorino/docs/features/#extra-auth-credentials-authenticationcredentials","title":"Extra: Auth credentials (<code>authentication.credentials</code>)","text":"<p>All the identity verification methods supported by Authorino can be configured regarding the location where access tokens and credentials (i.e. authentication secrets) fly within the request.</p> <p>By default, authentication secrets are expected to be supplied in the <code>Authorization</code> HTTP header, with the default <code>Bearer</code> prefix and the plain authentication secret separated by space.</p> <p>The full list of supported options is exemplified below:</p> <pre><code>spec:\n  authentication:\n    \"creds-in-the-authz-header\":\n      credentials:\n        authorizationHeader:\n          prefix: JWT\n\n    \"creds-in-a-custom-header\":\n      credentials:\n        customHeader:\n          name: X-MY-CUSTOM-HEADER\n          prefix: \"\"\n\n    \"creds-in-a-query-param\":\n      queryString:\n        name: my_param\n\n    \"creds-in-a-cookie-entry\":\n      cookie:\n        name: cookie-key\n</code></pre>"},{"location":"authorino/docs/features/#extra-identity-extension-authenticationdefaults-and-authenticationoverrides","title":"Extra: Identity extension (<code>authentication.defaults</code> and <code>authentication.overrides</code>)","text":"<p>Resolved identity objects can be extended with user-defined JSON properties. Values can be static or fetched from the Authorization JSON.</p> <p>A typical use-case for this feature is token normalization. Say you have more than one identity source listed in your <code>AuthConfig</code> but each source issues an access token with a different JSON structure \u2013 e.g. two OIDC issuers that use different names for custom JWT claims of similar meaning; when two different identity verification/authentication methods are combined, such as API keys (whose identity objects are the corresponding Kubernetes <code>Secret</code>s) and Kubernetes tokens (whose identity objects are Kubernetes UserInfo data).</p> <p>In such cases, identity extension can be used to normalize the token to always include the same set of JSON properties of interest, regardless of the source of identity that issued the original token verified by Authorino. This simplifies the writing of authorization policies and configuration of dynamic responses.</p> <p>In case of extending an existing property of the identity object (replacing), the API allows to control whether to overwrite the value or not. This is particularly useful for normalizing tokens of a same identity source that nonetheless may occasionally differ in structure, such as in the case of JWT claims that sometimes may not be present but can be safely replaced with another (e.g. <code>username</code> or <code>sub</code>).</p>"},{"location":"authorino/docs/features/#external-auth-metadata-features-metadata","title":"External auth metadata features (<code>metadata</code>)","text":""},{"location":"authorino/docs/features/#http-getget-by-post-metadatahttp","title":"HTTP GET/GET-by-POST (<code>metadata.http</code>)","text":"<p>Generic HTTP adapter that sends a request to an external service. It can be used to fetch external metadata for the authorization policies (phase ii of the Authorino Auth Pipeline), or as a web hook.</p> <p>The adapter allows issuing requests either by GET or POST methods; in both cases with URL and parameters defined by the user in the spec. Dynamic values fetched from the Authorization JSON can be used.</p> <p>POST request parameters as well as the encoding of the content can be controlled using the <code>bodyParameters</code> and <code>contentType</code> fields of the config, respectively. The Content-Type of POST requests can be either <code>application/x-www-form-urlencoded</code> (default) or <code>application/json</code>.</p> <p>Authentication of Authorino with the external metadata server can be set either via long-lived shared secret stored in a Kubernetes Secret or via OAuth2 client credentials grant. For long-lived shared secret, set the <code>sharedSecretRef</code> field. For OAuth2 client credentials grant, use the <code>oauth2</code> option.</p> <p>In both cases, the location where the secret (long-lived or OAuth2 access token) travels in the request performed to the external HTTP service can be specified in the <code>credentials</code> field. By default, the authentication secret is supplied in the <code>Authorization</code> header with the <code>Bearer</code> prefix.</p> <p>Custom headers can be set with the <code>headers</code> field. Nevertheless, headers such as <code>Content-Type</code> and <code>Authorization</code> (or eventual custom header used for carrying the authentication secret, set instead via the <code>credentials</code> option) will be superseded by the respective values defined for the fields <code>contentType</code> and <code>sharedSecretRef</code>.</p>"},{"location":"authorino/docs/features/#oidc-userinfo-metadatauserinfo","title":"OIDC UserInfo (<code>metadata.userInfo</code>)","text":"<p>Online fetching of OpenID Connect (OIDC) UserInfo data (phase ii of the Authorino Auth Pipeline), associated with an OIDC identity source configured and resolved in phase (i).</p> <p>Apart from possibly complementing information of the JWT, fetching OpenID Connect UserInfo in request-time can be particularly useful for remote checking the state of the session, as opposed to only verifying the JWT/JWS offline.</p> <p>Implementation requires a JWT verification authentication config (<code>spec.authentication.jwt</code>) in the same <code>AuthConfig</code>, so the well-known configuration of the OpenId Connect (OIDC) issuer can be reused.</p> <p>The response returned by the OIDC server to the UserInfo request is appended (as JSON) to <code>auth.metadata</code> in the authorization JSON.</p>"},{"location":"authorino/docs/features/#user-managed-access-uma-resource-registry-metadatauma","title":"User-Managed Access (UMA) resource registry (<code>metadata.uma</code>)","text":"<p>User-Managed Access (UMA) is an OAuth-based protocol for resource owners to allow other users to access their resources. Since the UMA-compliant server is expected to know about the resources, Authorino includes a client that fetches resource data from the server and adds that as metadata of the authorization payload.</p> <p>This enables the implementation of resource-level Attribute-Based Access Control (ABAC) policies. Attributes of the resource fetched in a UMA flow can be, e.g., the owner of the resource, or any business-level attributes stored in the UMA-compliant server.</p> <p>A UMA-compliant server is an external authorization server (e.g., Keycloak) where the protected resources are registered. It can be as well the upstream API itself, as long as it implements the UMA protocol, with initial authentication by <code>client_credentials</code> grant to exchange for a Protected API Token (PAT).</p> <p></p> <p>It's important to notice that Authorino does NOT manage resources in the UMA-compliant server. As shown in the flow above, Authorino's UMA client is only to fetch data about the requested resources. Authorino exchanges client credentials for a Protected API Token (PAT), then queries for resources whose URI match the path of the HTTP request (as passed to Authorino by the Envoy proxy) and fetches data of each matching resource.</p> <p>The resources data is added as metadata of the authorization payload and passed as input for the configured authorization policies. All resources returned by the UMA-compliant server in the query by URI are passed along. They are available in the PDPs (authorization payload) as <code>input.auth.metadata.custom-name =&gt; Array</code>. (See The \"Auth Pipeline\" for details.)</p>"},{"location":"authorino/docs/features/#authorization-features-authorization","title":"Authorization features (<code>authorization</code>)","text":""},{"location":"authorino/docs/features/#pattern-matching-authorization-authorizationpatternmatching","title":"Pattern-matching authorization (<code>authorization.patternMatching</code>)","text":"<p>Grant/deny access based on simple pattern-matching expressions (\"patterns\") compared against values selected from the Authorization JSON.</p> <p>Each expression is composed of exactly one of the following options:</p> <ol> <li>a <code>predicate</code> field - Common Expression Language (CEL) expression that evaluates to a boolean value;</li> <li>a tuple composed of:</li> <li><code>selector</code>: a JSON path to fetch a value from the Authorization JSON</li> <li><code>operator</code>: one of: <code>eq</code> (equals), <code>neq</code> (not equal); <code>incl</code> (includes) and <code>excl</code> (excludes), for arrays; and <code>matches</code>, for regular expressions</li> <li><code>value</code>: a static string value to compare the value selected from the Authorization JSON with;</li> <li>a <code>patternRef</code> field \u2013 value that maps to a predefined set of <code>{ selector, operator, value }</code> tuples stored at the top-level of the AuthConfig spec (<code>patterns</code>).</li> </ol> <p>Rules can mix and combine literal expressions and references to expression sets (\"named patterns\") defined at the upper level of the <code>AuthConfig</code> spec. (See Common feature: Conditions)</p> <pre><code>spec:\n  authorization:\n    \"my-simple-json-pattern-matching-policy\":\n      patternMatching:\n        patterns: # All patterns must match for access to be granted\n\n        - predicate: auth.identity.email_verified\n        - patternRef: admin\n\n  patterns:\n    admin: # a named pattern that can be reused in other sets of rules or conditions\n\n    - selector: auth.identity.roles\n      operator: incl\n      value: admin\n</code></pre>"},{"location":"authorino/docs/features/#open-policy-agent-opa-rego-policies-authorizationopa","title":"Open Policy Agent (OPA) Rego policies (<code>authorization.opa</code>)","text":"<p>You can model authorization policies in Rego language and add them as part of the protection of your APIs.</p> <p>Policies can be either declared in-line in Rego language (<code>rego</code>) or as an HTTP endpoint where Authorino will fetch the source code of the policy in reconciliation-time (<code>externalPolicy</code>).</p> <p>Policies pulled from external registries can be configured to be automatically refreshed (pulled again from the external registry), by setting the <code>authorization.opa.externalPolicy.ttl</code> field (given in seconds, default: <code>0</code> \u2013 i.e. auto-refresh disabled).</p> <p>Authorino's built-in OPA module precompiles the policies during reconciliation of the AuthConfig and caches the precompiled policies for fast evaluation in runtime, where they receive the Authorization JSON as input.</p> <p></p> <p>An optional field <code>allValues: boolean</code> makes the values of all rules declared in the Rego document to be returned in the OPA output after policy evaluation. When disabled (default), only the boolean value <code>allow</code> is returned. Values of internal rules of the Rego document can be referenced in subsequent policies/phases of the Auth Pipeline.</p>"},{"location":"authorino/docs/features/#kubernetes-subjectaccessreview-authorizationkubernetessubjectaccessreview","title":"Kubernetes SubjectAccessReview (<code>authorization.kubernetesSubjectAccessReview</code>)","text":"<p>Access control enforcement based on rules defined in the Kubernetes authorization system, i.e. <code>Role</code>, <code>ClusterRole</code>, <code>RoleBinding</code> and <code>ClusterRoleBinding</code> resources of Kubernetes RBAC.</p> <p>Authorino issues a SubjectAccessReview (SAR) inquiry that checks with the underlying Kubernetes server whether the user can access a particular resource, resource kind or generic URL.</p> <p>It supports resource attributes authorization check (parameters defined in the <code>AuthConfig</code>) and non-resource attributes authorization check (HTTP endpoint inferred from the original request).</p> <ul> <li>Resource attributes: adequate for permissions set at namespace level, defined in terms of common attributes of operations on Kubernetes resources (namespace, API group, kind, name, subresource, verb)</li> <li>Non-resource attributes: adequate for permissions set at cluster scope, defined for protected endpoints of a generic HTTP API (URL path + verb)</li> </ul> <p>Example of Kubernetes role for resource attributes authorization:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pet-reader\nrules:\n\n- apiGroups: [\"pets.io\"]\n  resources: [\"pets\"]\n  verbs: [\"get\"]\n</code></pre> <p>Example of Kubernetes cluster role for non-resource attributes authorization:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: pet-editor\nrules:\n\n- nonResourceURLs: [\"/pets/*\"]\n  verbs: [\"put\", \"delete\"]\n</code></pre> <p>Kubernetes' authorization policy configs look like the following in an Authorino <code>AuthConfig</code>:</p> <pre><code>authorization:\n  \"kubernetes-rbac\":\n    kubernetesSubjectAccessReview:\n      user: # values of the parameter can be fixed (`value`) or fetched from the Authorization JSON (`selector`)\n        expression: auth.identity.metadata.annotations.userid\n\n      groups: [] # user groups to test for.\n\n      # for resource attributes permission checks; omit it to perform a non-resource attributes SubjectAccessReview with path and method/verb assumed from the original request\n      # if included, use the resource attributes, where the values for each parameter can be fixed (`value`) or fetched from the Authorization JSON (`selector`)\n      resourceAttributes:\n        namespace:\n          value: default\n        group:\n          value: pets.io # the api group of the protected resource to be checked for permissions for the user\n        resource:\n          value: pets # the resource kind\n        name:\n          expression: request.path.split('/')[2] # resource name \u2013 e.g., the {id} in `/pets/{id}`\n        verb:\n          expression: request.method.lowerAscii() # api operation \u2013 e.g., copying from the context to use the same http method of the request\n</code></pre> <p><code>user</code> and properties of <code>resourceAttributes</code> can be defined from fixed values or patterns of the Authorization JSON.</p> <p>An array of <code>groups</code> (optional) can as well be set. When defined, it will be used in the <code>SubjectAccessReview</code> request.</p>"},{"location":"authorino/docs/features/#spicedb-authorizationspicedb","title":"SpiceDB (<code>authorization.spicedb</code>)","text":"<p>Check permission requests via gRPC with an external Google Zanzibar-inspired SpiceDB server, by Authzed.</p> <p>Subject, resource and permission parameters can be set to static values or read from the Authorization JSON.</p> <pre><code>spec:\n  authorization:\n    \"spicedb\":\n      spicedb:\n        endpoint: spicedb:50051\n        insecure: true # disables TLS\n        sharedSecretRef:\n          name: spicedb\n          key: token\n        subject:\n          kind:\n            value: blog/user\n          name:\n            expression: auth.identity.sub\n        resource:\n          kind:\n            value: blog/post\n          name:\n            expression: request.path.split('/')[2] # /posts/{id}\n        permission:\n          expression: request.method\n</code></pre>"},{"location":"authorino/docs/features/#custom-response-features-response","title":"Custom response features (<code>response</code>)","text":""},{"location":"authorino/docs/features/#custom-response-forms-successful-authorization-vs-custom-denial-status","title":"Custom response forms: successful authorization vs custom denial status","text":"<p>The response to the external authorization request can be customized in the following fashion:</p> <ul> <li>Successful authorization (<code>response.success</code>)</li> <li>Added HTTP headers (<code>response.success.headers</code>)</li> <li>Envoy Dynamic Metadata (<code>response.success.dynamicMetadata</code>)</li> <li>Custom denial status</li> <li>Unauthenticated (<code>response.unauthenticated</code>)</li> <li>Unauthorized (<code>response.unauthorized</code>)</li> </ul> <p>Successful authorization custom responses can be set based on any of the supported custom authorization methods:</p> <ul> <li>Plain text value</li> <li>JSON injection</li> <li>Festival Wristband Tokens</li> </ul>"},{"location":"authorino/docs/features/#added-http-headers","title":"Added HTTP headers","text":"<p>Set custom responses as HTTP headers injected in the request post-successful authorization by specifying one of the supported methods under <code>response.success.headers</code>.</p> <p>The name of the response config (default) or the value of the <code>key</code> option (if provided) will used as the name of the header.</p>"},{"location":"authorino/docs/features/#envoy-dynamic-metadata","title":"Envoy Dynamic Metadata","text":"<p>Authorino custom response methods can also be used to propagate Envoy Dynamic Metadata. To do so, set one of the supported methods under <code>response.success.dynamicMetadata</code>.</p> <p>The name of the response config (default) or the value of the <code>key</code> option (if provided) will used as the name of the root property of the dynamic metadata content.</p> <p>A custom response exported as Envoy Dynamic Metadata can be set in the Envoy route or virtual host configuration as input to a consecutive filter in the filter chain.</p> <p>E.g., to read metadata emitted by the authorization service with scheme <code>{ \"auth-data\": { \"api-key-ns\": string, \"api-key-name\": string } }</code>, as input in a rate limit configuration placed in the filter chain after the external authorization, the Envoy config may look like the following:</p> <pre><code># Envoy config snippet to inject `user_namespace` and `username` rate limit descriptors from metadata emitted by Authorino\nrate_limits:\n\n- actions:\n  - metadata:\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - key: auth-data # root of the dynamic metadata object, as declared in a custom response config of the AuthConfig (name or key)\n        - key: api-key-ns\n      descriptor_key: user_namespace\n  - metadata:\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - key: auth-data # root of the dynamic metadata object, as declared in a custom response config of the AuthConfig (name or key)\n        - key: api-key-name\n      descriptor_key: username\n</code></pre>"},{"location":"authorino/docs/features/#custom-denial-status-responseunauthenticated-and-responseunauthorized","title":"Custom denial status (<code>response.unauthenticated</code> and <code>response.unauthorized</code>)","text":"<p>By default, Authorino will inform Envoy to respond with <code>401 Unauthorized</code> or <code>403 Forbidden</code> respectively when the identity verification (phase i of the Auth Pipeline) or authorization (phase ii) fail. These can be customized respectively by specifying <code>spec.response.unauthanticated</code> and <code>spec.response.unauthorized</code> in the <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/features/#custom-response-methods","title":"Custom response methods","text":""},{"location":"authorino/docs/features/#plain-text-responsesuccessheadersdynamicmetadataplain","title":"Plain text (<code>response.success.&lt;headers|dynamicMetadata&gt;.plain</code>)","text":"<p>Simpler, yet more generalized form, for extending the authorization response for header mutation and Envoy Dynamic Metadata, based on plain text values.</p> <p>The value can be static:</p> <pre><code>response:\n  success:\n    headers:\n      \"x-auth-service\"\n        plain:\n          value: Authorino\n</code></pre> <p>or fetched dynamically from the Authorization JSON (which includes support for interpolation):</p> <pre><code>response:\n  success:\n    headers:\n      \"x-username\":\n        plain:\n          expression: auth.identity.username\n</code></pre>"},{"location":"authorino/docs/features/#json-injection-responsesuccessheadersdynamicmetadatajson","title":"JSON injection (<code>response.success.&lt;headers|dynamicMetadata&gt;.json</code>)","text":"<p>User-defined dynamic JSON objects generated by Authorino in the response phase, from static or dynamic data of the auth pipeline, and passed back to the external authorization client within added HTTP headers or Dynamic Metadata.</p> <p>The following Authorino <code>AuthConfig</code> custom resource is an example that defines 3 dynamic JSON response items, where two items are returned to the client, stringified, in added HTTP headers, and the third as Envoy Dynamic Metadata. Envoy proxy can be configured to propagate the dynamic metadata emitted by Authorino into another filter \u2013 e.g. the rate limit filter.</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  namespace: my-namespace\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"edge\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-my-custom-header\":\n          json:\n            properties:\n              \"prop1\":\n                value: value1\n              \"prop2\":\n                expression: some.path.within.auth.json\n        \"x-ext-auth-other-json\":\n          json:\n            properties:\n              \"propX\":\n                value: valueX\n\n      dynamicMetadata:\n        \"auth-data\":\n          json:\n            properties:\n              \"api-key-ns\":\n                expression: auth.identity.metadata.namespace\n              \"api-key-name\":\n                expression: auth.identity.metadata.name\n</code></pre>"},{"location":"authorino/docs/features/#festival-wristband-tokens-responsesuccessheadersdynamicmetadatawristband","title":"Festival Wristband tokens (<code>response.success.&lt;headers|dynamicMetadata&gt;.wristband</code>)","text":"<p>Festival Wristbands are signed OpenID Connect JSON Web Tokens (JWTs) issued by Authorino at the end of the auth pipeline and passed back to the client, typically in added HTTP response header. It is an opt-in feature that can be used to implement Edge Authentication Architecture (EAA) and enable token normalization. Authorino wristbands include minimal standard JWT claims such as <code>iss</code>, <code>iat</code>, and <code>exp</code>, and optional user-defined custom claims, whose values can be static or dynamically fetched from the authorization JSON.</p> <p>The Authorino <code>AuthConfig</code> custom resource below sets an API protection that issues a wristband after a successful authentication via API key. Apart from standard JWT claims, the wristband contains 2 custom claims: a static value <code>aud=internal</code> and a dynamic value <code>born</code> that fetches from the authorization JSON the date/time of creation of the secret that represents the API key used to authenticate.</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  namespace: my-namespace\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"edge\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-wristband\":\n          wristband:\n            issuer: https://authorino-oidc.default.svc:8083/my-namespace/my-api-protection/x-wristband\n            customClaims:\n              \"aud\":\n                value: internal\n              \"age\":\n                expression: int(request.time.seconds) - (timestamp(auth.identity.metadata.creationTimestamp) - timestamp(\"1970-01-01T00:00:00Z\")).getSeconds()\n            tokenDuration: 300\n            signingKeyRefs:\n            - name: my-signing-key\n              algorithm: ES256\n            - name: my-old-signing-key\n              algorithm: RS256\n</code></pre> <p>The signing key names listed in <code>signingKeyRefs</code> must match the names of Kubernetes <code>Secret</code> resources created in the same namespace, where each secret contains a <code>key.pem</code> entry that holds the value of the private key that will be used to sign the wristbands issued, formatted as PEM. The first key in this list will be used to sign the wristbands, while the others are kept to support key rotation.</p> <p>For each protected API configured for the Festival Wristband issuing, Authorino exposes the following OpenID Connect Discovery well-known endpoints (available for requests within the cluster):</p> <ul> <li>OpenID Connect configuration:   https://authorino-oidc.default.svc:8083/{namespace}/{api-protection-name}/{response-config-name}/.well-known/openid-configuration</li> <li>JSON Web Key Set (JWKS) well-known endpoint:   https://authorino-oidc.default.svc:8083/{namespace}/{api-protection-name}/{response-config-name}/.well-known/openid-connect/certs</li> </ul>"},{"location":"authorino/docs/features/#callbacks-callbacks","title":"Callbacks (<code>callbacks</code>)","text":""},{"location":"authorino/docs/features/#http-endpoints-callbackshttp","title":"HTTP endpoints (<code>callbacks.http</code>)","text":"<p>Sends requests to specified HTTP endpoints at the end of the auth pipeline.</p> <p>The scheme of the <code>http</code> field is the same as of <code>metadata.http</code>.</p> <p>Example:</p> <pre><code>spec:\n  authentication: [\u2026]\n  authorization: [\u2026]\n\n  callbacks:\n    \"log\":\n      http:\n        url: http://logsys\n        method: POST\n        body:\n          expression: |\n            { \"requestId\": request.id, \"username\": auth.identity.username, \"authorizationResult\": auth.authorization }\n    \"important-forbidden\":\n      when:\n\n      - predicate: \"!auth.authorization.important-policy\"\n      http:\n        urlExpression: |\n          \"http://monitoring/important?forbidden-user=\" + auth.identity.username\n</code></pre>"},{"location":"authorino/docs/features/#common-feature-priorities","title":"Common feature: Priorities","text":"<p>Priorities allow to set sequence of execution for blocks of concurrent evaluators within phases of the Auth Pipeline.</p> <p>Evaluators of same priority execute concurrently to each other \"in a block\". After syncing that block (i.e. after all evaluators of the block have returned), the next block of evaluator configs of consecutive priority is triggered.</p> <p>Use cases for priorities are:</p> <ol> <li>Saving expensive tasks to be triggered when there's a high chance of returning immediately after finishing executing a less expensive one \u2013 e.g.<ul> <li>an identity config that calls an external IdP to verify a token that is rarely used, compared to verifying JWTs preferred by most users of the service;</li> <li>an authorization policy that performs some quick checks first, such as verifying allowed paths, and only if it passes, moves to the evaluation of a more expensive policy.</li> </ul> </li> <li>Establishing dependencies between evaluators - e.g.<ul> <li>an external metadata request that needs to wait until a previous metadata responds first (in order to use data from the response)</li> </ul> </li> </ol> <p>Priorities can be set using the <code>priority</code> property available in all evaluator configs of all phases of the Auth Pipeline (identity, metadata, authorization and response). The lower the number, the highest the priority. By default, all evaluators have priority 0 (i.e. highest priority).</p> <p>Consider the following example to understand how priorities work:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api\n  authentication:\n    \"tier-1\":\n      priority: 0\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"1\"\n    \"tier-2\":\n      priority: 1\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"2\"\n    \"tier-3\":\n      priority: 1\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"3\"\n  metadata:\n    \"first\":\n      http:\n        url: http://talker-api:3000\n    \"second\":\n      priority: 1\n      http:\n        url: http://talker-api:3000/first_uuid={auth.metadata.first.uuid}\n  authorization:\n    \"allowed-endpoints\":\n      when:\n      - predicate: |\n          !(request.path in ['/hi', '/hello', '/aloha', '/ciao'])\n      patternMatching:\n        patterns:\n        - pattern: \"true\"\n    \"more-expensive-policy\": # no point in evaluating this one if it's not an allowed endpoint\n      priority: 1\n      opa:\n        rego: |\n          allow { true }\n  response:\n    success:\n      headers:\n        \"x-auth-data\":\n          json:\n            properties:\n              \"tier\":\n                expression: auth.identity.metadata.labels.tier\n              \"first-uuid\":\n                expression: auth.metadata.first.uuid\n              \"second-uuid\":\n                expression: auth.metadata.second.uuid\n              \"second-path\":\n                expression: auth.metadata.second.path\n</code></pre> <p>For the <code>AuthConfig</code> above,</p> <ul> <li> <p>Identity configs <code>tier-2</code> and <code>tier-3</code> (priority 1) will only trigger (concurrently) in case <code>tier-1</code> (priority 0) fails to validate the authentication token first. (This behavior happens without prejudice of context canceling between concurrent evaluators \u2013 i.e. evaluators that are triggered concurrently to another, such as <code>tier-2</code> and <code>tier-3</code>, continue to cancel the context of each other if any of them succeeds validating the token first.)</p> </li> <li> <p>Metadata source <code>second</code> (priority 1) uses the response of the request issued by metadata source <code>first</code> (priority 0), so it will wait for <code>first</code> to finish by triggering only in the second block.</p> </li> <li> <p>Authorization policy <code>allowed-endpoints</code> (priority 0) is considered to be a lot less expensive than <code>more-expensive-policy</code> (priority 1) and has a high chance of denying access to the protected service (if the path is not one of the allowed endpoints). By setting different priorities to these policies we ensure the more expensive policy if triggered in sequence of the less expensive one, instead of concurrently.</p> </li> </ul>"},{"location":"authorino/docs/features/#common-feature-conditions-when","title":"Common feature: Conditions (<code>when</code>)","text":"<p>Conditions, identified by the <code>when</code> field in the AuthConfig API, are logical expressions (\"predicates\") that can be used to condition the evaluation of a particular auth rule, as well as of the AuthConfig altogether (\"top-level conditions\").</p> <p>The predicates are evaluated against the Authorization JSON, where each predicate is composed of exactly one of the following options:</p> <ol> <li>a <code>predicate</code> field \u2013 CEL expression that evaluates to a boolean value;</li> <li>a tuple composed of:</li> <li><code>selector</code>: a JSON path to fetch a value from the Authorization JSON</li> <li><code>operator</code>: one of: <code>eq</code> (equals); <code>neq</code> (not equal); <code>incl</code> (includes) and <code>excl</code> (excludes), for when the value fetched from the Authorization JSON is expected to be an array; <code>matches</code>, for regular expressions</li> <li><code>value</code>: a static string value to compare the value selected from the Authorization JSON with;</li> <li>a <code>patternRef</code> field \u2013 value that maps to a predefined set of <code>{ selector, operator, value }</code> tuples stored at the top-level of the AuthConfig spec (<code>patterns</code>).</li> </ol> <p>An expression contains one or more patterns and they must either all evaluate to true (\"AND\" operator, declared by grouping the patterns within an <code>all</code> block) or at least one of the patterns must be true (\"OR\" operator, when grouped within an <code>any</code> block.) Patterns not explicitly grouped are AND'ed by default.</p> <p>Examples of <code>when</code> conditions</p> <p>i) to skip an entire <code>AuthConfig</code> based on the context (AND operator assumed by default):</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/*\n\n  - predicate: request.method == 'POST' &amp;&amp; request.path.matches(\"^/resources/.*\")\n</code></pre> <p>ii) equivalent to the above using <code>{ selector, operator, value }</code> tuples and an explicit AND operator (<code>all</code>):</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/*\n\n  - all:\n    - selector: request.method\n      operator: eq\n      value: POST\n    - selector: request.path\n      operator: matches\n      value: ^/resources/.*\n</code></pre> <p>iii) OR condition (<code>any</code>) using <code>{ selector, operator, value }</code> tuples:</p> <pre><code>spec:\n  when: # auth enforced only on requests with HTTP method equals to POST or PUT\n\n  - any:\n    - selector: request.method\n      operator: eq\n      value: POST\n    - selector: request.method\n      operator: eq\n      value: PUT\n</code></pre> <p>iv) complex expression with nested operations using <code>{ selector, operator, value }</code> tuples:</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/* or PUT /resources/*\n\n  - any:\n    - all:\n      - selector: request.method\n        operator: eq\n        value: POST\n      - selector: request.path\n        operator: matches\n        value: ^/resources/.*\n    - all:\n      - selector: request.method\n        operator: eq\n        value: PUT\n      - selector: request.path\n        operator: matches\n        value: ^/resources/.*\n</code></pre> <p>v) more concise equivalent of the above using CEL:</p> <pre><code>spec:\n  when: # auth enforced only on requests to /resources/* path with method equals to POST or PUT\n\n  - predicate: request.path .matches(\"^/resources/.*\") &amp;&amp; request.method in ['POST', 'PUT']\n</code></pre> <p>vi) to skip part of an AuthConfig (i.e., a specific auth rule):</p> <pre><code>spec:\n  metadata:\n    \"metadata-source\":\n      http:\n        url: https://my-metadata-source.io\n      when: # only fetch the external metadata if the context is HTTP method other than OPTIONS\n\n      - predicate: request.method != 'OPTIONS'\n</code></pre> <p>vii) skipping part of an AuthConfig will not affect other auth rules:</p> <pre><code>spec:\n  authentication:\n    \"authn-meth-1\":\n      apiKey: {\u2026} # this auth rule only triggers for POST requests to /foo[/*]\n      when:\n\n      - predicate: request.method == 'POST' &amp;&amp; request.path.matches(\"^/foo(/.*)?$\")\n\n    \"authn-meth-2\": # this auth rule triggerred regardless\n      jwt: {\u2026}\n</code></pre> <p>viii) concrete use-case: evaluating only the necessary identity checks based on the user's indication of the preferred authentication method (prefix of the value supplied in the HTTP <code>Authorization</code> request header):</p> <pre><code>spec:\n  authentication:\n    \"jwt\":\n      when:\n\n      - predicate: request.headers['authorization'].startsWith('JWT')\n      jwt: {\u2026}\n\n    \"api-key\":\n      when:\n\n      - predicate: request.headers['authorization'].startsWith('APIKEY')\n      apiKey: {\u2026}\n</code></pre> <p>ix) to avoid repetition while defining patterns for conditions:</p> <pre><code>spec:\n  patterns:\n    a-pet: # a named pattern that can be reused in sets of conditions\n\n    - selector: context.request.http.path\n      operator: matches\n      value: ^/pets/\\d+(/.*)$\n\n  metadata:\n    \"pets-info\":\n      when:\n\n      - patternRef: a-pet\n      http:\n        urlExpression: |\n          \"https://pets-info.io?petId=\" + request.path.split('/')[2]\n\n  authorization:\n    \"pets-owners-only\":\n      when:\n\n      - patternRef: a-pet\n      opa:\n        rego: |\n          allow { input.metadata[\"pets-info\"].ownerid == input.auth.identity.userid }\n</code></pre> <p>x) combining literals and refs \u2013 concrete case: authentication required for selected operations:</p> <pre><code>spec:\n  patterns:\n    api-base-path:\n\n    - selector: request.path\n      operator: matches\n      value: ^/api/.*\n\n    authenticated-user:\n\n    - selector: auth.identity.anonymous\n      operator: neq\n      value: \"true\"\n\n  authentication:\n    api-users: # tries to authenticate all requests to path /api/*\n      when:\n\n      - patternRef: api-base-path\n      jwt: {\u2026}\n\n    others: # defaults to anonymous access when authentication fails or not /api/* path\n      anonymous: {}\n      priority: 1\n\n  authorization:\n    api-write-access-requires-authentication: # POST/PUT/DELETE requests to /api/* path cannot be anonymous\n      when:\n\n      - patternRef: api-base-path\n      - predicate: request.method in ['POST', 'PUT', 'DELETE']\n      opa:\n        patternMatching:\n          rules:\n          - patternRef: authenticated-user\n\n  response: # bonus: export user data if available\n    success:\n      dynamicMetadata:\n        \"user-data\":\n          when:\n\n          - patternRef: authenticated-user\n          json:\n            properties:\n              jwt-claims:\n                expression: auth.identity\n</code></pre>"},{"location":"authorino/docs/features/#common-feature-caching-cache","title":"Common feature: Caching (<code>cache</code>)","text":"<p>Objects resolved at runtime in an Auth Pipeline can be cached \"in-memory\", and avoided being evaluated again at a subsequent request, until it expires. A lookup cache key and a TTL can be set individually for any evaluator config in an AuthConfig.</p> <p>Each cache config induces a completely independent cache table (or \"cache namespace\"). Consequently, different evaluator configs can use the same cache key and there will be no collision between entries from different evaluators.</p> <p>E.g.:</p> <pre><code>spec:\n  hosts:\n\n  - my-api.io\n\n  authentication: [\u2026]\n\n  metadata:\n    \"external-metadata\":\n      http:\n        urlExpression: |\n          \"http://my-external-source?search=\" + request.path\n      cache:\n        key:\n          expression: request.path\n        ttl: 300\n\n  authorization:\n    \"complex-policy\":\n      opa:\n        externalPolicy:\n          url: http://my-policy-registry\n      cache:\n        key:\n          expression: auth.identity.group + '-' + request.method + '-' + request.path\n        ttl: 60\n</code></pre> <p>The example above sets caching for the 'external-metadata' metadata config and for the 'complex-policy' authorization policy. In the case of 'external-metadata', the cache key is the path of the original HTTP request being authorized by Authorino (fetched dynamically from the Authorization JSON); i.e., after obtaining a metadata object from the external source for a given contextual HTTP path one first time, whenever that same HTTP path repeats in a subsequent request, Authorino will use the cached object instead of sending a request again to the external source of metadata. After 5 minutes (300 seconds), the cache entry will expire and Authorino will fetch again from the source if requested.</p> <p>As for the 'complex-policy' authorization policy, the cache key is a string composed the 'group' the identity belongs to, the method of the HTTP request and the path of the HTTP request. Whenever these repeat, Authorino will use the result of the policy that was evaluated and cached priorly. Cache entries in this namespace expire after 60 seconds.</p> <p>Notes on evaluator caching</p> <p>Capacity - By default, each cache namespace is limited to 1 mb. Entries will be evicted following First-In-First-Out (FIFO) policy to release space. The individual capacity of cache namespaces is set at the level of the Authorino instance (via <code>--evaluator-cache-size</code> command-line flag or <code>spec.evaluatorCacheSize</code> field of the <code>Authorino</code> CR).</p> <p>Usage - Avoid caching objects whose evaluation is considered to be relatively cheap. Examples of operations associated to Authorino auth features that are usually NOT worth caching: validation of JSON Web Tokens (JWT), Kubernetes TokenReviews and SubjectAccessReviews, API key validation, simple JSON pattern-matching authorization rules, simple OPA policies. Examples of operations where caching may be desired: OAuth2 token introspection, fetching of metadata from external sources (via HTTP request), complex OPA policies.</p>"},{"location":"authorino/docs/features/#common-feature-metrics-metrics","title":"Common feature: Metrics (<code>metrics</code>)","text":"<p>By default, Authorino will only export metrics down to the level of the AuthConfig. Deeper metrics at the level of each evaluator within an AuthConfig can be activated by setting the common field <code>metrics: true</code> of the evaluator config.</p> <p>E.g.:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-authconfig\n  namespace: my-ns\nspec:\n  metadata:\n    \"my-external-metadata\":\n      http:\n        url: http://my-external-source?search={request.path}\n      metrics: true\n</code></pre> <p>The above will enable the metrics <code>auth_server_evaluator_duration_seconds</code> (histogram) and <code>auth_server_evaluator_total</code> (counter) with labels <code>namespace=\"my-ns\"</code>, <code>authconfig=\"my-authconfig\"</code>, <code>evaluator_type=\"METADATA_GENERIC_HTTP\"</code> and <code>evaluator_name=\"my-external-metadata\"</code>.</p> <p>The same pattern works for other types of evaluators. Find below the list of all types and corresponding label constant used in the metric:</p> Evaluator type Metric's <code>evaluator_type</code> label <code>authentication.apiKey</code> IDENTITY_APIKEY <code>authentication.kubernetesTokenReview</code> IDENTITY_KUBERNETES <code>authentication.jwt</code> IDENTITY_OIDC <code>authentication.oauth2Introspection</code> IDENTITY_OAUTH2 <code>authentication.x509</code> IDENTITY_MTLS <code>authentication.plain</code> IDENTITY_PLAIN <code>authentication.anonymous</code> IDENTITY_NOOP <code>metadata.http</code> METADATA_GENERIC_HTTP <code>metadata.userInfo</code> METADATA_USERINFO <code>metadata.uma</code> METADATA_UMA <code>authorization.patternMatching</code> AUTHORIZATION_JSON <code>authorization.opa</code> AUTHORIZATION_OPA <code>authorization.kubernetesSubjectAccessReview</code> AUTHORIZATION_KUBERNETES <code>authorization.spicedb</code> AUTHORIZATION_AUTHZED <code>response.success..plain</code> RESPONSE_PLAIN <code>response.success..json</code> RESPONSE_JSON <code>response.success..wristband</code> RESPONSE_WRISTBAND <p>Metrics at the level of the evaluators can also be enforced to an entire Authorino instance, by setting the <code>--deep-metrics-enabled</code> command-line flag. In this case, regardless of the value of the field <code>spec.(authentication|metadata|authorization|response).metrics</code> in the AuthConfigs, individual metrics for all evaluators of all AuthConfigs will be exported.</p> <p>For more information about metrics exported by Authorino, see Observability.</p>"},{"location":"authorino/docs/getting-started/","title":"Getting started","text":"<p>This page covers requirements and instructions to deploy Authorino on a Kubernetes cluster, as well as the steps to declare, apply and try out a protection layer of authentication and authorization over your service, clean-up and complete uninstallation.</p> <p>If you prefer learning with an example, check out our Hello World.</p>"},{"location":"authorino/docs/getting-started/#requirements","title":"Requirements","text":""},{"location":"authorino/docs/getting-started/#platform-requirements","title":"Platform requirements","text":"<p>These are the platform requirements to use Authorino:</p> <ul> <li> <p>Kubernetes server (recommended v1.21 or later), with permission to create Kubernetes Custom Resource Definitions (CRDs) (for bootstrapping Authorino and Authorino Operator)</p> <p> Alternative: K8s distros and platforms <p>Alternatively to upstream Kubernetes, you should be able to use any other Kubernetes distribution or Kubernetes Management Platform (KMP) with support for Kubernetes Custom Resources Definitions (CRD) and custom controllers, such as Red Hat OpenShift, IBM Cloud Kubernetes Service (IKS), Google Kubernetes Engine (GKE), Amazon Elastic Kubernetes Service (EKS) and Azure Kubernetes Service (AKS). </p> <li> <p>Envoy proxy (recommended v1.19 or later), to wire up Upstream services (i.e. the services to be protected with Authorino) and external authorization filter (Authorino) for integrations based on the reverse-proxy architecture - example</p> <p> Alternative: Non-reverse-proxy integration <p>Technically, any client that implements Envoy's external authorization gRPC protocol should be compatible with Authorino. For integrations based on the reverse-proxy architecture nevertheless, we strongly recommended that you leverage Envoy alongside Authorino. </p>"},{"location":"authorino/docs/getting-started/#feature-specific-requirements","title":"Feature-specific requirements","text":"<p>A few examples are:</p> <ul> <li> <p>For OpenID Connect, make sure you have access to an identity provider (IdP) and an authority that can issue ID tokens (JWTs). Check out Keycloak which can solve both and connect to external identity sources and user federation like LDAP.</p> </li> <li> <p>For Kubernetes authentication tokens, platform support for the TokenReview and SubjectAccessReview APIs of Kubernetes shall be required. In case you want to be able to requests access tokens for clients running outside the custer, you may also want to check out the requisites for using Kubernetes TokenRequest API (GA in v1.20).</p> </li> <li> <p>For User-Managed Access (UMA) resource data, you will need a UMA-compliant server running as well. This can be an implementation of the UMA protocol by each upstream API itself or (more typically) an external server that knows about the resources. Again, Keycloak can be a good fit here as well. Just keep in mind that, whatever resource server you choose, changing-state actions commanded in the upstream APIs or other parties will have to be reflected in the resource server. Authorino will not do that for you.</p> </li> </ul> <p>Check out the Feature specification page for more feature-specific requirements.</p>"},{"location":"authorino/docs/getting-started/#installation","title":"Installation","text":""},{"location":"authorino/docs/getting-started/#step-install-the-authorino-operator","title":"Step: Install the Authorino Operator","text":"<p>The simplest way to install the Authorino Operator is by applying the manifest bundle:</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre> <p>The above will install the latest build of the Authorino Operator and latest version of the manifests (CRDs and RBAC), which by default points as well to the latest build of Authorino, both based on the <code>main</code> branches of each component. To install a stable released version of the Operator and therefore also defaults to its latest compatible stable release of Authorino, replace <code>main</code> with another tag of a proper release of the Operator, e.g. 'v0.2.0'.</p> <p>This step will also install cert-manager in the cluster (required).</p> <p>Alternatively, you can deploy the Authorino Operator using the Operator Lifecycle Manager bundles. For instructions, check out Installing via OLM.</p>"},{"location":"authorino/docs/getting-started/#step-request-an-authorino-instance","title":"Step: Request an Authorino instance","text":"<p>Choose either cluster-wide or namespaced deployment mode and whether you want TLS termination enabled for the Authorino endpoints (gRPC authorization, raw HTTP authorization, and OIDC Festival Wristband Discovery listeners), and follow the corresponding instructions below.</p> <p>The instructions here are for centralized gateway or centralized authorization service architecture. Check out the Topologies section of the docs for alternatively running Authorino in a sidecar container.</p> Cluster-wide (with TLS) <p>Create the namespace:   <pre><code>kubectl create namespace authorino\n</code></pre></p> <p>Create the TLS certificates (requires cert-manager; skip if you already have certificates and certificate keys created and stored in Kubernetes <code>Secret</code>s in the namespace):   <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/authorino/g\" | kubectl -n authorino apply -f -\n</code></pre></p> <p>Deploy Authorino:   <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  replicas: 1\n  clusterWide: true\n  listener:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre></p> Cluster-wide (without TLS) <pre><code>kubectl create namespace authorino\nkubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: true\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> Namespaced (with TLS) <p>Create the namespace:   <pre><code>kubectl create namespace myapp\n</code></pre></p> <p>Create the TLS certificates (requires cert-manager; skip if you already have certificates and certificate keys created and stored in Kubernetes <code>Secret</code>s in the namespace):   <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/myapp/g\" | kubectl -n myapp apply -f -\n</code></pre></p> <p>Deploy Authorino:   <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: false\n  listener:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre></p> Namespaced (without TLS) <pre><code>kubectl create namespace myapp\nkubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: false\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/getting-started/#protect-a-service","title":"Protect a service","text":"<p>The most typical integration to protect services with Authorino is by putting the service (upstream) behind a reverse-proxy or API gateway, enabled with an authorization filter that ensures all requests to the service are first checked with the authorization server (Authorino).</p> <p>To do that, make sure you have your upstream service deployed and running, usually in the same Kubernetes server where you installed Authorino. Then, setup an Envoy proxy and create an Authorino <code>AuthConfig</code> for your service.</p> <p>Authorino exposes 2 interfaces to serve the authorization requests:</p> <ul> <li>a gRPC interface that implements Envoy's External Authorization protocol;</li> <li>a raw HTTP authorization interface, suitable for using Authorino with Kubernetes ValidatingWebhook, for Envoy external authorization via HTTP, and other integrations (e.g. other proxies).</li> </ul> <p>To use Authorino as a simple satellite (sidecar) Policy Decision Point (PDP), applications can integrate directly via any of these interfaces. By integrating via a proxy or API gateway, the combination makes Authorino to perform as an external Policy Enforcement Point (PEP) completely decoupled from the application.</p>"},{"location":"authorino/docs/getting-started/#life-cycle","title":"Life cycle","text":""},{"location":"authorino/docs/getting-started/#step-setup-envoy","title":"Step: Setup Envoy","text":"<p>To configure Envoy for proxying requests targeting the upstream service and authorizing with Authorino, setup an Envoy configuration that enables Envoy's external authorization HTTP filter. Store the configuration in a <code>ConfigMap</code>.</p> <p>These are the important bits in the Envoy configuration to activate Authorino:</p> <pre><code>static_resources:\n  listeners:\n\n  - address: {\u2026} # TCP socket address and port of the proxy\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          route_config: {\u2026} # routing configs - virtual host domain and endpoint matching patterns and corresponding upstream services to redirect the traffic\n          http_filters:\n          - name: envoy.filters.http.ext_authz # the external authorization filter\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n              transport_api_version: V3\n              failure_mode_allow: false # ensures only authenticated and authorized traffic goes through\n              grpc_service:\n                envoy_grpc:\n                  cluster_name: authorino\n                timeout: 1s\n  clusters:\n  - name: authorino\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: authorino\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: authorino-authorino-authorization # name of the Authorino service deployed \u2013 it can be the fully qualified name with `.&lt;namespace&gt;.svc.cluster.local` suffix (e.g. `authorino-authorino-authorization.myapp.svc.cluster.local`)\n                port_value: 50051\n    transport_socket: # in case TLS termination is enabled in Authorino; omit it otherwise\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: /etc/ssl/certs/authorino-ca-cert.crt\n</code></pre> <p>For a complete Envoy <code>ConfigMap</code> containing an upstream API protected with Authorino, with TLS enabled and option for rate limiting with Limitador, plus a webapp served with under the same domain of the protected API, check out this example.</p> <p>After creating the <code>ConfigMap</code> with the Envoy configuration, create an Envoy <code>Deployment</code> and <code>Service</code>. E.g.:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: envoy\n  labels:\n    app: envoy\nspec:\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n\n        - name: envoy\n          image: envoyproxy/envoy:v1.19-latest\n          command: [\"/usr/local/bin/envoy\"]\n          args:\n            - --config-path /usr/local/etc/envoy/envoy.yaml\n            - --service-cluster front-proxy\n            - --log-level info\n            - --component-log-level filter:trace,http:debug,router:debug\n          ports:\n            - name: web\n              containerPort: 8000 # matches the address of the listener in the envoy config\n          volumeMounts:\n            - name: config\n              mountPath: /usr/local/etc/envoy\n              readOnly: true\n            - name: authorino-ca-cert # in case TLS termination is enabled in Authorino; omit it otherwise\n              subPath: ca.crt\n              mountPath: /etc/ssl/certs/authorino-ca-cert.crt\n              readOnly: true\n      volumes:\n        - name: config\n          configMap:\n            name: envoy\n            items:\n              - key: envoy.yaml\n                path: envoy.yaml\n        - name: authorino-ca-cert # in case TLS termination is enabled in Authorino; omit it otherwise\n          secret:\n            defaultMode: 420\n            secretName: authorino-ca-cert\n  replicas: 1\nEOF\n</code></pre> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\nspec:\n  selector:\n    app: envoy\n  ports:\n\n    - name: web\n      port: 8000\n      protocol: TCP\nEOF\n</code></pre>"},{"location":"authorino/docs/getting-started/#step-apply-an-authconfig","title":"Step: Apply an <code>AuthConfig</code>","text":"<p>Check out the docs for a full description of Authorino's <code>AuthConfig</code> Custom Resource Definition (CRD) and its features.</p> <p>For examples based on specific use-cases, check out the User guides.</p> <p>For authentication based on OpenID Connect (OIDC) JSON Web Tokens (JWT), plus one simple JWT claim authorization check, a typical <code>AuthConfig</code> custom resource looks like the following:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts: # any hosts that resolve to the envoy service and envoy routing config where the external authorization filter is enabled\n\n  - my-api.io # north-south traffic through a Kubernetes `Ingress` or OpenShift `Route`\n  - my-api.myapp.svc.cluster.local # east-west traffic (between applications within the cluster)\n  authentication:\n    \"idp-users\":\n      jwt:\n        issuerUrl: https://my-idp.com/auth/realm\n  authorization:\n    \"check-claim\":\n      patternMatching:\n        patterns:\n        - selector: auth.identity.group\n          operator: eq\n          value: allowed-users\nEOF\n</code></pre> <p>After applying the <code>AuthConfig</code>, consumers of the protected service should be able to start sending requests.</p>"},{"location":"authorino/docs/getting-started/#clean-up","title":"Clean-up","text":""},{"location":"authorino/docs/getting-started/#remove-protection","title":"Remove protection","text":"<p>Delete the <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp delete authconfig/my-api-protection\n</code></pre> <p>Decommission the Authorino instance:</p> <pre><code>kubectl -n myapp delete authorino/authorino\n</code></pre>"},{"location":"authorino/docs/getting-started/#uninstall","title":"Uninstall","text":"<p>To completely remove Authorino CRDs, run from the Authorino Operator directory:</p> <pre><code>make uninstall\n</code></pre>"},{"location":"authorino/docs/getting-started/#next-steps","title":"Next steps","text":"<ol> <li>Read the docs. The Architecture page and the Features page are good starting points to learn more about how Authorino works and its functionalities.</li> <li>Check out the User guides for several examples of <code>AuthConfig</code>s based on specific use-cases</li> </ol>"},{"location":"authorino/docs/terminology/","title":"Terminology","text":"<p>Here we define some terms that are used in the project, with the goal of avoiding confusion and facilitating more accurate conversations related to <code>Authorino</code>.</p> <p>If you see terms used that are not here (or are used in place of terms here) please consider contributing a definition to this doc with a PR, or modifying the use elsewhere to align with these terms.</p>"},{"location":"authorino/docs/terminology/#terms","title":"Terms","text":"<p>Access token Type of temporary password (security token), tied to an authenticated identity, issued by an auth server as of request from either the identity subject itself or a registered auth client known by the auth server, and that delegates to a party powers to operate on behalf of that identity before a resource server; it can be formatted  as an opaque data string or as an encoded JSON Web Token (JWT).</p> <p>Application Programming Interface (API) Interface that defines interactions between multiple software applications; (in HTTP communication) set of endpoints and specification to expose resources hosted by a resource server, to be consumed by client applications; the access facade of a resource server.</p> <p>Attribute-based Access Control (ABAC) Authorization model that grants/denies access to resources based on evaluation of authorization policies which combine attributes together (from claims, from the request, from the resource, etc).</p> <p>Auth Usually employed as a short for authentication and authorization together (AuthN/AuthZ).</p> <p>Auth client Application client (software) that uses an auth server, either in the process of authenticating and/or authorizing identity subjects (including self) who want to consume resources from a resources server or auth server.</p> <p>Auth server Server where auth clients, users, roles, scopes, resources, policies and permissions can be stored and managed.</p> <p>Authentication (AuthN) Process of verifying that a given credential belongs to a claimed-to-be identity; usually resulting in the issuing of an access token.</p> <p>Authorization (AuthZ) Process of granting (or denying) access over a resource to a party based on the set of authorization rules, policies and/or permissions enforced.</p> <p>Authorization header HTTP request header frequently used to carry credentials to authenticate a user in an HTTP communication, like in requests sent to an API; alternatives usually include credentials carried in another (custom) HTTP header, query string parameter or HTTP cookie.</p> <p>Capability Usually employed to refer to a management feature of a Kubernetes-native system, based on the definition and use of Kubernetes Custom Resources (CRDs and CRs), that enables that system to one of the following \u201ccapability levels\u201d: Basic Install, Seamless Upgrades, Full Lifecycle, Deep Insights, Auto Pilot.</p> <p>Claim Attribute packed in a security token which represents a claim that one who bears the token is making about an entity, usually an identity subject.</p> <p>Client ID Unique identifier of an auth client within an auth server domain (or auth server realm).</p> <p>Client secret Password presented by auth clients together with their Client IDs while authenticating with an auth server, either when requesting access tokens to be issued or when consuming services from the auth servers in general.</p> <p>Delegation Process of granting a party (usually an auth client) with powers to act, often with limited scope, on behalf of an identity, to access resources from a resource server. See also OAuth2.</p> <p>Hash-based Message Authentication Code (HMAC) Specific type of message authentication code (MAC) that involves a cryptographic hash function and a shared secret cryptographic key; it can be used to verify the authenticity of a message and therefore as an authentication method.</p> <p>Identity Set of properties that qualifies a subject as a strong identifiable entity (usually a user), who can be authenticated by an auth server. See also Claims.</p> <p>Identity and Access Management (IAM) system Auth system that implements and/or connects with sources of identity (IdP) and offers interfaces for managing access (authorization policies and permissions). See also Auth server.</p> <p>Identity Provider (IdP) Source of identity; it can be a feature of an auth server or external source connected to an auth server.</p> <p>ID token Special type of access token; an encoded JSON Web Token (JWT) that packs claims about an identity.</p> <p>JSON Web Token (JWT) JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.</p> <p>JSON Web Signature (JWS) Standard for signing arbitrary data, especially JSON Web Tokens (JWT).</p> <p>JSON Web Key Set (JWKS) Set of keys containing the public keys used to verify any JSON Web Token (JWT).</p> <p>Keycloak Open source auth server to allow single sign-on with identity and access management.</p> <p>Lightweight Directory Access Protocol (LDAP) Open standard for distributed directory information services for sharing of information about users, systems, networks, services and applications.</p> <p>Mutual Transport Layer Security (mTLS) Protocol for the mutual authentication of client-server communication, i.e., the client authenticates the server and the server authenticates the client, based on the acceptance of the X.509 certificates of each party.</p> <p>OAuth 2.0 (OAuth2) Industry-standard protocol for delegation.</p> <p>OpenID Connect (OIDC) Simple identity verification (authentication) layer built on top of the OAuth2 protocol.</p> <p>Open Policy Agent (OPA) Authorization policy agent that enables the usage of declarative authorization policies written in Rego language.</p> <p>Opaque token Security token devoid of explicit meaning (e.g. random string); it requires the usage of lookup mechanism to be translated into a meaningful set claims representing an identity.</p> <p>Permission Association between a protected resource the authorization policies that must be evaluated whether access should be granted; e.g. <code>&lt;user|group|role&gt;</code> CAN DO <code>&lt;action&gt;</code> ON RESOURCE <code>&lt;X&gt;</code>.</p> <p>Policy Rule or condition (authorization policy) that must be satisfied to grant access to a resource; strongly related to the different access control mechanisms (ACMs) and strategies one can use to protect resources, e.g. attribute-based access control (ABAC), role-based access control (RBAC), context-based access control, user-based access control (UBAC).</p> <p>Policy Administration Point (PAP) Set of UIs and APIs to manage resources servers, resources, scopes, policies and permissions; it is where the auth system is configured.</p> <p>Policy Decision Point (PDP) Where the authorization requests are sent, with permissions being requested, and authorization policies are evaluated accordingly.</p> <p>Policy Enforcement Point (PEP) Where the authorization is effectively enforced, usually at the resource server or at a proxy, based on a response provided by the Policy Decision Point (PDP).</p> <p>Policy storage Where policies are stored and from where they can be fetched, perhaps to be cached.</p> <p>Red Hat SSO Auth server; downstream product created from the Keycloak Open Source project.</p> <p>Refresh token Special type of security token, often provided together with an access token in an OAuth2 flow, used to renew the duration of an access token before it expires; it requires client authentication.</p> <p>Request Party Token (RPT) JSON Web Token (JWT) digitally signed using JSON Web Signature (JWS), issued by the Keycloak auth server.</p> <p>Resource One or more endpoints of a system, API or server, that can be protected.</p> <p>Resource-level Access Control (RLAC) Authorization model that takes into consideration attributes of each specific request resource to grant/deny access to those resources (e.g. the resource's owner).</p> <p>Resource server Server that hosts protected resources.</p> <p>Role Aspect of a user\u2019s identity assigned to the user to indicate the level of access they should have to the system; essentially, roles represent collections of permissions</p> <p>Role-based Access Control (RBAC) Authorization model that grants/denies access to resources based on the roles of authenticated users (rather than on complex attributes/policy rules).</p> <p>Scope Mechanism that defines the specific operations that applications can be allowed to do or information that they can request on an identity\u2019s behalf; often presented as a parameter when access is requested as a way to communicate what access is needed, and used by auth server to respond what actual access is granted.</p> <p>Single Page Application (SPA) Web application or website that interacts with the user by dynamically rewriting the current web page with new data from the web server.</p> <p>Single Sign-on (SSO) Authentication scheme that allows a user to log in with a single ID and password to any of several related, yet independent, software systems.</p> <p>Upstream (In the context of authentication/authorization) API whose endpoints must be protected by the auth system; the unprotected service in front of which a protection layer is added (by connecting with a Policy Decision Point).</p> <p>User-based Access Control (UBAC) Authorization model that grants/denies access to resources based on claims of the identity (attributes of the user).</p> <p>User-Managed Access (UMA) OAuth2-based access management protocol, used for users of an auth server to control the authorization process, i.e. directly granting/denying access to user-owned resources to other requesting parties.</p>"},{"location":"authorino/docs/user-guides/","title":"User guides","text":"<ul> <li> <p>Hello World The basics of protecting an API with Authorino.</p> </li> <li> <p>Authentication with Kubernetes tokens (TokenReview API) Validate Kubernetes Service Account tokens to authenticate requests to your protected hosts.</p> </li> <li> <p>Authentication with API keys Issue API keys stored in Kubernetes <code>Secret</code>s for clients to authenticate with your protected hosts.</p> </li> <li> <p>Authentication with X.509 certificates and mTLS Verify client X.509 certificates against trusted root CAs.</p> </li> <li> <p>OpenID Connect Discovery and authentication with JWTs Validate JSON Web Tokens (JWT) issued and signed by an OpenID Connect server; leverage OpenID Connect Discovery to automatically fetch JSON Web Key Sets (JWKS).</p> </li> <li> <p>OAuth 2.0 token introspection (RFC 7662) Introspect OAuth 2.0 access tokens (e.g. opaque tokens) for online user data and token validation in request-time.</p> </li> <li> <p>Passing credentials (<code>Authorization</code> header, cookie headers and others) Customize where credentials are supplied in the request by each trusted source of identity.</p> </li> <li> <p>HTTP \"Basic\" Authentication (RFC 7235) Turn Authorino API key <code>Secret</code>s settings into HTTP basic auth.</p> </li> <li> <p>Anonymous access Bypass identity verification or fall back to anonymous access when credentials fail to validate</p> </li> <li> <p>Token normalization Normalize identity claims from trusted sources and reduce complexity in your policies.</p> </li> <li> <p>Edge Authentication Architecture (EAA) Exchange satellite (outer-layer) authentication tokens for \"Festival Wristbands\" accepted ubiquitously at the inside of your network. Normalize from multiple and varied sources of identity and authentication methods in the edge of your architecture; filter privacy data, limit the scope of permissions, and simplify authorization rules to your internal microservices.</p> </li> <li> <p>Fetching auth metadata from external sources Get online data from remote HTTP services to enhance authorization rules.</p> </li> <li> <p>OpenID Connect UserInfo Fetch user info for OpenID Connect ID tokens in request-time for extra metadata for your policies and online verification of token validity.</p> </li> <li> <p>Resource-level authorization with User-Managed Access (UMA) resource registry Fetch resource attributes relevant for authorization from a User-Managed Access (UMA) resource registry such as Keycloak resource server clients.</p> </li> <li> <p>Simple pattern-matching authorization policies Write simple authorization rules based on JSON patterns matched against Authorino's Authorization JSON; check contextual information of the request, validate JWT claims, cross metadata fetched from external sources, etc.</p> </li> <li> <p>OpenID Connect (OIDC) and Role-Based Access Control (RBAC) with Authorino and Keycloak Combine OpenID Connect (OIDC) authentication and Role-Based Access Control (RBAC) authorization rules leveraging Keycloak and Authorino working together.</p> </li> <li> <p>Open Policy Agent (OPA) Rego policies Leverage the power of Open Policy Agent (OPA) policies, evaluated against Authorino's Authorization JSON in a built-in runtime compiled together with Authorino; pre-cache policies defined in Rego language inline or fetched from an external policy registry.</p> </li> <li> <p>Kubernetes RBAC for service authorization (SubjectAccessReview API) Manage permissions in the Kubernetes RBAC and let Authorino to check them in request-time with the authorization system of the cluster.</p> </li> <li> <p>Authorization with Keycloak Authorization Services Use Authorino as an adapter for Keycloak Authorization Services without importing any library or rebuilding your application code.</p> </li> <li> <p>Integration with Authzed/SpiceDB Permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> </li> <li> <p>Injecting data in the request Inject HTTP headers with serialized JSON content.</p> </li> <li> <p>Authenticated rate limiting (with Envoy Dynamic Metadata) Provide Envoy with dynamic metadata from the external authorization process to be injected and used by consecutive filters, such as by a rate limiting service.</p> </li> <li> <p>Redirecting to a login page Customize response status code and headers on failed requests. E.g. redirect users of a web application protected with Authorino to a login page instead of a <code>401 Unauthorized</code>; mask resources on access denied behind a <code>404 Not Found</code> response instead of <code>403 Forbidden</code>.</p> </li> <li> <p>Mixing Envoy built-in filter for auth and Authorino Have JWT validation handled by Envoy beforehand and the JWT payload injected into the request to Authorino, to be used in custom authorization policies defined in a AuthConfig.</p> </li> <li> <p>Host override via context extension Induce the lookup of an AuthConfig by supplying extended host context, for use cases such as of path prefix-based lookup and wildcard subdomains lookup.</p> </li> <li> <p>Using Authorino as ValidatingWebhook service Use Authorino as a generic Kubernetes ValidatingWebhook service where the rules to validate a request to the Kubernetes API are written in an AuthConfig.</p> </li> <li> <p>Reducing the operational space: sharding, noise and multi-tenancy Have multiple instances of Authorino running in the same space (Kubernetes namespace or cluster-scoped), yet watching particular sets of resources.</p> </li> <li> <p>Caching Cache auth objects resolved at runtime for any configuration bit of an AuthConfig, for easy access in subsequent requests whenever an arbitrary cache key repeats, until the cache entry expires.</p> </li> <li> <p>Observability Prometheus metrics exported by Authorino, readiness probe, logging, tracing, etc.</p> </li> </ul>"},{"location":"authorino/docs/user-guides/anonymous-access/","title":"User guide: Anonymous access","text":"<p>Bypass identity verification or fall back to anonymous access when credentials fail to validate</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Anonymous access</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/anonymous-access/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/anonymous-access/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"public\":\n      anonymous: {}\nEOF\n</code></pre> <p>The example above enables anonymous access (i.e. removes authentication), without adding any extra layer of protection to the API. This is virtually equivalent to setting a top-level condition to the <code>AuthConfig</code> that always skips the configuration, or to switching authentication/authorization off completely in the route to the API.</p> <p>For more sophisticated use cases of anonymous access with Authorino, consider combining this feature with other identity sources in the <code>AuthConfig</code> while playing with the priorities of each source, as well as combination with <code>when</code> conditions, and/or adding authorization policies that either cover authentication or address anonymous access with proper rules (e.g. enforcing read-only access).</p> <p>Check out the docs for the Anonymous access feature for an example of an <code>AuthConfig</code> that falls back to anonymous access when a priority OIDC/JWT-based authentication fails, and enforces a read-only policy in such cases.</p>"},{"location":"authorino/docs/user-guides/anonymous-access/#consume-the-api","title":"\u277b Consume the API","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/api-key-authentication/","title":"User guide: Authentication with API keys","text":"<p>Issue API keys stored in Kubernetes <code>Secret</code>s for clients to authenticate with your protected hosts.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>In Authorino, API keys are stored as Kubernetes <code>Secret</code>s. Each resource must contain an <code>api_key</code> entry with the value of the API key, and labeled to match the selectors specified in <code>spec.identity.apiKey.selector</code> of the <code>AuthConfig</code>.</p> <p>API key <code>Secret</code>s must also include labels that match the <code>secretLabelSelector</code> field of the Authorino instance. See Resource reconciliation and status update for details.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/api-key-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/api-key-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid API key:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>With missing or invalid API key:</p> <pre><code>curl -H 'Authorization: APIKEY invalid' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"friends\"\n# x-ext-auth-reason: the API Key provided is invalid\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#delete-an-api-key-revoke-access-to-the-api","title":"\u277d Delete an API key (revoke access to the API)","text":"<pre><code>kubectl delete secret/api-key-1\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/","title":"User guide: Authenticated rate limiting (with Envoy Dynamic Metadata)","text":"<p>Provide Envoy with dynamic metadata about the external authorization process to be injected into the rate limiting filter.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Response wrappers \u2192 Envoy Dynamic Metadata</li> <li>Dynamic response \u2192 JSON injection</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Dynamic JSON objects built out of static values and values fetched from the Authorization JSON can be wrapped to be returned to the reverse-proxy as Envoy Well Known Dynamic Metadata content. Envoy can use those to inject data returned by the external authorization service into the other filters, such as the rate limiting filter.</p> <p>Check out as well the user guides about Injecting data in the request and Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-limitador","title":"\u2778 Deploy Limitador","text":"<p>Limitador is a lightweight rate limiting service that can be used with Envoy.</p> <p>On this bundle, we will deploy Limitador pre-configured to limit requests to the <code>talker-api</code> domain up to 5 requests per interval of 60 seconds per <code>user_id</code>. Envoy will be configured to recognize the presence of Limitador and activate it on requests to the Talker API.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-the-talker-api","title":"\u2779 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#setup-envoy","title":"\u277a Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#create-an-authconfig","title":"\u277b Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>An annotation <code>auth-data/username</code> will be read from the Kubernetes API Key secret and passed as dynamic metadata <code>{ \"ext_auth_data\": { \"username\": \u00abannotations.auth-data/username\u00bb } }</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      dynamicMetadata:\n        \"rate-limit\":\n          json:\n            properties:\n              \"username\":\n                expression: auth.identity.metadata.annotations['auth-data/username']\n          key: ext_auth_data # how this bit of dynamic metadata from the ext authz service is named in the Envoy config\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#create-the-api-keys","title":"\u277c Create the API keys","text":"<p>For user John:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/username: john\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>For user Jane:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/username: jane\nstringData:\n  api_key: 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#consume-the-api","title":"\u277d Consume the API","text":"<p>As John:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Repeat the request a few more times within the 60-second time window, until the response status is <code>429 Too Many Requests</code>.</p> <p>While the API is still limited to John, send requests as Jane:</p> <pre><code>curl -H 'Authorization: APIKEY 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete secret/api-key-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/authzed/","title":"User guide: Integration with Authzed/SpiceDB","text":"<p>Permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 SpiceDB</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p></p>"},{"location":"authorino/docs/user-guides/authzed/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/authzed/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-the-permission-database","title":"\u277a Create the permission database","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace spicedb\n</code></pre> <p>Create the SpiceDB instance:</p> <pre><code>kubectl -n spicedb apply -f -&lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: spicedb\n  labels:\n    app: spicedb\nspec:\n  selector:\n    matchLabels:\n      app: spicedb\n  template:\n    metadata:\n      labels:\n        app: spicedb\n    spec:\n      containers:\n\n      - name: spicedb\n        image: authzed/spicedb\n        args:\n        - serve\n        - \"--grpc-preshared-key\"\n        - secret\n        - \"--http-enabled\"\n        ports:\n        - containerPort: 50051\n        - containerPort: 8443\n  replicas: 1\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: spicedb\nspec:\n  selector:\n    app: spicedb\n  ports:\n    - name: grpc\n      port: 50051\n      protocol: TCP\n    - name: http\n      port: 8443\n      protocol: TCP\nEOF\n</code></pre> <p>Forward local request to the SpiceDB service inside the cluster:</p> <pre><code>kubectl -n spicedb port-forward service/spicedb 8443:8443 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Create the permission schema:</p> <pre><code>curl -X POST http://localhost:8443/v1/schema/write \\\n  -H 'Authorization: Bearer secret' \\\n  -H 'Content-Type: application/json' \\\n  -d @- &lt;&lt; EOF\n{\n  \"schema\": \"definition blog/user {}\\ndefinition blog/post {\\n\\trelation reader: blog/user\\n\\trelation writer: blog/user\\n\\n\\tpermission read = reader + writer\\n\\tpermission write = writer\\n}\"\n}\nEOF\n</code></pre> <p>Create the relationships:</p> <ul> <li><code>blog/user:emilia</code> \u2192 <code>writer</code> of <code>blog/post:1</code></li> <li><code>blog/user:beatrice</code> \u2192 <code>reader</code> of <code>blog/post:1</code></li> </ul> <pre><code>curl -X POST http://localhost:8443/v1/relationships/write \\\n  -H 'Authorization: Bearer secret' \\\n  -H 'Content-Type: application/json' \\\n  -d @- &lt;&lt; EOF\n{\n  \"updates\": [\n    {\n      \"operation\": \"OPERATION_CREATE\",\n      \"relationship\": {\n        \"resource\": {\n          \"objectType\": \"blog/post\",\n          \"objectId\": \"1\"\n        },\n        \"relation\": \"writer\",\n        \"subject\": {\n          \"object\": {\n            \"objectType\": \"blog/user\",\n            \"objectId\": \"emilia\"\n          }\n        }\n      }\n    },\n    {\n      \"operation\": \"OPERATION_CREATE\",\n      \"relationship\": {\n        \"resource\": {\n          \"objectType\": \"blog/post\",\n          \"objectId\": \"1\"\n        },\n        \"relation\": \"reader\",\n        \"subject\": {\n          \"object\": {\n            \"objectType\": \"blog/user\",\n            \"objectId\": \"beatrice\"\n          }\n        }\n      }\n    }\n  ]\n}\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Store the shared token for Authorino to authenticate with the SpiceDB instance in a Service:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: spicedb\n  labels:\n    app: spicedb\nstringData:\n  grpc-preshared-key: secret\nEOF\n</code></pre> <p>Create the AuthConfig:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"blog-users\":\n      apiKey:\n        selector:\n          matchLabels:\n            app: talker-api\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  authorization:\n    \"authzed-spicedb\":\n      spicedb:\n        endpoint: spicedb.spicedb.svc.cluster.local:50051\n        insecure: true\n        sharedSecretRef:\n          name: spicedb\n          key: grpc-preshared-key\n        subject:\n          kind:\n            value: blog/user\n          name:\n            selector: auth.identity.metadata.annotations.username\n        resource:\n          kind:\n            value: blog/post\n          name:\n            selector: context.request.http.path.@extract:{\"sep\":\"/\",\"pos\":2}\n        permission:\n          selector: context.request.http.method.@replace:{\"old\":\"GET\",\"new\":\"read\"}.@replace:{\"old\":\"POST\",\"new\":\"write\"}\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-the-api-keys","title":"\u277c Create the API keys","text":"<p>For Emilia (writer):</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-writer\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: talker-api\n  annotations:\n    username: emilia\nstringData:\n  api_key: IAMEMILIA\nEOF\n</code></pre> <p>For Beatrice (reader):</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-reader\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: talker-api\n  annotations:\n    username: beatrice\nstringData:\n  api_key: IAMBEATRICE\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#consume-the-api","title":"\u277d Consume the API","text":"<p>As Emilia, send a GET request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMEMILIA' \\\n     -X GET \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Emilia, send a POST request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMEMILIA' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Beatrice, send a GET request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMBEATRICE' \\\n     -X GET \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Beatrice, send a POST request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMBEATRICE' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: PERMISSIONSHIP_NO_PERMISSION;token=GhUKEzE2NzU3MDE3MjAwMDAwMDAwMDA=\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace spicedb\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/caching/","title":"User guide: Caching","text":"<p>Cache auth objects resolved at runtime for any configuration bit of an AuthConfig (i.e. any evaluator), of any phase (identity, metadata, authorization and dynamic response), for easy access in subsequent requests, whenever an arbitrary (user-defined) cache key repeats, until the cache entry expires.</p> <p>This is particularly useful for configuration bits whose evaluation is significantly more expensive than accessing the cache. E.g.:</p> <ul> <li>Caching of metadata fetched from external sources in general</li> <li>Caching of previously validated identity access tokens (e.g. for OAuth2 opaque tokens that involve consuming the token introspection endpoint of an external auth server)</li> <li>Caching of complex Rego policies that involve sending requests to external services</li> </ul> <p>Cases where one will NOT want to enable caching, due to relatively cheap compared to accessing and managing the cache:</p> <ul> <li>Validation of OIDC/JWT access tokens</li> <li>OPA/Rego policies that do not involve external requests</li> <li>JSON pattern-matching authorization</li> <li>Dynamic JSON responses</li> <li>Anonymous access</li> </ul> Authorino capabilities featured in this guide: <ul> <li>Common feature \u2192 Caching</li> <li>Identity verification &amp; authentication \u2192 Anonymous access</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Dynamic response \u2192 JSON injection</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/caching/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/caching/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The example below enables caching for the external source of metadata, which in this case, for convenience, is the same upstream API protected by Authorino (i.e. the Talker API), though consumed directly by Authorino, without passing through the proxy. This API generates a <code>uuid</code> random hash that it injects in the JSON response. This value is different in every request processed by the API.</p> <p>The example also enables caching of returned OPA virtual documents. <code>cached-authz</code> is a trivial Rego policy that always grants access, but generates a timestamp, which Authorino will cache.</p> <p>In both cases, the path of the HTTP request is used as cache key. I.e., whenever the path repeats, Authorino reuse the values stored previously in each cache table (<code>cached-metadata</code> and <code>cached-authz</code>), respectively saving a request to the external source of metadata and the evaluation of the OPA policy. Cache entries will expire in both cases after 60 seconds they were stored in the cache.</p> <p>The cached values will be visible in the response returned by the Talker API in <code>x-authz-data</code> header injected by Authorino. This way, we can tell when an existing value in the cache was used and when a new one was generated and stored.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"anonymous\":\n      anonymous: {}\n  metadata:\n    \"cached-metadata\":\n      http:\n        url: \"http://talker-api.default.svc.cluster.local:3000/metadata/{context.request.http.path}\"\n      cache:\n        key:\n          selector: context.request.http.path\n        ttl: 60\n  authorization:\n    \"cached-authz\":\n      opa:\n        rego: |\n          now = time.now_ns()\n          allow = true\n        allValues: true\n      cache:\n        key:\n          selector: context.request.http.path\n        ttl: 60\n  response:\n    success:\n      headers:\n        \"x-authz-data\":\n          json:\n            properties:\n              \"cached-metadata\":\n                selector: auth.metadata.cached-metadata.uuid\n              \"cached-authz\":\n                selector: auth.authorization.cached-authz.now\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#consume-the-api","title":"\u277b Consume the API","text":"<ol> <li>To <code>/hello</code></li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343067462380300\\\",\\\"cached-metadata\\\":\\\"92c111cd-a10f-4e86-8bf0-e0cd646c6f79\\\"}\",\n# [\u2026]\n</code></pre> <ol> <li>To a different path</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/goodbye\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343097860450300\\\",\\\"cached-metadata\\\":\\\"37fce386-1ee8-40a7-aed1-bf8a208f283c\\\"}\",\n# [\u2026]\n</code></pre> <ol> <li>To <code>/hello</code> again before the cache entry expires (60 seconds from the first request sent to this path)</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343067462380300\\\",\\\"cached-metadata\\\":\\\"92c111cd-a10f-4e86-8bf0-e0cd646c6f79\\\"}\",  &lt;=== same cache-id as before\n# [\u2026]\n</code></pre> <ol> <li>To <code>/hello</code> again after the cache entry expires (60 seconds from the first request sent to this path)</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343135702743800\\\",\\\"cached-metadata\\\":\\\"e708a3a6-5caf-4028-ab5c-573ad9be7188\\\"}\",  &lt;=== different cache-id\n# [\u2026]\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/","title":"User guide: Redirecting to a login page","text":"<p>Customize response status code and headers on failed requests to redirect users of a web application protected with Authorino to a login page instead of a <code>401 Unauthorized</code>.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Custom denial status</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino's default response status codes, messages and headers for unauthenticated (<code>401</code>) and unauthorized (<code>403</code>) requests can be customized with static values and values fetched from the Authorization JSON.</p> <p>Check out as well the user guides about HTTP \"Basic\" Authentication (RFC 7235) and OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample web application called Matrix Quotes to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#deploy-the-matrix-quotes-web-application","title":"\u2778 Deploy the Matrix Quotes web application","text":"<p>The Matrix Quotes is a static web application that contains quotes from the film The Matrix.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/matrix-quotes-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Matrix Quotes webapp behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/envoy-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>matrix-quotes.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: matrix-quotes-protection\nspec:\n  hosts:\n\n  - matrix-quotes.127.0.0.1.nip.io\n  authentication:\n    \"browser-users\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        cookie:\n          name: TOKEN\n    \"http-basic-auth\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        authorizationHeader:\n          prefix: Basic\n  response:\n    unauthenticated:\n      code: 302\n      headers:\n        \"Location\":\n          expression: |\n            'http://matrix-quotes.127.0.0.1.nip.io:8000/login.html?redirect_to=' + request.path\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: user-credential-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: am9objpw # john:p\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#consume-the-application","title":"\u277c Consume the application","text":"<p>On a web browser, navigate to http://matrix-quotes.127.0.0.1.nip.io:8000.</p> <p>Click on the cards to read quotes from characters of the movie. You should be redirected to login page.</p> <p>Log in using John's credentials:</p> <ul> <li>Username: john</li> <li>Password: p</li> </ul> <p>Click again on the cards and check that now you are able to access the inner pages.</p> <p>You can also consume a protected endpoint of the application using HTTP Basic Authentication:</p> <pre><code>curl -u john:p http://matrix-quotes.127.0.0.1.nip.io:8000/neo.html\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#optional-modify-the-authconfig-to-authenticate-with-oidc","title":"\u277d (Optional) Modify the <code>AuthConfig</code> to authenticate with OIDC","text":""},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#setup-a-keycloak-server","title":"Setup a Keycloak server","text":"<p>Deploy a Keycloak server preloaded with a realm named <code>kuadrant</code>:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Resolve local Keycloak domain so it can be accessed from the local host and inside the cluster with the name: (This will be needed to redirect to Keycloak's login page and at the same time validate issued tokens.)</p> <pre><code>echo '127.0.0.1 keycloak' &gt;&gt; /etc/hosts\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl port-forward deployment/keycloak 8080:8080 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Create a client:</p> <pre><code>curl -H \"Authorization: Bearer $(curl http://keycloak:8080/realms/master/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=admin-cli' -d 'username=admin' -d 'password=p' | jq -r .access_token)\" \\\n     -H 'Content-type: application/json' \\\n     -d '{ \"name\": \"matrix-quotes\", \"clientId\": \"matrix-quotes\", \"publicClient\": true, \"redirectUris\": [\"http://matrix-quotes.127.0.0.1.nip.io:8000/auth*\"], \"enabled\": true }' \\\n     http://keycloak:8080/admin/realms/kuadrant/clients\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#reconfigure-the-matrix-quotes-app-to-use-keycloaks-login-page","title":"Reconfigure the Matrix Quotes app to use Keycloak's login page","text":"<pre><code>kubectl set env deployment/matrix-quotes KEYCLOAK_REALM=http://keycloak:8080/realms/kuadrant CLIENT_ID=matrix-quotes\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#apply-the-changes-to-the-authconfig","title":"Apply the changes to the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: matrix-quotes-protection\nspec:\n  hosts:\n\n  - matrix-quotes.127.0.0.1.nip.io\n  authentication:\n    \"idp-users\":\n      jwt:\n        issuerUrl: http://keycloak:8080/realms/kuadrant\n      credentials:\n        cookie:\n          name: TOKEN\n  response:\n    unauthenticated:\n      code: 302\n      headers:\n        \"Location\":\n          expression: |\n            'http://keycloak:8080/realms/kuadrant/protocol/openid-connect/auth?client_id=matrix-quotes&amp;redirect_uri=http://matrix-quotes.127.0.0.1.nip.io:8000/auth?redirect_to=' + request.path + '&amp;scope=openid&amp;response_type=code'\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#consume-the-application-again","title":"Consume the application again","text":"<p>Refresh the browser window or navigate again to http://matrix-quotes.127.0.0.1.nip.io:8000.</p> <p>Click on the cards to read quotes from characters of the movie. You should be redirected to login page this time served by the Keycloak server.</p> <p>Log in as Jane (a user of the Keycloak realm):</p> <ul> <li>Username: jane</li> <li>Password: p</li> </ul> <p>Click again on the cards and check that now you are able to access the inner pages.</p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/user-credential-1\nkubectl delete authconfig/matrix-quotes-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/matrix-quotes-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/","title":"User guide: Edge Authentication Architecture (EAA)","text":"<p>Edge Authentication Architecture (EAA) is a pattern where more than extracting authentication logics and specifics from the application codebase to a proper authN/authZ layer, this is pushed to the edge of your cloud network, without violating the Zero Trust principle nevertheless.</p> <p>The very definition of \"edge\" is subject to discussion, but the underlying idea is that clients (e.g. API clients, IoT devices, etc.) authenticate with a layer that, before moving traffic to inside the network:</p> <ul> <li>understands the complexity of all the different methods of authentication supported;</li> <li>sometimes some token normalization is involved;</li> <li>eventually enforces some preliminary authorization policies; and</li> <li>possibly filters data bits that are sensitive to privacy concerns (e.g. to comply with local legislation such as GRPD, CCPA, etc)</li> </ul> <p>As a minimum, EAA allows to simplify authentication between applications and microservices inside the network, as well as to reduce authorization to domain-specific rules and policies, rather than having to deal all the complexity to support all types of clients in every node.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Festival Wristband tokens</li> <li>Identity verification &amp; authentication \u2192 Identity extension</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Festival Wristbands are OpenID Connect ID tokens (signed JWTs) issued by Authorino by the end of the Auth Pipeline, for authorized requests. It can be configured to include claims based on static values and values fetched from the Authorization JSON.</p> <p>Check out as well the user guides about Token normalization, Authentication with API keys and OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> <li>jwt, to inspect JWTs (optional)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino and configuring 2 environments of an architecture, <code>edge</code> and <code>internal</code>.</p> <p>The first environment is a facade for handling the first layer of authentication and exchanging any valid presented authentication token for a Festival Wristband token. In the second, we will deploy a sample service called Talker API that the authorization service will ensure to receive only authenticated traffic presented with a valid Festival Wristband.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u2779.</p> <p>At steps \u2779 and \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-namespaces","title":"\u2777 Create the namespaces","text":"<p>For simplicity, this examples will set up edge and internal nodes in different namespaces of the same Kubernetes cluster. Those will share a same single cluster-wide Authorino instance. In real-life scenarios, it does not have to be like that.</p> <pre><code>kubectl create namespace authorino\nkubectl create namespace edge\nkubectl create namespace internal\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#deploy-authorino","title":"\u2778 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources cluster-wide<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-the-edge","title":"\u2779 Setup the Edge","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-envoy","title":"Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up external authorization with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl -n edge apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/eaa/envoy-edge-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>edge.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 9000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n edge port-forward deployment/envoy 9000:9000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-authconfig","title":"Create the <code>AuthConfig</code>","text":"<p>Create a required secret that will be used by Authorino to sign the Festival Wristband tokens:</p> <pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: wristband-signing-key\nstringData:\n  key.pem: |\n    -----BEGIN EC PRIVATE KEY-----\n    MHcCAQEEIDHvuf81gVlWGo0hmXGTAnA/HVxGuH8vOc7/8jewcVvqoAoGCCqGSM49\n    AwEHoUQDQgAETJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZxJKDysoGwn\n    cnUvHIu23SgW+Ee9lxSmZGhO4eTdQeKxMA==\n    -----END EC PRIVATE KEY-----\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: edge-auth\nspec:\n  hosts:\n\n  - edge.127.0.0.1.nip.io\n  authentication:\n    \"api-clients\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n        allNamespaces: true\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n      overrides:\n        \"username\":\n          selector: auth.identity.metadata.annotations.authorino\\.kuadrant\\.io/username\n    \"idp-users\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      defaults:\n        \"username\":\n          selector: auth.identity.preferred_username\n  response:\n    success:\n      dynamicMetadata:\n        \"wristband\":\n          wristband:\n            issuer: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\n            customClaims:\n              \"username\":\n                selector: auth.identity.username\n            tokenDuration: 300\n            signingKeyRefs:\n            - name: wristband-signing-key\n              algorithm: ES256\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-the-internal-workload","title":"\u277a Setup the internal workload","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#deploy-the-talker-api","title":"Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl -n internal apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-envoy_1","title":"Setup Envoy","text":"<p>This other bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.</p> <pre><code>kubectl -n internal apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/eaa/envoy-node-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n internal port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-authconfig_1","title":"Create the <code>AuthConfig</code>","text":"Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n internal apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"edge-authenticated\":\n      jwt:\n        issuerUrl: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n  annotations:\n    authorino.kuadrant.io/username: alice\n    authorino.kuadrant.io/email: alice@host\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#consume-the-api","title":"\u277c Consume the API","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#using-the-api-key-to-authenticate","title":"Using the API key to authenticate","text":"<p>Authenticate at the edge:</p> <pre><code>WRISTBAND_TOKEN=$(curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://edge.127.0.0.1.nip.io:9000/auth -is | tr -d '\\r' | sed -En 's/^x-wristband-token: (.*)/\\1/p')\n</code></pre> <p>Consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $WRISTBAND_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Try to consume the API with authentication token that is only accepted in the edge:</p> <pre><code>curl -H \"Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"edge-authenticated\"\n# x-ext-auth-reason: credential not found\n</code></pre> <p>(Optional) Inspect the wristband token and verify that it only contains restricted info to authenticate and authorize with internal apps.</p> <pre><code>jwt decode $WRISTBAND_TOKEN\n# [...]\n#\n# Token claims\n# ------------\n# {\n#   \"exp\": 1638452051,\n#   \"iat\": 1638451751,\n#   \"iss\": \"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\",\n#   \"sub\": \"02cb51ea0e1c9f3c0960197a2518c8eb4f47e1b9222a968ffc8d4c8e783e4d19\",\n#   \"username\": \"alice\"\n# }\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#authenticating-with-the-keycloak-server","title":"Authenticating with the Keycloak server","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl -n edge run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>(Optional) Inspect the access token issue by Keycloak and verify and how it contains more details about the identity than required to authenticate and authorize with internal apps.</p> <pre><code>jwt decode $ACCESS_TOKEN\n# [...]\n#\n# Token claims\n# ------------\n# { [...]\n#   \"email\": \"jane@kuadrant.io\",\n#   \"email_verified\": true,\n#   \"exp\": 1638452220,\n#   \"family_name\": \"Smith\",\n#   \"given_name\": \"Jane\",\n#   \"iat\": 1638451920,\n#   \"iss\": \"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\",\n#   \"jti\": \"699f6e49-dea4-4f29-ae2a-929a3a18c94b\",\n#   \"name\": \"Jane Smith\",\n#   \"preferred_username\": \"jane\",\n#   \"realm_access\": {\n#     \"roles\": [\n#       \"offline_access\",\n#       \"member\",\n#       \"admin\",\n#       \"uma_authorization\"\n#     ]\n#   },\n# [...]\n</code></pre> <p>As Jane, obtain a limited wristband token at the edge:</p> <pre><code>WRISTBAND_TOKEN=$(curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://edge.127.0.0.1.nip.io:9000/auth -is | tr -d '\\r' | sed -En 's/^x-wristband-token: (.*)/\\1/p')\n</code></pre> <p>Consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $WRISTBAND_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete namespace edge\nkubectl delete namespace internal\nkubectl delete namespace authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino and Authorino Operator manifests, run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/","title":"User guide: Mixing Envoy built-in filter for auth and Authorino","text":"<p>Have JWT validation handled by Envoy beforehand and the JWT payload injected into the request to Authorino, to be used in custom authorization policies defined in a AuthConfig.</p> <p>In this user guide, we will set up Envoy and Authorino to protect a service called the Talker API service, with JWT authentication handled in Envoy and a more complex authorization policy enforced in Authorino.</p> <p>The policy defines a geo-fence by which only requests originated in Great Britain (country code: GB) will be accepted, unless the user is bound to a role called 'admin' in the auth server, in which case no geofence is enforced.</p> <p>All requests to the Talker API will be authenticated in Envoy. However, requests to <code>/global</code> will not trigger the external authorization.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Plain</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Pattern-matching authorization</li> <li>Dynamic response \u2192 Custom denial status</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following command deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app: authorino\n  name: envoy\ndata:\n  envoy.yaml: |\n    static_resources:\n      clusters:\n\n      - name: talker-api\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: talker-api\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: talker-api\n                    port_value: 3000\n      - name: keycloak\n        connect_timeout: 0.25s\n        type: logical_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: keycloak\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: keycloak.keycloak.svc.cluster.local\n                    port_value: 8080\n      - name: authorino\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        http2_protocol_options: {}\n        load_assignment:\n          cluster_name: authorino\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: authorino-authorino-authorization\n                    port_value: 50051\n      listeners:\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 8000\n        filter_chains:\n        - filters:\n          - name: envoy.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              stat_prefix: local\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: local_service\n                  domains: ['*']\n                  routes:\n                  - match: { path_separated_prefix: /global }\n                    route: { cluster: talker-api }\n                    typed_per_filter_config:\n                      envoy.filters.http.ext_authz:\n                        \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n                        disabled: true\n                  - match: { prefix: / }\n                    route: { cluster: talker-api }\n              http_filters:\n              - name: envoy.filters.http.jwt_authn\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication\n                  providers:\n                    keycloak:\n                      issuer: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n                      remote_jwks:\n                        http_uri:\n                          uri: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/certs\n                          cluster: keycloak\n                          timeout: 5s\n                        cache_duration:\n                          seconds: 300\n                      payload_in_metadata: verified_jwt\n                  rules:\n                  - match: { prefix: / }\n                    requires: { provider_name: keycloak }\n              - name: envoy.filters.http.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  failure_mode_allow: false\n                  metadata_context_namespaces:\n                  - envoy.filters.http.jwt_authn\n                  grpc_service:\n                    envoy_grpc:\n                      cluster_name: authorino\n                    timeout: 1s\n              - name: envoy.filters.http.router\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n              use_remote_address: true\n    admin:\n      access_log_path: \"/tmp/admin_access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: authorino\n    svc: envoy\n  name: envoy\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: authorino\n      svc: envoy\n  template:\n    metadata:\n      labels:\n        app: authorino\n        svc: envoy\n    spec:\n      containers:\n      - args:\n        - --config-path /usr/local/etc/envoy/envoy.yaml\n        - --service-cluster front-proxy\n        - --log-level info\n        - --component-log-level filter:trace,http:debug,router:debug\n        command:\n        - /usr/local/bin/envoy\n        image: envoyproxy/envoy:v1.22-latest\n        name: envoy\n        ports:\n        - containerPort: 8000\n          name: web\n        - containerPort: 8001\n          name: admin\n        volumeMounts:\n        - mountPath: /usr/local/etc/envoy\n          name: config\n          readOnly: true\n      volumes:\n      - configMap:\n          items:\n          - key: envoy.yaml\n            path: envoy.yaml\n          name: envoy\n        name: config\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: authorino\n  name: envoy\nspec:\n  ports:\n  - name: web\n    port: 8000\n    protocol: TCP\n  selector:\n    app: authorino\n    svc: envoy\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-wildcard-host\nspec:\n  rules:\n  - host: talker-api.127.0.0.1.nip.io\n    http:\n      paths:\n      - backend:\n          service:\n            name: envoy\n            port:\n              number: 8000\n        path: /\n        pathType: Prefix\nEOF\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-the-ip-location-service","title":"\u277a Deploy the IP Location service","text":"<p>The IP Location service is a simple service that resolves an IPv4 address into geo location info.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-examples/main/ip-location/ip-location-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#create-an-authconfig","title":"\u277b Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"jwt\":\n      plain:\n        selector: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\n  metadata:\n    \"geoinfo\":\n      http:\n        url: 'http://ip-location.default.svc.cluster.local:3000/{context.request.http.headers.x-forwarded-for.@extract:{\"sep\":\",\"}}'\n        headers:\n          \"Accept\":\n            value: application/json\n      cache:\n        key:\n          selector: \"context.request.http.headers.x-forwarded-for.@extract:{\\\"sep\\\":\\\",\\\"}\"\n  authorization:\n    \"geofence\":\n      when:\n      - selector: auth.identity.realm_access.roles\n        operator: excl\n        value: admin\n      patternMatching:\n        patterns:\n        - selector: auth.metadata.geoinfo.country_iso_code\n          operator: eq\n          value: \"GB\"\n  response:\n    unauthorized:\n      message:\n        selector: \"The requested resource is not available in {auth.metadata.geoinfo.country_name}\"\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-a-token-and-consume-the-api","title":"\u277c Obtain a token and consume the API","text":""},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user John, a non-admin (member) user:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As John, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: The requested resource is not available in Italy\n</code></pre> <p>As John, consume a path of the API that will cause Envoy to skip external authorization:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/global -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-an-access-token-and-consume-the-api-as-jane-admin","title":"Obtain an access token and consume the API as Jane (admin)","text":"<p>Obtain an access token with the Keycloak server for Jane, an admin user:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume a path of the API that will cause Envoy to skip external authorization:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/global -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete ingress/ingress-wildcard-host\nkubectl delete service/envoy\nkubectl delete deployment/envoy\nkubectl delete configmap/envoy\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/external-metadata/","title":"User guide: Fetching auth metadata from external sources","text":"<p>Get online data from remote HTTP services to enhance authorization rules.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>You can configure Authorino to fetch additional metadata from external sources in request-time, by sending either GET or POST request to an HTTP service. The service is expected to return a JSON content which is appended to the Authorization JSON, thus becoming available for usage in other configs of the Auth Pipeline, such as in authorization policies or custom responses.</p> <p>URL, parameters and headers of the request to the external source of metadata can be configured, including with dynamic values. Authentication between Authorino and the service can be set as part of these configuration options, or based on shared authentication token stored in a Kubernetes <code>Secret</code>.</p> <p>Check out as well the user guides about Authentication with API keys and Open Policy Agent (OPA) Rego policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/external-metadata/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/external-metadata/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, we will implement a geofence policy for the API, using OPA and metadata fetching from an external service that returns geolocalization JSON data for a given IP address. The policy establishes that only <code>GET</code> requests are allowed and the path of the request should be in the form <code>/{country-code}/*</code>, where <code>{country-code}</code> is the 2-character code of the country where the client is identified as being physically present.</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  metadata:\n    \"geo\":\n      http:\n        urlExpression: |\n          'http://ip-api.com/json/' + request.headers['x-forwarded-for'].split(',')[0] + '?fields=countryCode'\n        headers:\n          \"Accept\":\n            expression: '\"application/json\"'\n  authorization:\n    \"geofence\":\n      opa:\n        rego: |\n          import input.context.request.http\n\n          allow {\n            http.method = \"GET\"\n            split(http.path, \"/\") = [_, requested_country, _]\n            lower(requested_country) == lower(object.get(input.auth.metadata.geo, \"countryCode\", \"\"))\n          }\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/external-metadata/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#consume-the-api","title":"\u277c Consume the API","text":"<p>From an IP address assigned to the United Kingdom of Great Britain and Northern Ireland (country code GB):</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000/gb/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000/it/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>From an IP address assigned to Italy (country code IT):</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 109.112.34.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/gb/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 109.112.34.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/it/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/hello-world/","title":"User guide: Hello World","text":""},{"location":"authorino/docs/user-guides/hello-world/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant, you can skip step \u2778. You may already have Authorino installed and running as well. In this case, skip also step \u277a. If you even have your workload cluster configured, with sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, go straight to step \u277c.</p> <p>At step \u277c, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p>"},{"location":"authorino/docs/user-guides/hello-world/#create-the-namespace","title":"\u2776 Create the namespace","text":"<pre><code>kubectl create namespace hello-world\n# namespace/hello-world created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#deploy-the-talker-api","title":"\u2777 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n# deployment.apps/talker-api created\n# service/talker-api created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#setup-envoy","title":"\u2778 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>1</sup></p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/envoy-deploy.yaml\n# configmap/envoy created\n# deployment.apps/envoy created\n# service/envoy created\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n hello-world port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-unprotected","title":"\u2779 Consume the API (unprotected)","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#protect-the-api","title":"\u277a Protect the API","text":""},{"location":"authorino/docs/user-guides/hello-world/#install-the-authorino-operator","title":"Install the Authorino Operator","text":"<pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#deploy-authorino","title":"Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>2</sup> that watches for <code>AuthConfig</code> resources in the <code>hello-world</code> namespace<sup>3</sup>, with TLS disabled<sup>4</sup>.</p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/authorino.yaml\n# authorino.operator.authorino.kuadrant.io/authorino created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-behind-envoy-and-authorino","title":"\u277b Consume the API behind Envoy and Authorino","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 404 Not Found\n# x-ext-auth-reason: Service not found\n</code></pre> <p>Authorino does not know about the <code>talker-api.127.0.0.1.nip.io</code> host, hence the <code>404 Not Found</code>. Let's teach Authorino about this host by applying an <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/user-guides/hello-world/#apply-the-authconfig","title":"\u277c Apply the <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/authconfig.yaml\n# authconfig.authorino.kuadrant.io/talker-api-protection created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-without-credentials","title":"\u277d Consume the API without credentials","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-clients\"\n# x-ext-auth-reason: credential not found\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#grant-access-to-the-api-with-a-tailor-made-security-scheme","title":"Grant access to the API with a tailor-made security scheme","text":"<p>Check out other user guides for several use-cases of authentication and authorization, and the instructions to implement them using Authorino.</p> <p>A few examples of available ser guides:</p> <ul> <li>Authentication with API keys</li> <li>Authentication with JWTs and OpenID Connect Discovery</li> <li>Authentication with Kubernetes tokens (TokenReview API)</li> <li>Authorization with Open Policy Agent (OPA) Rego policies</li> <li>Authorization with simple JSON pattern-matching rules (e.g. JWT claims)</li> <li>Authorization with Kubernetes RBAC (SubjectAccessReview API)</li> <li>Fetching auth metadata from external sources</li> <li>Token normalization</li> </ul>"},{"location":"authorino/docs/user-guides/hello-world/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the namespaces created in step 1 and 5:</p> <pre><code>kubectl delete namespace hello-world\nkubectl delete namespace authorino-operator\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/host-override/","title":"Host override via context extension","text":"<p>By default, Authorino uses the host information of the HTTP request (<code>Attributes.Http.Host</code>) to lookup for an indexed AuthConfig to be enforced<sup>1</sup>. The host info be overridden by supplying a <code>host</code> entry as a (per-route) context extension (<code>Attributes.ContextExtensions</code>), which takes precedence whenever present.</p> <p>Overriding the host attribute of the HTTP request can be useful to support use cases such as of path prefix-based lookup and wildcard subdomains lookup.</p> \u26a0\ufe0f Important:         This feature may not be available to users of Authorino via Kuadrant.        <p></p> <p>In this guide:</p> <ul> <li>Example of host override for path prefix-based lookup</li> <li>Example of host override for wildcard subdomain lookup</li> </ul>"},{"location":"authorino/docs/user-guides/host-override/#example-of-host-override-for-path-prefix-based-lookup","title":"Example of host override for path prefix-based lookup","text":"<p>In this use case, 2 different APIs (i.e. Dogs API and Cats API) are served under the same base domain, and differentiated by the path prefix:</p> <ul> <li><code>pets.com/dogs</code> \u2192  Dogs API</li> <li><code>pets.com/cats</code> \u2192  Cats API</li> </ul> <p>Edit the Envoy config to extend the external authorization settings at the level of the routes, with the <code>host</code> value that will be favored by Authorino before the actual host attribute of the HTTP request:</p> <pre><code>virtual_hosts:\n\n- name: pets-api\n  domains: ['pets.com']\n  routes:\n  - match:\n      prefix: /dogs\n    route:\n      cluster: dogs-api\n    typed_per_filter_config:\n      envoy.filters.http.ext_authz:\n        \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n        check_settings:\n          context_extensions:\n            host: dogs.pets.com\n  - match:\n      prefix: /cats\n    route:\n      cluster: cats-api\n    typed_per_filter_config:\n      envoy.filters.http.ext_authz:\n        \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n        check_settings:\n          context_extensions:\n            host: cats.pets.com\n</code></pre> <p>Create the AuthConfig for the Pets API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: dogs-api-protection\nspec:\n  hosts:\n\n  - dogs.pets.com\n\n  authentication: [...]\n</code></pre> <p>Create the AuthConfig for the Cats API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: cats-api-protection\nspec:\n  hosts:\n\n  - cats.pets.com\n\n  authentication: [...]\n</code></pre> <p>Notice that the host subdomains <code>dogs.pets.com</code> and <code>cats.pets.com</code> are not really requested by the API consumers. Rather, users send requests to <code>pets.com/dogs</code> and <code>pets.com/cats</code>. When routing those requests, Envoy makes sure to inject the corresponding context extensions that will induce the right lookup in Authorino.</p>"},{"location":"authorino/docs/user-guides/host-override/#example-of-host-override-for-wildcard-subdomain-lookup","title":"Example of host override for wildcard subdomain lookup","text":"<p>In this use case, a single Pets API serves requests for any subdomain that matches <code>*.pets.com</code>, e.g.:</p> <ul> <li><code>dogs.pets.com</code> \u2192  Pets API</li> <li><code>cats.pets.com</code> \u2192  Pets API</li> </ul> <p>Edit the Envoy config to extend the external authorization settings at the level of the virtual host, with the <code>host</code> value that will be favored by Authorino before the actual host attribute of the HTTP request:</p> <pre><code>virtual_hosts:\n\n- name: pets-api\n  domains: ['*.pets.com']\n  typed_per_filter_config:\n    envoy.filters.http.ext_authz:\n      \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n      check_settings:\n        context_extensions:\n          host: pets.com\n  routes:\n  - match:\n      prefix: /\n    route:\n      cluster: pets-api\n</code></pre> <p>The <code>host</code> context extension used above is any key that matches one of the hosts listed in the targeted AuthConfig.</p> <p>Create the AuthConfig for the Pets API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: pets-api-protection\nspec:\n  hosts:\n\n  - pets.com\n\n  authentication: [...]\n</code></pre> <p>Notice that requests to <code>dogs.pets.com</code> and to <code>cats.pets.com</code> are all routed by Envoy to the same API, with same external authorization configuration. in all the cases, Authorino will lookup for the indexed AuthConfig associated with <code>pets.com</code>. The same is valid for a request sent, e.g., to <code>birds.pets.com</code>.</p> <ol> <li> <p>For further details about Authorino lookup of AuthConfig, check out Host lookup.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/http-basic-authentication/","title":"User guide: HTTP \"Basic\" Authentication (RFC 7235)","text":"<p>Turn Authorino API key <code>Secret</code>s settings into HTTP basic auth.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>HTTP \"Basic\" Authentication (RFC 7235) is not recommended if you can afford other more secure methods such as OpenID Connect. To support legacy nonetheless it is sometimes necessary to implement it.</p> <p>In Authorino, HTTP \"Basic\" Authentication can be modeled leveraging the API key authentication feature (stored as Kubernetes <code>Secret</code>s with an <code>api_key</code> entry and labeled to match selectors specified in <code>spec.identity.apiKey.selector</code> of the <code>AuthConfig</code>).</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The config uses API Key secrets to store base64-encoded <code>username:password</code> HTTP \"Basic\" authentication credentials. The config also specifies an Access Control List (ACL) by which only user <code>john</code> is authorized to consume the <code>/bye</code> endpoint of the API.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"http-basic-auth\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        authorizationHeader:\n          prefix: Basic\n  authorization:\n    \"acl\":\n      when:\n      - predicate: request.path == '/bye'\n      patternMatching:\n        patterns:\n        - selector: context.request.http.headers.authorization.@extract:{\"pos\":1}|@base64:decode|@extract:{\"sep\":\":\"}\n          operator: eq\n          value: john\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON. Check out as well the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#create-user-credentials","title":"\u277b Create user credentials","text":"<p>To create credentials for HTTP \"Basic\" Authentication, store each <code>username:password</code>, base64-encoded, in the <code>api_key</code> value of the Kubernetes <code>Secret</code> resources. E.g.:</p> <pre><code>printf \"john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" | base64\n# am9objpuZHlCenJlVXpGNHpxRFFzcVNQTUhrUmhyaUVPdGNSeA==\n</code></pre> <p>Create credentials for user John:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: basic-auth-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: am9objpuZHlCenJlVXpGNHpxRFFzcVNQTUhrUmhyaUVPdGNSeA== # john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>Create credentials for user Jane:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: basic-auth-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: amFuZTpkTnNScnNhcHkwbk5Dd210NTM3ZkhGcHl4MGNCc0xFcA== # jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>As John (authorized in the ACL):</p> <pre><code>curl -u john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -u john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx http://talker-api.127.0.0.1.nip.io:8000/bye\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane (NOT authorized in the ACL):</p> <pre><code>curl -u jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -u jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp http://talker-api.127.0.0.1.nip.io:8000/bye -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>With an invalid user/password:</p> <pre><code>curl -u unknown:invalid http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Basic realm=\"http-basic-auth\"\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#revoke-access-to-the-api","title":"\u277d Revoke access to the API","text":"<pre><code>kubectl delete secret/basic-auth-1\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/basic-auth-1\nkubectl delete secret/basic-auth-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/injecting-data/","title":"User guide: Injecting data in the request","text":"<p>Inject HTTP headers with serialized JSON content.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 JSON injection</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Inject serialized custom JSON objects as HTTP request headers. Values can be static or fetched from the Authorization JSON.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/injecting-data/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/injecting-data/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The following defines a JSON object to be injected as an added HTTP header into the request, named after the response config <code>x-ext-auth-data</code>. The object includes 3 properties:</p> <ol> <li>a static value <code>authorized: true</code>;</li> <li>a dynamic value <code>request-time</code>, from Envoy-supplied contextual data present in the Authorization JSON; and</li> <li>a greeting message <code>geeting-message</code> that interpolates a dynamic value read from an annotation of the Kubernetes <code>Secret</code> resource that represents the API key used to authenticate into a static string.</li> </ol> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-ext-auth-data\":\n          json:\n            properties:\n              \"authorized\":\n                expression: \"true\"\n              \"request-time\":\n                expression: request.time.seconds\n              \"greeting-message\":\n                expression: |\n                  'Hello, ' + auth.identity.metadata.annotations['auth-data/name']\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/injecting-data/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/name: Rita\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#consume-the-api","title":"\u277c Consume the API","text":"<pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# {\n#   \"method\": \"GET\",\n#   \"path\": \"/hello\",\n#   \"query_string\": null,\n#   \"body\": \"\",\n#   \"headers\": {\n#     \u2026\n#     \"X-Ext-Auth-Data\": \"{\\\"authorized\\\":true,\\\"greeting-message\\\":\\\"Hello, Rita!\\\",\\\"request-time\\\":1637954644}\",\n#   },\n#   \u2026\n# }\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/","title":"User guide: Simple pattern-matching authorization policies","text":"<p>Write simple authorization rules based on JSON patterns matched against Authorino's Authorization JSON; check contextual information of the request, validate JWT claims, cross metadata fetched from external sources, etc.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Pattern-matching authorization</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino provides a built-in authorization module to check simple pattern-matching rules against the Authorization JSON. This is an alternative to OPA when all you want is to check for some simple rules, without complex logics, such as match the value of a JWT claim.</p> <p>Check out as well the user guide about OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The <code>email-verified-only</code> authorization policy ensures that users consuming the API from a given network (IP range 192.168.1/24) must have their emails verified.</p> <p>The <code>email_verified</code> claim is a property of the identity added to the JWT by the OpenID Connect issuer.</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"email-verified-only\":\n      when:\n      - predicate: |\n          request.headers['x-forwarded-for'].split(',')[0].matches(\"^192\\\\\\.168\\\\\\.1\\\\\\.\\\\\\d+$\")\n      patternMatching:\n        patterns:\n        - predicate: auth.identity.email_verified\nEOF\n</code></pre> <p>Check out the doc about using Common Expression Language (CEL) for reading from the Authorization JSON. Check out as well the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api-as-jane-email-verified","title":"Obtain an access token and consume the API as Jane (email verified)","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As Jane, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api-as-peter-email-not-verified","title":"Obtain an access token and consume the API as Peter (email NOT verified)","text":"<p>Obtain an access token with the Keycloak server for Peter:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=peter' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Peter, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As Peter, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/","title":"User guide: Authorization with Keycloak Authorization Services","text":"<p>Keycloak provides a powerful set of tools (REST endpoints and administrative UIs), also known as Keycloak Authorization Services, to manage and enforce authorization, workflows for multiple access control mechanisms, including discretionary user access control and user-managed permissions.</p> <p>This user guide is an example of how to use Authorino as an adapter to Keycloak Authorization Services while still relying on the reverse-proxy integration pattern, thus not involving importing an authorization library nor rebuilding the application's code.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Keycloak server</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to Keycloak running inside the cluster (if using Kind):</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, Authorino will accept access tokens (JWTs) issued by the Keycloak server. These JWTs can be either normal Keycloak ID tokens or Requesting Party Tokens (RPT).</p> <p>RPTs include claims about the permissions of the user regarding protected resources and scopes associated with a Keycloak authorization client that the user can access.</p> <p>When the supplied access token is an RPT, Authorino will just validate whether the user's granted permissions present in the token include the requested resource ID (translated from the path) and scope (inferred from the HTTP method). If the token does not contain a <code>permissions</code> claim (i.e. it is not an RPT), Authorino will negotiate a User-Managed Access (UMA) ticket on behalf of the user and try to obtain an RPT on that UMA ticket.</p> <p>In cases of asynchronous user-managed permission control, the first request to the API using a normal Keycloak ID token is denied by Authorino. The user that owns the resource acknowledges the access request in the Keycloak UI. If access is granted, the new permissions will be reflected in subsequent RPTs obtained by Authorino on behalf of the requesting party.</p> <p>Whenever an RPT with proper permissions is obtained by Authorino, the RPT is supplied back to the API consumer, so it can be used in subsequent requests thus skipping new negotiations of UMA tickets.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"uma\":\n      opa:\n        rego: |\n          pat := http.send({\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token\",\"method\": \"post\",\"headers\":{\"Content-Type\":\"application/x-www-form-urlencoded\"},\"raw_body\":\"grant_type=client_credentials\"}).body.access_token\n          resource_id := http.send({\"url\":concat(\"\",[\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/authz/protection/resource_set?uri=\",input.context.request.http.path]),\"method\":\"get\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",pat])}}).body[0]\n          scope := lower(input.context.request.http.method)\n          access_token := trim_prefix(input.context.request.http.headers.authorization, \"Bearer \")\n\n          default rpt = \"\"\n          rpt = access_token { object.get(input.auth.identity, \"authorization\", {}).permissions }\n          else = rpt_str {\n            ticket := http.send({\"url\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/authz/protection/permission\",\"method\":\"post\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",pat]),\"Content-Type\":\"application/json\"},\"raw_body\":concat(\"\",[\"[{\\\"resource_id\\\":\\\"\",resource_id,\"\\\",\\\"resource_scopes\\\":[\\\"\",scope,\"\\\"]}]\"])}).body.ticket\n            rpt_str := object.get(http.send({\"url\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token\",\"method\":\"post\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",access_token]),\"Content-Type\":\"application/x-www-form-urlencoded\"},\"raw_body\":concat(\"\",[\"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket&amp;ticket=\",ticket,\"&amp;submit_request=true\"])}).body, \"access_token\", \"\")\n          }\n\n          allow {\n            permissions := object.get(io.jwt.decode(rpt)[1], \"authorization\", { \"permissions\": [] }).permissions\n            permissions[i]\n            permissions[i].rsid = resource_id\n            permissions[i].scopes[_] = scope\n          }\n        allValues: true\n  response:\n    success:\n      headers:\n        \"x-keycloak\":\n          when:\n\n          - selector: auth.identity.authorization.permissions\n            operator: eq\n            value: \"\"\n          json:\n            properties:\n              \"rpt\":\n                selector: auth.authorization.uma.rpt\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for user Jane:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#consume-the-api","title":"\u277c Consume the API","text":"<p>As Jane, try to send a <code>GET</code> request to the protected resource <code>/greetings/1</code>, owned by user John.</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>As John, log in to http://localhost:8080/realms/kuadrant/account in the web browser (username: <code>john</code> / password: <code>p</code>), and grant access to the resource <code>greeting-1</code> for Jane. A pending permission request by Jane shall exist in the list of John's Resources.</p> <p> </p> <p>As Jane, try to consume the protected resource <code>/greetings/1</code> again:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 200 OK\n#\n# {\u2026\n#   \"headers\": {\u2026\n#     \"X-Keycloak\": \"{\\\"rpt\\\":\\\"&lt;RPT&gt;\", \u2026\n</code></pre> <p>Copy the RPT from the response and repeat the request now using the RPT to authenticate:</p> <pre><code>curl -H \"Authorization: Bearer &lt;RPT&gt;\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/","title":"User guide: Kubernetes RBAC for service authorization (SubjectAccessReview API)","text":"<p>Manage permissions in the Kubernetes RBAC and let Authorino to check them in request-time with the authorization system of the cluster.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Kubernetes SubjectAccessReview</li> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> </ul> <p>Authorino can delegate authorization decision to the Kubernetes authorization system, allowing permissions to be stored and managed using the Kubernetes Role-Based Access Control (RBAC) for example. The feature is based on the <code>SubjectAccessReview</code> API and can be used for <code>resourceAttributes</code> (parameters defined in the <code>AuthConfig</code>) or <code>nonResourceAttributes</code> (inferring HTTP path and verb from the original request).</p> <p>Check out as well the user guide about Authentication with Kubernetes tokens (TokenReview API).</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC) and to create <code>TokenRequest</code>s (to consume the protected service from outside the cluster)</li> <li>jq</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The <code>AuthConfig</code> below sets all Kubernetes service accounts as trusted users of the API, and relies on the Kubernetes RBAC to enforce authorization using Kubernetes SubjectAccessReview API for non-resource endpoints:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  - envoy.default.svc.cluster.local\n  authentication:\n    \"service-accounts\":\n      kubernetesTokenReview:\n        audiences: [\"https://kubernetes.default.svc.cluster.local\"]\n  authorization:\n    \"k8s-rbac\":\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.user.username\nEOF\n</code></pre> <p>Check out the spec for the Authorino Kubernetes SubjectAccessReview authorization feature, for resource attributes permission checks where SubjectAccessReviews issued by Authorino are modeled in terms of common attributes of operations on Kubernetes resources (namespace, API group, kind, name, subresource, verb).</p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-roles-associated-with-endpoints-of-the-api","title":"\u277b Create roles associated with endpoints of the API","text":"<p>Because the <code>k8s-rbac</code> policy defined in the <code>AuthConfig</code> in the previous step is for non-resource access review requests, the corresponding roles and role bindings have to be defined at cluster scope.</p> <p>Create a <code>talker-api-greeter</code> role whose users and service accounts bound to this role can consume the non-resource endpoints <code>POST /hello</code> and <code>POST /hi</code> of the API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: talker-api-greeter\nrules:\n\n- nonResourceURLs: [\"/hello\"]\n  verbs: [\"post\"]\n- nonResourceURLs: [\"/hi\"]\n  verbs: [\"post\"]\nEOF\n</code></pre> <p>Create a <code>talker-api-speaker</code> role whose users and service accounts bound to this role can consume the non-resource endpoints <code>POST /say/*</code> of the API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: talker-api-speaker\nrules:\n\n- nonResourceURLs: [\"/say/*\"]\n  verbs: [\"post\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-the-serviceaccounts-and-permissions-to-consume-the-api","title":"\u277c Create the <code>ServiceAccount</code>s and permissions to consume the API","text":"<p>Create service accounts <code>api-consumer-1</code> and <code>api-consumer-2</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-1\nEOF\n</code></pre> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-2\nEOF\n</code></pre> <p>Bind both service accounts to the <code>talker-api-greeter</code> role:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: talker-api-greeter-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: talker-api-greeter\nsubjects:\n\n- kind: ServiceAccount\n  name: api-consumer-1\n  namespace: default\n- kind: ServiceAccount\n  name: api-consumer-2\n  namespace: default\nEOF\n</code></pre> <p>Bind service account <code>api-consumer-1</code> to the <code>talker-api-speaker</code> role:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: talker-api-speaker-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: talker-api-speaker\nsubjects:\n\n- kind: ServiceAccount\n  name: api-consumer-1\n  namespace: default\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#consume-the-api","title":"\u277d Consume the API","text":"<p>Run a pod that consumes one of the greeting endpoints of the API from inside the cluster, as service account <code>api-consumer-1</code>, bound to the <code>talker-api-greeter</code> and <code>talker-api-speaker</code> cluster roles in the Kubernetes RBAC:</p> <pre><code>kubectl run greeter --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/hi\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-1\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 200\n</code></pre> <p>Run a pod that sends a <code>POST</code> request to <code>/say/blah</code> from within the cluster, as service account <code>api-consumer-1</code>:</p> <pre><code>kubectl run speaker --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/say/blah\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-1\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 200\n</code></pre> <p>Run a pod that sends a <code>POST</code> request to <code>/say/blah</code> from within the cluster, as service account <code>api-consumer-2</code>, bound only to the <code>talker-api-greeter</code> cluster role in the Kubernetes RBAC:</p> <pre><code>kubectl run speaker --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/say/blah\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-2\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 403\n</code></pre> Extra: consume the API as service account <code>api-consumer-2</code> from outside the cluster <p></p> <p>Obtain a short-lived access token for service account <code>api-consumer-2</code>, bound to the <code>talker-api-greeter</code> cluster role in the Kubernetes RBAC, using the Kubernetes TokenRequest API:</p> <pre><code>export ACCESS_TOKEN=$(echo '{ \"apiVersion\": \"authentication.k8s.io/v1\", \"kind\": \"TokenRequest\", \"spec\": { \"expirationSeconds\": 600 } }' | kubectl create --raw /api/v1/namespaces/default/serviceaccounts/api-consumer-2/token -f - | jq -r .status.token)\n</code></pre> <p>Consume the API as <code>api-consumer-2</code> from outside the cluster:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X POST http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X POST http://talker-api.127.0.0.1.nip.io:8000/say/something -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete serviceaccount/api-consumer-1\nkubectl delete serviceaccount/api-consumer-2\nkubectl delete clusterrolebinding/talker-api-greeter-rolebinding\nkubectl delete clusterrolebinding/talker-api-speaker-rolebinding\nkubectl delete clusterrole/talker-api-greeter\nkubectl delete clusterrole/talker-api-speaker\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/","title":"User guide: Authentication with Kubernetes tokens (TokenReview API)","text":"<p>Validate Kubernetes Service Account tokens to authenticate requests to your protected hosts.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> </ul> <p>Authorino can verify Kubernetes-valid access tokens (using Kubernetes TokenReview API).</p> <p>These tokens can be either <code>ServiceAccount</code> tokens or any valid user access tokens issued to users of the Kubernetes server API.</p> <p>The <code>audiences</code> claim of the token must include the requested host and port of the protected API (default), or all audiences specified in <code>spec.identity.kubernetes.audiences</code> of the <code>AuthConfig</code>.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC) and to create <code>TokenRequest</code>s (to consume the protected service from outside the cluster)</li> <li>jq</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  - envoy.default.svc.cluster.local\n  authentication:\n    \"authorized-service-accounts\":\n      kubernetesTokenReview:\n        audiences:\n        - talker-api\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-protected-by-authorino","title":"\u277b Consume the API protected by Authorino","text":""},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#create-a-serviceaccount","title":"Create a <code>ServiceAccount</code>","text":"<p>Create a Kubernetes <code>ServiceAccount</code> to identify the consumer application that will send requests to the protected API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-1\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-from-outside-the-cluster","title":"Consume the API from outside the cluster","text":"<p>Obtain a short-lived access token for the <code>api-consumer-1</code> service account:</p> <pre><code>export ACCESS_TOKEN=$(echo '{ \"apiVersion\": \"authentication.k8s.io/v1\", \"kind\": \"TokenRequest\", \"spec\": { \"audiences\": [\"talker-api\"], \"expirationSeconds\": 600 } }' | kubectl create --raw /api/v1/namespaces/default/serviceaccounts/api-consumer-1/token -f - | jq -r .status.token)\n</code></pre> <p>Consume the API with a valid Kubernetes token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Consume the API with the Kubernetes token expired (10 minutes):</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"authorized-service-accounts\"\n# x-ext-auth-reason: Not authenticated\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-from-inside-the-cluster","title":"Consume the API from inside the cluster","text":"<p>Deploy an application that consumes an endpoint of the Talker API, in a loop, every 10 seconds. The application uses a short-lived service account token mounted inside the container using Kubernetes Service Account Token Volume Projection to authenticate.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: api-consumer\nspec:\n  containers:\n\n  - name: api-consumer\n    image: quay.io/kuadrant/authorino-examples:api-consumer\n    command: [\"./run\"]\n    args:\n      - --endpoint=http://envoy.default.svc.cluster.local:8000/hello\n      - --token-path=/var/run/secrets/tokens/api-token\n      - --interval=10\n    volumeMounts:\n    - mountPath: /var/run/secrets/tokens\n      name: talker-api-access-token\n  serviceAccountName: api-consumer-1\n  volumes:\n  - name: talker-api-access-token\n    projected:\n      sources:\n      - serviceAccountToken:\n          path: api-token\n          expirationSeconds: 7200\n          audience: talker-api\nEOF\n</code></pre> <p>Check the logs of <code>api-consumer</code>:</p> <pre><code>kubectl logs -f api-consumer\n# Sending...\n# 200\n# 200\n# 200\n# 200\n# ...\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete pod/api-consumer\nkubectl delete serviceaccount/api-consumer-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/mtls-authentication/","title":"User guide: Authentication with X.509 certificates and Mutual Transport Layer Security (mTLS)","text":"<p>Verify client X.509 certificates against trusted root CAs stored in Kubernetes <code>Secret</code>s to authenticate access to APIs protected with Authorino.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 X.509 client certificate authentication</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Authorino can verify x509 certificates presented by clients for authentication on the request to the protected APIs, at application level.</p> <p>Trusted root Certificate Authorities (CA) are stored as Kubernetes <code>kubernetes.io/tls</code> Secrets labeled according to selectors specified in the AuthConfig, watched and cached by Authorino.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/mtls-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/mtls-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following commands will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS enabled<sup>3</sup>.</p> <p>Create the TLS certificates for the Authorino service:</p> <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/default/g\" | kubectl apply -f -\n</code></pre> <p>Request the Authorino instance:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#create-a-ca","title":"\u2779 Create a CA","text":"<p>Create a CA (Certificate Authority) certificate to issue the client certificates that will be used to authenticate clients that send requests to the Talker API:</p> <pre><code>openssl req -x509 -sha512 -nodes \\\n  -days 365 \\\n  -newkey rsa:4096 \\\n  -subj \"/CN=talker-api-ca\" \\\n  -addext basicConstraints=CA:TRUE \\\n  -addext keyUsage=digitalSignature,keyCertSign \\\n  -keyout /tmp/ca.key \\\n  -out /tmp/ca.crt\n</code></pre> <p>Store the CA cert in a Kubernetes <code>Secret</code>, labeled to be discovered by Authorino and to be mounted in the file system of the Envoy container:</p> <pre><code>kubectl create secret tls talker-api-ca --cert=/tmp/ca.crt --key=/tmp/ca.key\nkubectl label secret talker-api-ca authorino.kuadrant.io/managed-by=authorino app=talker-api\n</code></pre> <p>Prepare an extension file for the client certificate signing requests:</p> <pre><code>cat &gt; /tmp/x509v3.ext &lt;&lt; EOF\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage=digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment\nextendedKeyUsage=clientAuth\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#setup-envoy","title":"\u277a Setup Envoy","text":"<p>The following command deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\ndata:\n  envoy.yaml: |\n    static_resources:\n      listeners:\n\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 8443\n        filter_chains:\n        - transport_socket:\n            name: envoy.transport_sockets.tls\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext\n              common_tls_context:\n                tls_certificates:\n                - certificate_chain: {filename: \"/etc/ssl/certs/talker-api/tls.crt\"}\n                  private_key: {filename: \"/etc/ssl/certs/talker-api/tls.key\"}\n                validation_context:\n                  trusted_ca:\n                    filename: /etc/ssl/certs/talker-api/tls.crt\n          filters:\n          - name: envoy.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              stat_prefix: local\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: local_service\n                  domains: ['*']\n                  routes:\n                  - match: { prefix: / }\n                    route: { cluster: talker-api }\n              http_filters:\n              - name: envoy.filters.http.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  failure_mode_allow: false\n                  include_peer_certificate: true\n                  grpc_service:\n                    envoy_grpc: { cluster_name: authorino }\n                    timeout: 1s\n              - name: envoy.filters.http.router\n                typed_config: {}\n              use_remote_address: true\n      clusters:\n      - name: authorino\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        http2_protocol_options: {}\n        load_assignment:\n          cluster_name: authorino\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: authorino-authorino-authorization\n                    port_value: 50051\n        transport_socket:\n          name: envoy.transport_sockets.tls\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n            common_tls_context:\n              validation_context:\n                trusted_ca:\n                  filename: /etc/ssl/certs/authorino-ca-cert.crt\n      - name: talker-api\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: talker-api\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: talker-api\n                    port_value: 3000\n    admin:\n      access_log_path: \"/tmp/admin_access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\nspec:\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - args:\n        - --config-path /usr/local/etc/envoy/envoy.yaml\n        - --service-cluster front-proxy\n        - --log-level info\n        - --component-log-level filter:trace,http:debug,router:debug\n        command:\n        - /usr/local/bin/envoy\n        image: envoyproxy/envoy:v1.19-latest\n        name: envoy\n        ports:\n        - containerPort: 8443\n          name: web\n        - containerPort: 8001\n          name: admin\n        volumeMounts:\n        - mountPath: /usr/local/etc/envoy\n          name: config\n          readOnly: true\n        - mountPath: /etc/ssl/certs/authorino-ca-cert.crt\n          name: authorino-ca-cert\n          readOnly: true\n          subPath: ca.crt\n        - mountPath: /etc/ssl/certs/talker-api\n          name: talker-api-ca\n          readOnly: true\n      volumes:\n      - configMap:\n          items:\n          - key: envoy.yaml\n            path: envoy.yaml\n          name: envoy\n        name: config\n      - name: authorino-ca-cert\n        secret:\n          defaultMode: 420\n          secretName: authorino-ca-cert\n      - name: talker-api-ca\n        secret:\n          defaultMode: 420\n          secretName: talker-api-ca\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\nspec:\n  selector:\n    app: envoy\n  ports:\n  - name: web\n    port: 8443\n    protocol: TCP\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-wildcard-host\nspec:\n  rules:\n  - host: talker-api.127.0.0.1.nip.io\n    http:\n      paths:\n      - backend:\n          service:\n            name: envoy\n            port: { number: 8443 }\n        path: /\n        pathType: Prefix\nEOF\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8443 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8443:8443 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#create-the-authconfig","title":"\u277b Create the <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"mtls\":\n      x509:\n        selector:\n          matchLabels:\n            app: talker-api\n  authorization:\n    \"acme\":\n      patternMatching:\n        patterns:\n        - selector: auth.identity.Organization\n          operator: incl\n          value: ACME Inc.\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a TLS certificate signed by the trusted CA:</p> <pre><code>openssl genrsa -out /tmp/aisha.key 4096\nopenssl req -new -subj \"/CN=aisha/C=PK/L=Islamabad/O=ACME Inc./OU=Engineering\" -key /tmp/aisha.key -out /tmp/aisha.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/ca.crt -CAkey /tmp/ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/aisha.csr -out /tmp/aisha.crt\n\ncurl -k --cert /tmp/aisha.crt --key /tmp/aisha.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>With a TLS certificate signed by the trusted CA, though missing an authorized Organization:</p> <pre><code>openssl genrsa -out /tmp/john.key 4096\nopenssl req -new -subj \"/CN=john/C=UK/L=London\" -key /tmp/john.key -out /tmp/john.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/ca.crt -CAkey /tmp/ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/john.csr -out /tmp/john.crt\n\ncurl -k --cert /tmp/john.crt --key /tmp/john.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#try-the-authconfig-via-raw-http-authorization-interface","title":"\u277d Try the AuthConfig via raw HTTP authorization interface","text":"<p>Expose Authorino's raw HTTP authorization to the local host:</p> <pre><code>kubectl port-forward service/authorino-authorino-authorization 5001:5001 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>With a TLS certificate signed by the trusted CA:</p> <pre><code>curl -k --cert /tmp/aisha.crt --key /tmp/aisha.key -H 'Content-Type: application/json' -d '{}' https://talker-api.127.0.0.1.nip.io:5001/check -i\n# HTTP/2 200\n</code></pre> <p>With a TLS certificate signed by an unknown authority:</p> <pre><code>openssl req -x509 -sha512 -nodes \\\n  -days 365 \\\n  -newkey rsa:4096 \\\n  -subj \"/CN=untrusted\" \\\n  -addext basicConstraints=CA:TRUE \\\n  -addext keyUsage=digitalSignature,keyCertSign \\\n  -keyout /tmp/untrusted-ca.key \\\n  -out /tmp/untrusted-ca.crt\n\nopenssl genrsa -out /tmp/niko.key 4096\nopenssl req -new -subj \"/CN=niko/C=JP/L=Osaka\" -key /tmp/niko.key -out /tmp/niko.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/untrusted-ca.crt -CAkey /tmp/untrusted-ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/niko.csr -out /tmp/niko.crt\n\ncurl -k --cert /tmp/niko.crt --key /tmp/niko.key -H 'Content-Type: application/json' -d '{}' https://talker-api.127.0.0.1.nip.io:5001/check -i\n# HTTP/2 401\n# www-authenticate: Basic realm=\"mtls\"\n# x-ext-auth-reason: x509: certificate signed by unknown authority\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#revoke-an-entire-chain-of-certificates","title":"\u277e Revoke an entire chain of certificates","text":"<pre><code>kubectl delete secret/talker-api-ca\n</code></pre> <p>Even if the deleted root certificate is still cached and accepted at the gateway, Authorino will revoke access at application level immediately.</p> <p>Try with a previously accepted certificate:</p> <pre><code>curl -k --cert /tmp/aisha.crt --key /tmp/aisha.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Basic realm=\"mtls\"\n# x-ext-auth-reason: x509: certificate signed by unknown authority\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#cleanup","title":"Cleanup","text":"<pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/","title":"User guide: OAuth 2.0 token introspection (RFC 7662)","text":"<p>Introspect OAuth 2.0 access tokens (e.g. opaque tokens) for online user data and token validation in request-time.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 OAuth 2.0 introspection</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Authorino can perform OAuth 2.0 token introspection (RFC 7662) on the access tokens supplied in the requests to protected APIs. This is particularly useful when using opaque tokens, for remote checking the token validity and resolving the identity object.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>OAuth 2.0 server that implements the token introspection endpoint (RFC 7662) (e.g. Keycloak or a12n-server)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Deploy an a12n-server server preloaded with all settings required for this guide:</p> <pre><code>kubectl create namespace a12n-server\nkubectl -n a12n-server apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/a12n-server/a12n-server-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create the required secrets that will be used by Authorino to authenticate with Keycloak and a12n-server during the introspection request:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: oauth2-token-introspection-credentials-keycloak\nstringData:\n  clientID: talker-api\n  clientSecret: 523b92b6-625d-4e1e-a313-77e7a8ae4e88\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: oauth2-token-introspection-credentials-a12n-server\nstringData:\n  clientID: talker-api\n  clientSecret: V6g-2Eq2ALB1_WHAswzoeZofJ_e86RI4tdjClDDDb4g\ntype: Opaque\nEOF\n</code></pre> <p>Create the Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak\":\n      oauth2Introspection:\n        endpoint: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token/introspect\n        tokenTypeHint: requesting_party_token\n        credentialsRef:\n          name: oauth2-token-introspection-credentials-keycloak\n    \"a12n-server\":\n      oauth2Introspection:\n        endpoint: http://a12n-server.a12n-server.svc.cluster.local:8531/introspect\n        credentialsRef:\n          name: oauth2-token-introspection-credentials-a12n-server\n  authorization:\n    \"can-read\":\n      when:\n      - selector: auth.identity.privileges\n        operator: neq\n        value: \"\"\n      patternMatching:\n        patterns:\n        - selector: auth.identity.privileges.talker-api\n          operator: incl\n          value: read\nEOF\n</code></pre> <p>On every request, Authorino will try to verify the token remotely with the Keycloak server and the a12n-server server.</p> <p>For authorization, whenever the introspected token data includes a <code>privileges</code> property (returned by a12n-server), Authorino will enforce only consumers whose <code>privileges.talker-api</code> includes the <code>\"read\"</code> permission are granted access.</p> <p>Check out the docs for information about the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-with-keycloak-and-consume-the-api","title":"Obtain an access token with Keycloak and consume the API","text":"<p>Obtain an access token with the Keycloak server for user Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>export $(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r '\"ACCESS_TOKEN=\"+.access_token,\"REFRESH_TOKEN=\"+.refresh_token')\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As user Jane, consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/logout -H \"Content-Type: application/x-www-form-urlencoded\" -d \"refresh_token=$REFRESH_TOKEN\" -d 'token_type_hint=requesting_party_token' -u demo:\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-with-a12n-server-and-consume-the-api","title":"Obtain an access token with a12n-server and consume the API","text":"<p>Forward local requests to a12n-server instance running in the cluster:</p> <pre><code>kubectl -n a12n-server port-forward deployment/a12n-server 8531:8531 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Obtain an access token with the a12n-server server for service account <code>service-account-1</code>:</p> <pre><code>ACCESS_TOKEN=$(curl -d 'grant_type=client_credentials' -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s \"http://localhost:8531/token\" | jq -r .access_token)\n</code></pre> <p>You can as well obtain an access token from within the cluster, in case your a12n-server is not reachable from the outside:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://a12n-server.a12n-server.svc.cluster.local:8531/token -s -d 'grant_type=client_credentials' -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s | jq -r .access_token)\n</code></pre> <p>Verify the issued token is an opaque access token in this case:</p> <pre><code>echo $ACCESS_TOKEN\n</code></pre> <p>As <code>service-account-1</code>, consumer the API with a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>curl -d \"token=$ACCESS_TOKEN\" -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s \"http://localhost:8531/revoke\" -i\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#consume-the-api-with-a-missing-or-invalid-access-token","title":"Consume the API with a missing or invalid access token","text":"<pre><code>curl -H \"Authorization: Bearer invalid\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete secret/oauth2-token-introspection-credentials-keycloak\nkubectl delete secret/oauth2-token-introspection-credentials-a12n-server\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\nkubectl delete namespace a12n-server\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/observability/","title":"Observability","text":""},{"location":"authorino/docs/user-guides/observability/#metrics","title":"Metrics","text":"<p>Authorino exports metrics at 2 endpoints:</p> /metrics Metrics of the controller-runtime about reconciliation (caching) of AuthConfigs and API key Secrets /server-metrics Metrics of the external authorization gRPC and OIDC/Festival Wristband validation built-in HTTP servers <p>The Authorino Operator creates a Kubernetes <code>Service</code> named <code>&lt;authorino-cr-name&gt;-controller-metrics</code> that exposes the endpoints on port 8080. The Authorino instance allows to modify the port number of the metrics endpoints, by setting the <code>--metrics-addr</code> command-line flag (default: <code>:8080</code>).</p> <p>Main metrics exported by endpoint<sup>1</sup>:</p> Endpoint: <code>/metrics</code> Metric name Description\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Labels Type controller_runtime_reconcile_total Total number of reconciliations per controller <code>controller=authconfig|secret</code>, <code>result=success|error|requeue</code> counter controller_runtime_reconcile_errors_total Total number of reconciliation errors per controller <code>controller=authconfig|secret</code> counter controller_runtime_reconcile_time_seconds Length of time per reconciliation per controller <code>controller=authconfig|secret</code> histogram controller_runtime_max_concurrent_reconciles Maximum number of concurrent reconciles per controller <code>controller=authconfig|secret</code> gauge workqueue_adds_total Total number of adds handled by workqueue <code>name=authconfig|secret</code> counter workqueue_depth Current depth of workqueue <code>name=authconfig|secret</code> gauge workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested <code>name=authconfig|secret</code> histogram workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running. <code>name=authconfig|secret</code> gauge workqueue_retries_total Total number of retries handled by workqueue <code>name=authconfig|secret</code> counter workqueue_unfinished_work_seconds How many seconds of work has been done that is in progress and hasn't been observed by work_duration. <code>name=authconfig|secret</code> gauge workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes. <code>name=authconfig|secret</code> histogram rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host. <code>code=200|404</code>, <code>method=GET|PUT|POST</code> counter Endpoint: <code>/server-metrics</code> Metric name Description Labels Type auth_server_evaluator_total<sup>2</sup> Total number of evaluations of individual authconfig rule performed by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_cancelled<sup>2</sup> Number of evaluations of individual authconfig rule cancelled by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_ignored<sup>2</sup> Number of evaluations of individual authconfig rule ignored by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_denied<sup>2</sup> Number of denials from individual authconfig rule evaluated by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_duration_seconds<sup>2</sup> Response latency of individual authconfig rule evaluated by the auth server (in seconds). <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> histogram auth_server_authconfig_total Total number of authconfigs enforced by the auth server, partitioned by authconfig. <code>namespace</code>, <code>authconfig</code> counter auth_server_authconfig_response_status Response status of authconfigs sent by the auth server, partitioned by authconfig. <code>namespace</code>, <code>authconfig</code>, <code>status=OK|UNAUTHENTICATED,PERMISSION_DENIED</code> counter auth_server_authconfig_duration_seconds Response latency of authconfig enforced by the auth server (in seconds). <code>namespace</code>, <code>authconfig</code> histogram auth_server_response_status Response status of authconfigs sent by the auth server. <code>status=OK|UNAUTHENTICATED,PERMISSION_DENIED|NOT_FOUND</code> counter grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure. <code>grpc_code=OK|Aborted|Canceled|DeadlineExceeded|Internal|ResourceExhausted|Unknown</code>, <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_handling_seconds Response latency (seconds) of gRPC that had been application-level handled by the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> histogram grpc_server_msg_received_total Total number of RPC stream messages received on the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_started_total Total number of RPCs started on the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter http_server_handled_total Total number of calls completed on the raw HTTP authorization server, regardless of success or failure. <code>http_code</code> counter http_server_handling_seconds Response latency (seconds) of raw HTTP authorization request that had been application-level handled by the server. histogram oidc_server_requests_total Number of get requests received on the OIDC (Festival Wristband) server. <code>namespace</code>, <code>authconfig</code>, <code>wristband</code>, <code>path=oidc-config|jwks</code> counter oidc_server_response_status Status of HTTP response sent by the OIDC (Festival Wristband) server. <code>status=200|404</code> counter <p><sup>1</sup> Both endpoints export metrics about the Go runtime, such as number of goroutines (go_goroutines) and threads (go_threads), usage of CPU, memory and GC stats.</p> <p><sup>2</sup> Opt-in metrics: <code>auth_server_evaluator_*</code> metrics require <code>authconfig.spec.(identity|metadata|authorization|response).metrics: true</code> (default: <code>false</code>). This can be enforced for the entire instance (all AuthConfigs and evaluators), by setting the <code>--deep-metrics-enabled</code> command-line flag in the Authorino deployment.</p> Example of metrics exported at the <code>/metrics</code> endpoint <pre><code># HELP controller_runtime_active_workers Number of currently used workers per controller\n# TYPE controller_runtime_active_workers gauge\ncontroller_runtime_active_workers{controller=\"authconfig\"} 0\ncontroller_runtime_active_workers{controller=\"secret\"} 0\n# HELP controller_runtime_max_concurrent_reconciles Maximum number of concurrent reconciles per controller\n# TYPE controller_runtime_max_concurrent_reconciles gauge\ncontroller_runtime_max_concurrent_reconciles{controller=\"authconfig\"} 1\ncontroller_runtime_max_concurrent_reconciles{controller=\"secret\"} 1\n# HELP controller_runtime_reconcile_errors_total Total number of reconciliation errors per controller\n# TYPE controller_runtime_reconcile_errors_total counter\ncontroller_runtime_reconcile_errors_total{controller=\"authconfig\"} 12\ncontroller_runtime_reconcile_errors_total{controller=\"secret\"} 0\n# HELP controller_runtime_reconcile_time_seconds Length of time per reconciliation per controller\n# TYPE controller_runtime_reconcile_time_seconds histogram\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.005\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.01\"} 11\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.025\"} 17\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.05\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.1\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.15\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.2\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.25\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.3\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.35\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.4\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.45\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.6\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.7\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.8\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.9\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.25\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.75\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"2\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"2.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"3\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"3.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"4\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"4.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"5\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"6\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"7\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"8\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"9\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"10\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"15\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"20\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"25\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"30\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"40\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"50\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"60\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"+Inf\"} 19\ncontroller_runtime_reconcile_time_seconds_sum{controller=\"authconfig\"} 5.171108321999999\ncontroller_runtime_reconcile_time_seconds_count{controller=\"authconfig\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.005\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.01\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.025\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.05\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.1\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.15\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.2\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.3\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.35\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.4\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.45\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.6\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.7\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.8\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.9\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.75\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"2\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"2.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"3\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"3.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"4\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"4.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"6\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"7\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"8\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"9\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"10\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"15\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"20\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"30\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"40\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"50\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"60\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"+Inf\"} 1\ncontroller_runtime_reconcile_time_seconds_sum{controller=\"secret\"} 0.000138025\ncontroller_runtime_reconcile_time_seconds_count{controller=\"secret\"} 1\n# HELP controller_runtime_reconcile_total Total number of reconciliations per controller\n# TYPE controller_runtime_reconcile_total counter\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"error\"} 12\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"requeue\"} 0\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"requeue_after\"} 0\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"success\"} 7\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"error\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"requeue\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"requeue_after\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"success\"} 1\n# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.\n# TYPE go_gc_cycles_automatic_gc_cycles_total counter\ngo_gc_cycles_automatic_gc_cycles_total 13\n# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.\n# TYPE go_gc_cycles_forced_gc_cycles_total counter\ngo_gc_cycles_forced_gc_cycles_total 0\n# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.\n# TYPE go_gc_cycles_total_gc_cycles_total counter\ngo_gc_cycles_total_gc_cycles_total 13\n# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.5971e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.69e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 0.000140699\ngo_gc_duration_seconds{quantile=\"0.75\"} 0.000313162\ngo_gc_duration_seconds{quantile=\"1\"} 0.001692423\ngo_gc_duration_seconds_sum 0.003671076\ngo_gc_duration_seconds_count 13\n# HELP go_gc_heap_allocs_by_size_bytes_total Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_by_size_bytes_total histogram\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 6357\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 45065\n[...]\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 128306\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"+Inf\"} 128327\ngo_gc_heap_allocs_by_size_bytes_total_sum 1.5021512e+07\ngo_gc_heap_allocs_by_size_bytes_total_count 128327\n# HELP go_gc_heap_allocs_bytes_total Cumulative sum of memory allocated to the heap by the application.\n# TYPE go_gc_heap_allocs_bytes_total counter\ngo_gc_heap_allocs_bytes_total 1.5021512e+07\n# HELP go_gc_heap_allocs_objects_total Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_objects_total counter\ngo_gc_heap_allocs_objects_total 128327\n# HELP go_gc_heap_frees_by_size_bytes_total Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_by_size_bytes_total histogram\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 3885\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 33418\n[...]\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 96417\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"+Inf\"} 96425\ngo_gc_heap_frees_by_size_bytes_total_sum 9.880944e+06\ngo_gc_heap_frees_by_size_bytes_total_count 96425\n# HELP go_gc_heap_frees_bytes_total Cumulative sum of heap memory freed by the garbage collector.\n# TYPE go_gc_heap_frees_bytes_total counter\ngo_gc_heap_frees_bytes_total 9.880944e+06\n# HELP go_gc_heap_frees_objects_total Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_objects_total counter\ngo_gc_heap_frees_objects_total 96425\n# HELP go_gc_heap_goal_bytes Heap size target for the end of the GC cycle.\n# TYPE go_gc_heap_goal_bytes gauge\ngo_gc_heap_goal_bytes 9.356624e+06\n# HELP go_gc_heap_objects_objects Number of objects, live or unswept, occupying heap memory.\n# TYPE go_gc_heap_objects_objects gauge\ngo_gc_heap_objects_objects 31902\n# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size.\n# TYPE go_gc_heap_tiny_allocs_objects_total counter\ngo_gc_heap_tiny_allocs_objects_total 11750\n# HELP go_gc_pauses_seconds_total Distribution individual GC-related stop-the-world pause latencies.\n# TYPE go_gc_pauses_seconds_total histogram\ngo_gc_pauses_seconds_total_bucket{le=\"9.999999999999999e-10\"} 0\ngo_gc_pauses_seconds_total_bucket{le=\"1.9999999999999997e-09\"} 0\n[...]\ngo_gc_pauses_seconds_total_bucket{le=\"206708.18602188796\"} 26\ngo_gc_pauses_seconds_total_bucket{le=\"+Inf\"} 26\ngo_gc_pauses_seconds_total_sum 0.003151488\ngo_gc_pauses_seconds_total_count 26\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 80\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.18.7\"} 1\n# HELP go_memory_classes_heap_free_bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory.\n# TYPE go_memory_classes_heap_free_bytes gauge\ngo_memory_classes_heap_free_bytes 589824\n# HELP go_memory_classes_heap_objects_bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.\n# TYPE go_memory_classes_heap_objects_bytes gauge\ngo_memory_classes_heap_objects_bytes 5.140568e+06\n# HELP go_memory_classes_heap_released_bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory.\n# TYPE go_memory_classes_heap_released_bytes gauge\ngo_memory_classes_heap_released_bytes 4.005888e+06\n# HELP go_memory_classes_heap_stacks_bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.\n# TYPE go_memory_classes_heap_stacks_bytes gauge\ngo_memory_classes_heap_stacks_bytes 786432\n# HELP go_memory_classes_heap_unused_bytes Memory that is reserved for heap objects but is not currently used to hold heap objects.\n# TYPE go_memory_classes_heap_unused_bytes gauge\ngo_memory_classes_heap_unused_bytes 2.0602e+06\n# HELP go_memory_classes_metadata_mcache_free_bytes Memory that is reserved for runtime mcache structures, but not in-use.\n# TYPE go_memory_classes_metadata_mcache_free_bytes gauge\ngo_memory_classes_metadata_mcache_free_bytes 13984\n# HELP go_memory_classes_metadata_mcache_inuse_bytes Memory that is occupied by runtime mcache structures that are currently being used.\n# TYPE go_memory_classes_metadata_mcache_inuse_bytes gauge\ngo_memory_classes_metadata_mcache_inuse_bytes 2400\n# HELP go_memory_classes_metadata_mspan_free_bytes Memory that is reserved for runtime mspan structures, but not in-use.\n# TYPE go_memory_classes_metadata_mspan_free_bytes gauge\ngo_memory_classes_metadata_mspan_free_bytes 17104\n# HELP go_memory_classes_metadata_mspan_inuse_bytes Memory that is occupied by runtime mspan structures that are currently being used.\n# TYPE go_memory_classes_metadata_mspan_inuse_bytes gauge\ngo_memory_classes_metadata_mspan_inuse_bytes 113968\n# HELP go_memory_classes_metadata_other_bytes Memory that is reserved for or used to hold runtime metadata.\n# TYPE go_memory_classes_metadata_other_bytes gauge\ngo_memory_classes_metadata_other_bytes 5.544408e+06\n# HELP go_memory_classes_os_stacks_bytes Stack memory allocated by the underlying operating system.\n# TYPE go_memory_classes_os_stacks_bytes gauge\ngo_memory_classes_os_stacks_bytes 0\n# HELP go_memory_classes_other_bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.\n# TYPE go_memory_classes_other_bytes gauge\ngo_memory_classes_other_bytes 537777\n# HELP go_memory_classes_profiling_buckets_bytes Memory that is used by the stack trace hash map used for profiling.\n# TYPE go_memory_classes_profiling_buckets_bytes gauge\ngo_memory_classes_profiling_buckets_bytes 1.455487e+06\n# HELP go_memory_classes_total_bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.\n# TYPE go_memory_classes_total_bytes gauge\ngo_memory_classes_total_bytes 2.026804e+07\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 5.140568e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 1.5021512e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.455487e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 108175\n# HELP go_memstats_gc_cpu_fraction The fraction of this program's available CPU time used by the GC since the program started.\n# TYPE go_memstats_gc_cpu_fraction gauge\ngo_memstats_gc_cpu_fraction 0\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 5.544408e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 5.140568e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 4.595712e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 7.200768e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 31902\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 4.005888e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.179648e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6461572121033354e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 140077\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 2400\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 16384\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 113968\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 131072\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 9.356624e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 537777\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 786432\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 786432\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.026804e+07\n# HELP go_sched_goroutines_goroutines Count of live goroutines.\n# TYPE go_sched_goroutines_goroutines gauge\ngo_sched_goroutines_goroutines 80\n# HELP go_sched_latencies_seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.\n# TYPE go_sched_latencies_seconds histogram\ngo_sched_latencies_seconds_bucket{le=\"9.999999999999999e-10\"} 244\ngo_sched_latencies_seconds_bucket{le=\"1.9999999999999997e-09\"} 244\n[...]\ngo_sched_latencies_seconds_bucket{le=\"206708.18602188796\"} 2336\ngo_sched_latencies_seconds_bucket{le=\"+Inf\"} 2336\ngo_sched_latencies_seconds_sum 0.18509832400000004\ngo_sched_latencies_seconds_count 2336\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 8\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 1.84\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 1.048576e+06\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 14\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.3728896e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.64615612779e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 7.65362176e+08\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n# HELP rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host.\n# TYPE rest_client_requests_total counter\nrest_client_requests_total{code=\"200\",host=\"10.96.0.1:443\",method=\"GET\"} 114\nrest_client_requests_total{code=\"200\",host=\"10.96.0.1:443\",method=\"PUT\"} 4\n# HELP workqueue_adds_total Total number of adds handled by workqueue\n# TYPE workqueue_adds_total counter\nworkqueue_adds_total{name=\"authconfig\"} 19\nworkqueue_adds_total{name=\"secret\"} 1\n# HELP workqueue_depth Current depth of workqueue\n# TYPE workqueue_depth gauge\nworkqueue_depth{name=\"authconfig\"} 0\nworkqueue_depth{name=\"secret\"} 0\n# HELP workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running.\n# TYPE workqueue_longest_running_processor_seconds gauge\nworkqueue_longest_running_processor_seconds{name=\"authconfig\"} 0\nworkqueue_longest_running_processor_seconds{name=\"secret\"} 0\n# HELP workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested\n# TYPE workqueue_queue_duration_seconds histogram\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-08\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-07\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-06\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-06\"} 8\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-05\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.001\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.01\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.1\"} 18\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1\"} 18\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"10\"} 19\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"+Inf\"} 19\nworkqueue_queue_duration_seconds_sum{name=\"authconfig\"} 4.969016371\nworkqueue_queue_duration_seconds_count{name=\"authconfig\"} 19\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-08\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-07\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-06\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-06\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-05\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.001\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.01\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.1\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"10\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"+Inf\"} 1\nworkqueue_queue_duration_seconds_sum{name=\"secret\"} 4.67e-06\nworkqueue_queue_duration_seconds_count{name=\"secret\"} 1\n# HELP workqueue_retries_total Total number of retries handled by workqueue\n# TYPE workqueue_retries_total counter\nworkqueue_retries_total{name=\"authconfig\"} 12\nworkqueue_retries_total{name=\"secret\"} 0\n# HELP workqueue_unfinished_work_seconds How many seconds of work has been done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.\n# TYPE workqueue_unfinished_work_seconds gauge\nworkqueue_unfinished_work_seconds{name=\"authconfig\"} 0\nworkqueue_unfinished_work_seconds{name=\"secret\"} 0\n# HELP workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes.\n# TYPE workqueue_work_duration_seconds histogram\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-08\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-07\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-05\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.001\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.01\"} 11\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.1\"} 18\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1\"} 18\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"10\"} 19\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"+Inf\"} 19\nworkqueue_work_duration_seconds_sum{name=\"authconfig\"} 5.171738079000001\nworkqueue_work_duration_seconds_count{name=\"authconfig\"} 19\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-08\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-07\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-05\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.001\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.01\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.1\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"10\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"+Inf\"} 1\nworkqueue_work_duration_seconds_sum{name=\"secret\"} 0.000150956\nworkqueue_work_duration_seconds_count{name=\"secret\"} 1\n</code></pre> Example of metrics exported at the <code>/server-metrics</code> endpoint <pre><code># HELP auth_server_authconfig_duration_seconds Response latency of authconfig enforced by the auth server (in seconds).\n# TYPE auth_server_authconfig_duration_seconds histogram\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.001\"} 0\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.051000000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.101\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.15100000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.201\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.251\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.301\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.351\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.40099999999999997\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.45099999999999996\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.501\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.551\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.6010000000000001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.6510000000000001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.7010000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.7510000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.8010000000000003\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.8510000000000003\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.9010000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.9510000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"+Inf\"} 1\nauth_server_authconfig_duration_seconds_sum{authconfig=\"edge-auth\",namespace=\"authorino\"} 0.001701795\nauth_server_authconfig_duration_seconds_count{authconfig=\"edge-auth\",namespace=\"authorino\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.051000000000000004\"} 4\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.101\"} 4\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.15100000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.201\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.251\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.301\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.351\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.40099999999999997\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.45099999999999996\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.501\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.551\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.6010000000000001\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.6510000000000001\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.7010000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.7510000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.8010000000000003\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.8510000000000003\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.9010000000000004\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.9510000000000004\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"+Inf\"} 5\nauth_server_authconfig_duration_seconds_sum{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 0.26967658299999997\nauth_server_authconfig_duration_seconds_count{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 5\n# HELP auth_server_authconfig_response_status Response status of authconfigs sent by the auth server, partitioned by authconfig.\n# TYPE auth_server_authconfig_response_status counter\nauth_server_authconfig_response_status{authconfig=\"edge-auth\",namespace=\"authorino\",status=\"OK\"} 1\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"OK\"} 2\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"PERMISSION_DENIED\"} 2\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"UNAUTHENTICATED\"} 1\n# HELP auth_server_authconfig_total Total number of authconfigs enforced by the auth server, partitioned by authconfig.\n# TYPE auth_server_authconfig_total counter\nauth_server_authconfig_total{authconfig=\"edge-auth\",namespace=\"authorino\"} 1\nauth_server_authconfig_total{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 5\n# HELP auth_server_evaluator_duration_seconds Response latency of individual authconfig rule evaluated by the auth server (in seconds).\n# TYPE auth_server_evaluator_duration_seconds histogram\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.001\"} 0\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.051000000000000004\"} 3\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.101\"} 3\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.15100000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.201\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.251\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.301\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.351\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.40099999999999997\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.45099999999999996\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.501\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.551\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.6010000000000001\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.6510000000000001\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.7010000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.7510000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.8010000000000003\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.8510000000000003\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.9010000000000004\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.9510000000000004\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"+Inf\"} 4\nauth_server_evaluator_duration_seconds_sum{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 0.25800055\nauth_server_evaluator_duration_seconds_count{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 4\n# HELP auth_server_evaluator_total Total number of evaluations of individual authconfig rule performed by the auth server.\n# TYPE auth_server_evaluator_total counter\nauth_server_evaluator_total{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 4\n# HELP auth_server_response_status Response status of authconfigs sent by the auth server.\n# TYPE auth_server_response_status counter\nauth_server_response_status{status=\"NOT_FOUND\"} 1\nauth_server_response_status{status=\"OK\"} 3\nauth_server_response_status{status=\"PERMISSION_DENIED\"} 2\nauth_server_response_status{status=\"UNAUTHENTICATED\"} 1\n# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.\n# TYPE go_gc_cycles_automatic_gc_cycles_total counter\ngo_gc_cycles_automatic_gc_cycles_total 11\n# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.\n# TYPE go_gc_cycles_forced_gc_cycles_total counter\ngo_gc_cycles_forced_gc_cycles_total 0\n# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.\n# TYPE go_gc_cycles_total_gc_cycles_total counter\ngo_gc_cycles_total_gc_cycles_total 11\n# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.5971e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.69e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 0.000158594\ngo_gc_duration_seconds{quantile=\"0.75\"} 0.000324091\ngo_gc_duration_seconds{quantile=\"1\"} 0.001692423\ngo_gc_duration_seconds_sum 0.003546711\ngo_gc_duration_seconds_count 11\n# HELP go_gc_heap_allocs_by_size_bytes_total Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_by_size_bytes_total histogram\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 6261\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 42477\n[...]\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 122133\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"+Inf\"} 122154\ngo_gc_heap_allocs_by_size_bytes_total_sum 1.455944e+07\ngo_gc_heap_allocs_by_size_bytes_total_count 122154\n# HELP go_gc_heap_allocs_bytes_total Cumulative sum of memory allocated to the heap by the application.\n# TYPE go_gc_heap_allocs_bytes_total counter\ngo_gc_heap_allocs_bytes_total 1.455944e+07\n# HELP go_gc_heap_allocs_objects_total Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_objects_total counter\ngo_gc_heap_allocs_objects_total 122154\n# HELP go_gc_heap_frees_by_size_bytes_total Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_by_size_bytes_total histogram\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 3789\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 31067\n[...]\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 91013\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"+Inf\"} 91021\ngo_gc_heap_frees_by_size_bytes_total_sum 9.399936e+06\ngo_gc_heap_frees_by_size_bytes_total_count 91021\n# HELP go_gc_heap_frees_bytes_total Cumulative sum of heap memory freed by the garbage collector.\n# TYPE go_gc_heap_frees_bytes_total counter\ngo_gc_heap_frees_bytes_total 9.399936e+06\n# HELP go_gc_heap_frees_objects_total Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_objects_total counter\ngo_gc_heap_frees_objects_total 91021\n# HELP go_gc_heap_goal_bytes Heap size target for the end of the GC cycle.\n# TYPE go_gc_heap_goal_bytes gauge\ngo_gc_heap_goal_bytes 9.601744e+06\n# HELP go_gc_heap_objects_objects Number of objects, live or unswept, occupying heap memory.\n# TYPE go_gc_heap_objects_objects gauge\ngo_gc_heap_objects_objects 31133\n# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size.\n# TYPE go_gc_heap_tiny_allocs_objects_total counter\ngo_gc_heap_tiny_allocs_objects_total 9866\n# HELP go_gc_pauses_seconds_total Distribution individual GC-related stop-the-world pause latencies.\n# TYPE go_gc_pauses_seconds_total histogram\ngo_gc_pauses_seconds_total_bucket{le=\"9.999999999999999e-10\"} 0\ngo_gc_pauses_seconds_total_bucket{le=\"1.9999999999999997e-09\"} 0\n[...]\ngo_gc_pauses_seconds_total_bucket{le=\"206708.18602188796\"} 22\ngo_gc_pauses_seconds_total_bucket{le=\"+Inf\"} 22\ngo_gc_pauses_seconds_total_sum 0.0030393599999999996\ngo_gc_pauses_seconds_total_count 22\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 79\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.18.7\"} 1\n# HELP go_memory_classes_heap_free_bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory.\n# TYPE go_memory_classes_heap_free_bytes gauge\ngo_memory_classes_heap_free_bytes 630784\n# HELP go_memory_classes_heap_objects_bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.\n# TYPE go_memory_classes_heap_objects_bytes gauge\ngo_memory_classes_heap_objects_bytes 5.159504e+06\n# HELP go_memory_classes_heap_released_bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory.\n# TYPE go_memory_classes_heap_released_bytes gauge\ngo_memory_classes_heap_released_bytes 3.858432e+06\n# HELP go_memory_classes_heap_stacks_bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.\n# TYPE go_memory_classes_heap_stacks_bytes gauge\ngo_memory_classes_heap_stacks_bytes 786432\n# HELP go_memory_classes_heap_unused_bytes Memory that is reserved for heap objects but is not currently used to hold heap objects.\n# TYPE go_memory_classes_heap_unused_bytes gauge\ngo_memory_classes_heap_unused_bytes 2.14776e+06\n# HELP go_memory_classes_metadata_mcache_free_bytes Memory that is reserved for runtime mcache structures, but not in-use.\n# TYPE go_memory_classes_metadata_mcache_free_bytes gauge\ngo_memory_classes_metadata_mcache_free_bytes 13984\n# HELP go_memory_classes_metadata_mcache_inuse_bytes Memory that is occupied by runtime mcache structures that are currently being used.\n# TYPE go_memory_classes_metadata_mcache_inuse_bytes gauge\ngo_memory_classes_metadata_mcache_inuse_bytes 2400\n# HELP go_memory_classes_metadata_mspan_free_bytes Memory that is reserved for runtime mspan structures, but not in-use.\n# TYPE go_memory_classes_metadata_mspan_free_bytes gauge\ngo_memory_classes_metadata_mspan_free_bytes 16696\n# HELP go_memory_classes_metadata_mspan_inuse_bytes Memory that is occupied by runtime mspan structures that are currently being used.\n# TYPE go_memory_classes_metadata_mspan_inuse_bytes gauge\ngo_memory_classes_metadata_mspan_inuse_bytes 114376\n# HELP go_memory_classes_metadata_other_bytes Memory that is reserved for or used to hold runtime metadata.\n# TYPE go_memory_classes_metadata_other_bytes gauge\ngo_memory_classes_metadata_other_bytes 5.544408e+06\n# HELP go_memory_classes_os_stacks_bytes Stack memory allocated by the underlying operating system.\n# TYPE go_memory_classes_os_stacks_bytes gauge\ngo_memory_classes_os_stacks_bytes 0\n# HELP go_memory_classes_other_bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.\n# TYPE go_memory_classes_other_bytes gauge\ngo_memory_classes_other_bytes 537777\n# HELP go_memory_classes_profiling_buckets_bytes Memory that is used by the stack trace hash map used for profiling.\n# TYPE go_memory_classes_profiling_buckets_bytes gauge\ngo_memory_classes_profiling_buckets_bytes 1.455487e+06\n# HELP go_memory_classes_total_bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.\n# TYPE go_memory_classes_total_bytes gauge\ngo_memory_classes_total_bytes 2.026804e+07\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 5.159504e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 1.455944e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.455487e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 100887\n# HELP go_memstats_gc_cpu_fraction The fraction of this program's available CPU time used by the GC since the program started.\n# TYPE go_memstats_gc_cpu_fraction gauge\ngo_memstats_gc_cpu_fraction 0\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 5.544408e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 5.159504e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 4.489216e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 7.307264e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 31133\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 3.858432e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.179648e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6461569717723043e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 132020\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 2400\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 16384\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 114376\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 131072\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 9.601744e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 537777\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 786432\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 786432\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.026804e+07\n# HELP go_sched_goroutines_goroutines Count of live goroutines.\n# TYPE go_sched_goroutines_goroutines gauge\ngo_sched_goroutines_goroutines 79\n# HELP go_sched_latencies_seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.\n# TYPE go_sched_latencies_seconds histogram\ngo_sched_latencies_seconds_bucket{le=\"9.999999999999999e-10\"} 225\ngo_sched_latencies_seconds_bucket{le=\"1.9999999999999997e-09\"} 225\n[...]\ngo_sched_latencies_seconds_bucket{le=\"206708.18602188796\"} 1916\ngo_sched_latencies_seconds_bucket{le=\"+Inf\"} 1916\ngo_sched_latencies_seconds_sum 0.18081453600000003\ngo_sched_latencies_seconds_count 1916\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 8\n# HELP grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure.\n# TYPE grpc_server_handled_total counter\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_handling_seconds Histogram of response latency (seconds) of gRPC that had been application-level handled by the server.\n# TYPE grpc_server_handling_seconds histogram\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.005\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.01\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.025\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.05\"} 6\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.1\"} 6\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.25\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"1\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"2.5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"10\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"+Inf\"} 7\ngrpc_server_handling_seconds_sum{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0.277605516\ngrpc_server_handling_seconds_count{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\n# HELP grpc_server_msg_received_total Total number of RPC stream messages received on the server.\n# TYPE grpc_server_msg_received_total counter\ngrpc_server_msg_received_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_msg_received_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_msg_received_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server.\n# TYPE grpc_server_msg_sent_total counter\ngrpc_server_msg_sent_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_msg_sent_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_msg_sent_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_started_total Total number of RPCs started on the server.\n# TYPE grpc_server_started_total counter\ngrpc_server_started_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_started_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_started_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP oidc_server_requests_total Number of get requests received on the OIDC (Festival Wristband) server.\n# TYPE oidc_server_requests_total counter\noidc_server_requests_total{authconfig=\"edge-auth\",namespace=\"authorino\",path=\"/.well-known/openid-configuration\",wristband=\"wristband\"} 1\noidc_server_requests_total{authconfig=\"edge-auth\",namespace=\"authorino\",path=\"/.well-known/openid-connect/certs\",wristband=\"wristband\"} 1\n# HELP oidc_server_response_status Status of HTTP response sent by the OIDC (Festival Wristband) server.\n# TYPE oidc_server_response_status counter\noidc_server_response_status{status=\"200\"} 2\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 1.42\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 1.048576e+06\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 14\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.370432e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.64615612779e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 7.65362176e+08\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n# HELP promhttp_metric_handler_requests_in_flight Current number of scrapes being served.\n# TYPE promhttp_metric_handler_requests_in_flight gauge\npromhttp_metric_handler_requests_in_flight 1\n# HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.\n# TYPE promhttp_metric_handler_requests_total counter\npromhttp_metric_handler_requests_total{code=\"200\"} 1\npromhttp_metric_handler_requests_total{code=\"500\"} 0\npromhttp_metric_handler_requests_total{code=\"503\"} 0\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#readiness-check","title":"Readiness check","text":"<p>Authorino exposes two main endpoints for health and readiness check of the AuthConfig controller:</p> <ul> <li><code>/healthz</code>: Health probe (ping) \u2013 reports \"ok\" if the controller is healthy.</li> <li><code>/readyz</code>: Readiness probe \u2013 reports \"ok\" if the controller is ready to reconcile AuthConfig-related events.</li> </ul> <p>In general, the endpoints return either <code>200</code> (\"ok\", i.e. all checks have passed) or <code>500</code> (when one or more checks failed).</p> <p>The default binding network address is <code>:8081</code>, which can be changed by setting the command-line flag <code>--health-probe-addr</code>.</p> <p>The following additional subpath is available and its corresponding check can be aggregated into the response from the main readiness probe:</p> <ul> <li><code>/readyz/authconfigs</code>: Aggregated readiness status of the AuthConfigs \u2013 reports \"ok\" if all AuthConfigs watched by the reconciler have been marked as ready.</li> </ul> Important!The AuthConfig readiness check within the scope of the aggregated readiness probe endpoint is deactivated by default \u2013 i.e. this check is an opt-in check. Sending a request to the <code>/readyz</code> endpoint without explicitly opting-in for the AuthConfigs check, by using the <code>include</code> parameter, will result in a response message that disregards the actual status of the watched AuthConfigs, possibly an \"ok\" message. To read the aggregated status of the watched AuthConfigs, either use the specific endpoint <code>/readyz/authconfigs</code> or opt-in for the check in the aggregated endpoint by sending a request to <code>/readyz?include=authconfigs</code> <p>Apart from <code>include</code> to add the aggregated status of the AuthConfigs, the following additional query string parameters are available:</p> <ul> <li><code>verbose=true|false</code> - provides more verbose response messages;</li> <li><code>exclude=(check name)</code> \u2013 to exclude a particular readiness check (for future usage).</li> </ul>"},{"location":"authorino/docs/user-guides/observability/#logging","title":"Logging","text":"<p>Authorino provides structured log messages (\"production\") or more log messages output to stdout in a more user-friendly format (\"development\" mode) and different level of logging.</p>"},{"location":"authorino/docs/user-guides/observability/#log-levels-and-log-modes","title":"Log levels and log modes","text":"<p>Authorino outputs 3 levels of log messages: (from lowest to highest level)</p> <ol> <li><code>debug</code></li> <li><code>info</code> (default)</li> <li><code>error</code></li> </ol> <p><code>info</code> logging is restricted to high-level information of the gRPC and HTTP authorization services, limiting messages to incoming request and respective outgoing response logs, with reduced details about the corresponding objects (request payload and authorization result), and without any further detailed logs of the steps in between, except for errors.</p> <p>Only <code>debug</code> logging will include processing details of each Auth Pipeline, such as intermediary requests to validate identities with external auth servers, requests to external sources of auth metadata or authorization policies.</p> <p>To configure the desired log level, set the <code>spec.logLevel</code> field of the <code>Authorino</code> custom resource (or <code>--log-level</code> command-line flag in the Authorino deployment), to one of the supported values listed above. Default log level is <code>info</code>.</p> <p>Apart from log level, Authorino can output messages to the logs in 2 different formats:</p> <ul> <li><code>production</code> (default): each line is a parseable JSON object with properties <code>{\"level\":string, \"ts\":int, \"msg\":string, \"logger\":string, extra values...}</code></li> <li><code>development</code>: more human-readable outputs, extra stack traces and logging info, plus extra values output as JSON, in the format: <code>&lt;timestamp-iso-8601&gt;\\t&lt;log-level&gt;\\t&lt;logger&gt;\\t&lt;message&gt;\\t{extra-values-as-json}</code></li> </ul> <p>To configure the desired log mode, set the <code>spec.logMode</code> field of the <code>Authorino</code> custom resource (or <code>--log-mode</code> command-line flag in the Authorino deployment), to one of the supported values listed above. Default log level is <code>production</code>.</p> <p>Example of <code>Authorino</code> custom resource with log level <code>debug</code> and log mode <code>production</code>:</p> <pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  logLevel: debug\n  logMode: production\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#sensitive-data-output-to-the-logs","title":"Sensitive data output to the logs","text":"<p>Authorino will never output HTTP headers and query string parameters to <code>info</code> log messages, as such values usually include sensitive data (e.g. access tokens, API keys and Authorino Festival Wristbands). However, <code>debug</code> log messages may include such sensitive information and those are not redacted.</p> <p>Therefore, DO NOT USE <code>debug</code> LOG LEVEL IN PRODUCTION! Instead, use either <code>info</code> or <code>error</code>.</p>"},{"location":"authorino/docs/user-guides/observability/#log-messages-printed-by-authorino","title":"Log messages printed by Authorino","text":"<p>Some log messages printed by Authorino and corresponding extra values included:</p> logger level message extra values <code>authorino</code> <code>info</code> \"setting instance base logger\" <code>min level=info\\|debug</code>, <code>mode=production\\|development</code> <code>authorino</code> <code>info</code> \"booting up authorino\" <code>version</code> <code>authorino</code> <code>debug</code> \"setting up with options\" <code>auth-config-label-selector</code>, <code>deep-metrics-enabled</code>, <code>enable-leader-election</code>, <code>evaluator-cache-size</code>, <code>ext-auth-grpc-port</code>, <code>ext-auth-http-port</code>, <code>health-probe-addr</code>, <code>log-level</code>, <code>log-mode</code>, <code>max-http-request-body-size</code>, <code>metrics-addr</code>, <code>oidc-http-port</code>, <code>oidc-tls-cert</code>, <code>oidc-tls-cert-key</code>, <code>secret-label-selector</code>, <code>timeout</code>, <code>tls-cert</code>, <code>tls-cert-key</code>, <code>watch-namespace</code> <code>authorino</code> <code>info</code> \"attempting to acquire leader lease &lt;namespace&gt;/cb88a58a.authorino.kuadrant.io...\\n\" <code>authorino</code> <code>info</code> \"successfully acquired lease &lt;namespace&gt;/cb88a58a.authorino.kuadrant.io\\n\" <code>authorino</code> <code>info</code> \"disabling grpc auth service\" <code>authorino</code> <code>info</code> \"starting grpc auth service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the grpc auth service\" <code>authorino</code> <code>error</code> \"failed to load tls cert for the grpc auth\" <code>authorino</code> <code>error</code> \"failed to start grpc auth service\" <code>authorino</code> <code>info</code> \"disabling http auth service\" <code>authorino</code> <code>info</code> \"starting http auth service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the http auth service\" <code>authorino</code> <code>error</code> \"failed to start http auth service\" <code>authorino</code> <code>info</code> \"disabling http oidc service\" <code>authorino</code> <code>info</code> \"starting http oidc service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the http oidc service\" <code>authorino</code> <code>error</code> \"failed to start http oidc service\" <code>authorino</code> <code>info</code> \"starting manager\" <code>authorino</code> <code>error</code> \"unable to start manager\" <code>authorino</code> <code>error</code> \"unable to create controller\" <code>controller=authconfig\\|secret\\|authconfigstatusupdate</code> <code>authorino</code> <code>error</code> \"problem running manager\" <code>authorino</code> <code>info</code> \"starting status update manager\" <code>authorino</code> <code>error</code> \"unable to start status update manager\" <code>authorino</code> <code>error</code> \"problem running status update manager\" <code>authorino.controller-runtime.metrics</code> <code>info</code> \"metrics server is starting to listen\" <code>addr</code> <code>authorino.controller-runtime.manager</code> <code>info</code> \"starting metrics server\" <code>path</code> <code>authorino.controller-runtime.manager.events</code> <code>debug</code> \"Normal\" <code>object={kind=ConfigMap, apiVersion=v1}</code>, <code>reauthorino.ason=LeaderElection</code>, <code>message=\"authorino-controller-manager-* became leader\"</code> <code>authorino.controller-runtime.manager.events</code> <code>debug</code> \"Normal\" <code>object={kind=Lease, apiVersion=coordination.k8s.io/v1}</code>, <code>reauthorino.ason=LeaderElection</code>, <code>message=\"authorino-controller-manager-* became leader\"</code> <code>authorino.controller-runtime.manager.controller.authconfig</code> <code>info</code> \"resource reconciled\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig</code> <code>info</code> \"host already taken\" <code>authconfig</code>, <code>host</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>debug</code> \"resource status did not change\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>debug</code> \"resource status changed\" <code>authconfig</code>, <code>authconfig/status</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>error</code> \"failed to update the resource\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>info</code> \"resource status updated\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.secret</code> <code>info</code> \"resource reconciled\" <code>authorino.controller-runtime.manager.controller.secret</code> <code>info</code> \"could not reconcile authconfigs using api key authorino.authentication\" <code>authorino.service.oidc</code> <code>info</code> \"request received\" <code>request id</code>, <code>url</code>, <code>realm</code>, <code>config</code>, <code>path</code> <code>authorino.service.oidc</code> <code>info</code> \"response sent\" <code>request id</code> <code>authorino.service.oidc</code> <code>error</code> \"failed to serve oidc request\" <code>authorino.service.auth</code> <code>info</code> \"incoming authorization request\" <code>request id</code>, <code>object</code> <code>authorino.service.auth</code> <code>debug</code> \"incoming authorization request\" <code>request id</code>, <code>object</code> <code>authorino.service.auth</code> <code>info</code> \"outgoing authorization response\" <code>request id</code>, <code>authorized</code>, <code>response</code>, <code>object</code> <code>authorino.service.auth</code> <code>debug</code> \"outgoing authorization response\" <code>request id</code>, <code>authorized</code>, <code>response</code>, <code>object</code> <code>authorino.service.auth</code> <code>error</code> \"failed to create dynamic metadata\" <code>request id</code>, <code>object</code> <code>authorino.service.auth.authpipeline</code> <code>debug</code> \"skipping config\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity</code> <code>debug</code> \"identity validated\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.identity</code> <code>debug</code> \"cannot validate identity\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity</code> <code>error</code> \"failed to extend identity object\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>error</code> \"failed to discovery openid connect configuration\" <code>endpoint</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>debug</code> \"auto-refresh of openid connect configuration disabled\" <code>endpoint</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>debug</code> \"openid connect configuration updated\" <code>endpoint</code> <code>authorino.service.auth.authpipeline.identity.oauth2</code> <code>debug</code> \"sending token introspection request\" <code>request id</code>, <code>url</code>, <code>data</code> <code>authorino.service.auth.authpipeline.identity.kubernetesauth</code> <code>debug</code> \"calling kubernetes token review api\" <code>request id</code>, <code>tokenreview</code> <code>authorino.service.auth.authpipeline.identity.apikey</code> <code>error</code> \"Something went wrong fetching the authorized credentials\" <code>authorino.service.auth.authpipeline.metadata</code> <code>debug</code> \"fetched auth metadata\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.metadata</code> <code>debug</code> \"cannot fetch metadata\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.metadata.http</code> <code>debug</code> \"sending request\" <code>request id</code>, <code>method</code>, <code>url</code>, <code>headers</code> <code>authorino.service.auth.authpipeline.metadata.userinfo</code> <code>debug</code> \"fetching user info\" <code>request id</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"requesting pat\" <code>request id</code>, <code>url</code>, <code>data</code>, <code>headers</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"querying resources by uri\" <code>request id</code>, <code>url</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"getting resource data\" <code>request id</code>, <code>url</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"evaluating for input\" <code>request id</code>, <code>input</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"access granted\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"access denied\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"invalid response from policy evaluation\" <code>policy</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to precompile policy\" <code>policy</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to download policy from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to refresh policy from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>debug</code> \"external policy unchanged\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>debug</code> \"auto-refresh  of external policy disabled\" <code>policy</code>, <code>endpoint</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>info</code> \"policy updated from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.kubernetesauthz</code> <code>debug</code> \"calling kubernetes subject access review api\" <code>request id</code>, <code>subjectaccessreview</code> <code>authorino.service.auth.authpipeline.response</code> <code>debug</code> \"dynamic response built\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.response</code> <code>debug</code> \"cannot build dynamic response\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.http</code> <code>debug</code> \"bad request\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"not found\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"request body too large\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"service unavailable\" <code>request id</code>"},{"location":"authorino/docs/user-guides/observability/#examples","title":"Examples","text":"<p>The examples below are all with <code>--log-level=debug</code> and <code>--log-mode=production</code>.</p> Booting up the service <pre><code>{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"setting instance base logger\",\"min level\":\"info\",\"mode\":\"production\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"build information\",\"version\":\"v1beta3\",\"commit\":\"ae2dc8150af2e6cdb35957ba7305c4c2a76d6149\",\"dirty\":\"false\",\"cmd\":\"server\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting http auth service\",\"port\":5001,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting grpc auth service\",\"port\":50051,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting http oidc service\",\"port\":8083,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting reconciliation manager\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting server\",\"kind\":\"health probe\",\"addr\":\"[::]:8081\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino.controller-runtime.metrics\",\"msg\":\"Starting metrics server\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino.controller-runtime.metrics\",\"msg\":\"Serving metrics server\",\"bindAddress\":\":8080\",\"secure\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"source\":\"kind source: *v1beta3.AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\",\"source\":\"kind source: *v1.Secret\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting status update manager\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"source\":\"kind source: *v1beta3.AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting workers\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\",\"worker count\":1}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting workers\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"worker count\":1}\n</code></pre> Reconciling an AuthConfig and 2 related API key secrets <pre><code>{\"level\":\"debug\",\"ts\":1669221208.7473805,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status changed\",\"authconfig\":\"default/talker-api-protection\",\"authconfig/status\":{\"conditions\":[{\"type\":\"Available\",\"status\":\"False\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"HostsNotLinked\",\"message\":\"No hosts linked to the resource\"},{\"type\":\"Ready\",\"status\":\"False\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"Unknown\"}],\"summary\":{\"ready\":false,\"hostsReady\":[],\"numHostsReady\":\"0/1\",\"numIdentitySources\":1,\"numMetadataSources\":0,\"numAuthorizationPolicies\":0,\"numResponseItems\":0,\"festivalWristbandEnabled\":false}}}\n{\"level\":\"info\",\"ts\":1669221208.7496614,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"info\",\"ts\":1669221208.7532616,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.7535005,\"logger\":\"authorino.controller.secret\",\"msg\":\"adding k8s secret to the index\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-1\",\"namespace\":\"default\",\"authconfig\":\"default/talker-api-protection\",\"config\":\"friends\"}\n{\"level\":\"debug\",\"ts\":1669221208.7535596,\"logger\":\"authorino.controller.secret.apikey\",\"msg\":\"api key added\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-1\",\"namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669221208.7536132,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-1\"}\n{\"level\":\"info\",\"ts\":1669221208.753772,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.753835,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status changed\",\"authconfig\":\"default/talker-api-protection\",\"authconfig/status\":{\"conditions\":[{\"type\":\"Available\",\"status\":\"True\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"HostsLinked\"},{\"type\":\"Ready\",\"status\":\"True\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"Reconciled\"}],\"summary\":{\"ready\":true,\"hostsReady\":[\"talker-api.127.0.0.1.nip.io\"],\"numHostsReady\":\"1/1\",\"numIdentitySources\":1,\"numMetadataSources\":0,\"numAuthorizationPolicies\":0,\"numResponseItems\":0,\"festivalWristbandEnabled\":false}}}\n{\"level\":\"info\",\"ts\":1669221208.7571108,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"info\",\"ts\":1669221208.7573664,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.757429,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status did not change\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.7586699,\"logger\":\"authorino.controller.secret\",\"msg\":\"adding k8s secret to the index\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-2\",\"namespace\":\"default\",\"authconfig\":\"default/talker-api-protection\",\"config\":\"friends\"}\n{\"level\":\"debug\",\"ts\":1669221208.7586884,\"logger\":\"authorino.controller.secret.apikey\",\"msg\":\"api key added\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-2\",\"namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669221208.7586913,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-2\"}\n{\"level\":\"debug\",\"ts\":1669221208.7597604,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status did not change\",\"authconfig\":\"default/talker-api-protection\"}\n</code></pre> Enforcing an AuthConfig with authentication based on Kubernetes tokens: <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830460.1486168,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"8157480586935853928\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830460.1491194,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"8157480586935853928\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830460,\"nanos\":147259000},\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"4c5d5c97-e15b-46a3-877a-d8188e09e08f\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830460.150506,\"logger\":\"authorino.service.auth.authpipeline.identity.kubernetesauth\",\"msg\":\"calling kubernetes token review api\",\"request id\":\"8157480586935853928\",\"tokenreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"token\":\"eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"audiences\":[\"talker-api\"]},\"status\":{\"user\":{}}}}\n{\"level\":\"debug\",\"ts\":1634830460.1509938,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830460.1517606,\"logger\":\"authorino.service.auth.authpipeline.identity.oauth2\",\"msg\":\"sending token introspection request\",\"request id\":\"8157480586935853928\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token/introspect\",\"data\":\"token=eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA&amp;token_type_hint=requesting_party_token\"}\n{\"level\":\"debug\",\"ts\":1634830460.1620777,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"identity validated\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"aud\":[\"talker-api\"],\"exp\":1634831051,\"iat\":1634830451,\"iss\":\"https://kubernetes.default.svc.cluster.local\",\"kubernetes.io\":{\"namespace\":\"authorino\",\"serviceaccount\":{\"name\":\"api-consumer-1\",\"uid\":\"b40f531c-ecab-4f31-a496-2ebc72add121\"}},\"nbf\":1634830451,\"sub\":\"system:serviceaccount:authorino:api-consumer-1\"}}\n{\"level\":\"debug\",\"ts\":1634830460.1622565,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"requesting pat\",\"request id\":\"8157480586935853928\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token\",\"data\":\"grant_type=client_credentials\",\"headers\":{\"Content-Type\":[\"application/x-www-form-urlencoded\"]}}\n{\"level\":\"debug\",\"ts\":1634830460.1670353,\"logger\":\"authorino.service.auth.authpipeline.metadata.http\",\"msg\":\"sending request\",\"request id\":\"8157480586935853928\",\"method\":\"GET\",\"url\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path=/hello\",\"headers\":{\"Content-Type\":[\"text/plain\"]}}\n{\"level\":\"debug\",\"ts\":1634830460.169326,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"cannot fetch metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"oidc-userinfo\",\"UserInfo\":{\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"}},\"UMA\":null,\"GenericHTTP\":null},\"reason\":\"Missing identity for OIDC issuer http://keycloak:8080/realms/kuadrant. Skipping related UserInfo metadata.\"}\n{\"level\":\"debug\",\"ts\":1634830460.1753876,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"http-metadata\",\"UserInfo\":null,\"UMA\":null,\"GenericHTTP\":{\"Endpoint\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path={context.request.http.path}\",\"Method\":\"GET\",\"Parameters\":[],\"ContentType\":\"application/x-www-form-urlencoded\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"1aa6ac66-3179-4351-b1a7-7f6a761d5b61\"}}\n{\"level\":\"debug\",\"ts\":1634830460.2331996,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"querying resources by uri\",\"request id\":\"8157480586935853928\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set?uri=/hello\"}\n{\"level\":\"debug\",\"ts\":1634830460.2495668,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"getting resource data\",\"request id\":\"8157480586935853928\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set/e20d194c-274c-4845-8c02-0ca413c9bf18\"}\n{\"level\":\"debug\",\"ts\":1634830460.2927864,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"uma-resource-registry\",\"UserInfo\":null,\"UMA\":{\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"GenericHTTP\":null},\"object\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}\n{\"level\":\"debug\",\"ts\":1634830460.2930083,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"evaluating for input\",\"request id\":\"8157480586935853928\",\"input\":{\"context\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830460,\"nanos\":147259000},\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"4c5d5c97-e15b-46a3-877a-d8188e09e08f\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}},\"auth\":{\"identity\":{\"aud\":[\"talker-api\"],\"exp\":1634831051,\"iat\":1634830451,\"iss\":\"https://kubernetes.default.svc.cluster.local\",\"kubernetes.io\":{\"namespace\":\"authorino\",\"serviceaccount\":{\"name\":\"api-consumer-1\",\"uid\":\"b40f531c-ecab-4f31-a496-2ebc72add121\"}},\"nbf\":1634830451,\"sub\":\"system:serviceaccount:authorino:api-consumer-1\"},\"metadata\":{\"http-metadata\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"1aa6ac66-3179-4351-b1a7-7f6a761d5b61\"},\"uma-resource-registry\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}}}}\n{\"level\":\"debug\",\"ts\":1634830460.2955465,\"logger\":\"authorino.service.auth.authpipeline.authorization.kubernetesauthz\",\"msg\":\"calling kubernetes subject access review api\",\"request id\":\"8157480586935853928\",\"subjectaccessreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"nonResourceAttributes\":{\"path\":\"/hello\",\"verb\":\"get\"},\"user\":\"system:serviceaccount:authorino:api-consumer-1\"},\"status\":{\"allowed\":false}}}\n{\"level\":\"debug\",\"ts\":1634830460.2986183,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"my-policy\",\"OPA\":{\"Rego\":\"fail := input.context.request.http.headers[\\\"x-ext-auth-mock\\\"] == \\\"FAIL\\\"\\nallow { not fail }\\n\",\"OPAExternalSource\":{\"Endpoint\":\"\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"JSON\":null,\"KubernetesAuthz\":null},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830460.3044975,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"kubernetes-rbac\",\"OPA\":null,\"JSON\":null,\"KubernetesAuthz\":{\"Conditions\":[],\"User\":{\"Static\":\"\",\"Pattern\":\"auth.identity.user.username\"},\"Groups\":null,\"ResourceAttributes\":null}},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830460.3052874,\"logger\":\"authorino.service.auth.authpipeline.response\",\"msg\":\"dynamic response built\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"wristband\",\"Wrapper\":\"httpHeader\",\"WrapperKey\":\"x-ext-auth-wristband\",\"Wristband\":{\"Issuer\":\"https://authorino-oidc.default.svc:8083/default/talker-api-protection/wristband\",\"CustomClaims\":[],\"TokenDuration\":300,\"SigningKeys\":[{\"use\":\"sig\",\"kty\":\"EC\",\"kid\":\"wristband-signing-key\",\"crv\":\"P-256\",\"alg\":\"ES256\",\"x\":\"TJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZw\",\"y\":\"SSg8rKBsJ3J1LxyLtt0oFvhHvZcUpmRoTuHk3UHisTA\",\"d\":\"Me-5_zWBWVYajSGZcZMCcD8dXEa4fy85zv_yN7BxW-o\"}]},\"DynamicJSON\":null},\"object\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IndyaXN0YmFuZC1zaWduaW5nLWtleSIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQ4MzA3NjAsImlhdCI6MTYzNDgzMDQ2MCwiaXNzIjoiaHR0cHM6Ly9hdXRob3Jpbm8tb2lkYy5hdXRob3Jpbm8uc3ZjOjgwODMvYXV0aG9yaW5vL3RhbGtlci1hcGktcHJvdGVjdGlvbi93cmlzdGJhbmQiLCJzdWIiOiI4NDliMDk0ZDA4MzU0ZjM0MjA4ZGI3MjBmYWZmODlmNmM3NmYyOGY3MTcxOWI4NTQ3ZDk5NWNlNzAwMjU2ZGY4In0.Jn-VB5Q_0EX1ed1ji4KvhO4DlMqZeIl5H0qlukbTyYkp-Pgb4SnPGSbYWp5_uvG8xllsFAA5nuyBIXeba-dbkw\"}\n{\"level\":\"info\",\"ts\":1634830460.3054585,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"8157480586935853928\",\"authorized\":true,\"response\":\"OK\"}\n{\"level\":\"debug\",\"ts\":1634830460.305476,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"8157480586935853928\",\"authorized\":true,\"response\":\"OK\"}\n</code></pre> Enforcing an AuthConfig with authentication based on API keys <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830413.2425854,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"7199257136822741594\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830413.2426975,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"7199257136822741594\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830413,\"nanos\":240094000},\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"d38f5e66-bd72-4733-95d1-3179315cdd60\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830413.2428744,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830413.2434332,\"logger\":\"authorino.service.auth.authpipeline\",\"msg\":\"skipping config\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"keycloak-jwts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"},\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"context canceled\"}\n{\"level\":\"debug\",\"ts\":1634830413.2479305,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"identity validated\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"object\":{\"apiVersion\":\"v1\",\"data\":{\"api_key\":\"bmR5QnpyZVV6RjR6cURRc3FTUE1Ia1JocmlFT3RjUng=\"},\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Secret\\\",\\\"metadata\\\":{\\\"annotations\\\":{\\\"userid\\\":\\\"john\\\"},\\\"labels\\\":{\\\"audience\\\":\\\"talker-api\\\",\\\"authorino.kuadrant.io/managed-by\\\":\\\"authorino\\\"},\\\"name\\\":\\\"api-key-1\\\",\\\"namespace\\\":\\\"authorino\\\"},\\\"stringData\\\":{\\\"api_key\\\":\\\"ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\\\"},\\\"type\\\":\\\"Opaque\\\"}\\n\",\"userid\":\"john\"},\"creationTimestamp\":\"2021-10-21T14:45:54Z\",\"labels\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"},\"managedFields\":[{\"apiVersion\":\"v1\",\"fieldsType\":\"FieldsV1\",\"fieldsV1\":{\"f:data\":{\".\":{},\"f:api_key\":{}},\"f:metadata\":{\"f:annotations\":{\".\":{},\"f:kubectl.kubernetes.io/last-applied-configuration\":{},\"f:userid\":{}},\"f:labels\":{\".\":{},\"f:audience\":{},\"f:authorino.kuadrant.io/managed-by\":{}}},\"f:type\":{}},\"manager\":\"kubectl-client-side-apply\",\"operation\":\"Update\",\"time\":\"2021-10-21T14:45:54Z\"}],\"name\":\"api-key-1\",\"namespace\":\"authorino\",\"resourceVersion\":\"8979\",\"uid\":\"c369852a-7e1a-43bd-94ca-e2b3f617052e\"},\"sub\":\"john\",\"type\":\"Opaque\"}}\n{\"level\":\"debug\",\"ts\":1634830413.248768,\"logger\":\"authorino.service.auth.authpipeline.metadata.http\",\"msg\":\"sending request\",\"request id\":\"7199257136822741594\",\"method\":\"GET\",\"url\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path=/hello\",\"headers\":{\"Content-Type\":[\"text/plain\"]}}\n{\"level\":\"debug\",\"ts\":1634830413.2496722,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"cannot fetch metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"oidc-userinfo\",\"UserInfo\":{\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"}},\"UMA\":null,\"GenericHTTP\":null},\"reason\":\"Missing identity for OIDC issuer http://keycloak:8080/realms/kuadrant. Skipping related UserInfo metadata.\"}\n{\"level\":\"debug\",\"ts\":1634830413.2497928,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"requesting pat\",\"request id\":\"7199257136822741594\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token\",\"data\":\"grant_type=client_credentials\",\"headers\":{\"Content-Type\":[\"application/x-www-form-urlencoded\"]}}\n{\"level\":\"debug\",\"ts\":1634830413.258932,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"http-metadata\",\"UserInfo\":null,\"UMA\":null,\"GenericHTTP\":{\"Endpoint\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path={context.request.http.path}\",\"Method\":\"GET\",\"Parameters\":[],\"ContentType\":\"application/x-www-form-urlencoded\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"97529f8c-587b-4121-a4db-cd90c63871fd\"}}\n{\"level\":\"debug\",\"ts\":1634830413.2945344,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"querying resources by uri\",\"request id\":\"7199257136822741594\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set?uri=/hello\"}\n{\"level\":\"debug\",\"ts\":1634830413.3123596,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"getting resource data\",\"request id\":\"7199257136822741594\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set/e20d194c-274c-4845-8c02-0ca413c9bf18\"}\n{\"level\":\"debug\",\"ts\":1634830413.3340268,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"uma-resource-registry\",\"UserInfo\":null,\"UMA\":{\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"GenericHTTP\":null},\"object\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}\n{\"level\":\"debug\",\"ts\":1634830413.3367748,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"evaluating for input\",\"request id\":\"7199257136822741594\",\"input\":{\"context\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830413,\"nanos\":240094000},\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"d38f5e66-bd72-4733-95d1-3179315cdd60\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}},\"auth\":{\"identity\":{\"apiVersion\":\"v1\",\"data\":{\"api_key\":\"bmR5QnpyZVV6RjR6cURRc3FTUE1Ia1JocmlFT3RjUng=\"},\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Secret\\\",\\\"metadata\\\":{\\\"annotations\\\":{\\\"userid\\\":\\\"john\\\"},\\\"labels\\\":{\\\"audience\\\":\\\"talker-api\\\",\\\"authorino.kuadrant.io/managed-by\\\":\\\"authorino\\\"},\\\"name\\\":\\\"api-key-1\\\",\\\"namespace\\\":\\\"authorino\\\"},\\\"stringData\\\":{\\\"api_key\\\":\\\"ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\\\"},\\\"type\\\":\\\"Opaque\\\"}\\n\",\"userid\":\"john\"},\"creationTimestamp\":\"2021-10-21T14:45:54Z\",\"labels\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"},\"managedFields\":[{\"apiVersion\":\"v1\",\"fieldsType\":\"FieldsV1\",\"fieldsV1\":{\"f:data\":{\".\":{},\"f:api_key\":{}},\"f:metadata\":{\"f:annotations\":{\".\":{},\"f:kubectl.kubernetes.io/last-applied-configuration\":{},\"f:userid\":{}},\"f:labels\":{\".\":{},\"f:audience\":{},\"f:authorino.kuadrant.io/managed-by\":{}}},\"f:type\":{}},\"manager\":\"kubectl-client-side-apply\",\"operation\":\"Update\",\"time\":\"2021-10-21T14:45:54Z\"}],\"name\":\"api-key-1\",\"namespace\":\"authorino\",\"resourceVersion\":\"8979\",\"uid\":\"c369852a-7e1a-43bd-94ca-e2b3f617052e\"},\"sub\":\"john\",\"type\":\"Opaque\"},\"metadata\":{\"http-metadata\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"97529f8c-587b-4121-a4db-cd90c63871fd\"},\"uma-resource-registry\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}}}}\n{\"level\":\"debug\",\"ts\":1634830413.339894,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"my-policy\",\"OPA\":{\"Rego\":\"fail := input.context.request.http.headers[\\\"x-ext-auth-mock\\\"] == \\\"FAIL\\\"\\nallow { not fail }\\n\",\"OPAExternalSource\":{\"Endpoint\":\"\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"JSON\":null,\"KubernetesAuthz\":null},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830413.3444238,\"logger\":\"authorino.service.auth.authpipeline.authorization.kubernetesauthz\",\"msg\":\"calling kubernetes subject access review api\",\"request id\":\"7199257136822741594\",\"subjectaccessreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"nonResourceAttributes\":{\"path\":\"/hello\",\"verb\":\"get\"},\"user\":\"john\"},\"status\":{\"allowed\":false}}}\n{\"level\":\"debug\",\"ts\":1634830413.3547812,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"kubernetes-rbac\",\"OPA\":null,\"JSON\":null,\"KubernetesAuthz\":{\"Conditions\":[],\"User\":{\"Static\":\"\",\"Pattern\":\"auth.identity.user.username\"},\"Groups\":null,\"ResourceAttributes\":null}},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830413.3558292,\"logger\":\"authorino.service.auth.authpipeline.response\",\"msg\":\"dynamic response built\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"wristband\",\"Wrapper\":\"httpHeader\",\"WrapperKey\":\"x-ext-auth-wristband\",\"Wristband\":{\"Issuer\":\"https://authorino-oidc.default.svc:8083/default/talker-api-protection/wristband\",\"CustomClaims\":[],\"TokenDuration\":300,\"SigningKeys\":[{\"use\":\"sig\",\"kty\":\"EC\",\"kid\":\"wristband-signing-key\",\"crv\":\"P-256\",\"alg\":\"ES256\",\"x\":\"TJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZw\",\"y\":\"SSg8rKBsJ3J1LxyLtt0oFvhHvZcUpmRoTuHk3UHisTA\",\"d\":\"Me-5_zWBWVYajSGZcZMCcD8dXEa4fy85zv_yN7BxW-o\"}]},\"DynamicJSON\":null},\"object\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IndyaXN0YmFuZC1zaWduaW5nLWtleSIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQ4MzA3MTMsImlhdCI6MTYzNDgzMDQxMywiaXNzIjoiaHR0cHM6Ly9hdXRob3Jpbm8tb2lkYy5hdXRob3Jpbm8uc3ZjOjgwODMvYXV0aG9yaW5vL3RhbGtlci1hcGktcHJvdGVjdGlvbi93cmlzdGJhbmQiLCJzdWIiOiI5NjhiZjViZjk3MDM3NWRiNjE0ZDFhMDgzZTg2NTBhYTVhMGVhMzAyOTdiYmJjMTBlNWVlMWZmYTkxYTYwZmY4In0.7G440sWgi2TIaxrGJf5KWR9UOFpNTjwVYeaJXFLzsLhVNICoMLbYzBAEo4M3ym1jipxxTVeE7anm4qDDc7cnVQ\"}\n{\"level\":\"info\",\"ts\":1634830413.3569078,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"7199257136822741594\",\"authorized\":true,\"response\":\"OK\"}\n{\"level\":\"debug\",\"ts\":1634830413.3569596,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"7199257136822741594\",\"authorized\":true,\"response\":\"OK\"}\n</code></pre> Enforcing an AuthConfig with authentication based on API keys (invalid API key) <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830373.2066543,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"12947265773116138711\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52288}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"12947265773116138711\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830373.2068064,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"12947265773116138711\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52288}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830373,\"nanos\":198329000},\"http\":{\"id\":\"12947265773116138711\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY invalid\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"9e391846-afe4-489a-8716-23a2e1c1aa77\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830373.2070816,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"keycloak-opaque\",\"ExtendedProperties\":[],\"OAuth2\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"TokenIntrospectionUrl\":\"http://keycloak:8080/realms/kuadrant/protocol/openid-connect/token/introspect\",\"TokenTypeHint\":\"requesting_party_token\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830373.207225,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"reason\":\"the API Key provided is invalid\"}\n{\"level\":\"debug\",\"ts\":1634830373.2072473,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830373.2072592,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"keycloak-jwts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"},\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"info\",\"ts\":1634830373.2073083,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"12947265773116138711\",\"authorized\":false,\"response\":\"UNAUTHENTICATED\",\"object\":{\"code\":16,\"status\":302,\"message\":\"Redirecting to login\"}}\n{\"level\":\"debug\",\"ts\":1634830373.2073889,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"12947265773116138711\",\"authorized\":false,\"response\":\"UNAUTHENTICATED\",\"object\":{\"code\":16,\"status\":302,\"message\":\"Redirecting to login\",\"headers\":[{\"Location\":\"https://my-app.io/login\"}]}}\n</code></pre> Deleting an AuthConfig and 2 related API key secrets <pre><code>{\"level\":\"info\",\"ts\":1669221361.5032296,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-1\"}\n{\"level\":\"info\",\"ts\":1669221361.5057878,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-2\"}\n</code></pre> Shutting down the service <pre><code>{\"level\":\"info\",\"ts\":1669221635.0135982,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for non leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0136683,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0135982,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for non leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0136883,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0137057,\"logger\":\"authorino.controller.secret\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669221635.013724,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.01375,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"All workers finished\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.013752,\"logger\":\"authorino.controller.secret\",\"msg\":\"All workers finished\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669221635.0137632,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for caches\"}\n{\"level\":\"info\",\"ts\":1669221635.013751,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.0137684,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"All workers finished\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.0137722,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for caches\"}\n{\"level\":\"info\",\"ts\":1669221635.0138857,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for webhooks\"}\n{\"level\":\"info\",\"ts\":1669221635.0138955,\"logger\":\"authorino\",\"msg\":\"Wait completed, proceeding to shutdown the manager\"}\n{\"level\":\"info\",\"ts\":1669221635.0138893,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for webhooks\"}\n{\"level\":\"info\",\"ts\":1669221635.0139785,\"logger\":\"authorino\",\"msg\":\"Wait completed, proceeding to shutdown the manager\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#tracing","title":"Tracing","text":""},{"location":"authorino/docs/user-guides/observability/#request-id","title":"Request ID","text":"<p>Processes related to the authorization request are identified and linked together by a request ID. The request ID can be:</p> <ul> <li>generated outside Authorino and passed in the authorization request \u2013 this is essentially the case of requests via GRPC authorization interface initiated by the Envoy;</li> <li>generated by Authorino \u2013 requests via Raw HTTP Authorization interface.</li> </ul>"},{"location":"authorino/docs/user-guides/observability/#propagation","title":"Propagation","text":"<p>Authorino propagates trace identifiers compatible with the W3C Trace Context format https://www.w3.org/TR/trace-context/ and user-defined baggage data in the W3C Baggage format https://www.w3.org/TR/baggage.</p>"},{"location":"authorino/docs/user-guides/observability/#log-tracing","title":"Log tracing","text":"<p>Most log messages associated with an authorization request include the <code>request id</code> value. This value can be used to match incoming request and corresponding outgoing response log messages, including at deep level when more fine-grained log details are enabled (<code>debug</code> level level).</p>"},{"location":"authorino/docs/user-guides/observability/#opentelemetry-integration","title":"OpenTelemetry integration","text":"<p>Integration with an OpenTelemetry collector can be enabled by supplying the <code>--tracing-service-endpoint</code> command-line flag (e.g. <code>authorino server --tracing-service-endpoint=http://jaeger:14268/api/traces</code>).</p> <p>The additional <code>--tracing-service-tags</code> command-line flag allow to specify fixed agent-level key-value tags for the trace signals emitted by Authorino (e.g. <code>authorino server --tracing-service-endpoint=... --tracing-service-tag=key1=value1 --tracing-service-tag=key2=value2</code>).</p> <p>Traces related to authorization requests are additionally tagged with the <code>authorino.request_id</code> attribute.</p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/","title":"User guide: OpenID Connect Discovery and authentication with JWTs","text":"<p>Validate JSON Web Tokens (JWT) issued and signed by an OpenID Connect server; leverage OpenID Connect Discovery to automatically fetch JSON Web Key Sets (JWKS).</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino validates JSON Web Tokens (JWT) issued by an OpenID Connect server that implements OpenID Connect Discovery. Authorino fetches the OpenID Connect configuration and JSON Web Key Set (JWKS) from the issuer endpoint, and verifies the JSON Web Signature (JWS) and time validity of the token.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>With missing or invalid access token:</p> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak-kuadrant-realm\"\n# x-ext-auth-reason: credential not found\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oidc-rbac/","title":"User guide: OpenID Connect (OIDC) and Role-Based Access Control (RBAC) with Authorino and Keycloak","text":"<p>Combine OpenID Connect (OIDC) authentication and Role-Based Access Control (RBAC) authorization rules leveraging Keycloak and Authorino working together.</p> <p>In this user guide, you will learn via example how to implement a simple Role-Based Access Control (RBAC) system to protect endpoints of an API, with roles assigned to users of an Identity Provider (Keycloak) and carried within the access tokens as JSON Web Token (JWT) claims. Users authenticate with the IdP via OAuth2/OIDC flow and get their access tokens verified and validated by Authorino on every request. Moreover, Authorino reads the role bindings of the user and enforces the proper RBAC rules based upon the context.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-rbac/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-rbac/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, the Keycloak realm defines a few users and 2 realm roles: 'member' and 'admin'. When users authenticate to the Keycloak server by any of the supported OAuth2/OIDC flows, Keycloak adds to the access token JWT a claim <code>\"realm_access\": { \"roles\": array }</code> that holds the list of roles assigned to the user. Authorino will verify the JWT on requests to the API and read from that claim to enforce the following RBAC rules:</p> Path Method Role /resources[/*] GET / POST / PUT member /resources/{id} DELETE admin /admin[/*] * admin Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Apply the AuthConfig:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n\n  patterns:\n    \"member-role\":\n\n    - selector: auth.identity.realm_access.roles\n      operator: incl\n      value: member\n    \"admin-role\":\n    - selector: auth.identity.realm_access.roles\n      operator: incl\n      value: admin\n\n  authorization:\n    # RBAC rule: 'member' role required for requests to /resources[/*]\n    \"rbac-resources-api\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/resources(/.*)?$\n      patternMatching:\n        patterns:\n        - patternRef: member-role\n\n    # RBAC rule: 'admin' role required for DELETE requests to /resources/{id}\n    \"rbac-delete-resource\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/resources/\\d+$\n      - selector: context.request.http.method\n        operator: eq\n        value: DELETE\n      patternMatching:\n        patterns:\n        - patternRef: admin-role\n\n    # RBAC rule: 'admin' role required for requests to /admin[/*]\n    \"rbac-admin-api\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/admin(/.*)?$\n      patternMatching:\n        patterns:\n        - patternRef: admin-role\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user John, who is assigned to the 'member' role:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, send a <code>GET</code> request to /resources:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/resources -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As John, send a <code>DELETE</code> request to /resources/123:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/resources/123 -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>As John, send a <code>GET</code> request to /admin/settings:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/admin/settings -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api-as-jane-memberadmin","title":"Obtain an access token and consume the API as Jane (member/admin)","text":"<p>Obtain an access token from within the cluster for the user Jane, who is assigned to the 'member' and 'admin' roles:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send a <code>GET</code> request to /resources:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/resources -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, send a <code>DELETE</code> request to /resources/123:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/resources/123 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, send a <code>GET</code> request to /admin/settings:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/admin/settings -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oidc-user-info/","title":"User guide: OpenID Connect UserInfo","text":"<p>Fetch user info for OpenID Connect ID tokens in request-time for extra metadata for your policies and online verification of token validity.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 OIDC UserInfo</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Apart from possibly complementing information of the JWT, fetching OpenID Connect UserInfo in request-time can be particularly useful for remote checking the state of the session, as opposed to only verifying the JWT/JWS offline. Implementation requires an OpenID Connect issuer (<code>spec.identity.oidc</code>) configured in the same <code>AuthConfig</code>.</p> <p>Check out as well the user guide about OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"userinfo\":\n      userInfo:\n        identitySource: keycloak-kuadrant-realm\n  authorization:\n    \"active-tokens-only\":\n      patternMatching:\n        patterns:\n        - selector: \"auth.metadata.userinfo.email\" # user email expected from the userinfo instead of the jwt\n          operator: neq\n          value: \"\"\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>export $(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r '\"ACCESS_TOKEN=\"+.access_token,\"REFRESH_TOKEN=\"+.refresh_token')\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/logout -H \"Content-Type: application/x-www-form-urlencoded\" -d \"refresh_token=$REFRESH_TOKEN\" -d 'token_type_hint=requesting_party_token' -u demo:\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/opa-authorization/","title":"User guide: Open Policy Agent (OPA) Rego policies","text":"<p>Leverage the power of Open Policy Agent (OPA) policies, evaluated against Authorino's Authorization JSON in a built-in runtime compiled together with Authorino; pre-cache policies defined in Rego language inline or fetched from an external policy registry.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Authorino supports Open Policy Agent policies, either inline defined in Rego language as part of the <code>AuthConfig</code> or fetched from an external endpoint, such as an OPA Policy Registry.</p> <p>Authorino's built-in OPA module precompiles the policies in reconciliation-time and cache them for fast evaluation in request-time, where they receive the Authorization JSON as input.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/opa-authorization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/opa-authorization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, we will use OPA to implement a read-only policy for requests coming from outside a trusted network (IP range 192.168.1/24).</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.<sup>5</sup></p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  authorization:\n    \"read-only-outside\":\n      opa:\n        rego: |\n          ips := split(input.context.request.http.headers[\"x-forwarded-for\"], \",\")\n          trusted_network { net.cidr_contains(\"192.168.1.1/24\", ips[0]) }\n\n          allow { trusted_network }\n          allow { not trusted_network; input.context.request.http.method == \"GET\" }\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#create-the-api-key","title":"\u277b Create the API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#consume-the-api","title":"\u277c Consume the API","text":"<p>Inside the trusted network:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Outside the trusted network:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> <li> <p>You can also set <code>use_remote_address: true</code> in the Envoy route configuration, so the proxy will append its IP address instead of run in transparent mode. This setting will also ensure real remote address of the client connection passed in the <code>x-envoy-external-address</code> HTTP header, which can be used to simplify the read-only policy in remote environment.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/passing-credentials/","title":"User guide: Passing credentials (<code>Authorization</code> header, cookie headers and others)","text":"<p>Customize where credentials are supplied in the request by each trusted source of identity.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Auth credentials</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Authentication tokens can be supplied in the <code>Authorization</code> header, in a custom header, cookie or query string parameter.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/passing-credentials/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/passing-credentials/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, <code>member</code> users can authenticate supplying the API key in any of 4 different ways:</p> <ul> <li>HTTP header <code>Authorization: APIKEY &lt;api-key&gt;</code></li> <li>HTTP header <code>X-API-Key: &lt;api-key&gt;</code></li> <li>Query string parameter <code>api_key=&lt;api-key&gt;</code></li> <li>Cookie <code>Cookie: APIKEY=&lt;api-key&gt;;</code></li> </ul> <p><code>admin</code> API keys are only accepted in the (default) HTTP header <code>Authorization: Bearer &lt;api-key&gt;</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"members-authorization-header\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY # instead of the default prefix 'Bearer'\n    \"members-custom-header\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        customHeader:\n          name: X-API-Key\n    \"members-query-string-param\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        queryString:\n          name: api_key\n    \"members-cookie\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        cookie:\n          name: APIKEY\n    \"admins\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: admins\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#create-the-api-keys","title":"\u277b Create the API keys","text":"<p>For a member user:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: members\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>For an admin user:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: admins\nstringData:\n  api_key: 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#consume-the-api","title":"\u277c Consume the API","text":"<p>As member user, passing the API key in the <code>Authorization</code> header:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the custom <code>X-API-Key</code> header:</p> <pre><code>curl -H 'X-API-Key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the query string parameter <code>api_key</code>:</p> <pre><code>curl \"http://talker-api.127.0.0.1.nip.io:8000/hello?api_key=ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\"\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the <code>APIKEY</code> cookie header:</p> <pre><code>curl -H 'Cookie: APIKEY=ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx;foo=bar' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As admin user:</p> <pre><code>curl -H 'Authorization: Bearer 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Missing the API key:</p> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"members-authorization-header\"\n# www-authenticate: X-API-Key realm=\"members-custom-header\"\n# www-authenticate: api_key realm=\"members-query-string-param\"\n# www-authenticate: APIKEY realm=\"members-cookie\"\n# www-authenticate: Bearer realm=\"admins\"\n# x-ext-auth-reason: {\"admins\":\"credential not found\",\"members-authorization-header\":\"credential not found\",\"members-cookie\":\"credential not found\",\"members-custom-header\":\"credential not found\",\"members-query-string-param\":\"credential not found\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete secret/api-key-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/","title":"User guide: Resource-level authorization with User-Managed Access (UMA) resource registry","text":"<p>Fetch resource metadata relevant for your authorization policies from Keycloak authorization clients, using User-Managed Access (UMA) protocol.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 User-Managed Access (UMA) resource registry</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Open Policy Agent (OPA) Rego policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> <p>This example of resource-level authorization leverages part of Keycloak's User-Managed Access (UMA) support. Authorino will fetch resource attributes stored in a Keycloak resource server client.</p> <p>The Keycloak server also provides the identities. The <code>sub</code> claim of the Keycloak-issued ID tokens must match the owner of the requested resource, identified by the URI of the request.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Create a required secret that will be used by Authorino to initiate the authentication with the UMA registry.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: talker-api-uma-credentials\nstringData:\n  clientID: talker-api\n  clientSecret: 523b92b6-625d-4e1e-a313-77e7a8ae4e88\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"resource-data\":\n      uma:\n        endpoint: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n        credentialsRef:\n          name: talker-api-uma-credentials\n  authorization:\n    \"owned-resources\":\n      opa:\n        rego: |\n          COLLECTIONS = [\"greetings\"]\n\n          http_request = input.context.request.http\n          http_method = http_request.method\n          requested_path_sections = split(trim_left(trim_right(http_request.path, \"/\"), \"/\"), \"/\")\n\n          get { http_method == \"GET\" }\n          post { http_method == \"POST\" }\n          put { http_method == \"PUT\" }\n          delete { http_method == \"DELETE\" }\n\n          valid_collection { COLLECTIONS[_] == requested_path_sections[0] }\n\n          collection_endpoint {\n            valid_collection\n            count(requested_path_sections) == 1\n          }\n\n          resource_endpoint {\n            valid_collection\n            some resource_id\n            requested_path_sections[1] = resource_id\n          }\n\n          identity_owns_the_resource {\n            identity := input.auth.identity\n            resource_attrs := object.get(input.auth.metadata, \"resource-data\", [])[0]\n            resource_owner := object.get(object.get(resource_attrs, \"owner\", {}), \"id\", \"\")\n            resource_owner == identity.sub\n          }\n\n          allow { get;    collection_endpoint }\n          allow { post;   collection_endpoint }\n          allow { get;    resource_endpoint; identity_owns_the_resource }\n          allow { put;    resource_endpoint; identity_owns_the_resource }\n          allow { delete; resource_endpoint; identity_owns_the_resource }\nEOF\n</code></pre> <p>The OPA policy <code>owned-resource</code> above enforces that all users can send GET and POST requests to <code>/greetings</code>, while only resource owners can send GET, PUT and DELETE requests to <code>/greetings/{resource-id}</code>.</p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-access-tokens-with-the-keycloak-server-and-consume-the-api","title":"\u277b Obtain access tokens with the Keycloak server and consume the API","text":""},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-john-and-consume-the-api","title":"Obtain an access token as John and consume the API","text":"<p>Obtain an access token for user John (owner of the resource <code>/greetings/1</code> in the UMA registry):</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2 -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-jane-and-consume-the-api","title":"Obtain an access token as Jane and consume the API","text":"<p>Obtain an access token for user Jane (owner of the resource <code>/greetings/2</code> in the UMA registry):</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-peter-and-consume-the-api","title":"Obtain an access token as Peter and consume the API","text":"<p>Obtain an access token for user Peter (does not own any resource in the UMA registry):</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=peter' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2 -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete secret/talker-api-uma-credentials\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/sharding/","title":"User guide: Reducing the operational space","text":"<p>By default, Authorino will watch events related to all <code>AuthConfig</code> custom resources in the reconciliation space (namespace or entire cluster). Instances can be configured though to only watch a subset of the resources, thus allowing such as:</p> <ul> <li>to reduce noise and lower memory usage inside instances meant for restricted scope (e.g. Authorino deployed as a dedicated sidecar to protect only one host);</li> <li>sharding auth config data across multiple instances;</li> <li>multiple environments (e.g. staging, production) inside of a same cluster/namespace;</li> <li>providing managed instances of Authorino that all watch CRs cluster-wide, yet dedicated to organizations allowed to create and operate their own <code>AuthConfig</code>s across multiple namespaces.</li> </ul> \u26a0\ufe0f Important:         This feature may not be available to users of Authorino via Kuadrant.        Authorino capabilities featured in this guide: <ul> <li>Sharding</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/sharding/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p>"},{"location":"authorino/docs/user-guides/sharding/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#deploy-instances-of-authorino","title":"\u2777 Deploy instances of Authorino","text":"<p>Deploy an instance of Authorino dedicated to <code>AuthConfig</code>s and API key <code>Secrets</code> labeled with <code>authorino/environment=staging</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino-staging\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: authorino/environment=staging\n  secretLabelSelectors: authorino/environment=staging\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>Deploy an instance of Authorino dedicated to <code>AuthConfig</code>s and API key <code>Secrets</code> labeled with <code>authorino/environment=production</code>, ans NOT labeled <code>disabled</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino-production\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: authorino/environment=production,!disabled\n  secretLabelSelectors: authorino/environment=production,!disabled\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The commands above will both request instances of Authorino that watch for <code>AuthConfig</code> resources cluster-wide<sup>1</sup>, with TLS disabled<sup>2</sup>.</p>"},{"location":"authorino/docs/user-guides/sharding/#create-a-namespace-for-user-resources","title":"\u2778 Create a namespace for user resources","text":"<pre><code>kubectl create namespace myapp\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#create-authconfigs-and-api-key-secrets-for-both-instances","title":"\u2779 Create <code>AuthConfig</code>s and API key <code>Secret</code>s for both instances","text":""},{"location":"authorino/docs/user-guides/sharding/#create-resources-for-authorino-staging","title":"Create resources for <code>authorino-staging</code>","text":"<p>Create an <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: auth-config-1\n  labels:\n    authorino/environment: staging\nspec:\n  hosts:\n\n  - my-host.staging.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino/api-key: \"true\"\n            authorino/environment: staging\nEOF\n</code></pre> <p>Create an API key <code>Secret</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino/api-key: \"true\"\n    authorino/environment: staging\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>Verify in the logs that only the <code>authorino-staging</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-staging -o name)\n# {\"level\":\"info\",\"ts\":1638382989.8327162,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-1\"}\n# {\"level\":\"info\",\"ts\":1638382989.837424,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig/status\":\"myapp/auth-config-1\"}\n# {\"level\":\"info\",\"ts\":1638383144.9486837,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"myapp/api-key-1\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#create-resources-for-authorino-production","title":"Create resources for <code>authorino-production</code>","text":"<p>Create an <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: auth-config-2\n  labels:\n    authorino/environment: production\nspec:\n  hosts:\n\n  - my-host.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino/api-key: \"true\"\n            authorino/environment: production\nEOF\n</code></pre> <p>Create an API key <code>Secret</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino/api-key: \"true\"\n    authorino/environment: production\nstringData:\n  api_key: MUWdeBte7AbSWxl6CcvYNJ+3yEIm5CaL\ntype: Opaque\nEOF\n</code></pre> <p>Verify in the logs that only the <code>authorino-production</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-production -o name)\n# {\"level\":\"info\",\"ts\":1638383423.86086,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig/status\":\"myapp/auth-config-2\"}\n# {\"level\":\"info\",\"ts\":1638383423.8608105,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-2\"}\n# {\"level\":\"info\",\"ts\":1638383460.3515081,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"myapp/api-key-2\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#remove-a-resource-from-scope","title":"\u277a Remove a resource from scope","text":"<pre><code>kubectl -n myapp label authconfig/auth-config-2 disabled=true\n# authconfig.authorino.kuadrant.io/auth-config-2 labeled\n</code></pre> <p>Verify in the logs that the <code>authorino-production</code> instance removes the authconfig from the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-production -o name)\n# {\"level\":\"info\",\"ts\":1638383515.6428752,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource de-indexed\",\"authconfig\":\"myapp/auth-config-2\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authorino/authorino-staging\nkubectl delete authorino/authorino-production\nkubectl delete namespace myapp\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/token-normalization/","title":"User guide: Token normalization","text":"<p>Broadly, the term token normalization in authentication systems usually implies the exchange of an authentication token, as provided by the user in a given format, and/or its associated identity claims, for another freshly issued token/set of claims, of a given (normalized) structure or format.</p> <p>The most typical use-case for token normalization involves accepting tokens issued by multiple trusted sources and of often varied authentication protocols, while ensuring that the eventual different data structures adopted by each of those sources are normalized, thus allowing to simplify policies and authorization checks that depend on those values. In general, however, any modification to the identity claims can be for the purpose of normalization.</p> <p>This user guide focuses on the aspect of mutation of the identity claims resolved from an authentication token, to a certain data format and/or by extending them, so that required attributes can thereafter be trusted to be present among the claims, in a desired form. For such, Authorino allows to extend resolved identity objects with custom attributes (custom claims) of either static values or with values fetched from the Authorization JSON.</p> <p>For not only normalizing the identity claims for purpose of writing simpler authorization checks and policies, but also getting Authorino to issue a new token in a normalized format, check the Festival Wristband tokens feature.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Identity extension</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Check out as well the user guides about Authentication with API keys, OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/token-normalization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/token-normalization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>This example implements a policy that only users bound to the <code>admin</code> role can send <code>DELETE</code> requests.</p> <p>The config trusts access tokens issued by a Keycloak realm as well as API keys labeled specifically to a selected group (<code>friends</code>). The roles of the identities handled by Keycloak are managed in Keycloak, as realm roles. Particularly, users <code>john</code> and <code>peter</code> are bound to the <code>member</code> role, while user <code>jane</code> is bound to roles <code>member</code> and <code>admin</code>. As for the users authenticating with API key, they are all bound to the <code>admin</code> role.</p> <p>Without normalizing identity claims from these two different sources, the policy would have to handle the differences of data formats with additional ifs-and-elses. Instead, the config here uses the <code>identity.extendedProperties</code> option to ensure a custom <code>roles</code> (Array) claim is always present in the identity object. In the case of Keycloak ID tokens, the value is extracted from the <code>realm_access.roles</code> claim; for API key-resolved objects, the custom claim is set to the static value <code>[\"admin\"]</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      overrides:\n        \"roles\":\n          selector: auth.identity.realm_access.roles\n    \"api-key-friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n      defaults:\n        \"roles\":\n          value: [\"admin\"]\n  authorization:\n    \"only-admins-can-delete\":\n      when:\n      - selector: context.request.http.method\n        operator: eq\n        value: DELETE\n      patternMatching:\n        patterns:\n        - selector: auth.identity.roles\n          operator: incl\n          value: admin\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#consume-the-api","title":"\u277c Consume the API","text":""},{"location":"authorino/docs/user-guides/token-normalization/#obtain-an-access-token-and-consume-the-api-as-jane-admin","title":"Obtain an access token and consume the API as Jane (admin)","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>Consume the API as Jane:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>Consume the API as John:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#consume-the-api-using-the-api-key-to-authenticate-admin","title":"Consume the API using the API key to authenticate (admin)","text":"<pre><code>curl -H \"Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/validating-webhook/","title":"User guide: Using Authorino as ValidatingWebhook service","text":"<p>Authorino provides an interface for raw HTTP external authorization requests. This interface can be used for integrations other than the typical Envoy gRPC protocol, such as (though not limited to) using Authorino as a generic Kubernetes ValidatingWebhook service.</p> <p>The rules to validate a request to the Kubernetes API \u2013 typically a <code>POST</code>, <code>PUT</code> or <code>DELETE</code> request targeting a particular Kubernetes resource or collection \u2013, according to which either the change will be deemed accepted or not, are written in an Authorino <code>AuthConfig</code> custom resource. Authentication and authorization are performed by the Kubernetes API server as usual, with auth features of Authorino implementing the additional validation within the scope of an <code>AdmissionReview</code> request.</p> <p>This user guide provides an example of using Authorino as a Kubernetes ValidatingWebhook service that validates requests to <code>CREATE</code> and <code>UPDATE</code> Authorino <code>AuthConfig</code> resources. In other words, we will use Authorino as a validator inside the cluster that decides what is a valid AuthConfig for any application which wants to rely on Authorino to protect itself.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Plain</li> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Kubernetes SubjectAccessReview</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Dynamic response \u2192 Festival Wristband tokens</li> <li>Common feature \u2192 Conditions</li> <li>Common feature \u2192 Priorities</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/validating-webhook/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <p>The Keycloak server is only needed for trying out validating AuthConfig resources that use the authentication server.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant you may already have Authorino installed and running. In this case, skip straight to step \u2778.</p> <p>At step \u277a, alternatively to creating an <code>AuthConfig</code> custom resource, you may create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/validating-webhook/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace authorino\n</code></pre> <p>Create the TLS certificates:</p> <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/authorino/g\" | kubectl -n authorino apply -f -\n</code></pre> <p>Create the Authorino instance:</p> <p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources cluster-wide<sup>2</sup>, with TLS enabled<sup>3</sup>.</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  listener:\n    ports:\n      grpc: 50051\n      http: 5001 # for admissionreview requests sent by the kubernetes api server\n    tls:\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre> <p>For convenience, the same instance of Authorino pointed as the validating webhook will also be targeted for the sample AuthConfigs created to test the validation. For using different instances of Authorino for the validating webhook and for protecting applications behind a proxy, check out the section about sharding in the docs. There is also a user guide on the topic, with concrete examples.</p>"},{"location":"authorino/docs/user-guides/validating-webhook/#create-the-authconfig-and-related-clusterrole","title":"\u2778 Create the <code>AuthConfig</code> and related <code>ClusterRole</code>","text":"<p>Create the <code>AuthConfig</code> with the auth rules to validate other AuthConfig resources applied to the cluster.</p> <p>The AuthConfig to validate other AuthConfigs will enforce the following rules:</p> <ul> <li>Authorino features that cannot be used by any application in their security schemes:</li> <li>Anonymous Access</li> <li>Plain identity object extracted from context</li> <li>Kubernetes authentication (TokenReview)</li> <li>Kubernetes authorization (SubjectAccessReview)</li> <li>Festival Wristband tokens</li> <li>Authorino features that require a RoleBinding to a specific ClusterRole in the 'authorino' namespace, to be used in a AuthConfig:</li> <li>Authorino API key authentication</li> <li>All metadata pulled from external sources must be cached for precisely 5 minutes (300 seconds)</li> </ul> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: authconfig-validator\nspec:\n  # admissionreview requests will be sent to this host name\n  hosts:\n\n  - authorino-authorino-authorization.authorino.svc\n\n  # because we're using a single authorino instance for the validating webhook and to protect the user applications,\n  # skip operations related to this one authconfig in the 'authorino' namespace\n  when:\n\n  - selector: context.request.http.body.@fromstr|request.object.metadata.namespace\n    operator: neq\n    value: authorino\n\n  # kubernetes admissionreviews carry info about the authenticated user\n  authentication:\n    \"k8s-userinfo\":\n      plain:\n        selector: context.request.http.body.@fromstr|request.userInfo\n\n  authorization:\n    \"features\":\n      opa:\n        rego: |\n          authconfig = json.unmarshal(input.context.request.http.body).request.object\n\n          forbidden { count(object.get(authconfig.spec, \"authentication\", [])) == 0 }\n          forbidden { authconfig.spec.authentication[_].anonymous }\n          forbidden { authconfig.spec.authentication[_].kubernetesTokenReview }\n          forbidden { authconfig.spec.authentication[_].plain }\n          forbidden { authconfig.spec.authorization[_].kubernetesSubjectAccessReview }\n          forbidden { authconfig.spec.response.success.headers[_].wristband }\n\n          apiKey { authconfig.spec.authentication[_].apiKey }\n\n          allow { count(authconfig.spec.authentication) &gt; 0; not forbidden }\n        allValues: true\n\n    \"apikey-authn-requires-k8s-role-binding\":\n      priority: 1\n      when:\n\n      - selector: auth.authorization.features.apiKey\n        operator: eq\n        value: \"true\"\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.username\n        resourceAttributes:\n          namespace: { value: authorino }\n          group: { value: authorino.kuadrant.io }\n          resource: { value: authconfigs-with-apikeys }\n          verb: { value: create }\n\n    \"metadata-cache-ttl\":\n      priority: 1\n      opa:\n        rego: |\n          invalid_ttl = input.auth.authorization.features.authconfig.spec.metadata[_].cache.ttl != 300\n          allow { not invalid_ttl }\nEOF\n</code></pre> <p>Define a <code>ClusterRole</code> to control the usage of protected features of Authorino:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: authorino-apikey\nrules:\n\n- apiGroups: [\"authorino.kuadrant.io\"]\n  resources: [\"authconfigs-with-apikeys\"] # not a real k8s resource\n  verbs: [\"create\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#create-the-validatingwebhookconfiguration","title":"\u2779 Create the <code>ValidatingWebhookConfiguration</code>","text":"<pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: authconfig-authz\n  annotations:\n    cert-manager.io/inject-ca-from: authorino/authorino-ca-cert\nwebhooks:\n\n- name: check-authconfig.authorino.kuadrant.io\n  clientConfig:\n    service:\n      namespace: authorino\n      name: authorino-authorino-authorization\n      port: 5001\n      path: /check\n  rules:\n  - apiGroups: [\"authorino.kuadrant.io\"]\n    apiVersions: [\"v1beta2\"]\n    resources: [\"authconfigs\"]\n    operations: [\"CREATE\", \"UPDATE\"]\n    scope: Namespaced\n  sideEffects: None\n  admissionReviewVersions: [\"v1\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#try-it-out","title":"\u277a Try it out","text":"<p>Create a namespace:</p> <pre><code>kubectl create namespace myapp\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-a-valid-authconfig","title":"With a valid <code>AuthConfig</code>","text":"Kuadrant users \u2013         For this and other example AuthConfigs below, if you create a Kuadrant <code>AuthPolicy</code> instead, the output of the commands shall differ. The requested AuthPolicy may be initially accepted, but its state will turn ready or not ready depending on whether the corresponding AuthConfig requested by Kuadrant is accepted or rejected, according to the validating webhook rules. Check the state of the resources to confirm.         For more, see Kuadrant auth.        <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection created\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-forbidden-features","title":"With forbidden features","text":"<p>Anonymous access:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":null}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"anonymous-access\":\n      anonymous: {}\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"anonymous-access\\\":{\\\"anonymous\\\":{}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"anonymous-access\":{\"anonymous\":{}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Kubernetes TokenReview:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"k8s-tokenreview\":\n      kubernetesTokenReview:\n        audiences: [\"myapp\"]\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"k8s-tokenreview\\\":{\\\"kubernetesTokenReview\\\":{\\\"audiences\\\":[\\\"myapp\\\"]}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"k8s-tokenreview\":{\"kubernetesTokenReview\":{\"audiences\":[\"myapp\"]}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Plain identity extracted from context:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"envoy-jwt-authn\":\n      plain:\n        selector: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"envoy-jwt-authn\\\":{\\\"plain\\\":{\\\"selector\\\":\\\"context.metadata_context.filter_metadata.envoy\\\\\\\\.filters\\\\\\\\.http\\\\\\\\.jwt_authn|verified_jwt\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"envoy-jwt-authn\":{\"plain\":{\"selector\":\"context.metadata_context.filter_metadata.envoy\\\\.filters\\\\.http\\\\.jwt_authn|verified_jwt\"}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Kubernetes SubjectAccessReview:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"k8s-subjectaccessreview\":\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.sub\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"authorization\\\":{\\\"k8s-subjectaccessreview\\\":{\\\"kubernetesSubjectAccessReview\\\":{\\\"user\\\":{\\\"selector\\\":\\\"auth.identity.sub\\\"}}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authorization\":{\"k8s-subjectaccessreview\":{\"kubernetesSubjectAccessReview\":{\"user\":{\"selector\":\"auth.identity.sub\"}}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Festival Wristband tokens:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: wristband-signing-key\nstringData:\n  key.pem: |\n    -----BEGIN EC PRIVATE KEY-----\n    MHcCAQEEIDHvuf81gVlWGo0hmXGTAnA/HVxGuH8vOc7/8jewcVvqoAoGCCqGSM49\n    AwEHoUQDQgAETJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZxJKDysoGwn\n    cnUvHIu23SgW+Ee9lxSmZGhO4eTdQeKxMA==\n    -----END EC PRIVATE KEY-----\ntype: Opaque\n---\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  response:\n    success:\n      headers:\n        \"wristband\":\n          wristband:\n            issuer: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\n            signingKeyRefs:\n            - algorithm: ES256\n              name: wristband-signing-key\nEOF\n# secret/wristband-signing-key created\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"response\\\":{\\\"success\\\":{\\\"headers\\\":{\\\"wristband\\\":{\\\"wristband\\\":{\\\"issuer\\\":\\\"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\\\",\\\"signingKeyRefs\\\":[{\\\"algorithm\\\":\\\"ES256\\\",\\\"name\\\":\\\"wristband-signing-key\\\"}]}}}}}}}\\n\"}},\"spec\":{\"response\":{\"success\":{\"headers\":{\"wristband\":{\"wristband\":{\"issuer\":\"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\",\"signingKeyRefs\":[{\"algorithm\":\"ES256\",\"name\":\"wristband-signing-key\"}]}}}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-features-that-require-additional-permissions","title":"With features that require additional permissions","text":"<p>Before adding the required permissions:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels: { app: myapp }\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"api-key\\\":{\\\"apiKey\\\":{\\\"selector\\\":{\\\"matchLabels\\\":{\\\"app\\\":\\\"myapp\\\"}}}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"api-key\":{\"apiKey\":{\"selector\":{\"matchLabels\":{\"app\":\"myapp\"}}}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Not authorized: unknown reason\n</code></pre> <p>Add the required permissions:</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: authorino-apikey\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: authorino-apikey\nsubjects:\n\n- kind: User\n  name: kubernetes-admin\nEOF\n# rolebinding.rbac.authorization.k8s.io/authorino-apikey created\n</code></pre> <p>After adding the required permissions:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels: { app: myapp }\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection configured\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-features-that-require-specific-property-validation","title":"With features that require specific property validation","text":"<p>Invalid:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"external-source\":\n      http:\n        url: http://metadata.io\n      cache:\n        key: { value: global }\n        ttl: 60\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"metadata\\\":{\\\"external-source\\\":{\\\"cache\\\":{\\\"key\\\":{\\\"value\\\":\\\"global\\\"},\\\"ttl\\\":60},\\\"http\\\":{\\\"url\\\":\\\"http://metadata.io\\\"}}}}}\\n\"}},\"spec\":{\"authentication\":{\"api-key\":null,\"keycloak\":{\"jwt\":{\"issuerUrl\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\"}}},\"metadata\":{\"external-source\":{\"cache\":{\"key\":{\"value\":\"global\"},\"ttl\":60},\"http\":{\"url\":\"http://metadata.io\"}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Valid:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"external-source\":\n      http:\n        url: http://metadata.io\n      cache:\n        key: { value: global }\n        ttl: 300\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection configured\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete namespace myapp\nkubectl delete namespace authorino\nkubectl delete clusterrole authorino-apikey\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino-operator/","title":"Authorino Operator","text":"<p>A Kubernetes Operator to manage Authorino instances.</p> <p> </p>"},{"location":"authorino-operator/#installation","title":"Installation","text":"<p>The Operator can be installed by applying the manifests to the Kubernetes cluster or using Operator Lifecycle Manager (OLM)</p>"},{"location":"authorino-operator/#applying-the-manifests-to-the-cluster","title":"Applying the manifests to the cluster","text":"<ol> <li>Install the Operator manifests</li> </ol> <pre><code>make install\n</code></pre> <ol> <li>Deploy the Operator</li> </ol> <pre><code>make deploy\n</code></pre> Tip: Deploy a custom image of the Operator    To deploy an image of the Operator other than the default <code>quay.io/kuadrant/authorino-operator:latest</code>, specify by setting the <code>OPERATOR_IMAGE</code> parameter. E.g.:    <pre><code>make deploy OPERATOR_IMAGE=authorino-operator:local\n</code></pre>"},{"location":"authorino-operator/#installing-via-olm","title":"Installing via OLM","text":"<p>To install the Operator using the Operator Lifecycle Manager, you need to make the Operator CSVs available in the cluster by creating a <code>CatalogSource</code> resource.</p> <p>The bundle and catalog images of the Operator are available in Quay.io:</p> Bundle quay.io/kuadrant/authorino-operator-bundle Catalog quay.io/kuadrant/authorino-operator-catalog <ol> <li>Create the namespace for the Operator</li> </ol> <pre><code>kubectl create namespace authorino-operator\n</code></pre> <ol> <li>Create the CatalogSource resource pointing to    one of the images from in the Operator's catalog repo:</li> </ol> <pre><code>kubectl -n authorino-operator apply -f -&lt;&lt;EOF\napiVersion: operators.coreos.com/v1alpha1\nkind: CatalogSource\nmetadata:\n  name: operatorhubio-catalog\n  namespace: authorino-operator\nspec:\n  sourceType: grpc\n  image: quay.io/kuadrant/authorino-operator-catalog:latest\n  displayName: Authorino Operator\nEOF\n</code></pre>"},{"location":"authorino-operator/#deploy-authorino-operator-using-operator-sdk","title":"Deploy authorino operator using operator-sdk","text":"<ol> <li>Install operator-sdk bin    <pre><code>make operator-sdk\n</code></pre></li> <li>Run operator-sdk bundle command     <pre><code>./bin/operator-sdk run bundle quay.io/kuadrant/authorino-operator-bundle:latest\n</code></pre> Note: For s390x &amp; ppc64le , use operator-sdk to install authorino-operator </li> </ol>"},{"location":"authorino-operator/#requesting-an-authorino-instance","title":"Requesting an Authorino instance","text":"<p>Once the Operator is up and running, you can request instances of Authorino by creating <code>Authorino</code> CRs. E.g.:</p> <pre><code>kubectl -n default apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino-operator/#the-authorino-custom-resource-definition-crd","title":"The <code>Authorino</code> Custom Resource Definition (CRD)","text":"<p>API to install, manage and configure Authorino authorization services .</p> <p>Each <code>Authorino</code> Custom Resource (CR) represents an instance of Authorino deployed to the cluster. The Authorino Operator will reconcile the state of the Kubernetes Deployment and associated resources, based on the state of the CR.</p>"},{"location":"authorino-operator/#api-specification","title":"API Specification","text":"Field Type Description Required/Default spec AuthorinoSpec Specification of the Authorino deployment. Required"},{"location":"authorino-operator/#authorinospec","title":"AuthorinoSpec","text":"Field Type Description Required/Default clusterWide Boolean Sets the Authorino instance's watching scope \u2013 cluster-wide or namespaced. Default: <code>true</code> (cluster-wide) authConfigLabelSelectors String Label selectors used by the Authorino instance to filter <code>AuthConfig</code>-related reconciliation events. Default: empty (all AuthConfigs are watched) secretLabelSelectors String Label selectors used by the Authorino instance to filter <code>Secret</code>-related reconciliation events (API key and mTLS authentication methods). Default: <code>authorino.kuadrant.io/managed-by=authorino</code> supersedingHostSubsets Boolean Enable/disable allowing AuthConfigs to supersede strict subsets of hosts already taken. Default: <code>false</code> replicas Integer Number of replicas desired for the Authorino instance. Values greater than 1 enable leader election in the Authorino service, where the leader updates the statuses of the <code>AuthConfig</code> CRs). Default: 1 evaluatorCacheSize Integer Cache size (in megabytes) of each Authorino evaluator (when enabled in an <code>AuthConfig</code>). Default: 1 image String Authorino image to be deployed (for dev/testing purpose only). Default: <code>quay.io/kuadrant/authorino:latest</code> imagePullPolicy String Sets the imagePullPolicy of the Authorino Deployment (for dev/testing purpose only). Default: k8s default logLevel String Defines the level of log you want to enable in Authorino (<code>debug</code>, <code>info</code> and <code>error</code>). Default: <code>info</code> logMode String Defines the log mode in Authorino (<code>development</code> or <code>production</code>). Default: <code>production</code> listener Listener Specification of the authorization service (gRPC interface). Required oidcServer OIDCServer Specification of the OIDC service. Required tracing Tracing Configuration of the OpenTelemetry tracing exporter. Optional metrics Metrics Configuration of the metrics server (port, level). Optional healthz Healthz Configuration of the health/readiness probe (port). Optional volumes VolumesSpec Additional volumes to be mounted in the Authorino pods. Optional"},{"location":"authorino-operator/#listener","title":"Listener","text":"<p>Configuration of the authorization server \u2013 gRPC and raw HTTP interfaces</p> Field Type Description Required/Default port Integer Port number of authorization server (gRPC interface). DEPRECATEDUse <code>ports</code> instead ports Ports Port numbers of the authorization server (gRPC and raw HTTPinterfaces). Optional tls TLS TLS configuration of the authorization server (GRPC and HTTP interfaces). Required timeout Integer Timeout of external authorization request (in milliseconds), controlled internally by the authorization server. Default: <code>0</code> (disabled)"},{"location":"authorino-operator/#oidcserver","title":"OIDCServer","text":"<p>Configuration of the OIDC Discovery server for Festival Wristband tokens.</p> Field Type Description Required/Default port Integer Port number of OIDC Discovery server for Festival Wristband tokens. Default: <code>8083</code> tls TLS TLS configuration of the OIDC Discovery server for Festival Wristband tokens Required"},{"location":"authorino-operator/#tls","title":"TLS","text":"<p>TLS configuration of server. Appears in <code>listener</code> and <code>oidcServer</code>.</p> Field Type Description Required/Default enabled Boolean Whether TLS is enabled or disabled for the server. Default: <code>true</code> certSecretRef LocalObjectReference The reference to the secret that contains the TLS certificates <code>tls.crt</code> and <code>tls.key</code>. Required when <code>enabled: true</code>"},{"location":"authorino-operator/#ports","title":"Ports","text":"<p>Port numbers of the authorization server.</p> Field Type Description Required/Default grpc Integer Port number of the gRPC interface of the authorization server. Set to 0 to disable this interface. Default: <code>50001</code> http Integer Port number of the raw HTTP interface of the authorization server. Set to 0 to disable this interface. Default: <code>5001</code>"},{"location":"authorino-operator/#tracing","title":"Tracing","text":"<p>Configuration of the OpenTelemetry tracing exporter.</p> Field Type Description Required/Default endpoint String Full endpoint of the OpenTelemetry tracing collector service (e.g. http://jaeger:14268/api/traces). Required tags Map Key-value map of fixed tags to add to all OpenTelemetry traces emitted by Authorino. Optional insecure Boolean Enable/disable insecure connection to the tracing endpoint Default: <code>false</code>"},{"location":"authorino-operator/#metrics","title":"Metrics","text":"<p>Configuration of the metrics server.</p> Field Type Description Required/Default port Integer Port number of the metrics server. Default: <code>8080</code> deep Boolean Enable/disable metrics at the level of each evaluator config (if requested in the <code>AuthConfig</code>) exported by the metrics server. Default: <code>false</code>"},{"location":"authorino-operator/#healthz","title":"Healthz","text":"<p>Configuration of the health/readiness probe (port).</p> Field Type Description Required/Default port Integer Port number of the health/readiness probe. Default: <code>8081</code>"},{"location":"authorino-operator/#volumesspec","title":"VolumesSpec","text":"<p>Additional volumes to project in the Authorino pods. Useful for validation of TLS self-signed certificates of external services known to have to be contacted by Authorino at runtime.</p> Field Type Description Required/Default items []VolumeSpec List of additional volume items to project. Optional defaultMode Integer Mode bits used to set permissions on the files. Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511. Optional"},{"location":"authorino-operator/#volumespec","title":"VolumeSpec","text":"Field Type Description Required/Default name String Name of the volume and volume mount within the Deployment. It must be unique in the CR. Optional mountPath String Absolute path where to mount all the items. Required configMaps []String List of of Kubernetes ConfigMap names to mount. Required exactly one of: <code>confiMaps</code>, <code>secrets</code>. secrets []String List of of Kubernetes Secret names to mount. Required exactly one of: <code>confiMaps</code>, <code>secrets</code>. items []KeyToPath Mount details for selecting specific ConfigMap or Secret entries. Optional"},{"location":"authorino-operator/#full-example","title":"Full example","text":"<pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: environment=production\n  secretLabelSelectors: authorino.kuadrant.io/component=authorino,environment=production\n\n  replicas: 2\n\n  evaluatorCacheSize: 2 # mb\n\n  image: quay.io/kuadrant/authorino:latest\n  imagePullPolicy: Always\n\n  logLevel: debug\n  logMode: production\n\n  listener:\n    ports:\n      grpc: 50001\n      http: 5001\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert # secret must contain `tls.crt` and `tls.key` entries\n\n  oidcServer:\n    port: 8083\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert # secret must contain `tls.crt` and `tls.key` entries\n\n  metrics:\n    port: 8080\n    deep: true\n\n  volumes:\n    items:\n\n      - name: keycloak-tls-cert\n        mountPath: /etc/ssl/certs\n        configMaps:\n          - keycloak-tls-cert\n        items: # details to mount the k8s configmap in the authorino pods\n          - key: keycloak.crt\n            path: keycloak.crt\n    defaultMode: 420\n</code></pre>"},{"location":"authorino-operator/#removal","title":"Removal","text":""},{"location":"authorino-operator/#removing-the-operator-installed-via-manifests","title":"Removing the operator installed via manifests","text":"<ol> <li>Undeploy the Operator</li> </ol> <pre><code>make undeploy\n</code></pre> <ol> <li>Remove the Operator manifests</li> </ol> <pre><code>make uninstall\n</code></pre>"},{"location":"authorino-operator/#remove-dependencies-optional","title":"Remove dependencies (Optional)","text":"<ol> <li> <p>Remove operator namespace <pre><code>make delete-namespace\n</code></pre></p> </li> <li> <p>Uninstall cert manager <pre><code>make uninstall-cert-manager\n</code></pre></p> </li> </ol>"},{"location":"authorino-operator/#license","title":"License","text":""},{"location":"limitador/","title":"Limitador","text":"<p>Limitador is a generic rate-limiter written in Rust. It can be used as a library, or as a service. The service exposes HTTP endpoints to apply and observe limits. Limitador can be used with Envoy because it also exposes a grpc service, on a different port, that implements the Envoy Rate Limit protocol (v3).</p> <ul> <li>Getting started</li> <li>How it works</li> <li>Configuration</li> <li>Development</li> <li>Testing Environment</li> <li>Kubernetes</li> <li>Contributing</li> <li>License</li> </ul> <p>Limitador is under active development, and its API has not been stabilized yet.</p>"},{"location":"limitador/#getting-started","title":"Getting started","text":"<ul> <li>Rust library</li> <li>Server</li> </ul>"},{"location":"limitador/#rust-library","title":"Rust library","text":"<p>Add this to your <code>Cargo.toml</code>: <pre><code>[dependencies]\nlimitador = { version = \"0.3.0\" }\n</code></pre></p> <p>For more information, see the <code>README</code> of the crate</p>"},{"location":"limitador/#server","title":"Server","text":"<p>Run with Docker (replace <code>latest</code> with the version you want): <pre><code>docker run --rm --net=host -it quay.io/kuadrant/limitador:v1.0.0\n</code></pre></p> <p>Run locally: <pre><code>cargo run --release --bin limitador-server -- --help\n</code></pre></p> <p>Refer to the help message on how to start up the server. More information are available in the server's <code>README.md</code></p>"},{"location":"limitador/#development","title":"Development","text":""},{"location":"limitador/#build","title":"Build","text":"<pre><code>cargo build\n</code></pre>"},{"location":"limitador/#run-the-tests","title":"Run the tests","text":"<p>Some tests need a redis deployed in <code>localhost:6379</code>. You can run it in Docker with: <pre><code>docker run --rm -p 6379:6379 -it redis\n</code></pre></p> <p>Then, run the tests:</p> <pre><code>cargo test --all-features\n</code></pre> <p>or you can run tests disabling the \"redis storage\" feature: <pre><code>cd limitador; cargo test --no-default-features\n</code></pre></p>"},{"location":"limitador/#contributing","title":"Contributing","text":"<p>Join us on the #kuadrant channel in the Kubernetes Slack workspace, for live discussions about the roadmap and more.</p>"},{"location":"limitador/#license","title":"License","text":"<p>Apache 2.0 License</p> <p></p>"},{"location":"limitador/doc/how-it-works/","title":"How it works","text":""},{"location":"limitador/doc/how-it-works/#how-it-works","title":"How it works","text":"<p>Limitador ensures that the most restrictive limit configuration will apply.</p> <p>Limitador will try to match each incoming descriptor with the same namespaced counter's conditions and variables. The namespace for the descriptors is defined by the <code>domain</code> field whereas for the rate limit configuration the <code>namespace</code> field is being used. For each matching counter, the counter is increased and the limits checked.</p> <p>One example to illustrate:</p> <p>Let's say we have 1 rate limit configuration (one counter per config):</p> <pre><code>conditions: [\"KEY_A == 'VALUE_A'\"]\nmax_value: 1\nseconds: 60\nvariables: []\nnamespace: example.org\n</code></pre> <p>Limitador receives one descriptor with two entries:</p> <pre><code>domain: example.org\ndescriptors:\n\n  - entries:\n    - KEY_A: VALUE_A\n    - OTHER_KEY: OTHER_VALUE\n</code></pre> <p>The counter's condition will match. Then, the counter will be increased and the limit checked. If the limit is exceeded, the request will be rejected with <code>429 Too Many Requests</code>, otherwise accepted.</p> <p>Note that the counter is being activated even though it does not match all the entries of the descriptor. The same rule applies for the variables field.</p> <p>Currently, the implementation of condition only allow for equal (<code>==</code>) and not equal (<code>!=</code>) operators. More operators will be implemented based off the use cases for them.</p> <p>The variables field is a list of keys. The matching rule is defined just as the existence of the list of descriptor entries with the same key values. If variables is <code>variables: [A, B, C]</code>, one descriptor matches if it has at least three entries with the same A, B, C keys.</p> <p>Few examples to illustrate.</p> <p>Having the following descriptors:</p> <pre><code>domain: example.org\ndescriptors:\n\n  - entries:\n    - KEY_A: VALUE_A\n    - OTHER_KEY: OTHER_VALUE\n</code></pre> <p>the following counters would not be activated.</p> <p><pre><code>conditions: [\"KEY_B == 'VALUE_B'\"]\nmax_value: 1\nseconds: 60\nvariables: []\nnamespace: example.org\n</code></pre> Reason: conditions key does not exist</p> <p><pre><code>conditions:\n\n  - \"KEY_A == 'VALUE_A'\"\n  - \"OTHER_KEY == 'WRONG_VALUE'\"\nmax_value: 1\nseconds: 60\nvariables: []\nnamespace: example.org\n</code></pre> Reason: not all the conditions match</p> <p><pre><code>conditions: []\nmax_value: 1\nseconds: 60\nvariables: [\"MY_VAR\"]\nnamespace: example.org\n</code></pre> Reason: the variable name does not exist</p> <p><pre><code>conditions: [\"KEY_B == 'VALUE_B'\"]\nmax_value: 1\nseconds: 60\nvariables: [\"MY_VAR\"]\nnamespace: example.org\n</code></pre> Reason: Both variables and conditions must match. In this particular case, only conditions match</p>"},{"location":"limitador/doc/topologies/","title":"Deployment topologies","text":""},{"location":"limitador/doc/topologies/#in-memory","title":"In-memory","text":""},{"location":"limitador/doc/topologies/#redis","title":"Redis","text":""},{"location":"limitador/doc/topologies/#redis-active-active-storage","title":"Redis active-active storage","text":"<p>The RedisLabs version of Redis supports active-active replication. Limitador is compatible with that deployment mode, but there are a few things to take into account regarding limit accuracy.</p>"},{"location":"limitador/doc/topologies/#considerations","title":"Considerations","text":"<p>With an active-active deployment, the data needs to be replicated between instances. An update in an instance takes a short time to be reflected in the other. That time lag depends mainly on the network speed between the Redis instances, and it affects the accuracy of the rate-limiting performed by Limitador because it can go over limits while the updates of the counters are being replicated.</p> <p>The impact of that greatly depends on the use case. With limits of a few seconds, and a low number of hits, we could easily go over limits. On the other hand, if we have defined limits with a high number of hits and a long period, the effect will be basically negligible. For example, if we define a limit of one hour, and we know that the data takes around one second to be replicated, the accuracy loss is going to be negligible.</p>"},{"location":"limitador/doc/topologies/#set-up","title":"Set up","text":"<p>In order to try active-active replication, you can follow this tutorial from RedisLabs.</p>"},{"location":"limitador/doc/topologies/#disk","title":"Disk","text":"<p>Disk storage using RocksDB. Counters are held on disk (persistent).</p>"},{"location":"limitador/doc/migrations/conditions/","title":"New condition syntax","text":"<p>With <code>limitador-server</code> version <code>1.0.0</code> (and the <code>limitador</code> crate version <code>0.3.0</code>), the syntax for <code>condition</code>s within  <code>limit</code> definitions has changed.</p>"},{"location":"limitador/doc/migrations/conditions/#changes","title":"Changes","text":""},{"location":"limitador/doc/migrations/conditions/#the-new-syntax","title":"The new syntax","text":"<p>The new syntax formalizes what part of an expression is the identifier and which is the value to test against.  Identifiers are simple string value, while string literals are to be demarcated by single quotes (<code>'</code>) or double quotes (<code>\"</code>) so that <code>foo == \" bar\"</code> now makes it explicit that the value is to be prefixed with a space character.</p> <p>A few remarks:</p> <ul> <li>Only <code>string</code> values are supported, as that's what they really are</li> <li>There is no escape character sequence supported in string literals</li> <li>A new operator has been added, <code>!=</code></li> </ul>"},{"location":"limitador/doc/migrations/conditions/#the-issue-with-the-deprecated-syntax","title":"The issue with the deprecated syntax","text":"<p>The previous syntax wouldn't differentiate between values and the identifier, so that <code>foo == bar</code> was valid. In this case <code>foo</code> was the identifier of the variable, while <code>bar</code> was the value to evaluate it against. Whitespaces before and after the operator <code>==</code> would be equally important. SO that <code>foo  ==  bar</code> would test for a <code>foo</code> variable being equal to <code>bar</code> where the trailing whitespace after the identifier, and the one prefixing the value, would have been evaluated.</p>"},{"location":"limitador/doc/migrations/conditions/#server-binary-users","title":"Server binary users","text":"<p>The server still allows for the deprecated syntax, but warns about its usage. You can easily migrate your limits file,  using the following command:</p> <pre><code>limitador-server --validate old_limits.yaml &gt; updated_limits.yaml\n</code></pre> <p>Which should output <code>Deprecated syntax for conditions corrected!</code> to <code>stderr</code> while <code>stdout</code> would be the limits using  the new syntax. It is recommended you manually verify the resulting <code>LIMITS_FILE</code>.</p>"},{"location":"limitador/doc/migrations/conditions/#crate-users","title":"Crate users","text":"<p>A feature <code>lenient_conditions</code> has been added, which lets you use the syntax used in previous version of the crate. The function <code>limitador::limit::check_deprecated_syntax_usages_and_reset()</code> lets you verify if the deprecated syntax  has been used as <code>limit::Limit</code>s are created with their condition strings using the deprecated syntax.</p>"},{"location":"limitador/doc/server/configuration/","title":"Limitador configuration","text":""},{"location":"limitador/doc/server/configuration/#command-line-configuration","title":"Command line configuration","text":"<p>The preferred way of starting and configuring the Limitador server is using the command line:</p> <pre><code>Rate Limiting Server\n\nUsage: limitador-server [OPTIONS] &lt;LIMITS_FILE&gt; [STORAGE]\n\nSTORAGES:\n  memory        Counters are held in Limitador (ephemeral)\n  disk          Counters are held on disk (persistent)\n  redis         Uses Redis to store counters\n  redis_cached  Uses Redis to store counters, with an in-memory cache\n\nArguments:\n  &lt;LIMITS_FILE&gt;  The limit file to use\n\nOptions:\n  -b, --rls-ip &lt;ip&gt;\n          The IP to listen on for RLS [default: 0.0.0.0]\n  -p, --rls-port &lt;port&gt;\n          The port to listen on for RLS [default: 8081]\n  -B, --http-ip &lt;http_ip&gt;\n          The IP to listen on for HTTP [default: 0.0.0.0]\n  -P, --http-port &lt;http_port&gt;\n          The port to listen on for HTTP [default: 8080]\n  -l, --limit-name-in-labels\n          Include the Limit Name in prometheus label\n      --tracing-endpoint &lt;tracing_endpoint&gt;\n          The host for the tracing service [default: ]\n  -v...\n          Sets the level of verbosity\n      --validate\n          Validates the LIMITS_FILE and exits\n  -H, --rate-limit-headers &lt;rate_limit_headers&gt;\n          Enables rate limit response headers [default: NONE] [possible values: NONE, DRAFT_VERSION_03]\n      --grpc-reflection-service\n          Enables gRPC server reflection service\n  -h, --help\n          Print help\n  -V, --version\n          Print version\n</code></pre> <p>The values used are authoritative over any environment variables independently set.</p>"},{"location":"limitador/doc/server/configuration/#limit-definitions","title":"Limit definitions","text":"<p>The <code>LIMITS_FILE</code> provided is the source of truth for all the limits that will be enforced. The file location will be monitored by the server for any changes and be hot reloaded. If the changes are invalid, they will be ignored on hot reload, or the server will fail to start.</p>"},{"location":"limitador/doc/server/configuration/#the-limits_files-format","title":"The <code>LIMITS_FILE</code>'s format","text":"<p>When starting the server, you point it to a <code>LIMITS_FILE</code>, which is expected to be a yaml file with an array of <code>limit</code> definitions, with the following format:</p> <pre><code>---\n\"$schema\": http://json-schema.org/draft-04/schema#\ntype: object\nproperties:\n  name:\n    type: string\n  namespace:\n    type: string\n  seconds:\n    type: integer\n  max_value:\n    type: integer\n  conditions:\n    type: array\n    items:\n\n      - type: string\n  variables:\n    type: array\n    items:\n      - type: string\nrequired:\n  - namespace\n  - seconds\n  - max_value\n  - conditions\n  - variables\n</code></pre> <p>Here is an example of such a limit definition:</p> <pre><code>- namespace: example.org\n  max_value: 10\n  seconds: 60\n  conditions:\n    - \"req.method == 'GET'\"\n  variables:\n    - user_id\n</code></pre> <ul> <li><code>namespace</code> namespaces the limit, will generally be the domain, see here</li> <li><code>seconds</code> is the duration for which the limit applies, in seconds: e.g. <code>60</code> is a span of time of one minute</li> <li><code>max_value</code> is the actual limit, e.g. <code>100</code> would limit to 100 requests</li> <li><code>name</code> lets the user optionally name the limit</li> <li><code>variables</code> is an array of variables, which once resolved, will be used to qualify counters for the limit,    e.g. <code>api_key</code> to limit per api keys</li> <li><code>conditions</code> is an array of conditions, which once evaluated will decide whether to apply the limit or not</li> </ul>"},{"location":"limitador/doc/server/configuration/#condition-syntax","title":"<code>condition</code> syntax","text":"<p>Each <code>condition</code> is an expression producing a boolean value (<code>true</code> or <code>false</code>). All <code>conditions</code> must evaluate to <code>true</code> for the <code>limit</code> to be applied on a request.</p> <p>Expressions follow the following syntax: <code>$IDENTIFIER $OP $STRING_LITERAL</code>, where:</p> <ul> <li><code>$IDENTIFIER</code> will be used to resolve the value at evaluation time, e.g. <code>role</code></li> <li><code>$OP</code> is an operator, either <code>==</code> or <code>!=</code></li> <li><code>$STRING_LITERAL</code> is a literal string value, <code>\"</code> or <code>'</code> demarcated, e.g. <code>\"admin\"</code></li> </ul> <p>So that <code>role != \"admin\"</code> would apply the limit on request from all users, but <code>admin</code>'s.</p>"},{"location":"limitador/doc/server/configuration/#counter-storages","title":"Counter storages","text":"<p>Limitador will load all the <code>limit</code> definitions from the <code>LIMITS_FILE</code> and keep these in memory. To enforce these limits, Limitador needs to track requests in the form of counters. There would be at least one counter per limit, but that number grows when <code>variables</code> are used to qualify counters per some arbitrary values.</p>"},{"location":"limitador/doc/server/configuration/#memory","title":"<code>memory</code>","text":"<p>As the name implies, Limitador will keep all counters in memory. This yields the best results in terms of latency as well as accuracy. By default, only up to <code>1000</code> \"concurrent\" counters will be kept around, evicting the oldest entries. \"Concurrent\" in this context means counters that need to exist at the \"same time\", based of the period of the limit, as \"expired\" counters are discarded.</p> <p>This storage is ephemeral, as if the process is restarted, all the counters are lost and effectively \"reset\" all the limits as if no traffic had been rate limited, which can be fine for short-lived limits, less for longer-lived ones.</p>"},{"location":"limitador/doc/server/configuration/#redis","title":"<code>redis</code>","text":"<p>When you want persistence of your counters, such as for disaster recovery or across restarts, using <code>redis</code> will store the counters in a redis instance using the provided <code>URL</code>. Increments to individual counters is made within redis itself, providing accuracy over these, races tho can occur when multiple Limitador servers are used against a single redis and using \"stacked\" limits (i.e. over different periods). Latency is also impacted, as it results in one additional hop to talk to redis and maintain the counters.</p> <p>TLS Support</p> <p>Connect to a redis instance using the <code>rediss://</code> URL scheme.</p> <p>To enable insecure mode, append <code>#insecure</code> at the end of the URL. For example:</p> <pre><code>limitador-server &lt;LIMITS_FILE&gt; redis rediss://127.0.0.1/#insecure\"\n</code></pre> <p>Authentication</p> <p>To enable authentication, use the username and password properties of the URL scheme. For example:</p> <pre><code>limitador-server &lt;LIMITS_FILE&gt; redis redis://my-username:my-password@127.0.0.1\"\n</code></pre> <p>when the username is omitted, redis assumes <code>default</code> user. For example:</p> <pre><code>limitador-server &lt;LIMITS_FILE&gt; redis redis://:my-password@127.0.0.1\"\n</code></pre> <p>Usage</p> <pre><code>Uses Redis to store counters\n\nUsage: limitador-server &lt;LIMITS_FILE&gt; redis &lt;URL&gt;\n\nArguments:\n  &lt;URL&gt;  Redis URL to use\n\nOptions:\n  -h, --help  Print help\n</code></pre>"},{"location":"limitador/doc/server/configuration/#redis_cached","title":"<code>redis_cached</code>","text":"<p>In order to avoid some communication overhead to redis, <code>redis_cached</code> adds an in memory caching layer within the Limitador servers. This lowers the latency, but sacrifices some accuracy as it will not only cache counters, but also coalesce counters updates to redis over time. See this configuration option for more information.</p> <p>TLS Support</p> <p>Connect to a redis instance using the <code>rediss://</code> URL scheme.</p> <p>To enable insecure mode, append <code>#insecure</code> at the end of the URL. For example:</p> <pre><code>limitador-server &lt;LIMITS_FILE&gt; redis rediss://127.0.0.1/#insecure\"\n</code></pre> <p>Authentication</p> <p>To enable authentication, use the username and password properties of the URL scheme. For example:</p> <pre><code>limitador-server &lt;LIMITS_FILE&gt; redis redis://my-username:my-password@127.0.0.1\"\n</code></pre> <p>when the username is omitted, redis assumes <code>default</code> user. For example:</p> <pre><code>limitador-server &lt;LIMITS_FILE&gt; redis redis://:my-password@127.0.0.1\"\n</code></pre> <p>Usage</p> <pre><code>Uses Redis to store counters, with an in-memory cache\n\nUsage: limitador-server &lt;LIMITS_FILE&gt; redis_cached [OPTIONS] &lt;URL&gt;\n\nArguments:\n  &lt;URL&gt;  Redis URL to use\n\nOptions:\n      --batch-size &lt;batch&gt;          Size of entries to flush in as single flush [default: 100]\n      --flush-period &lt;flush&gt;        Flushing period for counters in milliseconds [default: 1000]\n      --max-cached &lt;max&gt;            Maximum amount of counters cached [default: 10000]\n      --response-timeout &lt;timeout&gt;  Timeout for Redis commands in milliseconds [default: 350]\n  -h, --help                        Print help\n</code></pre>"},{"location":"limitador/doc/server/configuration/#disk","title":"<code>disk</code>","text":"<p>Disk storage using RocksDB. Counters are held on disk (persistent).</p> <pre><code>Counters are held on disk (persistent)\n\nUsage: limitador-server &lt;LIMITS_FILE&gt; disk [OPTIONS] &lt;PATH&gt;\n\nArguments:\n  &lt;PATH&gt;  Path to counter DB\n\nOptions:\n      --optimize &lt;OPTIMIZE&gt;  Optimizes either to save disk space or higher throughput [default: throughput] [possible values: throughput, disk]\n  -h, --help                 Print help\n</code></pre> <p>For an in-depth coverage of the different topologies supported and how they affect the behavior, see the topologies' document.</p>"},{"location":"limitador/doc/server/configuration/#configuration-using-environment-variables","title":"Configuration using environment variables","text":"<p>The Limitador server has some options that can be configured with environment variables. These will override the default values the server uses. Any argument used when starting the server will prevail over the environment variables.</p>"},{"location":"limitador/doc/server/configuration/#envoy_rls_host","title":"<code>ENVOY_RLS_HOST</code>","text":"<ul> <li>Host where the Envoy RLS server listens.</li> <li>Optional. Defaults to <code>\"0.0.0.0\"</code>.</li> <li>Format: <code>string</code>.</li> </ul>"},{"location":"limitador/doc/server/configuration/#envoy_rls_port","title":"<code>ENVOY_RLS_PORT</code>","text":"<ul> <li>Port where the Envoy RLS server listens.</li> <li>Optional. Defaults to <code>8081</code>.</li> <li>Format: <code>integer</code>.</li> </ul>"},{"location":"limitador/doc/server/configuration/#http_api_host","title":"<code>HTTP_API_HOST</code>","text":"<ul> <li>Host where the HTTP server listens.</li> <li>Optional. Defaults to <code>\"0.0.0.0\"</code>.</li> <li>Format: <code>string</code>.</li> </ul>"},{"location":"limitador/doc/server/configuration/#http_api_port","title":"<code>HTTP_API_PORT</code>","text":"<ul> <li>Port where the HTTP API listens.</li> <li>Optional. Defaults to <code>8080</code>.</li> <li>Format: <code>integer</code>.</li> </ul>"},{"location":"limitador/doc/server/configuration/#limits_file","title":"<code>LIMITS_FILE</code>","text":"<ul> <li>YAML file that contains the limits to create when Limitador boots. If the limits specified already have counters associated, Limitador will not delete them. Changes to the file will be picked up by the running server.</li> <li>Required. No default</li> <li>Format: <code>string</code>, file path.</li> </ul>"},{"location":"limitador/doc/server/configuration/#limit_name_in_prometheus_labels","title":"<code>LIMIT_NAME_IN_PROMETHEUS_LABELS</code>","text":"<ul> <li>Enables using limit names as labels in Prometheus metrics. This is disabled by default because for a few limits it should be fine, but it could become a problem when defining lots of limits. See the caution note in the Prometheus docs</li> <li>Optional. Disabled by default.</li> <li>Format: <code>bool</code>, set to <code>\"1\"</code> to enable.</li> </ul>"},{"location":"limitador/doc/server/configuration/#tracing_endpoint","title":"<code>TRACING_ENDPOINT</code>","text":"<ul> <li>The endpoint of the OTLP tracing collector (scheme://host:port).</li> <li>Optional. Default to <code>\"\"</code> (tracing disabled)</li> <li>Format: <code>string</code></li> </ul>"},{"location":"limitador/doc/server/configuration/#redis_local_cache_enabled","title":"<code>REDIS_LOCAL_CACHE_ENABLED</code>","text":"<ul> <li>Enables a storage implementation that uses Redis, but also caches some data in memory. The idea is to improve throughput and latencies by caching the counters in memory to reduce the number of accesses to Redis. To achieve that, this mode sacrifices some rate-limit accuracy. This mode does two things:<ul> <li>Batches counter updates. Instead of updating the counters on every request, it updates them in memory and commits them to Redis in batches. The flushing interval can be configured with the <code>REDIS_LOCAL_CACHE_FLUSHING_PERIOD_MS</code> env. The trade-off is that when running several instances of Limitador, other instances will not become aware of the counter updates until they're committed to Redis.</li> <li>Caches counters. Instead of fetching the value of a counter every time it's needed, the value is cached for a configurable period. The trade-off is that when running several instances of Limitador, an instance will not become aware of the counter updates other instances do while the value is cached. When a counter is already at 0 (limit exceeded), it's cached until it expires in Redis. In this case, no matter what other instances do, we know that the quota will not be reestablished until the key expires in Redis, so in this case, rate-limit accuracy is not affected. When a counter has still some quota remaining the situation is different, that's why we can tune for how long it will be cached. The formula is as follows: MIN(ttl_in_redis/<code>REDIS_LOCAL_CACHE_TTL_RATIO_CACHED_COUNTERS</code>, <code>REDIS_LOCAL_CACHE_MAX_TTL_CACHED_COUNTERS_MS</code>). For example, let's image that the current TTL (time remaining until the limit resets) in Redis for a counter is 10 seconds, and we set the ratio to 2, and the max time for 30s. In this case, the counter will be cached for 5s (min(10/2, 30)). During those 5s, Limitador will not fetch the value of that counter from Redis, so it will answer faster, but it will also miss the updates done by other instances, so it can go over the limits in that 5s interval.</li> </ul> </li> <li>Optional. Disabled by default.</li> <li>Format: set to \"1\" to enable.</li> <li>Note: \"REDIS_URL\" needs to be set.</li> </ul>"},{"location":"limitador/doc/server/configuration/#redis_local_cache_flushing_period_ms","title":"<code>REDIS_LOCAL_CACHE_FLUSHING_PERIOD_MS</code>","text":"<ul> <li>Used to configure the maximum flushing period. See <code>REDIS_LOCAL_CACHE_ENABLED</code>. This env only applies when <code>\"REDIS_LOCAL_CACHE_ENABLED\" == 1</code>.</li> <li>Optional. Defaults to <code>1000</code>.</li> <li>Format: <code>integer</code>. Duration in milliseconds.</li> </ul>"},{"location":"limitador/doc/server/configuration/#redis_local_cache_batch_size","title":"<code>REDIS_LOCAL_CACHE_BATCH_SIZE</code>","text":"<ul> <li>Used to configure the maximum number of counters to update in a flush. See <code>REDIS_LOCAL_CACHE_ENABLED</code>. This env only applies when <code>\"REDIS_LOCAL_CACHE_ENABLED\" == 1</code>.</li> <li>Optional. Defaults to <code>100</code>.</li> <li>Format: <code>integer</code>. </li> </ul>"},{"location":"limitador/doc/server/configuration/#redis_url","title":"<code>REDIS_URL</code>","text":"<ul> <li>Redis URL. Required only when you want to use Redis to store the limits.</li> <li>Optional. By default, Limitador stores the limits in memory and does not require Redis.</li> <li>Format: <code>string</code>, URL in the format of <code>\"redis://127.0.0.1:6379\"</code>.</li> </ul>"},{"location":"limitador/doc/server/configuration/#rust_log","title":"<code>RUST_LOG</code>","text":"<ul> <li>Defines the log level.</li> <li>Optional. Defaults to <code>\"error\"</code>.</li> <li>Format: <code>enum</code>: <code>\"debug\"</code>, <code>\"error\"</code>, <code>\"info\"</code>, <code>\"warn\"</code>, or <code>\"trace\"</code>.</li> </ul>"},{"location":"limitador/doc/server/configuration/#rate_limit_headers","title":"<code>RATE_LIMIT_HEADERS</code>","text":"<ul> <li>Enables rate limit response headers. Only supported by the RLS server.</li> <li>Optional. Defaults to <code>\"NONE\"</code>.</li> <li>Must be one of:</li> <li><code>\"NONE\"</code> - Does not add any additional headers to the http response.</li> <li><code>\"DRAFT_VERSION_03\"</code>.  Adds response headers per https://datatracker.ietf.org/doc/id/draft-polli-ratelimit-headers-03.html</li> </ul>"},{"location":"limitador/limitador/","title":"Limitador (library)","text":"<p>An embeddable rate-limiter library supporting in-memory, Redis and disk data stores.</p> <p>For the complete documentation of the crate's API, please refer to docs.rs</p>"},{"location":"limitador/limitador/#features","title":"Features","text":"<ul> <li><code>redis_storage</code>: support for using Redis as the data storage backend.</li> <li><code>disk_storage</code>: support for using RocksDB as a local disk storage backend.</li> <li><code>lenient_conditions</code>: support for the deprecated syntax of <code>Condition</code>s</li> <li><code>default</code>: <code>redis_storage</code>.</li> </ul>"},{"location":"limitador/limitador-server/","title":"Limitador (server)","text":"<p>By default, Limitador starts the HTTP server in <code>localhost:8080</code>, and the grpc service that implements the Envoy Rate Limit protocol in <code>localhost:8081</code>. That can be configured with these ENVs: <code>ENVOY_RLS_HOST</code>, <code>ENVOY_RLS_PORT</code>, <code>HTTP_API_HOST</code>, and <code>HTTP_API_PORT</code>.</p> <p>Or using the command line arguments:</p> <pre><code>Rate Limiting Server\n\nUsage: limitador-server [OPTIONS] &lt;LIMITS_FILE&gt; [STORAGE]\n\nSTORAGES:\n  memory        Counters are held in Limitador (ephemeral)\n  disk          Counters are held on disk (persistent)\n  redis         Uses Redis to store counters\n  redis_cached  Uses Redis to store counters, with an in-memory cache\n\nArguments:\n  &lt;LIMITS_FILE&gt;  The limit file to use\n\nOptions:\n  -b, --rls-ip &lt;ip&gt;\n          The IP to listen on for RLS [default: 0.0.0.0]\n  -p, --rls-port &lt;port&gt;\n          The port to listen on for RLS [default: 8081]\n  -B, --http-ip &lt;http_ip&gt;\n          The IP to listen on for HTTP [default: 0.0.0.0]\n  -P, --http-port &lt;http_port&gt;\n          The port to listen on for HTTP [default: 8080]\n  -l, --limit-name-in-labels\n          Include the Limit Name in prometheus label\n  -v...\n          Sets the level of verbosity\n      --tracing-endpoint &lt;tracing_endpoint&gt;\n          The endpoint for the tracing service\n      --validate\n          Validates the LIMITS_FILE and exits\n  -H, --rate-limit-headers &lt;rate_limit_headers&gt;\n          Enables rate limit response headers [default: NONE] [possible values: NONE, DRAFT_VERSION_03]\n  -h, --help\n          Print help\n  -V, --version\n          Print version\n</code></pre> <p>When using environment variables, these will override the defaults. While environment variable are themselves overridden by the command line arguments provided. See the individual <code>STORAGES</code> help for more options relative to each of the storages.</p> <p>The OpenAPI spec of the HTTP service is here.</p> <p>Limitador has to be started with a YAML file that has some limits defined. There's an example file that allows 10 requests per minute and per <code>user_id</code> when the HTTP method is <code>\"GET\"</code> and 5 when it is a <code>\"POST\"</code>. You can run it with Docker (replace <code>latest</code> with the version you want): <pre><code>docker run --rm --net=host -it -v $(pwd)/examples/limits.yaml:/home/limitador/my_limits.yaml:ro quay.io/kuadrant/limitador:latest limitador-server /home/limitador/my_limits.yaml\n</code></pre></p> <p>You can also use the YAML file when running locally: <pre><code>cargo run --release --bin limitador-server ./examples/limits.yaml\n</code></pre></p> <p>If you want to use Limitador with Envoy, there's a minimal Envoy config for testing purposes here. The config forwards the \"userid\" header and the request method to Limitador. It assumes that there's an upstream API deployed on port 1323. You can use echo, for example.</p> <p>Limitador has several options that can be configured via ENV. This doc specifies them.</p>"},{"location":"limitador/limitador-server/#limits-storage","title":"Limits storage","text":"<p>Limitador can store its limits and counters in-memory, disk or in Redis. In-memory is faster, but the limits are applied per instance. When using Redis, multiple instances of Limitador can share the same limits, but it's slower.</p>"},{"location":"limitador/limitador-server/kubernetes/","title":"Kubernetes","text":"<p>The purpose of this documentation is to deploy a sample application published via AWS ELB, that will be ratelimited at infrastructure level, thanks to the use the envoyproxy sidecar container, that will be in charge of contacting to a  ratelimit service (limitador), that will allow the request (or not) if it is within the permitted  limits.</p> <p>There are mainly two recommended way of using limitador in kubernetes:</p> <ol> <li>There is an ingress based on envoyproxy that contacts with limitador ratelimit service before forwarding (or not) the request to the application</li> <li>There is an envoyproxy sidecar container living in the application pod that contacts with limitador ratelimit service before forwarding (or not) the request to the main application container in the same pod</li> </ol> <p>In this example it will be described the second scenario (where there is an application with an envoyproxy sidecar container contacting to limitador service).</p> <p>NOTE  If you don't want to manually manage the sidecar container definitions on your deployments (harcoding the container spec, loading the envoy configuration from a configmap that requires a pod restart to reload possibles configuration changes...), you can use marin3r, a light weight envoy control plane that allows you to inject envoyproxy sidecar containers and dynamically consume configs from Kubernetes custom resources.</p> <p>This is the network diagram of the deployed example:</p> <p></p>"},{"location":"limitador/limitador-server/kubernetes/#components","title":"Components","text":"<p>In order to that that ratelimit test, you need to deploy a few components. Some of them are mandatory, and a few are optional:</p>"},{"location":"limitador/limitador-server/kubernetes/#mandatory","title":"Mandatory","text":"<ul> <li>Application (a sample application deployment called <code>kuard</code>):</li> <li>App has an <code>envoyproxy</code> sidecar container with its configuration file in a configmap, composed by:<ul> <li>Cluster <code>kuard</code> points to main application container (<code>127.0.0.1:8080</code>)</li> <li>Cluster <code>kuard_ratelimit</code> points to limitador headless service (<code>limitador:8081</code>)</li> <li>Listener HTTP points to envoyproxy sidecar (<code>0.0.0.0:38080</code>)</li> <li>When envoy contacts with the ratelimit service, you can define a timeout, and if there is no response within that timeout (because ratelimit is overloaded taking more time to process the request, or because rateliit service is down), you can choose from envoy to deny the request or pass it to the application. In this case, there is set a 1s timeout, and if there is no answer in this 1 second, request is passed to the application (<code>failure_mode_deny: false</code>), so we guarantee that the maximum overhead added by a non working ratelimit service is 1 extra second to the final response time.</li> </ul> </li> <li> <p>App service published with <code>type: LoadBalancer</code>, which creates a AWS ELB. This service has an annotation to enable proxy protocol on the AWS Load balancer in order to be able to keep the real client IP at envoy level (instead of the k8s node private IP), so it can be used to ratelimit per each real client IP if desired.</p> </li> <li> <p>Ratelimit application (a deployment called <code>limitador</code>):</p> </li> <li>Limitador Configmap with limits definition (1000 rps per hostname).</li> <li> <p>Limitador headless service published on <code>limitador:8081</code>. It is important to use a headless service in order to balance correctly the traffic between limitador pods, otherwise GRPC connections are not well balanced.</p> </li> <li> <p>Redis database to persist ratelimit configuration:</p> </li> <li>Redis service</li> <li>Redis statefulset with a persistent volume</li> </ul>"},{"location":"limitador/limitador-server/kubernetes/#optional","title":"Optional","text":"<ul> <li>Centos pod:</li> <li>Used to executed <code>hey</code> tool benchmarks from the cluster, so we ensure network latency does not affect the results. Actually, to achieve better results, this pod should be on another cluster (to not share the network between client and network) and be placed on the same Region (to reduce latency). The client could be a bottle neck for the performance test.</li> <li>This centos is going to public AWS ELB to access the app, so simulating it is a normal client from the same Region</li> <li>Prometheus monitoring and grafana dashboard resources</li> </ul>"},{"location":"limitador/limitador-server/kubernetes/#k8s-deployment","title":"K8s deployment","text":"<ul> <li> <p>Deploy the redis instance that will keep the limits for different limitador pods: <pre><code>kubectl apply -f redis-service.yaml\nkubectl apply -f redis-statefulset.yaml\n</code></pre></p> </li> <li> <p>Deploy limitador application. It is important to create the configmap with limitador limits before the deployment, in order to load it from limitador pods. At the moment, if you update the limits configmap you need to restart the pods. Additionally, limitador has an API in order to load limits dynamically, but for simplicity for this test a configmap has been used: <pre><code>kubectl apply -f limitador-config-configmap.yaml\nkubectl apply -f limitador-service.yaml\nkubectl apply -f limitador-deployment.yaml\n</code></pre></p> </li> <li> <p>Deploy sample kuard application with the envoyproxy sidecar container (if you do any change on the envoy configmap, remember you need to restart app pods in order to reload the config): <pre><code>kubectl apply -f kuard-envoy-config-configmap.yaml\nkubectl apply -f kuard-service.yaml\nkubectl apply -f kuard-deployment.yaml\n</code></pre></p> </li> <li> <p>At this point you shoud see all pods running, and kuard pods should have 2 containers (the main  kuard container, and the envoyproxy sidecar container): <pre><code>\u25b6 kubectl get pods\nNAME                         READY   STATUS    RESTARTS   AGE\nkuard-f859bb896-gmzxn        2/2     Running   0          7m\nkuard-f859bb896-z95w8        2/2     Running   0          7m\nlimitador-68d494f54c-qv996   1/1     Running   0          8m\nlimitador-68d494f54c-zzmhn   1/1     Running   0          8m\nredis-0                      1/1     Running   0          9m\n</code></pre></p> </li> <li> <p>Now you should be able to access to kuard application using the load balancer DNS name: <pre><code>\u25b6 kubectl get service kuard\nNAME    TYPE           CLUSTER-IP       EXTERNAL-IP                                                              PORT(S)        AGE\nkuard   LoadBalancer   172.30.117.198   a96d5449fbc3f4cd892e15e5b36cde48-457963259.us-east-1.elb.amazonaws.com   80:31450/TCP   4m\n</code></pre></p> </li> <li> <p>If you go to the browser and paste the <code>EXTERNAL-IP</code>, your request will follow the next workflow:</p> </li> <li>The requests will go from your local machine through internet to the public AWS ELB where the app is published</li> <li>Then it will go to the <code>NodePort</code> of your k8s cluster nodes</li> <li>Once on a k8s node, it will go to kuard <code>Service</code> Virtual IP, and will arrive to an envoyproxy sidecar container inside kuard pod</li> <li>Envoyproxy sidecar container will contact with limitador headless <code>Service</code>, to authorize the requests or not:<ul> <li>If the request is authorized (within the configured limits), it will send the request to the app container (<code>0.0.0.0:8080</code>) in the same pod, and request will end up with a <code>HTTP 200</code> response</li> <li>If the request is limited (beyond the limits), request will end up with <code>HTTP 429</code> response</li> </ul> </li> </ul>"},{"location":"limitador/limitador-server/kubernetes/#monitoring","title":"Monitoring","text":"<p>Both <code>envoyproxy</code> sidecar and <code>limitador</code> applications include built-in prometheus metrics.</p>"},{"location":"limitador/limitador-server/kubernetes/#prometheus","title":"Prometheus","text":"<p>In order to scrape that metrics within a prometheus-operator deployed in the cluster, you need to create a <code>PodMonitor</code> resource for every application: <pre><code>kubectl apply -f kuard-podmonitor.yaml\nkubectl apply -f limitador-podmonitor.yaml\n</code></pre></p>"},{"location":"limitador/limitador-server/kubernetes/#grafana-dashboard","title":"Grafana dashboard","text":"<p>Then, if you have grafana deployed in the cluster, you can import a Kuadrant Limitador grafana dashboard that we have prepared, which includes:</p> <ul> <li>Kuard envoyproxy sidecar metrics (globally and per pod)</li> <li>Limitador metrics (globally and per pod)</li> <li>And for every deployed component (limitador, kuard, redis):</li> <li>Number of pods (total, available, unavaible, pod restarts...)</li> <li>CPU usage per pod</li> <li>Memory usage per pod</li> <li>Network usage per pod</li> </ul>"},{"location":"limitador/limitador-server/kubernetes/#benchmarking","title":"Benchmarking","text":"<ul> <li>In order to check that the ratelimit is working as expected, you can use any benchmarking tool, like hey</li> <li>You can use if you want a centos pod (better to create it on a different custer within the same Region): <pre><code>kubectl apply -f centos-pod.yaml\n</code></pre></li> <li>Connect to centos pod: <pre><code>kubectl exec --stdin --tty centos -- /bin/bash\n</code></pre></li> <li>And install <code>hey</code> with: <pre><code>[root@centos /]# curl -sf https://gobinaries.com/rakyll/hey | sh\n</code></pre></li> <li>Now you can execute the benchmark using the following escenario:</li> </ul> Item Value Target AWS ELB DNS Name App pods 2 Limitador pods 2 Limits 1.000 rps per hostname Hey duration 1 minute Hey Traffic -c 60 -q 20 (around 1.200 rps) <ul> <li>Theoretically:</li> <li>It should let pass 1.000 requests, and limit 200 requests per second</li> <li>It should let pass 60 * 1.000 = 60.0000 requests, and limit 60 * 200 = 12.000 requests per minute</li> <li>Each limitador pod should handle half of the traffic (500 rps OK, and 200 rps limited)</li> </ul> <pre><code>[root@centos /]# hey -z 60s -c 60 -q 20 \"http://a96d5449fbc3f4cd892e15e5b36cde48-457963259.us-east-1.elb.amazonaws.com\"\n\nSummary:\n  Total:    60.0131 secs\n  Slowest:  0.1028 secs\n  Fastest:  0.0023 secs\n  Average:  0.0075 secs\n  Requests/sec: 1199.3721\n\n  Total data:   106581650 bytes\n  Size/request: 1480 bytes\n\nResponse time histogram:\n  0.002 [1] |\n  0.012 [70626] |\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\n  0.022 [1291]  |\u25a0\n  0.032 [0] |\n  0.043 [0] |\n  0.053 [0] |\n  0.063 [0] |\n  0.073 [0] |\n  0.083 [0] |\n  0.093 [23]    |\n  0.103 [37]    |\n\n\nLatency distribution:\n  10% in 0.0053 secs\n  25% in 0.0063 secs\n  50% in 0.0073 secs\n  75% in 0.0085 secs\n  90% in 0.0096 secs\n  95% in 0.0102 secs\n  99% in 0.0139 secs\n\nDetails (average, fastest, slowest):\n  DNS+dialup:   0.0001 secs, 0.0023 secs, 0.1028 secs\n  DNS-lookup:   0.0001 secs, 0.0000 secs, 0.0711 secs\n  req write:    0.0000 secs, 0.0000 secs, 0.0014 secs\n  resp wait:    0.0074 secs, 0.0023 secs, 0.0303 secs\n  resp read:    0.0000 secs, 0.0000 secs, 0.0049 secs\n\nStatus code distribution:\n  [200] 60046 responses\n  [429] 11932 responses\n</code></pre> <ul> <li> <p>We can see that:</p> <ul> <li>Client could send 1192.2171rps (about 1200rps)</li> <li>60046 requests (about 60000) were OK (HTTP 200)</li> <li>11932 requests (about 12000) were limited (HTTP 429)</li> <li>Average latency (since the request goes out from the client to AWS ELB, k8s node, envoyproxy container, limitador+redis, kuar app container) is 10ms</li> </ul> </li> <li> <p>In addition, if we do a longer test with 5 minutes traffic for example, you can check with the grafana dashboard how these requests are processed by envoyproxy sidecar container of kuard pods and limitador pods:</p> <ul> <li>Kuard Envoyproxy Sidecar Metrics:<ul> <li>Globally it handles around 1200rps: it permits around 1krps and limits around 200rps  </li> <li>Each envoyproxy sidecar of each kuard pod handles around half of the traffic: it permits around 500rps and limits around 100rps. The balance between pods is not 100% perfect, caused by random iptables forwarding when using a k8s service  </li> </ul> </li> <li>Limitador Metrics:<ul> <li>Globally it handles around 1200rps: it permits around 1krps and limits around 200rps  </li> <li>Each limitador pod handles around half of the traffic: it permits around 500rps and limits around 100rps. The balance between pods is perfect thanks to using a headless service with GRPC connections  </li> </ul> </li> </ul> </li> </ul>"},{"location":"limitador/limitador-server/sandbox/","title":"Sandbox","text":""},{"location":"limitador/limitador-server/sandbox/#testing-environment","title":"Testing Environment","text":""},{"location":"limitador/limitador-server/sandbox/#requirements","title":"Requirements","text":"<ul> <li>docker v24+</li> </ul>"},{"location":"limitador/limitador-server/sandbox/#setup","title":"Setup","text":"<p>Clone the project</p> <pre><code>git clone https://github.com/Kuadrant/limitador.git\ncd limitador/limitador-server/sandbox\n</code></pre> <p>Check out <code>make help</code> for all the targets.</p>"},{"location":"limitador/limitador-server/sandbox/#deployment-options","title":"Deployment options","text":"Limitador's configuration Command Info In-memory configuration <code>make deploy-in-memory</code> Counters are held in Limitador (ephemeral) Redis <code>make deploy-redis</code> Uses Redis to store counters Redis Secured <code>make deploy-redis-tls</code> Uses Redis with TLS and password protected to store counters Redis Cached <code>make deploy-redis-cached</code> Uses Redis to store counters, with an in-memory cache Redis Otel Instrumented <code>make deploy-redis-otel</code> Uses redis to store counters, instrumented with opentelemetry Disk <code>make deploy-disk</code> Uses disk to store counters Distributed <code>make deploy-distributed</code> Counters are held in Limitador (ephemeral) but replicated to other Limitador servers. <p>| Distributed 3 Node | <code>make deploy-distributed-3-node</code> | Counters are held in Limitador (ephemeral) but replicated to 3 other Limitador servers. |</p>"},{"location":"limitador/limitador-server/sandbox/#running-multi-node-distributed-deployments","title":"Running Multi Node Distributed Deployments","text":"<p>The <code>make deploy-distributed</code> target can be connected to other Limitador servers but requires you to set the <code>PEER_ID</code> and <code>PEER_URLS</code> environment variables when you run the target.</p> <p>If you have 3 servers you want to replicate between, you would run the following commands:</p> <pre><code># on server where: hostname=server1\nPEER_ID=`hostname` PEER_URLS=\"http://server2:15001 http://server3:15001\" make deploy-distributed\n</code></pre> <pre><code># on server where: hostname=server2\nPEER_ID=`hostname` PEER_URLS=\"http://server1:15001 http://server3:15001\" make deploy-distributed\n</code></pre> <pre><code># on server where: hostname=server3\nPEER_ID=`hostname` PEER_URLS=\"http://server1:15001 http://server2:15001\" make deploy-distributed\n</code></pre> <p>The <code>PEER_ID</code> just need to be unique between the servers, and the <code>PEER_URLS</code> should be a space-separated list of the other servers' URLs.</p>"},{"location":"limitador/limitador-server/sandbox/#limitadors-admin-http-endpoint","title":"Limitador's admin HTTP endpoint","text":"<p>Limits</p> <pre><code>curl -i http://127.0.0.1:18080/limits/test_namespace\n</code></pre> <p>Counters</p> <pre><code>curl -i http://127.0.0.1:18080/counters/test_namespace\n</code></pre> <p>Metrics</p> <pre><code>curl -i http://127.0.0.1:18080/metrics\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/#limitadors-grpc-ratelimitservice-endpoint","title":"Limitador's GRPC RateLimitService endpoint","text":"<p>Get <code>grpcurl</code>. You need Go SDK installed.</p> <p>Golang version &gt;= 1.18 (from fullstorydev/grpcurl)</p> <pre><code>make grpcurl\n</code></pre> <p>Inspect <code>RateLimitService</code> GRPC service</p> <pre><code>bin/grpcurl -plaintext 127.0.0.1:18081 describe envoy.service.ratelimit.v3.RateLimitService\n</code></pre> <p>Make a custom request</p> <pre><code>bin/grpcurl -plaintext -d @ 127.0.0.1:18081 envoy.service.ratelimit.v3.RateLimitService.ShouldRateLimit &lt;&lt;EOM\n{\n    \"domain\": \"test_namespace\",\n    \"hits_addend\": 1,\n    \"descriptors\": [\n        {\n            \"entries\": [\n                {\n                    \"key\": \"req.method\",\n                    \"value\": \"POST\"\n                },\n                {\n                    \"key\": \"req.path\",\n                    \"value\": \"/\"\n                }\n            ]\n        }\n    ]\n}\nEOM\n</code></pre> <p>Do repeated requests. As the limit is set to max 5 request for 60 seconds, you should see <code>OVER_LIMIT</code> response after 5 requests.</p> <pre><code>while :; do bin/grpcurl -plaintext -d @ 127.0.0.1:18081 envoy.service.ratelimit.v3.RateLimitService.ShouldRateLimit &lt;&lt;EOM; sleep 1; done\n{\n    \"domain\": \"test_namespace\",\n    \"hits_addend\": 1,\n    \"descriptors\": [\n        {\n            \"entries\": [\n                {\n                    \"key\": \"req.method\",\n                    \"value\": \"POST\"\n                },\n                {\n                    \"key\": \"req.path\",\n                    \"value\": \"/\"\n                }\n            ]\n        }\n    ]\n}\nEOM\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/#downstream-traffic","title":"Downstream traffic","text":"<p>Upstream service implemented by httpbin.org</p> <pre><code>curl -i -H \"Host: example.com\" http://127.0.0.1:18000/get\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/#load-testing-the-grpc-ratelimitservice-directly","title":"Load Testing the GRPC RateLimitService directly","text":"<p>This load test will use <code>grpcurl</code>. You need Go SDK installed.</p> <p>Run a load test a 5000 requests per second (RPS) for 10 seconds:</p> <pre><code>RPS=5000 make load-test\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/#load-testing-via-envoy-proxy","title":"Load Testing via Envoy Proxy","text":"<pre><code>cargo run --manifest-path loadtest/Cargo.toml  --package loadtest --release -- --report-file=report.htm\n</code></pre> <p>The report will be saved in <code>report.htm</code> file.</p>"},{"location":"limitador/limitador-server/sandbox/#limitador-image","title":"Limitador Image","text":"<p>By default, the sandbox will run Limitador's <code>limitador-testing:latest</code> image.</p> <p>Building <code>limitador-testing:latest</code> image</p> <p>You can easily build the limitador's image from the current workspace code base with:</p> <pre><code>make build\n</code></pre> <p>The image will be tagged with <code>limitador-testing:latest</code></p> <p>Using custom Limitador's image</p> <p>The <code>LIMITADOR_IMAGE</code> environment variable overrides the default image. For example:</p> <pre><code>make deploy-in-memory LIMITADOR_IMAGE=quay.io/kuadrant/limitador:latest\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/#clean-env","title":"Clean env","text":"<pre><code>make clean\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/redis-otel/","title":"Limitador instrumentation sandbox","text":"<p>Limitador is configured to push traces to an opentelemetry collector.</p>"},{"location":"limitador/limitador-server/sandbox/redis-otel/#run-sandbox","title":"Run sandbox","text":"<pre><code>make build\nmake deploy-redis-otel\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/redis-otel/#run-some-traffic","title":"Run some traffic","text":"<pre><code>make grpcurl\n</code></pre> <pre><code>bin/grpcurl -plaintext -d @ 127.0.0.1:18081 envoy.service.ratelimit.v3.RateLimitService.ShouldRateLimit &lt;&lt;EOM\n{\n    \"domain\": \"test_namespace\",\n    \"hits_addend\": 1,\n    \"descriptors\": [\n        {\n            \"entries\": [\n                {\n                    \"key\": \"req.method\",\n                    \"value\": \"POST\"\n                }\n            ]\n        }\n    ]\n}\nEOM\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/redis-otel/#see-the-trace-in-ui","title":"See the trace in UI","text":"<pre><code>firefox -private-window \"localhost:16686\"\n</code></pre> <p>Recommended to start looking at <code>check_and_update</code> operation.</p>"},{"location":"limitador/limitador-server/sandbox/redis-otel/#tear-down-sandbox","title":"Tear down sandbox","text":"<pre><code>make clean\n</code></pre>"},{"location":"limitador/limitador-server/sandbox/redis-tls/","title":"Index","text":""},{"location":"limitador/limitador-server/sandbox/redis-tls/#testing-redis-security","title":"Testing  redis security","text":"<p>Execute bash shell in redis pod</p> <pre><code>docker compose -p sandbox exec redis /bin/bash\n</code></pre> <p>Connect to this Redis server with redis-cli:</p> <pre><code>root@e024a29b74ba:/data# redis-cli --tls --cacert /usr/local/etc/redis/certs/ca.crt -a foobared\n</code></pre>"},{"location":"limitador-operator/","title":"Limitador Operator","text":""},{"location":"limitador-operator/#overview","title":"Overview","text":"<p>The Operator to manage Limitador deployments.</p>"},{"location":"limitador-operator/#customresourcedefinitions","title":"CustomResourceDefinitions","text":"<ul> <li>Limitador, which defines a desired Limitador deployment.</li> </ul>"},{"location":"limitador-operator/#limitador-crd","title":"Limitador CRD","text":"<p>Limitador v1alpha1 API reference</p> <p>Example:</p> <pre><code>---\napiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  listener:\n    http:\n      port: 8080\n    grpc:\n      port: 8081\n  limits:\n\n    - conditions: [\"get_toy == 'yes'\"]\n      max_value: 2\n      namespace: toystore-app\n      seconds: 30\n      variables: []\n</code></pre>"},{"location":"limitador-operator/#features","title":"Features","text":"<ul> <li>Storage Options</li> <li>Rate Limit Headers</li> <li>Logging</li> <li>Tracing</li> <li>Custom Image</li> </ul>"},{"location":"limitador-operator/#contributing","title":"Contributing","text":"<p>The Development guide describes how to build the operator and how to test your changes before submitting a patch or opening a PR.</p> <p>Join us on the #kuadrant channel in the Kubernetes Slack workspace,  for live discussions about the roadmap and more.</p>"},{"location":"limitador-operator/#licensing","title":"Licensing","text":"<p>This software is licensed under the Apache 2.0 license.</p> <p>See the LICENSE and NOTICE files that should have been provided along with this software for details.</p> <p></p>"},{"location":"limitador-operator/doc/custom-image/","title":"Custom Image","text":"<p>Currently, the limitador image being used in the deployment is read from different sources with some order of precedence:</p> <ul> <li>If Limtador CR's <code>spec.image</code> is set -&gt; image = <code>${spec.image}</code></li> <li>If Limtador CR's <code>spec.version</code> is set -&gt; image = <code>quay.io/kuadrant/limitador:${spec.version}</code> (note the repo is hardcoded)</li> <li>if <code>RELATED_IMAGE_LIMITADOR</code> env var is set -&gt; image = <code>$RELATED_IMAGE_LIMITADOR</code></li> <li>else: hardcoded to <code>quay.io/kuadrant/limitador:latest</code></li> </ul> <p>The <code>spec.image</code> field is not meant to be used in production environments. It is meant to be used for dev/testing purposes. The main drawback of the <code>spec.image</code> usage is that upgrades cannot be supported as the limitador operator cannot ensure the operation to be safe.</p> <pre><code>---\napiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-instance-1\nspec:\n  image: example.com/myorg/limitador-repo:custom-image-v1\nEOF\n</code></pre>"},{"location":"limitador-operator/doc/custom-image/#pull-an-image-from-a-private-registry","title":"Pull an Image from a Private Registry","text":"<p>To pull an image from a private container image registry or repository, you need to provide credentials.</p> <p>Create a Secret of type <code>kubernetes.io/dockerconfigjson</code> by providing credentials. For example, using <code>kubectl</code> tool with the following command line:</p> <pre><code>kubectl create secret docker-registry regcred --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt;\n</code></pre> <p>That will create a secret named <code>regcred</code>.</p> <p>Deploy limitador instance with the <code>imagePullSecrets</code> field having a reference to the <code>regcred</code>.</p> <pre><code>---\napiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-instance-1\nspec:\n  image: example.com/myorg/limitador-repo:custom-image-v1\n  imagePullSecrets:\n\n  - name: regcred\n</code></pre> <p>NOTE: It is mandatory that the secret and limitador CR are created in the same namespace.</p>"},{"location":"limitador-operator/doc/development/","title":"Development Guide","text":""},{"location":"limitador-operator/doc/development/#technology-stack-required-for-development","title":"Technology stack required for development","text":"<ul> <li>operator-sdk version 1.32.0</li> <li>kind version v0.22.0</li> <li>git</li> <li>go version 1.21+</li> <li>kubernetes version v1.25+</li> <li>kubectl version v1.25+</li> </ul>"},{"location":"limitador-operator/doc/development/#build","title":"Build","text":"<pre><code>make\n</code></pre>"},{"location":"limitador-operator/doc/development/#run-locally","title":"Run locally","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Optionally, run kind with <code>local-env-setup</code>.</p> <pre><code>make local-env-setup\n</code></pre> <p>Then, run the operator locally</p> <pre><code>make run\n</code></pre>"},{"location":"limitador-operator/doc/development/#deploy-the-operator-in-a-deployment-object","title":"Deploy the operator in a deployment object","text":"<pre><code>make local-setup\n</code></pre>"},{"location":"limitador-operator/doc/development/#deploy-the-operator-using-olm","title":"Deploy the operator using OLM","text":"<p>You can deploy the operator using OLM just running a few commands. No need to build any image. Kuadrant engineering team provides <code>latest</code> and released version tagged images. They are available in the Quay.io/Kuadrant image repository.</p> <p>Create kind cluster</p> <pre><code>make kind-create-cluster\n</code></pre> <p>Deploy OLM system</p> <pre><code>make install-olm\n</code></pre> <p>Deploy the operator using OLM. The <code>make deploy-catalog</code> target accepts the following variables:</p> Makefile Variable Description Default value <code>CATALOG_IMG</code> Catalog image URL <code>quay.io/kuadrant/limitador-operator-catalog:latest</code> <pre><code>make deploy-catalog [CATALOG_IMG=quay.io/kuadrant/limitador-operator-catalog:latest]\n</code></pre>"},{"location":"limitador-operator/doc/development/#build-custom-olm-catalog","title":"Build custom OLM catalog","text":"<p>If you want to deploy (using OLM) a custom limitador operator, you need to build your own catalog.</p>"},{"location":"limitador-operator/doc/development/#build-operator-bundle-image","title":"Build operator bundle image","text":"<p>The <code>make bundle</code> target accepts the following variables:</p> Makefile Variable Description Default value Notes <code>IMG</code> Operator image URL <code>quay.io/kuadrant/limitador-operator:latest</code> <code>VERSION</code> Bundle version <code>0.0.0</code> <code>RELATED_IMAGE_LIMITADOR</code> Limitador bundle URL <code>quay.io/kuadrant/limitador:latest</code> <code>LIMITADOR_VERSION</code> var could be use to build this URL providing the tag <code>CHANNELS</code> Bundle channels used in the bundle, comma separated <code>alpha</code> <code>DEFAULT_CHANNEL</code> The default channel used in the bundle <code>alpha</code> <ul> <li>Build the bundle manifests</li> </ul> <pre><code>make bundle [IMG=quay.io/kuadrant/limitador-operator:latest] \\\n            [VERSION=0.0.0] \\\n            [RELATED_IMAGE_LIMITADOR=quay.io/kuadrant/limitador:latest] \\\n            [CHANNELS=alpha] \\\n            [DEFAULT_CHANNEL=alpha]\n</code></pre> <ul> <li>Build the bundle image from the manifests</li> </ul> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Operator bundle image URL <code>quay.io/kuadrant/limitador-operator-bundle:latest</code> <pre><code>make bundle-build [BUNDLE_IMG=quay.io/kuadrant/limitador-operator-bundle:latest]\n</code></pre> <ul> <li>Push the bundle image to a registry</li> </ul> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Operator bundle image URL <code>quay.io/kuadrant/limitador-operator-bundle:latest</code> <pre><code>make bundle-push [BUNDLE_IMG=quay.io/kuadrant/limitador-operator-bundle:latest]\n</code></pre>"},{"location":"limitador-operator/doc/development/#build-custom-catalog","title":"Build custom catalog","text":"<p>The catalog format will be File-based Catalog.</p> <p>Make sure all the required bundles are pushed to the registry. It is required by the <code>opm</code> tool.</p> <p>The <code>make catalog</code> target accepts the following variables:</p> Makefile Variable Description Default value <code>BUNDLE_IMG</code> Operator bundle image URL <code>quay.io/kuadrant/limitador-operator-bundle:latest</code> <code>DEFAULT_CHANNEL</code> Catalog default channel <code>alpha</code> <pre><code>make catalog [BUNDLE_IMG=quay.io/kuadrant/limitador-operator-bundle:latest] [DEFAULT_CHANNEL=alpha]\n</code></pre> <ul> <li>Build the catalog image from the manifests</li> </ul> Makefile Variable Description Default value <code>CATALOG_IMG</code> Operator catalog image URL <code>quay.io/kuadrant/limitador-operator-catalog:latest</code> <pre><code>make catalog-build [CATALOG_IMG=quay.io/kuadrant/limitador-operator-catalog:latest]\n</code></pre> <ul> <li>Push the catalog image to a registry</li> </ul> <pre><code>make catalog-push [CATALOG_IMG=quay.io/kuadrant/limitador-operator-bundle:latest]\n</code></pre> <p>You can try out your custom catalog image following the steps of the Deploy the operator using OLM section.</p>"},{"location":"limitador-operator/doc/development/#cleaning-up","title":"Cleaning up","text":"<pre><code>make local-cleanup\n</code></pre>"},{"location":"limitador-operator/doc/development/#run-tests","title":"Run tests","text":""},{"location":"limitador-operator/doc/development/#unittests","title":"Unittests","text":"<pre><code>make test-unit\n</code></pre> <p>Optionally, add <code>TEST_NAME</code> makefile variable to run specific test</p> <pre><code>make test-unit TEST_NAME=TestConstants\n</code></pre> <p>or even subtest</p> <pre><code>make test-unit TEST_NAME=TestLimitIndexEquals/empty_indexes_are_equal\n</code></pre>"},{"location":"limitador-operator/doc/development/#integration-tests","title":"Integration tests","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Optionally, run local cluster with kind</p> <pre><code>make local-env-setup\n</code></pre> <p>Run integration tests</p> <pre><code>make test-integration\n</code></pre>"},{"location":"limitador-operator/doc/development/#all-tests","title":"All tests","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Optionally, run local cluster with kind</p> <pre><code>make local-env-setup\n</code></pre> <p>Run all tests</p> <pre><code>make test\n</code></pre>"},{"location":"limitador-operator/doc/development/#lint-tests","title":"Lint tests","text":"<pre><code>make run-lint\n</code></pre>"},{"location":"limitador-operator/doc/development/#uninstall-limitador-crd","title":"(Un)Install Limitador CRD","text":"<p>You need an active session open to a kubernetes cluster.</p> <p>Remove CRDs</p> <pre><code>make uninstall\n</code></pre>"},{"location":"limitador-operator/doc/logging/","title":"Logging","text":"<p>The limitador operator outputs 3 levels of log messages: (from lowest to highest level)</p> <ol> <li><code>debug</code></li> <li><code>info</code> (default)</li> <li><code>error</code></li> </ol> <p><code>info</code> logging is restricted to high-level information. Actions like creating, deleting or updating kubernetes resources will be logged with reduced details about the corresponding objects, and without any further detailed logs of the steps in between, except for errors.</p> <p>Only <code>debug</code> logging will include processing details.</p> <p>To configure the desired log level, set the environment variable <code>LOG_LEVEL</code> to one of the supported values listed above. Default log level is <code>info</code>.</p> <p>Apart from log level, the controller can output messages to the logs in 2 different formats:</p> <ul> <li><code>production</code> (default): each line is a parseable JSON object with properties <code>{\"level\":string, \"ts\":int, \"msg\":string, \"logger\":string, extra values...}</code></li> <li><code>development</code>: more human-readable outputs, extra stack traces and logging info, plus extra values output as JSON, in the format: <code>&lt;timestamp-iso-8601&gt;\\t&lt;log-level&gt;\\t&lt;logger&gt;\\t&lt;message&gt;\\t{extra-values-as-json}</code></li> </ul> <p>To configure the desired log mode, set the environment variable <code>LOG_MODE</code> to one of the supported values listed above. Default log mode is <code>production</code>.</p>"},{"location":"limitador-operator/doc/rate-limit-headers/","title":"Rate Limit Headers","text":"<p>It enables RateLimit Header Fields for HTTP as specified in Rate Limit Headers Draft</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  rateLimitHeaders: DRAFT_VERSION_03\n</code></pre> <p>Current valid values are:</p> <ul> <li>DRAFT_VERSION_03 (ref:  Rate Limit Headers Draft)</li> <li>NONE</li> </ul> <p>By default, when <code>spec.rateLimitHeaders</code> is null, <code>--rate-limit-headers</code> command line arg is not included in the limitador's deployment.</p>"},{"location":"limitador-operator/doc/resource-requirements/","title":"Resource Requirements","text":"<p>The default resource requirement for Limitador deployments is specified in Limitador v1alpha1 API reference and will be applied if the resource requirement is not set in the spec.</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  listener:\n    http:\n      port: 8080\n    grpc:\n      port: 8081\n  limits:\n\n    - conditions: [\"get_toy == 'yes'\"]\n      max_value: 2\n      namespace: toystore-app\n      seconds: 30\n      variables: []  \n</code></pre> Field json/yaml field Type Required Default value Description ResourceRequirements <code>resourceRequirements</code> *corev1.ResourceRequirements No <code>{\"limits\": {\"cpu\": \"500m\",\"memory\": \"64Mi\"},\"requests\": {\"cpu\": \"250m\",\"memory\": \"32Mi\"}}</code> Limitador deployment resource requirements"},{"location":"limitador-operator/doc/resource-requirements/#example-with-resource-limits","title":"Example with resource limits","text":"<p>The resource requests and limits for the deployment can be set like the following:</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  listener:\n    http:\n      port: 8080\n    grpc:\n      port: 8081\n  limits:\n\n    - conditions: [\"get_toy == 'yes'\"]\n      max_value: 2\n      namespace: toystore-app\n      seconds: 30\n      variables: []\n  resourceRequirements:\n    limits:\n      cpu: 200m\n      memory: 400Mi\n    requests:\n      cpu: 101m  \n      memory: 201Mi    \n</code></pre> <p>To specify the deployment without resource requests or limits, set an empty struct <code>{}</code> to the field: <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  listener:\n    http:\n      port: 8080\n    grpc:\n      port: 8081\n  limits:\n\n    - conditions: [ \"get_toy == 'yes'\" ]\n      max_value: 2\n      namespace: toystore-app\n      seconds: 30\n      variables: []\n  resourceRequirements: {}\n</code></pre></p>"},{"location":"limitador-operator/doc/storage/","title":"Storage","text":"<p>Limitador limits counters are stored in a backend storage. This is In contrast to the storage of the limits themselves, which are always stored in ephemeral memory. Limitador's operator supports several storage configurations:</p> <ul> <li>In-Memory: ephemeral and cannot be shared</li> <li>Redis: Persistent (depending on the redis storage configuration) and can be shared</li> <li>Redis Cached: Persistent (depending on the redis storage configuration) and can be shared</li> <li>Disk: Persistent (depending on the underlying disk persistence capabilities) and cannot be shared</li> </ul>"},{"location":"limitador-operator/doc/storage/#in-memory","title":"In-Memory","text":"<p>Counters are held in Limitador (ephemeral)</p> <p>In-Memory is the default option defined by the Limitador's Operator.</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  storage: null\n</code></pre> <p>For any of those, one should store the URL of the Redis service, inside a K8s opaque Secret.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: redisconfig\nstringData:\n  URL: redis://127.0.0.1/a # Redis URL of its running instance\ntype: Opaque\n</code></pre>"},{"location":"limitador-operator/doc/storage/#redis","title":"Redis","text":"<p>Uses Redis to store counters.</p> <p>Selected when <code>spec.storage.redis</code> is not <code>null</code>.</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  storage:\n    redis:\n      configSecretRef: # The secret reference storing the URL for Redis\n        name: redisconfig\n</code></pre> <p>The URL of the Redis service is provided inside a K8s opaque Secret. The secret is required to be in the same namespace as the <code>Limitador</code> CR.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: redisconfig\nstringData:\n  URL: redis://127.0.0.1/a # Redis URL of its running instance\ntype: Opaque\n</code></pre> <p>Note: Limitador's Operator will only read the <code>URL</code> field of the secret.</p>"},{"location":"limitador-operator/doc/storage/#redis-cached","title":"Redis Cached","text":"<p>Uses Redis to store counters, with an in-memory cache.</p> <p>Selected when <code>spec.storage.redis-cached</code> is not <code>null</code>.</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  storage:\n    redis-cached:\n      configSecretRef: # The secret reference storing the URL for Redis\n        name: redisconfig\n</code></pre> <p>The URL of the Redis service is provided inside a K8s opaque Secret. The secret is required to be in the same namespace as the <code>Limitador</code> CR. <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: redisconfig\nstringData:\n  URL: redis://127.0.0.1/a # Redis URL of its running instance\ntype: Opaque\n</code></pre></p> <p>Note: Limitador's Operator will only read the <code>URL</code> field of the secret.</p> <p>Additionally, caching options can be specified in the <code>spec.storage.redis-cached.options</code> field.</p>"},{"location":"limitador-operator/doc/storage/#options","title":"Options","text":"Option Description <code>batch-size</code> Size of entries to flush in as single flush [default: 100] <code>flush-period</code> Flushing period for counters in milliseconds [default: 1000] <code>max-cached</code> Maximum amount of counters cached [default: 10000] <code>response-timeout</code> Timeout for Redis commands in milliseconds [default: 350] <p>For example:</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  storage:\n    redis-cached:\n      configSecretRef: # The secret reference storing the URL for Redis\n        name: redisconfig\n      options: # Every option is optional\n        batch-size: 50\n        max-cached: 5000\n</code></pre>"},{"location":"limitador-operator/doc/storage/#disk","title":"Disk","text":"<p>Counters are held on disk (persistent). Kubernetes Persistent Volumes will be used to store counters.</p> <p>Selected when <code>spec.storage.disk</code> is not <code>null</code>.</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  storage:\n    disk: {}\n</code></pre> <p>Additionally, disk options can be specified in the <code>spec.storage.disk.persistentVolumeClaim</code> and <code>spec.storage.disk.optimize</code> fields.</p>"},{"location":"limitador-operator/doc/storage/#persistent-volume-claim-options","title":"Persistent Volume Claim Options","text":"<p><code>spec.storage.disk.persistentVolumeClaim</code> field is an object with the following fields.</p> Field Description <code>storageClassName</code> StorageClass of the storage offered by cluster administrators [default: default storage class of the cluster] <code>resources</code> The minimum resources the volume should have. Resources will not take any effect when VolumeName is provided. This parameter is not updateable when the underlying PV is not resizable. [default: 1Gi] <code>volumeName</code> The binding reference to the existing PersistentVolume backing this claim [default: null] <p>Example:</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  storage:\n    disk:\n      persistentVolumeClaim:\n        storageClassName: \"customClass\"\n        resources:\n          requests: 2Gi\n</code></pre>"},{"location":"limitador-operator/doc/storage/#optimize","title":"Optimize","text":"<p>Defines the valid optimization option of the disk persistence type.</p> <p><code>spec.storage.disk.optimize</code> field is a <code>string</code> type with the following valid values:</p> Option Description <code>throughput</code> Optimizes for higher throughput. Default <code>disk</code> Optimizes for disk usage <p>Example:</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  storage:\n    disk:\n      optimize: disk\n</code></pre>"},{"location":"limitador-operator/doc/tracing/","title":"Tracing","text":"<p>Limitador offers distributed tracing enablement using the <code>.spec.tracing</code> CR configuration:</p> <pre><code>---\napiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador-sample\nspec:\n  listener:\n    http:\n      port: 8080\n    grpc:\n      port: 8081\n  limits:\n\n    - conditions: [\"get_toy == 'yes'\"]\n      max_value: 2\n      namespace: toystore-app\n      seconds: 30\n      variables: []\n  verbosity: 3\n  tracing:\n    endpoint: rpc://my-otlp-collector:4317\n</code></pre> <p>Currently limitador only supports collectors using the OpenTelemetry Protocol with TLS disabled. The <code>endpoint</code> configuration option should contain the scheme, host and port of the service. The quantity and level of the information provided by the spans is configured via the <code>verbosity</code> argument.</p> <p></p>"},{"location":"architecture/docs/api-conventions/","title":"Kuadrant API Conventions","text":"<p>This document outlines a none exhaustive set of conventions that should be used when defining Kuadrant APIs. It is initially focused around the concept of a policy API as these make up the bulk of our public facing APIs. It is expected that this set of conventions will grow as needed overtime.</p>"},{"location":"architecture/docs/api-conventions/#general-rule-of-thumb","title":"General rule of thumb","text":"<p>If in doubt, first check if a similar API or field exists in the Gateway API spec and re-use that definition to specify what you need in your API. If you need to differ, ensure you explain why in any RFC or PR. </p> <p>Below are some common examples of these fields and specifications:</p>"},{"location":"architecture/docs/api-conventions/#policy-attachment-apis","title":"Policy Attachment APIs","text":"<p>Policy APIs must follow the specification laid out by the Gateway API policy attachment designs. First step is to understand if you are going to design or are working on a direct or inherited policy. The linked docs will help with this but if unsure reach out on github or slack. </p> <p>Within the linked docs are set of requirements for each type of policy:</p> <p>Direct Policy Requirements</p> <p>Inherited Policy Requirements</p> <p>Existing direct policy API</p> <p>Existing inherited policy API</p> <p>Beyond the set of requirement outlined in these specifications, Kuadrant has an additional set of conventions that are used in order to try and ensure our APIs remain consistent and familiar for users of the Gateway API. Most if not all of these come directly from looking at Gateway API.</p>"},{"location":"architecture/docs/api-conventions/#api-fields-and-types","title":"API Fields and Types","text":"<p>Durations</p> <p>A duration is a field expressing something that configures behaviour that should happen according to a specified duration of time. Examples of this include but are not limited to:</p> <ul> <li>RateLimit counter expiry</li> <li>HealthCheck interval (how often to do the check)</li> </ul> <p>Any API field that expresses this type of time bound behaviour should use a type of <code>time.Duration</code> allowing the duration to be specified in a single field and must match <code>^([0-9]{1,5}(h|m|s|ms)){1,4}$</code>: </p> <p>Examples:</p> <p><code>20ms,20s,20m,20h</code> </p> <p>more detail and information</p> <p>field names for this type of configuration are left up to the designer of the API as they are often specific to the task at hand: IE with a health check it is called an <code>interval</code> within a limit it is called a <code>duration</code> for the timeout filter in HTTPRoute it is called <code>request</code> and <code>backendRequest</code></p> <p>hostname | hostnames</p> <p>When asking for a hostname the field in the API should be named <code>hostname</code> rather than other options such as <code>host, domain</code> etc. The type used for this should be a <code>string</code> or an alias to a <code>string</code>. The plural of this for an array should be <code>hostnames</code>. This also aligns with how the Gateway API specifies these fields. where possible re-use the Gateway API types:</p> <p>HostnameType:</p> <p>Gateway Listener host</p> <p>HTTPRoute hostnames</p> <p>protocol</p> <p>If there is a need to specify a protocol in the API the field for asking for this should be named: <code>protocol</code> and should accept a <code>string</code> or an alias to a string where possible use ProtocolType provided by Gateway API </p> <p>port</p> <p>If there is a need to specify a port in the API, the field should be named <code>port</code> and should accept an <code>int32</code> with a min of 1 and a max of 65535. Where possible use PortNumberType provided by Gateway API </p> <p>status</p> <p>For more information on status please refer to </p> <p>Policy Status</p>"},{"location":"architecture/docs/design/architectural-overview-v1/","title":"Kuadrant Architectural Overview","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#overview","title":"Overview","text":"<p>Kuadrant provides connectivity, security and service protection capabilities in both a single and multi-cluster environment. It exposes these capabilities in the form of Kubernetes CRDs that implement the Gateway API concept of policy attachment. These policy APIs can target specific Gateway API resources such as <code>Gateways</code> and <code>HTTPRoutes</code> to extend their capabilities and configuration. They enable platform engineers to secure, protect and connect their infrastructure and allow application developers to self service and refine policies to their specific needs in order to protect exposed endpoints.  </p>"},{"location":"architecture/docs/design/architectural-overview-v1/#key-architectural-areas","title":"Key Architectural Areas","text":"<ul> <li>Kuadrant architecture is defined and implemented with both control plane and data plane components.</li> <li>The control plane is where policies are exposed and expressed as Kubernetes APIs and reconciled by a policy controller. </li> <li>The data plane is where Kuadrant's \"policy enforcement\" components exist. These components are configured by the  control plane and integrate either directly with the Gateway provider or via external integrations.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#10000m-architecture","title":"10000m Architecture","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#control-plane-components-and-responsibilities","title":"Control Plane Components and Responsibilities","text":"<p>The control plane is a set of controllers and operators that are responsible for for installation and configuration of other components such as the data plane enforcement components and configuration of the Gateway to enable the data plane components to interact with incoming requests. The control plane also owns and reconciles the policy CRD APIs into more complex and specific configuration objects that the policy enforcement components consume in order to know the rules to apply to incoming requests or the configuration to apply to external integrations such as DNS and ACME providers. </p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#kuadrant-operator","title":"Kuadrant Operator","text":"<ul> <li>Installation and configuration of other control plane components</li> <li>Installation of data plane policy enforcement components via their respective control plane operators</li> <li>Configures the Gateway via WASM plugin and other APIs to leverage the data plane components for auth and rate limiting on incoming requests.</li> <li>Exposes <code>RateLimitPolicy</code> , <code>AuthPolicy</code>, <code>DNSPolicy</code> and <code>TLSPolicy</code> and reconciles these into enforceable configuration for the data plane.</li> <li>Exposes <code>Kuadrant</code> and reconciles this to configure and trigger installation of the required data plane components and other control plane components.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#limitador-operator","title":"Limitador Operator:","text":"<ul> <li>Installs and configures the Limitador data plane component based on the Limitador CR. Limits specified in the limitador CR are mountd via configmap into the limitador component.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#authorino-operator","title":"Authorino Operator:","text":"<ul> <li>Installs and configures the Authorino data plane component based on the Authorino CR.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#cert-manager","title":"Cert-Manager:","text":"<ul> <li>Manages TLS certificates for our components and for the Gateways. Consumes Certificate resources created by Kuadrant operator in response to the TLSPolicy.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#dns-operator","title":"DNS Operator","text":"<ul> <li>DNS operator consumes DNSRecord resources that are configured via the DNSPolicy api and applies them into the targeted cloud DNS provider AWS, Azure and Google DNS are our main targets</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#data-plane-components-and-responsibilities","title":"Data Plane Components and Responsibilities","text":"<p>The data plane components sit in the request flow and are responsible for enforcing configuration defined by policy and providing service protection capabilities based on configuration managed and created by the control plane.</p>"},{"location":"architecture/docs/design/architectural-overview-v1/#limitador","title":"Limitador","text":"<ul> <li>Complies with the with Envoy rate limiting API to provide rate limiting to the gateway. Consumes limits from a configmap created based on the RateLimitPolicy API.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#authorino","title":"Authorino","text":"<ul> <li>Complies with the Envoy external auth API to provide auth integration to the gateway. It provides both Authn and Authz. Consumes AuthConfigs created by the kuadrant operator based on the defined <code>AuthPolicy</code> API.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#wasm-shim","title":"WASM Shim","text":"<ul> <li>Uses the Proxy WASM ABI Spec to integrate with Envoy and provide filtering and connectivity to Limitador for request time enforcement of and rate limiting.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#single-cluster-layout","title":"Single Cluster Layout","text":"<p>In a single cluster, you have the Kuadrant control plane and data plane sitting together. It is configured to integrate with Gateways on the same cluster and configure a DNS zone via a DNS provider secret (configured alongside a DNSPolicy). Storage of rate limit counters is possible but not required as they are not being shared.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#multi-cluster","title":"Multi-Cluster","text":"<p>In the default multi-cluster setup. Each individual cluster has Kuadrant installed. Each of these clusters are unaware of the other. They are effectively operating as single clusters. The multi-cluster aspect is created by sharing access with the DNS zone, using a shared host across the clusters and leveraging shared counter storage.  The zone is operated on independently by each of DNS operator on both clusters to form a single cohesive record set. More details on this can be found in the following RFC document: TODO add link. The rate limit counters can also be shared and used by different clusters in order to provide global rate limiting. This is achieved by connecting each instance of Limitador to a shared data store that uses the Redis protocol. There is another option available for achieving multi-cluster connectivity (see intgrations below) that requires the use of a \"hub\" cluster and integration with OCM (open cluster management).</p> <p></p> <p>Shown above is a multi-cluster multi ingress gateway topology. This might be used to support a geographically distributed system for example. However, it is also possible to leverage overlay networking tools such as Skupper that integrate at the Kubernetes service level to have a single gateway cluster that then integrates with multiple backends (on different clusters or in custom infrastructure).</p>"},{"location":"architecture/docs/design/architectural-overview-v1/#observability","title":"Observability","text":"<p>The Kuadrant architecture is intended to work with some popular monitoring tools for tracing, metrics and log aggregation. Those tools are:</p> <ul> <li>Prometheus for scraping metrics - and optionally Thanos for high availability &amp; federation</li> <li>Loki for log aggregation - via log collectors like vector</li> <li>Tempo for trace collecting</li> <li>Grafana for visualing the above</li> </ul> <p>Depending on the number of clusters in your configuration, you may decide to have a monitoring system on the same cluster as workloads, or in a separate cluster completely. Below are 2 example architectures based on the single cluster and multi cluster layouts. In the single cluster architecture, the collector components (Prometheus, Vector and Tempo) are in the same cluster as the log aggregation (Loki) and visualisation component (Grafana).</p> <p></p> <p>In the multi cluster architecture, the collectors that scrape metrics or logs (Prometheus &amp; Vector) are deployed alongside the workloads in each cluster. However, as traces are sent to a collector (Tempo) from each component, it can be centralised in a separate cluster. Thanos is used in this architecutre so that each prometheus can federate metrics back to a central location. The log collector (vector) can forward logs to a central loki instance. Finally, the visualisation component (Grafana) is centralised as well, with data sources configured for each of the 3 components on the same cluster.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#dependencies","title":"Dependencies","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#istio-required","title":"Istio: Required","text":"<ul> <li>Gateway API provider that Kuadrant integrates with via WASM and Istio APIS to provide service protection capabilities. Kuadrant configures Envoy via the Istio control plane in order to enforce the applied policies and register components such as Authorino and Limitador. </li> <li>Used by <code>RateLimitPolicy</code> and <code>AuthPolicy</code></li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#gateway-api-required","title":"Gateway API: Required","text":"<ul> <li>New standard for Ingress from the Kubernetes community</li> <li>Gateway API is the core API that Kuadrant integrates with.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#integrations","title":"Integrations","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#open-cluster-manager-optional","title":"Open Cluster Manager: Optional","text":"<ul> <li>Provides a multi-cluster control plane to enable the defining and distributing of Gateways across multiple clusters.</li> </ul> <p>While the default setup is to leverage a distributed configuration for DNS and rate limiting. There is also a component that offers experimental integration with Open Cluster Management. </p> <p>In this setup, the OCM integration controller is installed into the HUB alongside the DNS Operator and the cert-manager. This integration allows you to define gateways in the Hub and distribute them to \"spoke\" clusters. The addresses of these gateways are gathered from the spokes and aggregated back to the hub. The Kuadrant operator and DNS operator then act on this information as though it were a single cluster gateway with multiple addresses. The DNS zone in the configured DNS provider is managed centrally by one DNS operator instance.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview/","title":"Kuadrant Architectural Overview [Draft]","text":""},{"location":"architecture/docs/design/architectural-overview/#overview","title":"Overview","text":"<p>It is important to note that Kuadrant is not in itself a gateway provider. Kuadrant provides a set of valuable policy APIs that enhance Gateway API via its defined policy attachment extension point. The policy APIs are reconciled by a set of policy controllers and enforced via integration at different points to configure, enhance and secure the application connectivity provided via Gateway API and the underlying gateway provider.  These policy extensions are focused around areas such as DNS management supporting global load balancing and health checks, alongside service protection specific APIs such as rate limiting and auth. Kuadrant also integrates with Open Cluster Management as a multi-cluster control plane to enable defining and distributing Gateways across multiple clusters, providing load balancing and tls management for these distributed gateways. These integrations and features can be managed centrally in a declarative way from the Open Cluster Management Hub using Kubernetes resources.</p>"},{"location":"architecture/docs/design/architectural-overview/#key-architectural-areas","title":"Key Architectural Areas","text":"<ul> <li>The Kuadrant architecture is spread across a control plane and also a data plane. Kuadrant can work in both a single and multi-cluster context.  Currently in order for all APIs to work in a single or multi-cluster context you need to have Open Cluster Management installed.  While this may change in the future, this approach allows us to start with a single cluster and seamlessly scale as more clusters are added.</li> <li>The control plane is where policies are exposed and expressed as kubernetes APIs and reconciled by the Kuadrant policy controllers. </li> <li>The data plane is where Kuadrant's service protection components, configured by the  control plane policies, are enforced within the gateway instance as part of the request flow. </li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#1000m-architecture","title":"1000m Architecture","text":""},{"location":"architecture/docs/design/architectural-overview/#control-plane-components-and-responsibilities","title":"Control Plane Components and Responsibilities","text":"<p>A control plane component is something responsible for accepting instruction via a CRD based API and ensuring that configuration is manifested into state that can be acted on.</p>"},{"location":"architecture/docs/design/architectural-overview/#kuadrant-operator","title":"Kuadrant Operator","text":"<ul> <li>Installation of data plane service protection components via their respective operators</li> <li>Exposes <code>RateLimitPolicy</code> and <code>AuthPolicy</code> and is currently the policy controller for these APIs</li> <li>Configures the Gateway to be able to leverage the data plane service protection components</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#multi-cluster-gateway-controller","title":"Multi-Cluster Gateway Controller","text":"<ul> <li>Exposes <code>DNSPolicy</code> and <code>TLSPolicy</code></li> <li>Configures DNS providers (e.g AWS Route 53) and TLS providers</li> <li>Focused around use cases involving distributed gateways (for example across clouds or geographic regions)</li> <li>Integrates with Open Cluster Management as the multi-cluster management hub to distribute and observe gateway status based on the clusters they are deployed to. Works directly with Open Cluster Management APIs such <code>PlacementDecision</code> and <code>ManifestWork</code>.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#kuadrant-add-on-manager","title":"Kuadrant-add-on-manager","text":"<ul> <li>Sub component in the gateway controller repository</li> <li>Follows the add-on pattern from Open Cluster Management</li> <li>Responsible for configuring and installing Kuadrant into a target spoke cluster</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#limitador-operator","title":"Limitador Operator:","text":"<ul> <li>Installs and configures Limitador</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#authorino-operator","title":"Authorino Operator:","text":"<ul> <li>Installs and configures Authorino</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#data-plane-components-and-responsibilities","title":"Data Plane Components and Responsibilities","text":"<p>A data plane component sits in the request flow and is responsible for enforcing policy and providing service protection capabilities based on configuration managed and created by the control plane.</p>"},{"location":"architecture/docs/design/architectural-overview/#limitador","title":"Limitador","text":"<ul> <li>Complies with the with Envoy rate limiting API to provide rate limiting to the gateway</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#authorino","title":"Authorino","text":"<ul> <li>Complies with the Envoy external auth API to provide auth integration to the gateway</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#wasm-shim","title":"WASM Shim","text":"<ul> <li>Uses the Proxy WASM ABI Spec to integrate with Envoy and provide filtering and connectivity to Limitador for request time enforcement of and rate limiting</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#dependencies-and-integrations","title":"Dependencies and integrations","text":"<p>In order to provide its full suite of functionality, Kuadrant has several dependencies. Some of these are optional depending on the functionality needed.</p>"},{"location":"architecture/docs/design/architectural-overview/#cert-manager-required","title":"Cert-Manager: Required","text":"<ul> <li>Provides TLS integration</li> <li>Used by <code>TLSPolicy</code> and Authorino.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#open-cluster-manager-required","title":"Open Cluster Manager: Required","text":"<ul> <li>Provides a multi-cluster control plane to enable the defining and distributing of Gateways across multiple clusters.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#istio-required","title":"Istio: Required","text":"<ul> <li>Gateway API provider that Kuadrant integrates with via WASM and Istio APIS to provide service protection capabilities.</li> <li>Used by <code>RateLimitPolicy</code> and <code>AuthPolicy</code></li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#gateway-api-required","title":"Gateway API: Required","text":"<ul> <li>New standard for Ingress from the Kubernetes community</li> <li>Gateway API is the core API that Kuadrant integrates with.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#thanosprometheusgrafana-optional","title":"Thanos/Prometheus/Grafana: Optional","text":"<ul> <li>Provides observability integration</li> <li>Rather than providing any Kuadrant specific observability tooling, we instead look to leverage existing tools and technologies to provide observability capabilities for ingress. </li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#high-level-multi-cluster-architecture","title":"High Level Multi-Cluster Architecture","text":"<p>Kuadrant has a multi-cluster gateway controller that is intended to run in a Open Cluster Management provided \"Hub\" cluster. This cluster is effectively a central management cluster where policy and gateways along with all that Open Cluster Management offers can be defined and distributed to the managed \"spoke\" clusters. </p>"},{"location":"architecture/docs/design/architectural-overview/#single-cluster","title":"Single cluster","text":"<p>In a single cluster context, the overall architecture remains the same as above, the key difference is that the Hub and Spoke cluster are now a single cluster rather than multiple clusters. This is how we are initially supporting single cluster.</p>"},{"location":"architecture/docs/design/architectural-overview/#how-does-kuadrant-leverage-open-cluster-management","title":"How does Kuadrant leverage Open Cluster Management?","text":"<p>Kuadrant deploys a multi-cluster gateway controller into the Open Cluster Management hub (a control plane that manages a set of \"spoke\" clusters where workloads are executed). This controller offers its own APIs but also integrates with hub CRD based APIs (such as the placement API) along with the Gateway API CRD based APIs in order to provide multi-cluster Gateway capabilities to the hub and distribute actual gateway instances to the spokes. See the Open Cluster Management docs for further details on the hub spoke architecture.</p> <p>As part of installing Kuadrant, the Gateway API CRDs are also installed into the hub cluster and Kuadrant defines a standard Gateway API <code>GatewayClass</code> resource that the multi-cluster gateway controller is the chosen controller for. </p> <p>Once installed, an Open Cluster Management user can then (with the correct RBAC in place) define in the standard way a Gateway resource that inherits from the Kuadrant configured <code>GatewayClass</code> in the hub. There is nothing unique about this Gateway definition, the difference is what it represents and how it is used. This Gateway is used to represent a \"multi-cluster\" distributed gateway. As such there are no pods running behind this Gateway instance in the hub cluster, instead it serves as a template that the Kuadrant multi-cluster gateway controller reconciles and distributes to targeted spoke clusters.  It leverages the Open Cluster Management APIs to distribute these gateways (more info below) and aggregates the status information from each spoke cluster instance of this gateway back to this central definition, in doing this it can represent the status of the gateway across multiple clusters but also use that information to integrate with DNS providers etc.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview/#gateway-deployment-and-distribution","title":"Gateway Deployment and Distribution","text":"<p>In order for a multi-cluster gateway to be truly useful, it needs to be distributed or \"placed\" on a specific set of hub managed spoke clusters.  Open Cluster Management is responsible for a set of placement and replication APIs. Kuadrant is aware of these APIs, and so when a given gateway is chosen to be placed on a set of managed clusters, Kuadrant multi-cluster gateway controller will ensure the right resources (<code>ManifestWork</code>) are created in the correct namespaces in the hub. Open Cluster Management then is responsible for syncing these to the actual spoke cluster and reporting back the status of these resources to the Hub. A user would indicate which clusters they want a gateway placed on by using a <code>Placement</code> and then labeling the gateway using the <code>cluster.open-cluster-management.io/placement</code> label.</p> <p>In order for the Gateway to be instantiated, we need to know what underlying gateway provider is being used on the spoke clusters. Admins can then set this provider in the hub via the GatewayClass params. In the hub, Kuadrant will then apply a transformation to the gateway to ensure when synced it references this spoke gateway provider (Istio for example). </p> <p>It is the Open Cluster Management workagent that is responsible for syncing down and applying the resources into the managed spoke cluster. It is also responsible for syncing status information back to the hub. It is the multi-cluster gateway controller that is responsible for aggregating this status.</p> <p>The status information reported back to the Hub is used by the multi-cluster gateway controller to know what LB hosts / IPAddresses to use for DNSRecords that it creates and manages.</p> <p></p> <p>More info on the Open Cluster Management hub and spoke architecture can be found here</p>"},{"location":"architecture/docs/design/architectural-overview/#how-does-kuadrant-integrate-with-gateway-providers","title":"How does Kuadrant integrate with Gateway Providers?","text":"<p>Currently the Kuadrant data plane only integrates with an Istio based gateway provider:</p> <ul> <li>It registers Authorino with the <code>IstioOperator</code> as an auth provider so that Authorino can be used as an external auth provider.</li> <li>It leverages an <code>EnvoyFilter</code> to register the rate limiting service as an upstream service.</li> <li>Based on the Kuadrant <code>AuthPolicy</code>, it leverages Istio's <code>AuthorizationPolicy</code> resource to configure when a request should trigger Authorino to be called for a given host, path and method etc. </li> <li>It provides a WebAssembly (WASM) Plugin that conforms to the Proxy WASM ABI (application binary interface). This WASM Plugin is loaded into the underlying Envoy based gateway provider and configured via the Kuadrant Operator based on defined <code>RateLimitPolicy</code> resources. This binary is executed in response to a HTTP request being accepted by the gateway via the underlying Envoy instance that provides the proxy layer for the Gateway (IE Envoy). This plugin is configured with the correct upstream rate limit service name and when it sees a request, based on the provided configuration, it will trigger a call to the installed Limitador that is providing the rate limit capabilities and either allow the request to continue or trigger a response to the client with a 429 (too many requests) HTTP code.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview/#data-flows","title":"Data Flows","text":"<p>There are several different data flows when using Kuadrant. </p>"},{"location":"architecture/docs/design/architectural-overview/#control-plane-configuration-and-status-reporting","title":"Control plane configuration and status reporting","text":"<p>The initial creation of these APIs (gateways, policies etc) is done by the relevant persona in the control plane just as they would any other k8s resource. We use the term cluster admin or gateway admin as the operations type persona configuring, and placing gateways.  As shown above, in a multi-cluster configuration. API definitions are pulled from the Hub and \"manifested\" into the spokes. The Status of those synced resources are reported back to the Hub. The same happens for a single cluster, the only difference being the work agent hub controllers are all installed on one cluster.</p>"},{"location":"architecture/docs/design/architectural-overview/#third-party-enforcement-and-integration","title":"Third party enforcement and Integration","text":"<p>In order to enforce the policy configuration, components in the control plane and data plane can reach out to configured 3rd parties such as cloud based DNS provider, TLS providers and Auth providers.</p>"},{"location":"architecture/docs/design/architectural-overview/#request-flow","title":"Request Flow","text":"<p>Requests coming through the gateway instance can be sent to Limitador based on configuration of the WASM plugin installed into the Envoy based gateway provider or to Authorino based configuration provided by the Istio <code>AuthorizationPolicy</code>.  Each of these components have the capability to see the request and need to in order to make the required decision. Each of these components can also prevent the request from reaching its intended backend destination based on user configuration. </p> <p></p>"},{"location":"architecture/docs/design/architectural-overview/#auth","title":"Auth","text":"<p>As all of the APIs are CRDs, auth around creating these resources is handled in the standard way IE by the kubernetes cluster and RBAC. There is no relationship by default between the Auth features provided by Authorino to application developers and the auth requirements of the cluster API server.</p> <p>For Auth between Spoke and Hub see Open Cluster Management docs</p>"},{"location":"architecture/docs/design/architectural-overview/#observability","title":"Observability","text":"<p>Kuadrant doesn't provide any specific observability components, but rather provides a reference setup using well known and established components along with some useful dashboards to help observe key things around the Gateways. The focus of this setup, is in the context of a multi-cluster setup where Open Cluster Management is installed and gateways are being defined and distributed from that hub.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview/#some-notes-on-future-direction","title":"Some notes on future direction","text":"<p>This section is here to provide some insight into architectural changes that may be seen in the near future:</p> <p>What is in this doc represents the architecture at point our MVP release. Below are some areas that we have identified that are likely to change in the coming releases. As these happen, this doc will also evolve.</p> <ul> <li>We want to separate out the ocm integration into its own controller so that policies can evolve without a coupling to any one multi-cluster management solution</li> <li>We want to separate the policies into their own controller that is capable of supporting both single (without Open Cluster Management) and multi-cluster (with Open Cluster Management enabled) contexts, so that the barrier to entry is reduced for those starting with a single cluster</li> <li>We want to allow for an on cluster DNS Provider such as CoreDNS so that we can provide an implementation that is disconnected from any cloud provider and provides more flexible DNS setups.</li> <li>We will look to reduce our integration with Istio and want to provide integration with additional gateway providers such as EnvoyGateway</li> </ul>"},{"location":"architecture/docs/design/modular_installation/","title":"Kuadrant Proposal - Modular Installation","text":"<p>Kuadrant is developing a set of loosely coupled functionalities built directly on top of Kubernetes. Kuadrant aims to allow customers to just install, use and understand those functionalities they need.</p>"},{"location":"architecture/docs/design/modular_installation/#problem-statement","title":"Problem Statement","text":"<p>Currently, the installation tool of kuadrant, the kuadrantctl CLI, installs all or nothing. Installing more than the customer needs adds unneeded complexity and operational effort. For example, if a customer is looking for rate limiting and not interested in authentication functionality, then the customer should be able to just install and run that part of Kuadrant.</p>"},{"location":"architecture/docs/design/modular_installation/#high-level-goals","title":"High Level Goals","text":"<ul> <li>Install only required components. Operate only required components.</li> </ul> <p>Reduce system complexity and operational effort to the minimum required. Components in this context make reference to deployments and running instances.</p> <ul> <li>Expose only the activated functionalities</li> </ul> <p>A user of a partial Kuadrant install should not be confronted with data in custom resources that has no meaning or is not accessible in their partial Kuadrant install. The design of the kuadrant API should have this goal into account.</p>"},{"location":"architecture/docs/design/modular_installation/#proposed-solution","title":"Proposed Solution","text":"<p>The kuadrant installation mechanism should offer modular installation to enable/disable loosely coupled pieces of kuadrant. Modular installation options should be feature oriented rather than deployment component oriented. Then, it is up to the installation tool to decide what components need to be deployed and how to configure it.</p> <p>Each feature, or part of it, is eligible to be included or excluded when installing kuadrant.</p> <p>Some profiles can be defined to group set of commonly required features. Naming the profiles allows the customer to easily express wanted installation configuration. Furthermore, profiles not only can be used to group a set of features, profiles can be used to define deployment options.</p> Name Description Minimal Minimal installation required to run an API without any protection, analytics or API management. Default deployment option AuthZ Authentication and authorization mechanisms activated RateLimit Basic rate limit (only pre-auth rate limit) features Full Full featured kuadrant installation <p>A kuadrant operator, together with a design of a kuadrant CRD is desired. Not only for kuadrant installation, but also for lifecycle management. Additionally, the kuadrantctl CLI tool can also be useful to either deploy kuadrant components and manifests or just deploy the kuadrant operator.</p> <p>The kuadrant control plane should be aware of the installed profile via env vars or command line params in the control plane running components. With that information, the control plane can decide to enable or disable CRD watching, label and annotation monitoring and ultimately reject any configuration object that relies on disabled functionality. The least a customer can expect from kuadrant is to be consistent and reject any functionality request that cannot provide.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/","title":"RateLimitPolicy API v2","text":"<ul> <li>Feature Name: <code>rlp-v2</code></li> <li>Start Date: 2023-02-02</li> <li>RFC PR: Kuadrant/architecture#12</li> <li>Issue tracking: Kuadrant/architecture#13</li> </ul>"},{"location":"architecture/rfcs/0001-rlp-v2/#summary","title":"Summary","text":"<p>Proposal of new API for the Kuadrant's <code>RateLimitPolicy</code> (RLP) CRD, for improved UX.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#motivation","title":"Motivation","text":"<p>The <code>RateLimitPolicy</code> API (v1beta1), particularly its <code>RateLimit</code> type used in <code>ratelimitpolicy.spec.rateLimits</code>, designed in part to fit the underlying implementation based on the Envoy Rate limit filter, has been proven to be complex, as well as somewhat limiting for the extension of the API for other platforms and/or for supporting use cases of not contemplated in the original design.</p> <p>Users of the <code>RateLimitPolicy</code> will immediately recognize elements of Envoy's Rate limit API in the definitions of the <code>RateLimit</code> type, with almost 1:1 correspondence between the <code>Configuration</code> type and its counterpart in the Envoy configuration. Although compatibility between those continue to be desired, leaking such implementation details to the level of the API can be avoided to provide a better abstraction for activators (\"matchers\") and payload (\"descriptors\"), stated by users in a seamless way.</p> <p>Furthermore, the <code>Limit</code> type \u2013 used as well in the RLP's <code>RateLimit</code> type \u2013 implies presently a logical relationship between its inner concepts \u2013 i.e. conditions and variables on one side, and limits themselves on the other \u2013 that otherwise could be shaped in a different manner, to provide clearer understanding of the meaning of these concepts by the user and avoid repetition. I.e., one limit definition contains multiple rate limits, and not the other way around.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#goals","title":"Goals","text":"<ol> <li>Decouple the API from the underlying implementation - i.e. provide a more generic and more user-friendly abstraction</li> <li>Prepare the API for upcoming changes in the Gateway API Policy Attachment specification</li> <li>Improve consistency of the API with respect to Kuadrant's AuthPolicy CRD - i.e. same language, similar UX</li> </ol>"},{"location":"architecture/rfcs/0001-rlp-v2/#current-wip-to-consider","title":"Current WIP to consider","text":"<ol> <li>Policy attachment update (kubernetes-sigs/gateway-api#1565)</li> <li>No merging of policies (kuadrant/architecture#10)</li> <li>A single Policy scoped to HTTPRoutes and HTTPRouteRule (kuadrant/architecture#4) - future</li> <li>Implement <code>skip_if_absent</code> for the RequestHeaders action (kuadrant/wasm-shim#29)</li> </ol>"},{"location":"architecture/rfcs/0001-rlp-v2/#highlights","title":"Highlights","text":"<ul> <li><code>spec.rateLimits[]</code> replaced with <code>spec.limits{&lt;limit-name&gt;: &lt;limit-definition&gt;}</code></li> <li><code>spec.rateLimits.limits</code> replaced with <code>spec.limits.&lt;limit-name&gt;.rates</code></li> <li><code>spec.rateLimits.limits.maxValue</code> replaced with <code>spec.limits.&lt;limit-name&gt;.rates.limit</code></li> <li><code>spec.rateLimits.limits.seconds</code> replaced with <code>spec.limits.&lt;limit-name&gt;.rates.duration</code> + <code>spec.limits.&lt;limit-name&gt;.rates.unit</code></li> <li><code>spec.rateLimits.limits.conditions</code> replaced with <code>spec.limits.&lt;limit-name&gt;.when</code>, structured field based on well-known selectors, mainly for expressing conditions not related to the HTTP route (although not exclusively)</li> <li><code>spec.rateLimits.limits.variables</code> replaced with <code>spec.limits.&lt;limit-name&gt;.counters</code>, based on well-known selectors</li> <li><code>spec.rateLimits.rules</code> replaced with <code>spec.limits.&lt;limit-name&gt;.routeSelectors</code>, for selecting (or \"sub-targeting\") HTTPRouteRules that trigger the limit</li> <li>new matcher <code>spec.limits.&lt;limit-name&gt;.routeSelectors.hostnames[]</code></li> <li><code>spec.rateLimits.configurations</code> removed \u2013 descriptor actions configuration (previously <code>spec.rateLimits.configurations.actions</code>) generated from <code>spec.limits.&lt;limit-name&gt;.when.selector</code> \u222a <code>spec.limits.&lt;limit-name&gt;.counters</code> and unique identifier of the limit (associated with <code>spec.limits.&lt;limit-name&gt;.routeSelectors</code>)</li> <li>Limitador conditions composed of \"soft\" <code>spec.limits.&lt;limit-name&gt;.when</code> conditions + a \"hard\" condition that binds the limit to its trigger HTTPRouteRules</li> </ul> <p>For detailed differences between current and new RLP API, see Comparison to current RateLimitPolicy.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#guide-level-explanation","title":"Guide-level explanation","text":""},{"location":"architecture/rfcs/0001-rlp-v2/#examples-of-rlps-based-on-the-new-api","title":"Examples of RLPs based on the new API","text":"<p>Given the following network resources:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1alpha2\nkind: Gateway\nmetadata:\n  name: istio-ingressgateway\n  namespace: istio-system\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - hostname:\n    - \"*.acme.com\"\n---\napiVersion: gateway.networking.k8s.io/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: toystore\nspec:\n  parentRefs:\n  - name: istio-ingressgateway\n    namespace: istio-system\n  hostnames:\n  - \"*.toystore.acme.com\"\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/toys\"\n      method: GET\n    - path:\n        type: PathPrefix\n        value: \"/toys\"\n      method: POST\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/assets/\"\n    backendRefs:\n    - name: toystore\n      port: 80\n    filters:\n    - type: ResponseHeaderModifier\n      responseHeaderModifier:\n        set:\n        - name: Cache-Control\n          value: \"max-age=31536000, immutable\"\n</code></pre> <p>The following are examples of RLPs targeting the route and the gateway. Each example is independent from the other.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#example-1-minimal-example-network-resource-targeted-entirely-without-filtering-unconditional-and-unqualified-rate-limiting","title":"Example 1. Minimal example - network resource targeted entirely without filtering, unconditional and unqualified rate limiting","text":"<p>In this example, all traffic to <code>*.toystore.acme.com</code> will be limited to 5rps, regardless of any other attribute of the HTTP request (method, path, headers, etc), without any extra \"soft\" conditions (conditions non-related to the HTTP route), across all consumers of the API (unqualified rate limiting).</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-infra-rl\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    base: # user-defined name of the limit definition - future use for handling hierarchical policy attachment\n\n    - rates: # at least one rate limit required\n      - limit: 5\n        unit: second\n</code></pre> <sub>How is this RLP implemented under the hood?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/toys*\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/toys*\"]\n    methods: [\"POST\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/assets/*\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-infra-rl/base\"\n      descriptor_value: \"1\"\n</code></pre> <pre><code>limits:\n\n- conditions:\n  - toystore/toystore-infra-rl/base == \"1\"\n  max_value: 5\n  seconds: 1\n  namespace: TDB\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#example-2-targeting-specific-route-rules-with-counter-qualifiers-multiple-rates-per-limit-definition-and-soft-conditions","title":"Example 2. Targeting specific route rules, with counter qualifiers, multiple rates per limit definition and \"soft\" conditions","text":"<p>In this example, a distinct limit will be associated (\"bound\") to each individual HTTPRouteRule of the targeted HTTPRoute, by using the <code>routeSelectors</code> field for selecting (or \"sub-targeting\") the HTTPRouteRule.</p> <p>The following limit definitions will be bound to each HTTPRouteRule:</p> <ul> <li><code>/toys*</code> \u2192 50rpm, enforced per username (counter qualifier) and only in case the user is not an admin (\"soft\" condition).</li> <li><code>/assets/*</code> \u2192 5rpm / 100rp12h</li> </ul> <p>Each set of trigger matches in the RLP will be matched to all HTTPRouteRules whose HTTPRouteMatches is a superset of the set of trigger matches in the RLP. For every HTTPRouteRule matched, the HTTPRouteRule will be bound to the corresponding limit definition that specifies that trigger. In case no HTTPRouteRule is found containing at least one HTTPRouteMatch that is identical to some set of matching rules of a particular limit definition, the limit definition is considered invalid and reported as such in the status of RLP.</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-per-endpoint\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    toys:\n      rates:\n\n      - limit: 50\n        duration: 1\n        unit: minute\n      counters:\n      - auth.identity.username\n      routeSelectors:\n      - matches: # matches the 1st HTTPRouteRule (i.e. GET or POST to /toys*)\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n      when:\n      - selector: auth.identity.group\n        operator: neq\n        value: admin\n\n    assets:\n      rates:\n\n      - limit: 5\n        duration: 1\n        unit: minute\n      - limit: 100\n        duration: 12\n        unit: hour\n      routeSelectors:\n      - matches: # matches the 2nd HTTPRouteRule (i.e. /assets/*)\n        - path:\n            type: PathPrefix\n            value: \"/assets/\"\n</code></pre> <sub>How is this RLP implemented under the hood?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/toys*\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/toys*\"]\n    methods: [\"POST\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-per-endpoint/toys\"\n      descriptor_value: \"1\"\n  - metadata:\n      descriptor_key: \"auth.identity.group\"\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - segment:\n            key: \"identity\"\n        - segment:\n            key: \"group\"\n  - metadata:\n      descriptor_key: \"auth.identity.username\"\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - segment:\n            key: \"identity\"\n        - segment:\n            key: \"username\"\n- rules:\n  - paths: [\"/assets/*\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-per-endpoint/assets\"\n      descriptor_value: \"1\"\n</code></pre> <pre><code>limits:\n\n- conditions:\n  - toystore/toystore-per-endpoint/toys == \"1\"\n  - auth.identity.group != \"admin\"\n  variables:\n  - auth.identity.username\n  max_value: 50\n  seconds: 60\n  namespace: kuadrant\n- conditions:\n  - toystore/toystore-per-endpoint/assets == \"1\"\n  max_value: 5\n  seconds: 60\n  namespace: kuadrant\n- conditions:\n  - toystore/toystore-per-endpoint/assets == \"1\"\n  max_value: 100\n  seconds: 43200 # 12 hours\n  namespace: kuadrant\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#example-3-targeting-a-subset-of-an-httprouterule-httproutematch-missing","title":"Example 3. Targeting a subset of an HTTPRouteRule - HTTPRouteMatch missing","text":"<p>Consider a 150rps rate limit set on requests to <code>GET /toys/special</code>. Such specific application endpoint is covered by the first HTTPRouteRule in the HTTPRoute (as a subset of <code>GET</code> or <code>POST</code> to any path that starts with <code>/toys</code>). However, to avoid binding limits to HTTPRouteRules that are more permissive than the actual intended scope of the limit, the RateLimitPolicy controller requires trigger matches to find identical matching rules explicitly defined amongst the sets of HTTPRouteMatches of the HTTPRouteRules potentially targeted.</p> <p>As a consequence, by simply defining a trigger match for <code>GET /toys/special</code> in the RLP, the <code>GET|POST /toys*</code> HTTPRouteRule will NOT be bound to the limit definition. In order to ensure the limit definition is properly bound to a routing rule that strictly covers the <code>GET /toys/special</code> application endpoint, first the user has to modify the spec of the HTTPRoute by adding an explicit HTTPRouteRule for this case:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: toystore\nspec:\n  parentRefs:\n\n  - name: istio-ingressgateway\n    namespace: istio-system\n  hostnames:\n  - \"*.toystore.acme.com\"\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/toys\"\n      method: GET\n    - path:\n        type: PathPrefix\n        value: \"/toys\"\n      method: POST\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/assets/\"\n    backendRefs:\n    - name: toystore\n      port: 80\n    filters:\n    - type: ResponseHeaderModifier\n      responseHeaderModifier:\n        set:\n        - name: Cache-Control\n          value: \"max-age=31536000, immutable\"\n  - matches: # new (more specific) HTTPRouteRule added\n    - path:\n        type: Exact\n        value: \"/toys/special\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\n</code></pre> <p>After that, the RLP can target the new HTTPRouteRule strictly:</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-special-toys\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    specialToys:\n      rates:\n\n      - limit: 150\n        unit: second\n      routeSelectors:\n      - matches: # matches the new HTTPRouteRule (i.e. GET /toys/special)\n        - path:\n            type: Exact\n            value: \"/toys/special\"\n          method: GET\n</code></pre> <sub>How is this RLP implemented under the hood?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/toys/special\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-special-toys/specialToys\"\n      descriptor_value: \"1\"\n</code></pre> <pre><code>limits:\n\n- conditions:\n  - toystore/toystore-special-toys/specialToys == \"1\"\n  max_value: 150\n  seconds: 1\n  namespace: kuadrant\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#example-4-targeting-a-subset-of-an-httprouterule-httproutematch-found","title":"Example 4. Targeting a subset of an HTTPRouteRule - HTTPRouteMatch found","text":"<p>This example is similar to Example 3. Consider the use case of setting a 150rpm rate limit on requests to <code>GET /toys*</code>.</p> <p>The targeted application endpoint is covered by the first HTTPRouteRule in the HTTPRoute (as a subset of <code>GET</code> or <code>POST</code> to any path that starts with <code>/toys</code>). However, unlike in the previous example where, at first, no HTTPRouteRule included an explicit HTTPRouteMatch for <code>GET /toys/special</code>, in this example the HTTPRouteMatch for the targeted application endpoint <code>GET /toys*</code> does exist explicitly in one of the HTTPRouteRules, thus the RateLimitPolicy controller would find no problem to bind the limit definition to the HTTPRouteRule. That would nonetheless cause a unexpected behavior of the limit triggered not strictly for <code>GET /toys*</code>, but also for <code>POST /toys*</code>.</p> <p>To avoid extending the scope of the limit beyond desired, with no extra \"soft\" conditions, again the user must modify the spec of the HTTPRoute, so an exclusive HTTPRouteRule exists for the <code>GET /toys*</code> application endpoint:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: toystore\nspec:\n  parentRefs:\n\n  - name: istio-ingressgateway\n    namespace: istio-system\n  hostnames:\n  - \"*.toystore.acme.com\"\n  rules:\n  - matches: # first HTTPRouteRule split into two \u2013 one for GET /toys*, other for POST /toys*\n    - path:\n        type: PathPrefix\n        value: \"/toys\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/toys\"\n      method: POST\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/assets/\"\n    backendRefs:\n    - name: toystore\n      port: 80\n    filters:\n    - type: ResponseHeaderModifier\n      responseHeaderModifier:\n        set:\n        - name: Cache-Control\n          value: \"max-age=31536000, immutable\"\n</code></pre> <p>The RLP can then target the new HTTPRouteRule strictly:</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toy-readers\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    toyReaders:\n      rates:\n\n      - limit: 150\n        unit: second\n      routeSelectors:\n      - matches: # matches the new more specific HTTPRouteRule (i.e. GET /toys*)\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n          method: GET\n</code></pre> <sub>How is this RLP implemented under the hood?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/toys*\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toy-readers/toyReaders\"\n      descriptor_value: \"1\"\n</code></pre> <pre><code>limits:\n\n- conditions:\n  - toystore/toy-readers/toyReaders == \"1\"\n  max_value: 150\n  seconds: 1\n  namespace: kuadrant\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#example-5-one-limit-triggered-by-multiple-httprouterules","title":"Example 5. One limit triggered by multiple HTTPRouteRules","text":"<p>In this example, both HTTPRouteRules, i.e. <code>GET|POST /toys*</code> and <code>/assets/*</code>, are targeted by the same limit of 50rpm per username.</p> <p>Because the HTTPRoute has no other rule, this is technically equivalent to targeting the entire HTTPRoute and therefore similar to Example 1. However, if the HTTPRoute had other rules or got other rules added afterwards, this would ensure the limit applies only to the two original route rules.</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-per-user\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    toysOrAssetsPerUsername:\n      rates:\n\n      - limit: 50\n        duration: 1\n        unit: minute\n      counters:\n      - auth.identity.username\n      routeSelectors:\n      - matches:\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n          method: GET\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n          method: POST\n      - matches:\n        - path:\n            type: PathPrefix\n            value: \"/assets/\"\n</code></pre> <sub>How is this RLP implemented under the hood?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/toys*\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/toys*\"]\n    methods: [\"POST\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/assets/*\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-per-user/toysOrAssetsPerUsername\"\n      descriptor_value: \"1\"\n  - metadata:\n      descriptor_key: \"auth.identity.username\"\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - segment:\n            key: \"identity\"\n        - segment:\n            key: \"username\"\n</code></pre> <pre><code>limits:\n\n- conditions:\n  - toystore/toystore-per-user/toysOrAssetsPerUsername == \"1\"\n  variables:\n  - auth.identity.username\n  max_value: 50\n  seconds: 60\n  namespace: kuadrant\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#example-6-multiple-limit-definitions-targeting-the-same-httprouterule","title":"Example 6. Multiple limit definitions targeting the same HTTPRouteRule","text":"<p>In case multiple limit definitions target a same HTTPRouteRule, all those limit definitions will be bound to the HTTPRouteRule. No limit \"shadowing\" will be be enforced by the RLP controller. Due to how things work as of today in Limitador nonetheless (i.e. the rule of the most restrictive limit wins), in some cases, across multiple limits triggered, one limit ends up \"shadowing\" others, depending on further qualification of the counters and the actual RL values.</p> <p>E.g., the following RLP intends to set 50rps per username on <code>GET /toys*</code>, and 100rps on <code>POST /toys*</code> or <code>/assets/*</code>:</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-per-endpoint\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    readToys:\n      rates:\n\n      - limit: 50\n        unit: second\n      counters:\n      - auth.identity.username\n      routeSelectors:\n      - matches: # matches the 1st HTTPRouteRule (i.e. GET or POST to /toys*)\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n          method: GET\n\n    postToysOrAssets:\n      rates:\n\n      - limit: 100\n        unit: second\n      routeSelectors:\n      - matches: # matches the 1st HTTPRouteRule (i.e. GET or POST to /toys*)\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n          method: POST\n      - matches: # matches the 2nd HTTPRouteRule (i.e. /assets/*)\n        - path:\n            type: PathPrefix\n            value: \"/assets/\"\n</code></pre> <sub>How is this RLP implemented under the hood?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/toys*\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/toys*\"]\n    methods: [\"POST\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-per-endpoint/readToys\"\n      descriptor_value: \"1\"\n  - metadata:\n      descriptor_key: \"auth.identity.username\"\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - segment:\n            key: \"identity\"\n        - segment:\n            key: \"username\"\n- rules:\n  - paths: [\"/toys*\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/toys*\"]\n    methods: [\"POST\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/assets/*\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-per-endpoint/readToys\"\n      descriptor_value: \"1\"\n  - generic_key:\n      descriptor_key: \"toystore/toystore-per-endpoint/postToysOrAssets\"\n      descriptor_value: \"1\"\n</code></pre> <pre><code>limits:\n\n- conditions: # actually applies to GET|POST /toys*\n  - toystore/toystore-per-endpoint/readToys == \"1\"\n  variables:\n  - auth.identity.username\n  max_value: 50\n  seconds: 1\n  namespace: kuadrant\n- conditions: # actually applies to GET|POST /toys* and /assets/*\n  - toystore/toystore-per-endpoint/postToysOrAssets == \"1\"\n  max_value: 100\n  seconds: 1\n  namespace: kuadrant\n</code></pre> <p>This example was only written in this way to highlight that it is possible that multiple limit definitions select a same HTTPRouteRule. To avoid over-limiting between <code>GET|POST /toys*</code> and thus ensure the originally intended limit definitions for each of these routes apply, the HTTPRouteRule should be split into two, like done in Example 4.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#example-7-limits-triggered-for-specific-hostnames","title":"Example 7. Limits triggered for specific hostnames","text":"<p>In the previous examples, the limit definitions and therefore the counters were set indistinctly for all hostnames \u2013 i.e. no matter if the request is sent to <code>games.toystore.acme.com</code> or <code>dolls.toystore.acme.com</code>, the same counters are expected to be affected. In this example on the other hand, a 1000rpd rate limit is set for requests to <code>/assets/*</code> only when the hostname matches <code>games.toystore.acme.com</code>.</p> <p>First, the user needs to edit the HTTPRoute to make the targeted hostname <code>games.toystore.acme.com</code> explicit:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: toystore\nspec:\n  parentRefs:\n\n  - name: istio-ingressgateway\n    namespace: istio-system\n  hostnames:\n  - \"*.toystore.acme.com\"\n  - games.toystore.acme.com # new (more specific) hostname added\n  rules:\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/toys\"\n      method: GET\n    - path:\n        type: PathPrefix\n        value: \"/toys\"\n      method: POST\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches:\n    - path:\n        type: PathPrefix\n        value: \"/assets/\"\n    backendRefs:\n    - name: toystore\n      port: 80\n    filters:\n    - type: ResponseHeaderModifier\n      responseHeaderModifier:\n        set:\n        - name: Cache-Control\n          value: \"max-age=31536000, immutable\"\n</code></pre> <p>After that, the RLP can target specifically the newly added hostname:</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-per-hostname\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    games:\n      rates:\n\n      - limit: 1000\n        unit: day\n      routeSelectors:\n      - matches:\n        - path:\n            type: PathPrefix\n            value: \"/assets/\"\n        hostnames:\n        - games.toystore.acme.com\n</code></pre> <sub>How is this RLP implemented under the hood?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/assets/*\"]\n    hosts: [\"games.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-per-hostname/games\"\n      descriptor_value: \"1\"\n</code></pre> <pre><code>limits:\n\n- conditions:\n  - toystore/toystore-per-hostname/games == \"1\"\n  max_value: 1000\n  seconds: 86400 # 1 day\n  namespace: kuadrant\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#example-8-targeting-the-gateway","title":"Example 8. Targeting the Gateway","text":"<p>Note: Additional meaning and context may be given to this use case in the future, when discussing defaults and overrides.</p> <p>Targeting a Gateway is a shortcut to targeting all individual HTTPRoutes referencing the gateway as parent. This differs from Example 1 nonetheless because, by targeting the gateway rather than an individual HTTPRoute, the RLP applies automatically to all HTTPRoutes pointing to the gateway, including routes created before and after the creation of the RLP. Moreover, all those routes will share the same limit counters specified in the RLP.</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rl\n  namespace: istio-ingressgateway\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: istio-ingressgateway\n  limits:\n    base:\n\n    - rates:\n      - limit: 5\n        unit: second\n</code></pre> <sub>How is this RLP implemented under the hood?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/toys*\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/toys*\"]\n    methods: [\"POST\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/assets/*\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"istio-system/gw-rl/base\"\n      descriptor_value: \"1\"\n</code></pre> <pre><code>limits:\n\n- conditions:\n  - istio-system/gw-rl/base == \"1\"\n  max_value: 5\n  seconds: 1\n  namespace: TDB\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#comparison-to-current-ratelimitpolicy","title":"Comparison to current RateLimitPolicy","text":"Current New Reason 1:1 relation between Limit (the object) and the actual Rate limit (the value) (<code>spec.rateLimits.limits</code>) Rate limit becomes a detail of Limit where each limit may define one or more rates (1:N) (<code>spec.limits.&lt;limit-name&gt;.rates</code>) <ul> <li>It allows to reuse <code>when</code> conditions and <code>counters</code> for groups of rate limits</li> </ul> Parsed <code>spec.rateLimits.limits.conditions</code> field, directly exposing the Limitador's API Structured <code>spec.limits.&lt;limit-name&gt;.when</code> condition field composed of 3 well-defined properties: <code>selector</code>, <code>operator</code> and <code>value</code> <ul> <li>Feels more K8s-native</li> <li>Consistent with github.com/kuadrant/authorino/api/v1beta1#JSONPatternExpression</li> <li>No need for a parser (only if implemented by Limitador)</li> </ul> <code>spec.rateLimits.configurations</code> as a list of \"variables assignments\" and direct exposure of Envoy's RL descriptor actions API Descriptor actions composed from selectors used in the limit definitions (<code>spec.limits.&lt;limit-name&gt;.when.selector</code> and <code>spec.limits.&lt;limit-name&gt;.counters</code>) plus a fixed identifier of the route rules (<code>spec.limits.&lt;limit-name&gt;.routeSelectors</code>) <ul> <li>Abstract the Envoy-specific concepts of \"actions\" and \"descriptors\"</li> <li>No risk of mismatching descriptors keys between \"actions\" and actual usage in the limits</li> <li>No user-defined generic descriptors (e.g. \"limited = 1\")</li> <li>Source value of the selectors defined from an implicit \"context\" data structure</li> </ul> Key-value descriptors Structured descriptors referring to a contextual well-known data structure <ul> <li>Consistent with Authorino's Authorization JSON (#context)</li> </ul> Limitador conditions independent from the route rules Artificial Limitador condition injected to bind routes and corresponding limits <ul> <li>Ensure the limit is enforced only for corresponding selected HTTPRouteRules</li> </ul> <code>translate(spec.rateLimits.rules) \u2282 httproute.spec.rules</code> <code>spec.limits.&lt;limit-name&gt;.routeSelectors.matches \u2286 httproute.spec.rules.matches</code> <ul> <li>HTTPRouteRule selector (via HTTPRouteMatch subset)</li> <li>Gateway API language</li> <li>Preparation for inherited policies and defaults &amp; overrides</li> </ul> <code>spec.rateLimits.limits.seconds</code> <code>spec.limits.&lt;limit-name&gt;.rates.duration</code> and <code>spec.limits.&lt;limit-name&gt;.rates.unit</code> <ul> <li>Support for more units beyond seconds</li> <li><code>duration: 1</code> by default</li> </ul> <code>spec.rateLimits.limits.variables</code> <code>spec.limits.&lt;limit-name&gt;.counters</code> <ul> <li>Improved (more specific) naming</li> </ul> <code>spec.rateLimits.limits.maxValue</code> <code>spec.limits.&lt;limit-name&gt;.rates.limit</code> <ul> <li>Improved (more generic) naming</li> </ul>"},{"location":"architecture/rfcs/0001-rlp-v2/#reference-level-explanation","title":"Reference-level explanation","text":"<p>By completely dropping out the <code>configurations</code> field from the RLP, composing the RL descriptor actions is now done based essentially on the selectors listed in the <code>when</code> conditions and the <code>counters</code>, plus an artificial condition used to bind the HTTPRouteRules to the corresponding limits to trigger in Limitador.</p> <p>The descriptor actions composed from the selectors in the \"soft\" <code>when</code> conditions and counter qualifiers originate from the direct references these selectors make to paths within a well-known data structure that stores information about the context (HTTP request and ext-authz filter). These selectors in \"soft\" <code>when</code> conditions and counter qualifiers are thereby called well-known selectors.</p> <p>Other descriptor actions might be composed by the RLP controller to define additional RL conditions to bind HTTPRouteRules and corresponding limits.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#well-known-selectors","title":"Well-known selectors","text":"<p>Each selector used in a <code>when</code> condition or counter qualifier is a direct reference to a path within a well-known data structure that stores information about the <code>context</code> (L4 and L7 data of the original request handled by the proxy), as well as <code>auth</code> data (dynamic metadata occasionally exported by the external authorization filter and injected by the proxy into the rate-limit filter).</p> <p>The well-known data structure for building RL descriptor actions resembles Authorino's \"Authorization JSON\", whose <code>context</code> component consists of Envoy's <code>AttributeContext</code> type of the external authorization API (marshalled as JSON). Compared to the more generic <code>RateLimitRequest</code> struct, the <code>AttributeContext</code> provides a more structured and arguibly more intuitive relation between the data sources for the RL descriptors actions and their corresponding key names through which the values are referred within the RLP, in a context of predominantly serving for HTTP applications.</p> <p>To keep compatibility with the Envoy Rate Limit API, the well-known data structure can optionally be extended with the <code>RateLimitRequest</code>, thus resulting in the following final structure.</p> <pre><code>context: # Envoy's Ext-Authz `CheckRequest.AttributeContext` type\n  source:\n    address: \u2026\n    service: \u2026\n    \u2026\n  destination:\n    address: \u2026\n    service: \u2026\n    \u2026\n  request:\n    http:\n      host: \u2026\n      path: \u2026\n      method: \u2026\n      headers: {\u2026}\n\nauth: # Dynamic metadata exported by the external authorization service\n\nratelimit: # Envoy's Rate Limit `RateLimitRequest` type\n  domain: \u2026 # generated by the Kuadrant controller\n  descriptors: {\u2026} # descriptors configured by the user directly in the proxy (not generated by the Kuadrant controller, if allowed)\n  hitsAddend: \u2026 # only in case we want to allow users to refer to this value in a policy\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#mechanics-of-generating-rl-descriptor-actions","title":"Mechanics of generating RL descriptor actions","text":"<p>From the perspective of a user who writes a RLP, the selectors used in then <code>when</code> and <code>counters</code> fields are paths to the well-known data structure (see Well-known selectors). While desiging a policy, the user intuitively pictures the well-known data structure and states each limit definition having in mind the possible values assumed by each of those paths in the data plane. For example,</p> <p>The user story:</p> <p>Each distinct user (<code>auth.identity.username</code>) can send no more than 1rps to the same HTTP path (<code>context.request.http.path</code>).</p> <p>...materializes as the following RLP:</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    dolls:\n      rates:\n\n      - limit: 1\n        unit: second\n      counters:\n      - auth.identity.username\n      - context.request.http.path\n</code></pre> <p>The following selectors are to be interpreted by the RLP controller:</p> <ul> <li><code>auth.identity.username</code></li> <li><code>context.request.http.path</code></li> </ul> <p>The RLP controller uses a map to translate each selector into its corresponding descriptor action. (Roughly described:)</p> <pre><code>context.source.address    \u2192 source_cluster(...) # TBC\ncontext.source.service    \u2192 source_cluster(...) # TBC\ncontext.destination...    \u2192 destination_cluster(...)\ncontext.destination...    \u2192 destination_cluster(...)\ncontext.request.http.&lt;X&gt;  \u2192 request_headers(header_name: \":&lt;X&gt;\")\ncontext.request...        \u2192 ...\nauth.&lt;X&gt;                  \u2192 metadata(key: \"envoy.filters.http.ext_authz\", path: &lt;X&gt;)\nratelimit.domain          \u2192 &lt;hostname&gt;\n</code></pre> <p>...to yield effectively:</p> <pre><code>rate_limits:\n\n- actions:\n  - metadata:\n      descriptor_key: \"auth.identity.username\"\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - segment:\n            key: \"identity\"\n        - segment:\n            key: \"username\"\n  - request_headers:\n      descriptor_key: \"context.request.http.path\"\n      header_name: \":path\"\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#artificial-limitador-condition-for-routeselectors","title":"Artificial Limitador condition for <code>routeSelectors</code>","text":"<p>For each limit definition that explicitly or implicitly defines a <code>routeSelectors</code> field, the RLP controller will generate an artificial Limitador condition that ensures that the limit applies only when the filterred rules are honoured when serving the request. This can be implemented with a 2-step procedure:</p> <ol> <li>generate an unique identifier of the limit - i.e. <code>&lt;policy-namespace&gt;/&lt;policy-name&gt;/&lt;limit-name&gt;</code></li> <li>associate a <code>generic_key</code> type descriptor action with each <code>HTTPRouteRule</code> targeted by the limit \u2013 i.e. <code>{ descriptor_key: &lt;unique identifier of the limit&gt;, descriptor_value: \"1\" }</code>.</li> </ol> <p>For example, given the following RLP:</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-non-admin-users\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    toys:\n      routeSelectors:\n\n      - matches:\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n          method: GET\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n          method: POST\n      rates:\n      - limit: 50\n        duration: 1\n        unit: minute\n      when:\n      - selector: auth.identity.group\n        operator: neq\n        value: admin\n\n    assets:\n      routeSelectors:\n\n      - matches:\n        - path:\n            type: PathPrefix\n            value: \"/assets/\"\n      rates:\n      - limit: 5\n        duration: 1\n        unit: minute\n      when:\n      - selector: auth.identity.group\n        operator: neq\n        value: admin\n</code></pre> <p>Apart from the following descriptor action associated with both routes:</p> <pre><code>- metadata:\n    descriptor_key: \"auth.identity.group\"\n    metadata_key:\n      key: \"envoy.filters.http.ext_authz\"\n      path:\n      - segment:\n          key: \"identity\"\n      - segment:\n          key: \"group\"\n</code></pre> <p>...and its corresponding Limitador condition:</p> <pre><code>auth.identity.group != \"admin\"\n</code></pre> <p>The following additional artificial descriptor actions will be generated:</p> <pre><code># associated with route rule GET|POST /toys*\n\n- generic_key:\n    descriptor_key: \"toystore/toystore-non-admin-users/toys\"\n    descriptor_value: \"1\"\n\n# associated with route rule /assets/*\n\n- generic_key:\n    descriptor_key: \"toystore/toystore-non-admin-users/assets\"\n    descriptor_value: \"1\"\n</code></pre> <p>...and their corresponding Limitador conditions.</p> <p>In the end, the following Limitador configuration is yielded:</p> <pre><code>- conditions:\n  - toystore/toystore-non-admin-users/toys == \"1\"\n  - auth.identity.group != \"admin\"\n  max_value: 50\n  seconds: 60\n  namespace: kuadrant\n\n\n- conditions:\n  - toystore/toystore-non-admin-users/assets == \"1\"\n  - auth.identity.group != \"admin\"\n  max_value: 5\n  seconds: 60\n  namespace: kuadrant\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#support-in-wasm-shim-and-envoy-rl-api","title":"Support in wasm shim and Envoy RL API","text":"<p>This proposal tries to keep compatibility with the Envoy API for rate limit and does not introduce any new requirement that otherwise would require the use of wasm shim to be implemented.</p> <p>In the case of implementation of this proposal in the wasm shim, all types of matchers supported by the HTTPRouteMatch type of Gateway API must be also supported in the <code>rate_limit_policies.gateway_actions.rules</code> field of the wasm plugin configuration. These include matchers based on path (prefix, exact), headers, query string parameters and method.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#drawbacks","title":"Drawbacks","text":"<p>HTTPRoute editing occasionally required Need to duplicate rules that don't explicitly include a matcher wanted for the policy, so that matcher can be added as a special case for each of those rules.</p> <p>Risk of over-targeting Some HTTPRouteRules might need to be split into more specific ones so a limit definition is not bound to beyond intended (e.g. target <code>method: GET</code> when the route matches <code>method: POST|GET</code>).</p> <p>Prone to consistency issues Typos and updates to the HTTPRoute can easily cause a mismatch and invalidate a RLP.</p> <p>Two types of conditions \u2013 <code>routeSelectors</code> and <code>when</code> conditions Although with different meanings (evaluates in the gateway vs. evaluated in Limitador) and meant for expressing different types of rules (HTTPRouteRule selectors vs. \"soft\" conditions based on attributes not related to the HTTP request), users might still perceive these as two ways of expressing conditions and find difficult to understand at first that \"soft\" conditions do not accept expressions related to attributes of the HTTP request.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#rationale-and-alternatives","title":"Rationale and alternatives","text":""},{"location":"architecture/rfcs/0001-rlp-v2/#targeting-full-httprouterules","title":"Targeting full HTTPRouteRules","text":"<p>Requiring users to specify full HTTPRouteRule matches in the RLP (as opposed to any subset of HTTPRoureMatches of targeted HTTPRouteRules \u2013 current proposal) contains some of the same drawbacks of this proposal, such as HTTPRoute editing occasionally required and prone to consistency issues. If, on one hand, it eliminates the risk of over-targeting, on the other hand, it does it at the cost of requiring excessively verbose policies written by the users, to the point of sometimes expecting user to have to specify trigger matching rules that are significantly more than what's originally and strictly intended.</p> <p>E.g.:</p> <p>On a HTTPRoute that contains the following HTTPRouteRules (simplified representation):</p> <pre><code>{ header: x-canary=true } \u2192 backend-canary\n{ * } \u2192 backend-rest\n</code></pre> <p>Where the user wants to define a RLP that targets <code>{ method: POST }</code>. First, the user needs to edit the HTTPRoute and duplicate the HTTPRouteRules:</p> <pre><code>{ header: x-canary=true, method: POST } \u2192 backend-canary\n{ header: x-canary=true } \u2192 backend-canary\n{ method: POST } \u2192 backend-rest\n{ * } \u2192 backend-rest\n</code></pre> <p>Then, user needs to include the following trigger in the RLP so only full HTTPRouteRules are specified:</p> <pre><code>{ header: x-canary=true, method: POST }\n{ method: POST }\n</code></pre> <p>The first matching rule of the trigger (i.e. <code>{ header: x-canary=true, method: POST }</code>) is beoynd the original user intent of targeting simply <code>{ method: POST }</code>.</p> <p>This issue can be even more concerning in the case of targeting gateways with multiple child HTTPRoutes. All the HTTPRoutes would have to be fixed and the HTTPRouteRules that cover for all the cases in all HTTPRoutes listed in the policy targeting the gateway.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#all-limit-definitions-apply-vs-limit-shadowing","title":"All limit definitions apply vs. Limit \"shadowing\"","text":"<p>The proposed binding between limit definition and HTTPRouteRules that trigger the limits was thought so multiple limit definitions can be bound to a same HTTPRouteRule that triggers those limits in Limitador. That means that no limit definition will \"shadow\" another at the level of the RLP controller, i.e. the RLP controller will honour the intended binding according to the selectors specified in the policy.</p> <p>Due to how things work as of today in Limitador nonetheless, i.e., the rule of the most restrictive limit wins, and because all limit definitions triggered by a given shared HTTPRouteRule, it might be the case that, across multiple limits triggered, one limit ends up \"shadowing\" other limits. However, that is by implementation of Limitador and therefore beyond the scope of the API.</p> <p>An alternative to the approach of allowing all limit definitions to be bound to a same selected HTTPRouteRules would be enforcing that, amongst multiple limit definitions targeting a same HTTPRouteRule, only the first of those limits definitions is bound to the HTTPRouteRule. This alternative approach effectively would cause the first limit to \"shadow\" any other on that particular HTTPRouteRule, as by implementation of the RLP controller (i.e., at API level).</p> <p>While the first approach causes an artificial Limitador condition of the form <code>&lt;policy-ns&gt;/&lt;policy-name&gt;/&lt;limit-name&gt; == \"1\"</code>, the alternative approach (\"limit shadowing\") could be implemented by generating a descriptor of the following form instead: <code>ratelimit.binding == \"&lt;policy-ns&gt;/&lt;policy-name&gt;/&lt;limit-name&gt;\"</code>.</p> <p>The downside of allowing multiple bindings to the same HTTPRouteRule is that all limits apply in Limitador, thus making status report frequently harder. The most restritive rate limit strategy implemented by Limitador might not be obvious to users who set multiple limit definitions and will require additional information reported back to the user about the actual status of the limit definitions stated in a RLP. On the other hand, it allows enables use cases of different limit definitions that vary on the counter qualifiers, additional \"soft\" conditions, or actual rate limit values to be triggered by a same HTTPRouteRule.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#writing-soft-when-conditions-based-on-attributes-of-the-http-request","title":"Writing \"soft\" <code>when</code> conditions based on attributes of the HTTP request","text":"<p>As a first step, users will not be able to write \"soft\" <code>when</code> conditions to selective apply rate limit definitions based on attributes of the HTTP request that otherwise could be specified using the <code>routeSelectors</code> field of the RLP instead.</p> <p>On one hand, using <code>when</code> conditions for route filtering would make it easy to define limits when the HTTPRoute cannot be modified to include the special rule. On the other hand, users would miss information in the status. An HTTPRouteRule for <code>GET|POST /toys*</code>, for example, that is targeted with an additional \"soft\" <code>when</code> condition that specifies that the method must be equal to <code>GET</code> and the path exactly equal to <code>/toys/special</code> (see Example 3) would be reported as rate limited with extra details that this is in fact only for <code>GET /toys/special</code>. For small deployments, this might be considered acceptable; however it would easily explode to unmanageable number of cases for deployments with only a few limit definitions and HTTPRouteRules.</p> <p>Moreover, by not specifying a more strict HTTPRouteRule for <code>GET /toys/special</code>, the RLP controller would bind the limit definition to other rules that would cause the rate limit filter to invoke the rate limit service (Limitador) for cases other than strictly <code>GET /toys/special</code>. Even if the rate limits would still be ensured to apply in Limitador only for <code>GET /toys/special</code> (due to the presence of a hypothetical \"soft\" <code>when</code> condition), an extra no-op hop to the rate limit service would happen. This is avoided with the current imposed limitation.</p> <p>Example of \"soft\" <code>when</code> conditions for rate limit based on attributes of the HTTP request (NOT SUPPORTED):</p> <pre><code>apiVersion: kuadrant.io/v2beta1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-special-toys\n  namespace: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    specialToys:\n      rates:\n\n      - limit: 150\n        unit: second\n      routeSelectors:\n      - matches: # matches the original HTTPRouteRule GET|POST /toys*\n        - path:\n            type: PathPrefix\n            value: \"/toys\"\n          method: GET\n      when:\n      - selector: context.request.http.method # cannot omit this selector or POST /toys/special would also be rate limited\n        operator: eq\n        value: GET\n      - selector: context.request.http.path\n        operator: eq\n        value: /toys/special\n</code></pre> <sub>How is this RLP would be implemented under the hood if supported?</sub> <pre><code>gateway_actions:\n\n- rules:\n  - paths: [\"/toys*\"]\n    methods: [\"GET\"]\n    hosts: [\"*.toystore.acme.com\"]\n  - paths: [\"/toys*\"]\n    methods: [\"POST\"]\n    hosts: [\"*.toystore.acme.com\"]\n  configurations:\n  - generic_key:\n      descriptor_key: \"toystore/toystore-special-toys/specialToys\"\n      descriptor_value: \"1\"\n  - request_headers:\n      descriptor_key: \"context.request.http.method\"\n      header_name: \":method\"\n  - request_headers:\n      descriptor_key: \"context.request.http.path\"\n      header_name: \":path\"\n</code></pre> <pre><code>limits:\n\n- conditions:\n  - toystore/toystore-special-toys/specialToys == \"1\"\n  - context.request.http.method == \"GET\"\n  - context.request.http.path == \"/toys/special\"\n  max_value: 150\n  seconds: 1\n  namespace: kuadrant\n</code></pre>"},{"location":"architecture/rfcs/0001-rlp-v2/#possible-variations-for-the-selectors-conditions-and-counter-qualifiers","title":"Possible variations for the selectors (conditions and counter qualifiers)","text":"<p>The main drivers behind the proposed design for the selectors (conditions and counter qualifiers), based on (i) structured condition expressions composed of fields <code>selector</code>, <code>operator</code>, and <code>value</code>, and (ii) <code>when</code> conditions and <code>counters</code> separated in two distinct fields (variation \"C\" below), are:</p> <ol> <li>consistency with the Authorino <code>AuthConfig</code> API, which also specifies <code>when</code> conditions expressed in <code>selector</code>, <code>operator</code>, and <code>value</code> fields;</li> <li>explicit user intent, without subtle distinction of meaning based on presence of optional fields.</li> </ol> <p>Nonetheless here are a few alternative variations to consider:</p> Structured condition expressions Parsed condition expressions Single field A <pre>\nselectors:\n\n  - selector: context.request.http.method\n    operator: eq\n    value: GET\n  - selector: auth.identity.username</pre> B <pre>\nselectors:\n  - context.request.http.method == \"GET\"\n  - auth.identity.username</pre> Distinct fields C <sup>\u2b50\ufe0f</sup> <pre>\nwhen:\n  - selector: context.request.http.method\n    operator: eq\n    value: GET\ncounters:\n  - auth.identity.username</pre> D <pre>\nwhen:\n  - context.request.http.method == \"GET\"\ncounters:\n  - auth.identity.username</pre> <p><sup>\u2b50\ufe0f Variation adopted for the examples and (so far) final design proposal.</sup></p>"},{"location":"architecture/rfcs/0001-rlp-v2/#prior-art","title":"Prior art","text":"<p>Most implementations currently orbiting around Gateway API (e.g. Istio, Envoy Gateway, etc) for added RL functionality seem to have been leaning more to the direct route extension pattern instead of Policy Attachment. That might be an option particularly suitable for gateway implementations (gateway providers) and for those aiming to avoid dealing with defaults and overrides.</p>"},{"location":"architecture/rfcs/0001-rlp-v2/#unresolved-questions","title":"Unresolved questions","text":"<ol> <li>In case a limit definition lists route selectors such that some can be bound to HTTPRouteRules and some cannot (see Example 6), do we bind the valid route selectors and ignore the invalid ones or the limit definition is invalid altogether and bound to no HTTPRouteRule at all? A: By allowing multiple limit definitions to target a same HTTPRouteRule, the issue here stated will become less often. For the other cases where a limit definition still fails to select an HTTPRouteRule (e.g. due to mismatching trigger matches), the limit definition is not considered invalid. Possibly the limit definitions is considered \"stale\" (or \"orphan\"), i.e., not bound to any HTTPRouteRule.</li> <li>What should we fill domain/namespace with, if no longer with the hostname? This can be useful for multi-tenancy. A: For now, the domain/namespace field of the RL configuration (Envoy and Limitador ends) will be filled with a fixed (configurable) string (e.g. \"kuadrant\"). This can change in future to better support multi-tenancy and/or other use cases where a total sharding of the limit definitions within a same instance of Kuadrant is desired.</li> <li>How do we support lists of hostnames in Limitador conditions (single counter)? Should we open an issue for a new <code>in</code> operator? A: Not needed. The hostnames must exist in the targeted object explicitly, just like any other routing rules intended to be targeted by a limit definition. By setting the explicit hostname in the targeted network object (Gateway or HTTPRoute), the also becomes a route rules available for \"hard\" trigger configuration.</li> <li>What \"soft\" condition <code>operator</code>s do we need to support (e.g. <code>eq</code>, <code>neq</code>, <code>exists</code>, <code>nexists</code>, <code>matches</code>)?</li> <li>Do we need special field to define shared counters across clusters/Limitador instances or that's to be solved at another layer (<code>Limitador</code>, <code>Kuadrant</code> CRDs, MCTC)?</li> </ol>"},{"location":"architecture/rfcs/0001-rlp-v2/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Port <code>routeSelectors</code> and the semantics around it to the <code>AuthPolicy</code> API (aka \"KAP v2\").</li> <li>Defaults and overrides, either along the lines of architecture#4 or architecture#10.</li> </ul>"},{"location":"architecture/rfcs/0002-well-known-attributes/","title":"Well-known Attributes","text":"<ul> <li>Feature Name: <code>well-known-attributes</code></li> <li>Start Date: 2023-06-13</li> <li>RFC PR: Kuadrant/architecture#17</li> <li>Issue tracking: Kuadrant/architecture#53</li> </ul>"},{"location":"architecture/rfcs/0002-well-known-attributes/#summary","title":"Summary","text":"<p>Define a well-known structure for users to declare request data selectors in their RateLimitPolicies and AuthPolicies. This structure is referred to as the Kuadrant Well-known Attributes.</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#motivation","title":"Motivation","text":"<p>The well-known attributes let users write policy rules \u2013 conditions and, in general, dynamic values that refer to attributes in the data plane - in a concise and seamless way.</p> <p>Decoupled from the policy CRDs, the well-known attributes:</p> <ol> <li>define a common language for referring to values of the data plane in the Kuadrant policies;</li> <li>allow dynamically evolving the policy APIs regarding how they admit references to data plane attributes;</li> <li>encompass all common and component-specific selectors for data plane attributes;</li> <li>have a single and unified specification, although this specification may occasionally link to additional, component-specific, external docs.</li> </ol>"},{"location":"architecture/rfcs/0002-well-known-attributes/#guide-level-explanation","title":"Guide-level explanation","text":"<p>One who writes a Kuadrant policy and wants to build policy constructs such as conditions, qualifiers, variables, etc, based on dynamic values of the data plane, must refer the attributes that carry those values, using the declarative language of Kuadrant's Well-known Attributes.</p> <p>A dynamic data plane value is typically a value of an attribute of the request or an Envoy Dynamic Metadata entry. It can be a value of the outer request being handled by the API gateway or proxy that is managed by Kuadrant (\"context request\") or an attribute of the direct request to the Kuadrant component that delivers the functionality in the data plane (rate-limiting or external auth).</p> <p>A Well-known Selector is a construct of a policy API whose value contains a direct reference to a well-known attribute. The language of the well-known attributes and therefore what one would declare within a well-known selector resembles a JSON path for navigating a possibly complex JSON object.</p> <p>Example 1. Well-known selector used in a condition</p> <pre><code>apiGroup: examples.kuadrant.io\nkind: PaintPolicy\nspec:\n  rules:\n\n  - when:\n    - selector: auth.identity.group\n      operator: eq\n      value: admin\n    color: red\n</code></pre> <p>In the example, <code>auth.identity.group</code> is a well-known selector of an attribute <code>group</code>, known to be injected by the external authorization service (<code>auth</code>) to describe the group the user (<code>identity</code>) belongs to. In the data plane, whenever this value is equal to <code>admin</code>, the abstract <code>PaintPolicy</code> policy states that the traffic must be painted <code>red</code>.</p> <p>Example 2. Well-known selector used in a variable</p> <pre><code>apiGroup: examples.kuadrant.io\nkind: PaintPolicy\nspec:\n  rules:\n\n  - color: red\n    alpha:\n      dynamic: request.headers.x-color-alpha\n</code></pre> <p>In the example, <code>request.headers.x-color-alpha</code> is a selector of a well-known attribute <code>request.headers</code> that gives access to the headers of the context HTTP request. The selector retrieves the value of the <code>x-color-alpha</code> request header to dynamically fill the <code>alpha</code> property of the abstract <code>PaintPolicy</code> policy at each request.</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#reference-level-explanation","title":"Reference-level explanation","text":"<p>The Well-known Attributes are a compilation inspired by some of the Envoy attributes and Authorino's Authorization JSON and its related JSON paths.</p> <p>From the Envoy attributes, only attributes that are available before establishing connection with the upstream server qualify as a Kuadrant well-known attribute. This excludes attributes such as the response attributes and the upstream attributes.</p> <p>As for the attributes inherited from Authorino, these are either based on Envoy's <code>AttributeContext</code> type of the external auth request API or from internal types defined by Authorino to fulfill the Auth Pipeline.</p> <p>These two subsets of attributes are unified into a single set of well-known attributes. For each attribute that exists in both subsets, the name of the attribute as specified in the Envoy attributes subset prevails. Example of such is <code>request.id</code> (to refer to the ID of the request) superseding <code>context.request.http.id</code> (as the same attribute is referred in an Authorino <code>AuthConfig</code>).</p> <p></p> <p>The next sections specify the well-known attributes organized in the following groups:</p> <ul> <li>Request attributes</li> <li>Connection attributes</li> <li>Metadata and filter state attributes</li> <li>Auth attributes</li> <li>Rate-limit attributes</li> </ul>"},{"location":"architecture/rfcs/0002-well-known-attributes/#request-attributes","title":"Request attributes","text":"<p>The following attributes are related to the context HTTP request that is handled by the API gateway or proxy managed by Kuadrant.</p> <p>Attribute</p> <p>Type</p> <p>Description</p> <p>Auth</p> <p>RL</p> <p>request.id</p> <p>String</p> <p>Request ID corresponding to <code>x-request-id</code> header value</p> <p>\u2713</p> <p>\u2713</p> <p>request.time</p> <p>Timestamp</p> <p>Time of the first byte received</p> <p>\u2713</p> <p>\u2713</p> <p>request.protocol</p> <p>String</p> <p>Request protocol (\u201cHTTP/1.0\u201d, \u201cHTTP/1.1\u201d, \u201cHTTP/2\u201d, or \u201cHTTP/3\u201d)</p> <p>\u2713</p> <p>\u2713</p> <p>request.scheme</p> <p>String</p> <p>The scheme portion of the URL e.g. \u201chttp\u201d</p> <p>\u2713</p> <p>\u2713</p> <p>request.host</p> <p>String</p> <p>The host portion of the URL</p> <p>\u2713</p> <p>\u2713</p> <p>request.method</p> <p>String</p> <p>Request method e.g. \u201cGET\u201d</p> <p>\u2713</p> <p>\u2713</p> <p>request.path</p> <p>String</p> <p>The path portion of the URL</p> <p>\u2713</p> <p>\u2713</p> <p>request.url_path</p> <p>String</p> <p>The path portion of the URL without the query string</p> <p></p> <p>\u2713</p> <p>request.query</p> <p>String</p> <p>The query portion of the URL in the format of \u201cname1=value1&amp;name2=value2\u201d</p> <p>\u2713</p> <p>\u2713</p> <p>request.headers</p> <p>Map&lt;String, String&gt;</p> <p>All request headers indexed by the lower-cased header name</p> <p>\u2713</p> <p>\u2713</p> <p>request.referer</p> <p>String</p> <p>Referer request header</p> <p></p> <p>\u2713</p> <p>request.useragent</p> <p>String</p> <p>User agent request header</p> <p></p> <p>\u2713</p> <p>request.size</p> <p>Number</p> <p>The HTTP request size in bytes. If unknown, it must be -1</p> <p>\u2713</p> <p></p> <p>request.body</p> <p>String</p> <p>The HTTP request body. (Disabled by default. Requires additional proxy configuration to enabled it.)</p> <p>\u2713</p> <p></p> <p>request.raw_body</p> <p>Array&lt;Number&gt;</p> <p>The HTTP request body in bytes. This is sometimes used instead of <code>body</code> depending on the proxy configuration.</p> <p>\u2713</p> <p></p> <p>request.context_extensions</p> <p>Map&lt;String, String&gt;</p> <p>This is analogous to <code>request.headers</code>, however these contents are not sent to the upstream server. It provides an extension mechanism for sending additional information to the auth service without modifying the proto definition. It maps to the internal opaque context in the proxy filter chain. (Requires additional configuration in the proxy.)</p> <p>\u2713</p> <p></p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#connection-attributes","title":"Connection attributes","text":"<p>The following attributes are available once the downstream connection with the API gateway or proxy managed by Kuadrant is established. They apply to HTTP requests (L7) as well, but also to proxied connections limited at L3/L4.</p> <p>Attribute</p> <p>Type</p> <p>Description</p> <p>Auth</p> <p>RL</p> <p>source.address</p> <p>String</p> <p>Downstream connection remote address</p> <p>\u2713</p> <p>\u2713</p> <p>source.port</p> <p>Number</p> <p>Downstream connection remote port</p> <p>\u2713</p> <p>\u2713</p> <p>source.service</p> <p>String</p> <p>The canonical service name of the peer</p> <p>\u2713</p> <p></p> <p>source.labels</p> <p>Map&lt;String, String&gt;</p> <p>The labels associated with the peer. These could be pod labels for Kubernetes or tags for VMs. The source of the labels could be an X.509 certificate or other configuration.</p> <p>\u2713</p> <p></p> <p>source.principal</p> <p>String</p> <p>The authenticated identity of this peer. If an X.509 certificate is used to assert the identity in the proxy, this field is sourced from \u201cURI Subject Alternative Names\u201c, \u201cDNS Subject Alternate Names\u201c or \u201cSubject\u201c in that order. The format is issuer specific \u2013 e.g. SPIFFE format is <code>spiffe://trust-domain/path</code>, Google account format is <code>https://accounts.google.com/{userid}</code>.</p> <p>\u2713</p> <p></p> <p>source.certificate</p> <p>String</p> <p>The X.509 certificate used to authenticate the identify of this peer. When present, the certificate contents are encoded in URL and PEM format.</p> <p>\u2713</p> <p></p> <p>destination.address</p> <p>String</p> <p>Downstream connection local address</p> <p>\u2713</p> <p>\u2713</p> <p>destination.port</p> <p>Number</p> <p>Downstream connection local port</p> <p>\u2713</p> <p>\u2713</p> <p>destination.service</p> <p>String</p> <p>The canonical service name of the peer</p> <p>\u2713</p> <p></p> <p>destination.labels</p> <p>Map&lt;String, String&gt;</p> <p>The labels associated with the peer. These could be pod labels for Kubernetes or tags for VMs. The source of the labels could be an X.509 certificate or other configuration.</p> <p>\u2713</p> <p></p> <p>destination.principal</p> <p>String</p> <p>The authenticated identity of this peer. If an X.509 certificate is used to assert the identity in the proxy, this field is sourced from \u201cURI Subject Alternative Names\u201c, \u201cDNS Subject Alternate Names\u201c or \u201cSubject\u201c in that order. The format is issuer specific \u2013 e.g. SPIFFE format is <code>spiffe://trust-domain/path</code>, Google account format is <code>https://accounts.google.com/{userid}</code>.</p> <p>\u2713</p> <p></p> <p>destination.certificate</p> <p>String</p> <p>The X.509 certificate used to authenticate the identify of this peer. When present, the certificate contents are encoded in URL and PEM format.</p> <p>\u2713</p> <p></p> <p>connection.id</p> <p>Number</p> <p>Downstream connection ID</p> <p></p> <p>\u2713</p> <p>connection.mtls</p> <p>Boolean</p> <p>Indicates whether TLS is applied to the downstream connection and the peer ceritificate is presented</p> <p></p> <p>\u2713</p> <p>connection.requested_server_name</p> <p>String</p> <p>Requested server name in the downstream TLS connection</p> <p></p> <p>\u2713</p> <p>connection.tls_session.sni</p> <p>String</p> <p>SNI used for TLS session</p> <p>\u2713</p> <p></p> <p>connection.tls_version</p> <p>String</p> <p>TLS version of the downstream TLS connection</p> <p></p> <p>\u2713</p> <p>connection.subject_local_certificate</p> <p>String</p> <p>The subject field of the local certificate in the downstream TLS connection</p> <p></p> <p>\u2713</p> <p>connection.subject_peer_certificate</p> <p>String</p> <p>The subject field of the peer certificate in the downstream TLS connection</p> <p></p> <p>\u2713</p> <p>connection.dns_san_local_certificate</p> <p>String</p> <p>The first DNS entry in the SAN field of the local certificate in the downstream TLS connection</p> <p></p> <p>\u2713</p> <p>connection.dns_san_peer_certificate</p> <p>String</p> <p>The first DNS entry in the SAN field of the peer certificate in the downstream TLS connection</p> <p></p> <p>\u2713</p> <p>connection.uri_san_local_certificate</p> <p>String</p> <p>The first URI entry in the SAN field of the local certificate in the downstream TLS connection</p> <p></p> <p>\u2713</p> <p>connection.uri_san_peer_certificate</p> <p>String</p> <p>The first URI entry in the SAN field of the peer certificate in the downstream TLS connection</p> <p></p> <p>\u2713</p> <p>connection.sha256_peer_certificate_digest</p> String <p>SHA256 digest of the peer certificate in the downstream TLS connection if present</p> <p></p> <p>\u2713</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#metadata-and-filter-state-attributes","title":"Metadata and filter state attributes","text":"<p>The following attributes are related to the Envoy proxy filter chain. They include metadata exported by the proxy throughout the filters and information about the states of the filters themselves.</p> <p>Attribute</p> <p>Type</p> <p>Description</p> <p>Auth</p> <p>RL</p> <p>metadata</p> <p>Metadata</p> <p>Dynamic request metadata</p> <p>\u2713</p> <p>\u2713</p> <p>filter_state</p> <p>Map&lt;String, String&gt;</p> <p>Mapping from a filter state name to its serialized string value</p> <p></p> <p>\u2713</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#auth-attributes","title":"Auth attributes","text":"<p>The following attributes are exclusive of the external auth service (Authorino).</p> <p>Attribute</p> <p>Type</p> <p>Description</p> <p>Auth</p> <p>RL</p> <p>auth.identity</p> <p>Any</p> <p>Single resolved identity object, post-identity verification</p> <p>\u2713</p> <p></p> <p>auth.metadata</p> <p>Map&lt;String, Any&gt;</p> <p>External metadata fetched</p> <p>\u2713</p> <p></p> <p>auth.authorization</p> <p>Map&lt;String, Any&gt;</p> <p>Authorization results resolved by each authorization rule, access granted only</p> <p>\u2713</p> <p></p> <p>auth.response</p> <p>Map&lt;String, Any&gt;</p> <p>Response objects exported by the auth service post-access granted</p> <p>\u2713</p> <p></p> <p>auth.callbacks</p> <p>Map&lt;String, Any&gt;</p> <p>Response objects returned by the callback requests issued by the auth service</p> <p>\u2713</p> <p></p> <p>The auth service also supports modifying selected values by chaining modifiers in the path.</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#rate-limit-attributes","title":"Rate-limit attributes","text":"<p>The following attributes are exclusive of the rate-limiting service (Limitador).</p> <p>Attribute</p> <p>Type</p> <p>Description</p> <p>Auth</p> <p>RL</p> <p>ratelimit.domain</p> <p>String</p> <p>The rate limit domain. This enables the configuration to be namespaced per application (multi-tenancy).</p> <p></p> <p>\u2713</p> <p>ratelimit.hits_addend</p> <p>Number</p> <p>Specifies the number of hits a request adds to the matched limit. Fixed value: `1`. Reserved for future usage.</p> <p></p> <p>\u2713</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#drawbacks","title":"Drawbacks","text":"<p>The decoupling of the well-known attributes and the language of well-known attributes and selectors from the individual policy CRDs is what makes it somewhat flexible and common across the components (rate-limiting and auth). However, it's less structured and it introduces another syntax for users to get familiar with.</p> <p>This additional language competes with the language of the route selectors (RFC 0001), based on Gateway API's <code>HTTPRouteMatch</code> type.</p> <p>Being \"soft-coded\" in the policy specs (as opposed to a hard-coded sub-structure inside of each policy type) does not mean it's completely decoupled from implementation in the control plane and/or intermediary data plane components. Although many attributes can be supported almost as a pass-through, from being used in a selector in a policy, to a corresponding value requested by the wasm-shim to its host, that is not always the case. Some translation may be required for components not integrated via wasm-shim (e.g. Authorino), as well as for components integrated via wasm-shim (e.g. Limitador) in special cases of composite or abstraction well-known attributes (i.e. attributes not available as-is via ABI, e.g. <code>auth.identity</code> in a RLP). Either way, some validation of the values introduced by users in the selectors may be needed at some point in the control plane, thus requiring arguably a level of awaresness and coupling between the well-known selectors specification and the control plane (policy controllers) or intermediary data plane (wasm-shim) components.</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>As an alternative to JSON path-like selectors based on a well-known structure that induces the proposed language of well-known attributes, these same attributes could be defined as sub-types of each policy CRD. The Golang packages defining the common attributes across CRDs could be shared by the policy type definitions to reduce repetition. However, that approach would possibly involve a staggering number of new type definitions to cover all the cases for all the groups of attributes to be supported. These are constructs that not only need to be understood by the policy controllers, but also known by the user who writes a policy.</p> <p>Additionally, all attributes, including new attributes occasionally introduced by Envoy and made available to the wasm-shim via ABI, would always require translation from the user-level abstraction how it's represented in a policy, to the actual form how it's used in the wasm-shim configuration and Authorino AuthConfigs.</p> <p>Not implementing this proposal and keeping the current state of things mean little consistency between these common constructs for rules and conditions on how they are represented in each type of policy. This lack of consistency has a direct impact on the overhead faced by users to learn how to interact with Kuadrant and write different kinds of policies, as well as for the maintainers on tasks of coding for policy validation and reconciliation of data plane configurations.</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#prior-art","title":"Prior art","text":"<p>Authorino's dynamic JSON paths, related to Authorino's Authorization JSON and used in <code>when</code> conditions and inside of multiple other constructs of the AuthConfig, are an example of feature of very similar approach to the one proposed here.</p> <p>Arguably, Authorino's perceived flexibility would not have been possible with the Authorization JSON selectors. Users can write quite sophisticated policy rules (conditions, variable references, etc) by leveraging the those dynamic selectors. Because they are backed by JSON-based machinery in the code, Authorino's selectors have very little to, in some cases, none at all variation compared Open Policy Agent's Rego policy language, which is often used side by side in the same AuthConfigs.</p> <p>Authorino's Authorization JSON selectors are, in one hand, more restrict to the structure of the <code>CheckRequest</code> payload (<code>context.*</code> attributes). At the same time, they are very open in the part associated with the internal attributes built along the Auth Pipeline (i.e. <code>auth.*</code> attributes). That makes Authorino's Authorization JSON selectors more limited, compared to the Envoy attributes made available to the wasm-shim via ABI, but also harder to validate. In some cases, such as of deep references to inside objects fetched from external sources of metadata, resolved OPA objects, JWT claims, etc, it is impossible to validate for correct references.</p> <p>Another experience learned from Authorino's Authorization JSON selectors is that they depend substantially on the so-called \"modifiers\". Many use cases involving parsing and breaking down attributes that are originally available in a more complex form would not be possible without the modifiers. Examples of such cases are: extracting portions of the path and/or query string parameters (e.g. collection and resource identifiers), applying translations on HTTP verbs into corresponding operations, base64-decoding values from the context HTTP request, amongst several others.</p>"},{"location":"architecture/rfcs/0002-well-known-attributes/#unresolved-questions","title":"Unresolved questions","text":"<ol> <li> <p>How to deal with the differences regarding the availability and data types of the attributes across clients/hosts?</p> </li> <li> <p>Can we make more attributes that are currently available to only one of the components common to both?</p> </li> <li> <p>Will we need some kind of global support for modifiers (functions) in the well-known selectors or those can continue to be an Authorino-only feature?</p> </li> <li> <p>Does Authorino, which is more strict regarding the data structure that induces the selectors, need to implement this specification or could/should it keep its current selectors and a translation be performed by the AuthPolicy controller?</p> </li> </ol>"},{"location":"architecture/rfcs/0002-well-known-attributes/#future-possibilities","title":"Future possibilities","text":"<ol> <li>Extend with more well-known attributes that abstract common patterns and/or for rather opinioned use cases. Examples:</li> <li><code>auth.*</code> attributes supported in the rate limit service</li> <li><code>request.authenticated</code></li> <li><code>request.operation.(read|write)</code></li> <li><code>request.param.my-param</code></li> <li> <p><code>connection.secure</code></p> </li> <li> <p>Other Envoy attributes</p> </li> </ol> Wasm attributes <p>Attribute</p> <p>Type</p> <p>Description</p> <p>Auth</p> <p>RL</p> <p>wasm.plugin_name</p> <p>String</p> <p>Plugin name</p> <p></p> <p>\u2713</p> <p>wasm.plugin_root_id</p> <p>String</p> <p>Plugin root ID</p> <p></p> <p>\u2713</p> <p>wasm.plugin_vm_id</p> <p>String</p> <p>Plugin VM ID</p> <p></p> <p>\u2713</p> <p>wasm.node</p> <p>Node</p> <p>Local node description</p> <p></p> <p>\u2713</p> <p>wasm.cluster_name</p> <p>String</p> <p>Upstream cluster name</p> <p></p> <p>\u2713</p> <p>wasm.cluster_metadata</p> <p>Metadata</p> <p>Upstream cluster metadata</p> <p></p> <p>\u2713</p> <p>wasm.listener_direction</p> <p>Number</p> <p>Enumeration value of the listener traffic direction</p> <p></p> <p>\u2713</p> <p>wasm.listener_metadata</p> <p>Metadata</p> <p>Listener metadata</p> <p></p> <p>\u2713</p> <p>wasm.route_name</p> <p>String</p> <p>Route name</p> <p></p> <p>\u2713</p> <p>wasm.route_metadata</p> <p>Metadata</p> <p>Route metadata</p> <p></p> <p>\u2713</p> <p>wasm.upstream_host_metadata</p> <p>Metadata</p> <p>Upstream host metadata</p> <p></p> <p>\u2713</p> Proxy configuration attributes <p>Attribute</p> <p>Type</p> <p>Description</p> <p>Auth</p> <p>RL</p> <p>xds.cluster_name</p> <p>String</p> <p>Upstream cluster name</p> <p></p> <p>\u2713</p> <p>xds.cluster_metadata</p> <p>Metadata</p> <p>Upstream cluster metadata</p> <p></p> <p>\u2713</p> <p>xds.route_name</p> <p>String</p> <p>Route name</p> <p></p> <p>\u2713</p> <p>xds.route_metadata</p> <p>Metadata</p> <p>Route metadata</p> <p></p> <p>\u2713</p> <p>xds.upstream_host_metadata</p> <p>Metadata</p> <p>Upstream host metadata</p> <p></p> <p>\u2713</p> <p>xds.filter_chain_name</p> <p>String</p> <p>Listener filter chain name</p> <p></p> <p>\u2713</p> <ol> <li>Add some support for value modifiers (functions), along the lines of Authorino's JSON path modifiers and/or Envoy attributes' path expressions.</li> </ol>"},{"location":"architecture/rfcs/0003-dns-policy/","title":"RFC Template","text":"<ul> <li>Feature Name: DNSPolicy</li> <li>Start Date: 2023-07-01</li> <li>RFC PR: Kuadrant/architecture#20</li> <li>Issue tracking: Kuadrant/multicluster-gateway-controller#219</li> <li>Labels: DNS, Load Balancing, Multi-Cluster</li> </ul>"},{"location":"architecture/rfcs/0003-dns-policy/#summary","title":"Summary","text":"<p>Provide a policy for configuring how DNS should be handed for a given gateway. Provide a mechanism for enabling DNS based load balancing.</p>"},{"location":"architecture/rfcs/0003-dns-policy/#motivation","title":"Motivation","text":"<p>Gateway admins, need a way to define the DNS policy for a multi-cluster gateway in order to control how much and which traffic reaches these gateways.  Ideally we would allow them to express a strategy that they want to use without needing to get into the details of each provider and needing to create and maintain dns record structure and individual records for all the different gateways that may be within their infrastructure.</p>"},{"location":"architecture/rfcs/0003-dns-policy/#guide-level-explanation","title":"Guide-level explanation","text":"<p>Allow definition of a DNSPolicy that configures load balancing to decide how traffic should be distributed across multiple gateway instances from the central control plane.</p>"},{"location":"architecture/rfcs/0003-dns-policy/#terms","title":"Terms","text":"<ul> <li>managed listener: This is a listener with a host backed by a DNS zone managed by the multi-cluster gateway controller</li> <li>hub cluster: control plane cluster that managed 1 or more spokes</li> <li>spoke cluster: a cluster managed by the hub control plane cluster. This is where gateway are instantiated</li> </ul> <p>Provide a control plane DNSPolicy API that uses the idea of direct policy attachment from gateway API that allows a load balancing strategy to be applied to the DNS records structure for any managed listeners being served by the data plane instances of this gateway.  The DNSPolicy also covers health checks that inform the DNS response but that is not covered in this document.</p> <p>Below is a draft API for what we anticipate the DNSPolicy to look like</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nspec:\n  targetRef: # defaults to gateway gvk and current namespace\n    name: gateway-name\n  health:\n   ...\n  loadBalancing:\n    weighted:\n     defaultWeight: 10\n     custom: #optional\n\n     - value: AWS  #optional with both GEO and weighted. With GEO the custom weight is applied to gateways within a Geographic region\n       weight: 10\n     - value: GCP\n       weight: 20\n    GEO: #optional\n      defaultGeo: IE # required with GEO. Chooses a default DNS response when no particular response is defined for a request from an unknown GEO.\n</code></pre>"},{"location":"architecture/rfcs/0003-dns-policy/#available-load-balancing-strategies","title":"Available Load Balancing Strategies","text":"<p>GEO and Weighted load balancing are well understood strategies and this API effectively allow a complex requirement to be expressed relatively simply and executed by the gateway controller in the chosen DNS provider. Our default policy will execute a \"Round Robin\" weighted strategy which reflects the current default behaviour.</p> <p>With the above API we can provide weighted and GEO and weighted within a GEO. A weighted strategy with a minimum of a default weight is always required and the simplest type of policy. The multi-cluster gateway controller will set up a default policy when a gateway is discovered (shown below). This policy can be replaced or modified by the user.  A weighted strategy can be complimented with a GEO strategy IE they can be used together in order to provide a GEO and weighted (within a GEO) load balancing. By defining a GEO section, you are indicating that you want to use a GEO based strategy (how this works is covered below).</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nname: default-policy\nspec:\n  targetRef: # defaults to gateway gvk and current namespace\n    name: gateway-name\n  loadBalancing:\n    weighted: # required\n     defaultWeight: 10  #required, all records created get this weight\n  health:\n   ...   \n</code></pre> <p>In order to provide GEO based DNS and allow customisation of the weighting, we need some additional information to be provided by the gateway / cluster admin about where this gateway has been placed. For example if they want to use GEO based DNS as a strategy, we need to know what GEO identifier(s) to use for each record we create and a default GEO to use as a catch-all. Also, if the desired load balancing approach is to provide custom weighting and no longer simply use Round Robin, we will need a way to identify which records to apply that custom weighting to based on the clusters the gateway is placed on.</p> <p>To solve this we will allow two new attributes to be added to the <code>ManagedCluster</code> resource as labels:</p> <pre><code>   kuadrant.io/lb-attribute-geo-code: \"IE\"\n   kuadrant.io/lb-attribute-custom-weight: \"GCP\"\n</code></pre> <p>These two labels allow setting values in the DNSPolicy that will be reflected into DNS records for gateways placed on that cluster depending on the strategies used. (see the first DNSPolicy definition above to see how these values are used) or take a look at the examples at the bottom.</p> <p>example : <pre><code>apiVersion: cluster.open-cluster-management.io/v1\nkind: ManagedCluster\nmetadata:\n labels:\n   kuadrant.io/lb-attribute-geo-code: \"IE\"\n   kuadrant.io/lb-attribute-custom-weight: \"GCP\"\nspec:    \n</code></pre></p> <p>The attributes provide the key and value we need in order to understand how to define records for a given LB address based on the DNSPolicy targeting the gateway.</p> <p>The <code>kuadrant.io/lb-attribute-geo-code</code> attribute value is provider specific, using an invalid code will result in an error status condition in the DNSrecord resource. </p>"},{"location":"architecture/rfcs/0003-dns-policy/#dns-record-structure","title":"DNS Record Structure","text":"<p>This is an advanced topic and so is broken out into its own proposal doc DNS Record Structure</p>"},{"location":"architecture/rfcs/0003-dns-policy/#custom-weighting","title":"Custom Weighting","text":"<p>Custom weighting will use the associated <code>custom-weight</code> attribute set on the <code>ManagedCluster</code> to decide which records should get a specific weight. The value of this attribute is up to the end user.</p> <p>example:</p> <pre><code>apiVersion: cluster.open-cluster-management.io/v1\nkind: ManagedCluster\nmetadata:\n labels:\n   kuadrant.io/lb-attribute-custom-weight: \"GCP\"\n</code></pre> <p>The above is then used in the DNSPolicy to set custom weights for the records associated with the target gateway.</p> <pre><code>    - value: GCP\n      weight: 20\n</code></pre> <p>So any gateway targeted by a DNSPolicy with the above definition that is placed on a <code>ManagedCluster</code> with the <code>kuadrant.io/lb-attribute-custom-weight</code> set with a value of GCP will get an A record with a weight of 20 </p>"},{"location":"architecture/rfcs/0003-dns-policy/#status","title":"Status","text":"<p>DNSPolicy should have a ready condition that reflect that the DNSRecords have been created and configured as expected. In the case that there is an invalid policy, the status message should reflect this and indicate to the user that the old DNS has been preserved.</p> <p>We will also want to add a status condition to the gateway status indicating it is effected by this policy. Gateway API recommends the following status condition </p> <pre><code>- type: gateway.networking.k8s.io/PolicyAffected\n  status: True \n  message: \"DNSPolicy has been applied\"\n  reason: PolicyApplied\n  ...\n</code></pre> <p>https://github.com/kubernetes-sigs/gateway-api/pull/2128/files#diff-afe84021d0647e83f420f99f5d18b392abe5ec82d68f03156c7534de9f19a30aR888</p>"},{"location":"architecture/rfcs/0003-dns-policy/#example-policies","title":"Example Policies","text":""},{"location":"architecture/rfcs/0003-dns-policy/#round-robin-the-default-policy","title":"Round Robin (the default policy)","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nname: RoundRobinPolicy\nspec:\n  targetRef: # defaults to gateway gvk and current namespace\n    name: gateway-name\n  loadBalancing:\n    weighted:\n     defaultWeight: 10\n</code></pre>"},{"location":"architecture/rfcs/0003-dns-policy/#geo-round-robin","title":"GEO (Round Robin)","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nname: GEODNS\nspec:\n  targetRef: # defaults to gateway gvk and current namespace\n    name: gateway-name\n  loadBalancing:\n    weighted:\n     defaultWeight: 10\n    GEO:\n     defaultGeo: IE\n</code></pre>"},{"location":"architecture/rfcs/0003-dns-policy/#custom","title":"Custom","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nname: SendMoreToAzure\nspec:\n  targetRef: # defaults to gateway gvk and current namespace\n    name: gateway-name\n  loadBalancing:\n    weighted:\n     defaultWeight: 10\n     custom:\n\n     - attribute: cloud\n       value: Azure #any record associated with a gateway on a cluster without this value gets the default\n       weight: 30\n</code></pre>"},{"location":"architecture/rfcs/0003-dns-policy/#geo-with-custom-weights","title":"GEO with Custom Weights","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nname: GEODNSAndSendMoreToAzure\nspec:\n  targetRef: # defaults to gateway gvk and current namespace\n    name: gateway-name\n  loadBalancing:\n    weighted:\n     defaultWeight: 10\n     custom:\n\n     - attribute: cloud\n       value: Azure\n       weight: 30\n    GEO:\n      defaultGeo: IE\n</code></pre>"},{"location":"architecture/rfcs/0003-dns-policy/#reference-level-explanation","title":"Reference-level explanation","text":"<ul> <li>Add a DNSPolicy CRD that conforms to policy attachment spec</li> <li>Add a new DNSPolicy controller to MCG</li> <li>DNS logic and record management should all migrate out of the gateway controller into this new DNSPolicy controller as it is the responsibility and domain of the DNSPolicy controller to manage DNS</li> <li>remove the Hosts interface as we want do not want other controllers using this to bring DNS Logic into other areas of the code.</li> </ul>"},{"location":"architecture/rfcs/0003-dns-policy/#drawbacks","title":"Drawbacks","text":"<p>You cannot have a different load balancing strategy for each listener within a gateway. So in the following gateway definition</p> <pre><code>spec:\n    gatewayClassName: kuadrant-multi-cluster-gateway-instance-per-cluster\n    listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      hostname: myapp.hcpapps.net\n      name: api\n      port: 443\n      protocol: HTTPS\n    - allowedRoutes:\n        namespaces:\n          from: All\n      hostname: other.hcpapps.net\n      name: api\n      port: 443\n      protocol: HTTPS      \n</code></pre> <p>The DNS policy targeting this gateway will apply to both myapp.hcpapps.net and other.hcpapps.net</p> <p>However, there is still significant value even with this limitation. This limitation is something we will likely revisit in the future</p>"},{"location":"architecture/rfcs/0003-dns-policy/#background-docs","title":"Background Docs","text":"<p>DNS Provider Support</p> <p>Direct Policy Attachment </p>"},{"location":"architecture/rfcs/0003-dns-policy/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>An alternative is to configure all of this yourself manually in a dns provider. This can be a highly complex dns configuration that it would be easy to get wrong.</p>"},{"location":"architecture/rfcs/0004-policy-status/","title":"Policy Status","text":"<ul> <li>Feature Name: <code>policy_status_states</code></li> <li>Start Date: 2023-02-03</li> <li>RFC PR: Kuadrant/architecture#0009</li> <li>Issue tracking: Kuadrant/architecture#0038</li> </ul>"},{"location":"architecture/rfcs/0004-policy-status/#summary","title":"Summary","text":"<p>This RFC proposes a new design for any Kuadrant Policy (<code>RateLimitPolicy</code>, <code>AuthPolicy</code>, etc..) status definition and transitions.</p>"},{"location":"architecture/rfcs/0004-policy-status/#motivation","title":"Motivation","text":"<p>At the time being, the <code>RateLimitPolicy</code> and <code>AuthPolicy</code> status doesn't clearly and truthfully communicate the actual state of reconciliation and healthiness with its operator managed services, i.e., the Rate Limit service (\"Limitador\") and the Auth service (\"Authorino\"), referred to as \"Kuadrant services\".</p> <p>As a consequence, misleading information is shared causing unexpected errors and flawed assumptions.</p> <p>The following are some issues reported in relation to the aforementioned problems:</p> <ul> <li>https://github.com/Kuadrant/kuadrant-operator/issues/87</li> <li>https://github.com/Kuadrant/kuadrant-operator/issues/96</li> <li>https://github.com/Kuadrant/kuadrant-operator/issues/140</li> </ul>"},{"location":"architecture/rfcs/0004-policy-status/#guide-level-explanation","title":"Guide-level explanation","text":"<p>This design for setting the status of the Kuadrant policy CRs is divided in 2 stages, where each stage could be applied/developed in order and would reflect valuable and accurate information with different degrees of acuity.</p> <p>The Policy CRD Status in the following diagrams are simplified as states, which in the Reference-level explanation will be translated to the actual Status Conditions.</p>"},{"location":"architecture/rfcs/0004-policy-status/#stage-1","title":"Stage 1","text":"<p>State of the policy CR defined by: application, validation, and reconciliation of it</p> <p>The main signalization at Stage 1 is about whether a policy CR has been <code>Accepted</code> or not.</p> <p>States rationale:</p> <ul> <li><code>Accepted</code>: This state is reached after the <code>Validation</code> and <code>Reconciliation</code> event has being successfully passed.</li> <li><code>Invalid</code>: When the <code>Validation</code> process encounters an error, this state will be set.</li> <li><code>TargetNotFound</code>: This state will be set when the <code>Reconciliation</code> process encounters an error.</li> <li><code>Conflicted</code>: This state will be set when the <code>Reconciliation</code> process encounters an error.</li> </ul> <p></p> <p>Notes:</p> <ul> <li>States from the Stage 2 could be implemented as well, but only relying on Validation and Reconciliation events.</li> </ul>"},{"location":"architecture/rfcs/0004-policy-status/#stage-2","title":"Stage 2","text":"<p>Final state of the policy CR defined by: health check with the Kuadrant services (post-reconciliation)</p> <p>The <code>Enforced</code> type is introduced to capture the difference between a policy been reconciled and it's been enforced at the service.</p> <p>States rationale:</p> <ul> <li><code>Enforced</code>: After a successful response of the <code>Service Probe</code>, this states communicates the policy is finally enforced.</li> <li><code>PartiallyEnforced</code>: This state will be set when the <code>Reconciliation</code> event encounters an overlap with other policies.</li> <li><code>Overridden</code>: This state will be set when the <code>Reconciliation</code> event invalidates the policy because another one takes precedence.</li> </ul> <p></p>"},{"location":"architecture/rfcs/0004-policy-status/#reference-level-explanation","title":"Reference-level explanation","text":"<p>In general, the new states and conditions align with GEP-713.</p> <p>Besides the proposed <code>Accepted</code> PolicyType, the <code>Enforced</code> PolicyType would be added to reflect the final state of the policy, which means that the policy is showing the synced actual state of the Kuadrant services.</p> <p>The missing <code>Failed</code> PolicyType would be implicitly represented by the <code>TargetNotFound</code> and <code>Invalid</code> PolicyTypeReason.</p>"},{"location":"architecture/rfcs/0004-policy-status/#conditions","title":"Conditions","text":"<p>All conditions are top-level.</p> Type Status Reason Message Accepted True \"Accepted\" \"KuadrantPolicy has been accepted\" False \"Conflicted\" \"KuadrantPolicy is conflicted by [policy-ns/policy-name], ...\" False \"Invalid\" \"KuadrantPolicy is invalid\" False \"TargetNotFound\" \"KuadrantPolicy target [resource-name] was not found\" Enforced True \"Enforced\" \"KuadrantPolicy has been successfully enforced\" False \"Unknown\" \"KuadrantPolicy has encountered some issues\" False \"Overridden\" \"KuadrantPolicy is overridden by [policy-ns/policy-name], ...\" <p>Messages corresponding falsey statuses are required and should reflect the error that encountered.</p> <p>It's possible to have the Failed state as a top level condition too. In this case, it might be useful to consider a third \"Unknown\" status.</p>"},{"location":"architecture/rfcs/0004-policy-status/#policy-ancestor-status","title":"Policy ancestor status","text":"<p>The Status stanza of the policy CRs must implement Gateway API's PolicyAncestorStatus struct. This will provide broader consistency and improved discoverability of effective policies.</p>"},{"location":"architecture/rfcs/0004-policy-status/#implementation-detailsrequisites","title":"Implementation details/requisites","text":"<p>Full implementation of Stage 2 states assumes reporting mechanisms in place, provided by the Kuadrant services, that allow tracing the state of the configurations applied on the services, back to the original policies, to infer the final state of the policy CRs (i.e. whether truly <code>Enforced</code> or not.)</p> <p>Without such, Stage 2 could be only partially achieved, by relying only on Reconciliation events.</p>"},{"location":"architecture/rfcs/0004-policy-status/#drawbacks","title":"Drawbacks","text":"<ul> <li>This proposal will require to change the code controllers assert the status</li> <li>Since the Status is part of the \"API\", won't be backwards compatible</li> <li>Documentation updating</li> <li>The implementation of the affected policies will create a fan-out problem, that might lead to updating many policy objects and apiserver load.</li> </ul>"},{"location":"architecture/rfcs/0004-policy-status/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>Another option was considered (previously referred to as \"Option 1\"). While valid, this alternative would not align with GEP-713, neither it would be as flexible as the final design proposed.</p> Details of the discarded alternative     This alternative design would come in 3 stages:    **Stage 1 : State of the policy CR defined by: application and validation of it**    This first stage is a simple version where the operator only relies on itself, not checking the healthiness with the   Kuadrant services, but just validating the Spec.    ![](0004-policy-status-assets/policy_status_1.png)    States rationale:    * `Created`: The initial state. It announces that the policy has successfully being created, the operator acknowledges it.   * `Applied`: This state is reached after the `Validation` event has being successfully passed.   * `Failed`: This one would be set when the `Validation` process encounters an error. This could be either condition's failed/error   state or a top-level condition.   * `Updated`: From `Failed` or `Applied`, it could be triggered a `Spec Change` event that would move it to this state.    **Stage 2: Further reconciliation check provides a new state**    This following one, besides checking what the former stage does, it also adds the states reflecting the reconciliation   process of any needed Kubernets object, Kuadrant Services custom resources and any other 3rd party CR required.   An example would be in the case of the RLP, it would create/update the `ConfigMap` holding the `Limitador` config file.    ![](0004-policy-status-assets/policy_status_2.png)    States rationale:    * `Applied`: The __Applied__ state would not be final, and would be preceding a `Reconciliation` event.   * `Reconciled`: It communicates that the policy has successfully being reconciled, and any K8s object or required CR has been updated.   * `Failed`: This one would be reached when either of `Validation` and `Reconcilation` processes have encounter any errors.    **Stage 3: Final state of the policy CR defined by: health check with the Kuadrant services (post-reconciliation)**    The final stage would bring a greater degree of accuracy, thanks for a final process that would check the healthiness and   configuration version the Kuadrant services currently enforces.    ![](0004-policy-status-assets/policy_status_3.png)    States rationale:    * `Reconciled`: This state would precede the \"Health check\" process  graphed as `Service Probe` event.   * `Enforced`: After a successful response of the `Service Probe`, this states communicates the policy is finally enforced.   This is the final top-level condition.   * `Failed`: Now this state could also be set after encountering errors in the `Service Probe` check.        The stages before mentioned would follow the [Kubernetes guidelines](https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties)   regarding the Status object definition.    **Conditions**    All conditions are top-level.    | Type        | Status | Reason                      | Message                                                                     |   |-------------|--------|-----------------------------|-----------------------------------------------------------------------------|   | Progressing | True   | \"PolicyCreated\"             | \"KuadrantPolicy created\"                                                    |   |             | True   | \"PolicyUpdated\"             | \"KuadrantPolicy has been updated\"                                           |   |             | True   | \"PolicyApplied\"             | \"KuadrantPolicy has been successfully applied                               |   |             | True   | \"PolicyReconciled\"          | \"KuadrantPolicy has been successfully reconciled\"                           |   |             | False  | \"PolicyEnforced\"            | \"KuadrantPolicy has been successfully enforced\"                             |   |             | False  | \"PolicyError\"               | \"KuadrantPolicy has encountered an error\"                                   |   | Enforced    | True   | \"PolicyEnforced\"            | \"KuadrantPolicy has been successfully enforced\"                             |   |             | False  | \"PolicyPartiallyEnforced\"   | \"KuadrantPolicy has encountered some issues and has been partially applied\" |   |             | False  | \"PolicyOverridden\"          | \"KuadrantPolicy is overridden by [policy-ns/policy-name]\"                   |   | Failed      | True   | \"PolicyValidationError\"     | \"KuadrantPolicy has failed to validate\"                                     |   |             | True   | \"PolicyServiceError\"        | \"KuadrantPolicy has encountered has failed to enforce\"                      |   |             | False  | \"PolicyEnforced\"            | \"KuadrantPolicy has been successfully enforced\"                             |"},{"location":"architecture/rfcs/0004-policy-status/#prior-art","title":"Prior art","text":"<ul> <li>Kubernetes API Conventions</li> <li>Current KuadrantPolicy Status work</li> </ul>"},{"location":"architecture/rfcs/0004-policy-status/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>Is it worthy to implement a state machine or state machine design pattern to achieve this set of conditions?</li> </ul>"},{"location":"architecture/rfcs/0004-policy-status/#future-possibilities","title":"Future possibilities","text":"<p>The implementation of this proposal could be part of kuadrant/gateway-api-machinery.</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/","title":"Single Cluster DNSPolicy","text":"<ul> <li>Feature Name: <code>single-cluster-dnspolicy</code></li> <li>Start Date: 2023-10-09</li> <li>RFC PR: Kuadrant/architecture#30</li> <li>Issue tracking: </li> <li>Kuadrant/architecture#31</li> <li>Kuadrant/architecture#67</li> </ul>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#summary","title":"Summary","text":"<p>Proposal for changes to the <code>DNSPolicy</code> API to allow it to provide a simple routing strategy as an option in a single cluster context. This will remove, but not negate, the complex DNS structure we use in a multi-cluster environment and in doing so allow use of popular dns integrators such as external-dns .</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#motivation","title":"Motivation","text":"<p>The <code>DNSPolicy</code> API (v1alpha1), was implemented as part of our multi cluster gateway offering using OCM and as such the design and implementation were influenced heavily by how we want multi cluster dns to work.</p> <ul> <li>Decouple the API entirely from OCM and multi cluster specific concepts.</li> <li>Simplify the DNS record structure created for a gateway listeners host for single cluster use.</li> <li>Improve the likelihood of adoption by creating an integration path for other kubernetes dns controllers such as external-dns.</li> </ul>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#guide-level-explanation","title":"Guide-level explanation","text":"<p>The DNSPolicy can be used to target a Gateway in a single cluster context and will create dns records for each listener host in an appropriately configured external dns provider. In this context the advanced <code>loadbalancing</code> configuration is unnecessary, and the resulting DNSRecord can be created mapping individual listener hosts to a single DNS A or CNAME record by using the <code>simple</code> routing strategy in the DNSPolicy.</p> <p>Example 1. DNSPolicy using <code>simple</code> routing strategy</p> <pre><code>apiVersion: kuadrant.io/v1alpha2\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: my-gateways\nspec:\n  providerRef:\n    name: my-route53-credentials\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  routingStrategy: simple\n</code></pre> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: prod-web\n  namespace: my-gateways\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: \"myapp.mn.hcpapps.net\"\n      port: 80\n      protocol: HTTP\nstatus:\n  addresses:\n    - type: IPAddress\n      value: 172.31.200.0\n</code></pre> <p>In the example the <code>api</code> listener has a hostname <code>myapp.mn.hcpapps.net</code> that matches a hosted zone being managed by the provider referenced <code>my-route53-credentials</code> in the DNSPolicy.  As the <code>simple</code> routing strategy is set in the DNSPolicy a DNSRecord resource with the following contents will be created:</p> <pre><code>apiVersion: kuadrant.io/v1alpha2\nkind: DNSRecord\nmetadata:\n  name: prod-web-api\n  namespace: my-gateways\nspec:\n  providerRef:\n    name: my-route53-credentials\n  endpoints:\n\n    - dnsName: myapp.mn.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.200.0\n</code></pre> <p>The <code>providerRef</code> is included in the DNSRecord to allow the dns record controller to load the appropriate provider configuration during reconciliation and create the DNS records in the dns provider service e.g. route 53.</p> <p>Example 2. DNSPolicy using <code>simple</code> routing strategy on multi cluster gateway</p> <pre><code>apiVersion: kuadrant.io/v1alpha2\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: my-gateways\nspec:\n  providerRef:\n    name: my-route53-credentials\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  routingStrategy: simple\n</code></pre> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: prod-web\n  namespace: my-gateways\nspec:\n  gatewayClassName: kuadrant-multi-cluster-gateway-instance-per-cluster\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: \"myapp.mn.hcpapps.net\"\n      port: 80\n      protocol: HTTP\nstatus:\n  addresses:\n    - type: kuadrant.io/MultiClusterIPAddress\n      value: 172.31.200.0\n    - type: kuadrant.io/MultiClusterIPAddress\n      value: 172.31.201.0\n</code></pre> <p>Similar to example 1, except here the Gateway is a multi cluster gateway that has had its status updated by the <code>Gateway</code> controller to include <code>kuadrant.io/MultiClusterIPAddress</code> type addresses. As the <code>simple</code> routing strategy is set in the DNSPolicy a DNSRecord resource with the following contents will be created:</p> <pre><code>apiVersion: kuadrant.io/v1alpha2\nkind: DNSRecord\nmetadata:\n  name: prod-web-api\n  namespace: my-gateways\nspec:\n  providerRef:\n    name: my-route53-credentials\n  endpoints:\n\n    - dnsName: myapp.mn.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.200.0\n        - 172.31.201.0\n</code></pre>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#api-updates","title":"API Updates","text":"<p>DNSPolicy:</p> <ul> <li>new providerRef field <code>spec.providerRef</code></li> <li>new routingStrategy field <code>spec.routingStrategy</code></li> <li>new api version <code>v1alpha2</code></li> </ul> <p>DNSRecord:</p> <ul> <li><code>spec.managedZone</code> replaced with <code>spec.providerRef</code></li> <li>new zoneID field <code>spec.zoneID</code> </li> <li>new api version <code>v1alpha2</code></li> </ul> <p>ManagedZone:</p> <ul> <li>ManagedZone API wil be removed and no longer supported as part of MGC/Kuadrant.</li> </ul>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#dnspolicyspecproviderref","title":"DNSPolicy.spec.providerRef","text":"<p>The <code>providerRef</code> field is mandatory and contains a reference to a secret containing provider credentials.</p> <pre><code>- `spec.providerRef.name` - name of the provider resource.\n</code></pre> <p>A <code>DNSPolicy</code> referencing a providerRef secret will expect that secret to exist in the same namespace. The expected contents of the secrets data is comparable to the <code>dnsProviderSecretRef</code> used by ManageZones.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: aws-credentials\ntype: kuadrant.io/aws\ndata:\n  AWS_ACCESS_KEY_ID: \"foo\"\n  AWS_SECRET_ACCESS_KEY: \"bar\"\n  CONFIG:\n    zoneIDFilter:\n\n      - Z04114632NOABXYWH93QUl\n</code></pre> <p>The <code>CONFIG</code> section of the secrets data will be added to allow provider specific configuration to be stored alongside the providers credentials and can be used during the instantiation of the provider client, and during any provider operations. The above for example would use the <code>zoneIDFilter</code> value to limit what hosted zones this provider is allowed to update.</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#dnspolicyspecroutingstrategysimpleweightedgeo","title":"DNSPolicy.spec.routingStrategy[simple|weightedGeo]","text":"<p>The <code>routingStrategy</code> field is mandatory and dictates what kind of dns record structure the policy will create. Two routing strategy options are allowed <code>simple</code> or <code>weightedGeo</code>.</p> <p>A reconciliation of DNSPolicy processes the target gateway and creates a DNSRecord per listener that is supported by the currently configured provider(hostname matches the hosted zones accessible with the credentials and config). The routing strategy used will determine the contents of the DNSRecord resources Endpoints array.</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#simple","title":"simple","text":"<pre><code>apiVersion: kuadrant.io/v1alpha2\nkind: DNSRecord\nspec:\n  providerRef:\n    name: my-route53-credentials\n  endpoints:\n\n    - dnsName: myapp.mn.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.200.0\n</code></pre> <p>Simple creates a single endpoint for an A record with multiple targets. Although intended for use in a single cluster context a simple routing strategy can still be used in a multi-cluster environment (OCM hub). In this scenario each clusters address will be added to the targets array to create a multi answer section in the dns response.</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#weightedgeo","title":"weightedGeo","text":"<pre><code>apiVersion: kuadrant.io/v1alpha2\nkind: DNSRecord\nspec:\n  providerRef:\n    name: my-route53-credentials\n  endpoints:\n\n    - dnsName: myapp.mn.hcpapps.net\n      recordTTL: 300\n      recordType: CNAME\n      targets:\n        - lb-4ej5le.myapp.mn.hcpapps.net\n    - dnsName: lb-4ej5le.myapp.mn.hcpapps.net\n      providerSpecific:\n        - name: geo-code\n          value: '*'\n      recordTTL: 300\n      recordType: CNAME\n      setIdentifier: default\n      targets:\n        - default.lb-4ej5le.myapp.mn.hcpapps.net\n    - dnsName: default.lb-4ej5le.myapp.mn.hcpapps.net\n      providerSpecific:\n        - name: weight\n          value: \"120\"\n      recordTTL: 60\n      recordType: CNAME\n      setIdentifier: lrnse3.lb-4ej5le.myapp.mn.hcpapps.net\n      targets:\n        - lrnse3.lb-4ej5le.myapp.mn.hcpapps.net\n    - dnsName: lrnse3.lb-4ej5le.myapp.mn.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.200.0\n</code></pre> <p>WeightedGeo creates a more complex set of endpoints which use a combination of weighted and geo routing strategies. Although intended for use in a multi-cluster environment  (OCM hub) it will still be possible to use it in a single cluster context. In this scenario the record structure described above would be created for the single cluster.</p> <p>This is the current default for DNSPolicy in a multi-cluster environment (OCM hub) and more details about it can be found in the original DNSPolicy rfc.</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#dnsrecordspecproviderref","title":"DNSRecord.spec.providerRef","text":"<p>More details of <code>providerRef</code> found in DNSPolicy.spec.providerRef</p> <p>The DNSRecord API is updated to remove the <code>managedZone</code> reference in favour of directly referencing the <code>providerRef</code> credentials instead. The DNSRecord reconciliation will be unchanged except for loading the provider client from <code>providerRef</code> credentials.</p> <p>The DNSPolicy reconciliation will be updated to remove the requirement for a ManagedZone resource to be created before a DNSPolicy can create dns records for it, instead it will be replaced in favour of just listing available zones directly in the currently configured dns provider. If no matching zone is found, no DNSRecord will be created.</p> <p>There is a potential for a DNSRecord to be created successfully, but then a provider updated to remove access. In this case it is the responsibility of the DNSPolicy controller to report appropriate status back to the policy and target resource about the failure to process the record. More details on how status will be reported can be found in rfc-0004</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#dnsrecordspeczoneid","title":"DNSRecord.spec.zoneID","text":"<p>The <code>zoneID</code> field is mandatory and contains the provider specific id of the hosted zone that this record should be published into. </p> <p>The DNSRecord reconciliation will use this zone when creating/updating or deleting endpoints for this record set. </p> <p>The <code>zoneID</code> should not change after being selected during initial creation and as such will be marked as immutable.</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#prior-art","title":"Prior art","text":"<p>ExternalDNS</p> <ul> <li>Uses annotations on the target Gateway as opposed to a proper API.</li> <li>Requires access to the HTTP route resources.</li> <li>Supports only a single provider per external dns instance.</li> </ul>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#unresolved-questions","title":"Unresolved questions","text":"<p>When a provider is configured using a kind not supported by the <code>DNSPolicy</code> controller e.g. <code>ExternalDNS</code> we will be relying on an external controller to correctly update the status of any DNSRecord resources created by our policy. This may have a negative impact on our ability to correctly report status back to the target resource.</p> <p>When using a weightedGeo routing strategy in a single cluster context it is not expected that this will offer multi cluster capabilities without the use of OCM. Currently, it is expected that if you want to create a recordset that contains the addresses of multiple clusters you must use an OCM hub.</p>"},{"location":"architecture/rfcs/0005-single-cluster-dnspolicy/#future-possibilities","title":"Future possibilities","text":"<p>The ability to support other kubernetes dns controllers such as ExternalDNS would potentially allow us to contribute to some of these projects in the area of polices for dns management of Gateway resources in kubernetes.</p>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/","title":"Configuration of Kuadrant Sub Components","text":"<ul> <li>Feature Name: <code>sub-components-config</code></li> <li>Start Date: 2023-09-11</li> <li>RFC PR: Kuadrant/architecture#25</li> <li>Issue tracking: Kuadrant/kuadrant-operator#163</li> <li>Status: Withdrawn</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#summary","title":"Summary","text":"<p>Enable configuration of sub components of Kuadrant from a centralized location, namely the Kuadrant CR. </p>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#motivation","title":"Motivation","text":"<p>The initial request comes from MGC to configure Redis for Limitador by the following issue #163. MGC's current work around is to update the Limitador CR after the deployment with the configuration setting for Redis Instance. This change would allow for the configuration of sub components before the Kuadrant is deployed. </p> <p>This reduces the number of CRs that users of Kuadrant are required to modify to get the installation they require. The sub components CRs (Authorino, Limitador) never have to be modified by a Kuadrant user (and should never be modified by a Kuadrant User).</p>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#guide-level-explanation","title":"Guide-level explanation","text":"<p>As the Kuadrant operator would be responsible for reconciling these configurations into the requested components, restrictions and limitations can be placed on the components which maybe allowed in a standalone installation. An example in this space is the disk storage for Limitador which is a new feature and the Kuadrant installation may not want to support it till there is a proven track record for the feature.</p> <p>For existing Kuadrant Users this may be a possible breaking changes if those users manually configure the Kuadrant sub components via their CRs. A guide can be created to help migrate the users configurations to the Kuadrant CR. This guide can be part of the release notes and/or possibly released before the release of Kuadrant.</p> <p>The deployment configuration for each component can be placed in the Kuadrant CR. These configurations are then reconciled into the CRs for each component.  Only the options below are exposed in the Kuadrant CR.  All fields in the spec are optional.</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n    name: kuadrant-sample\nspec:\n    limitador:\n        afffinity: ...\n        listener: ...\n        pdb: ...\n        replicas: ...\n        resourceRequirements: ...\n        storage: ...\n    authorino:\n        evaluatorCacheSize: ...\n        healthz: ...\n        listener: ...\n        logLevel: ...\n        metrics: ...\n        oidcServer: ...\n        replicas: ...\n        tracing: ...\n        volumes: ...\nstatus:\n    ...\n</code></pre> <p>The Kuadrant operator will watch for changes in the Authorino and Limitador CRs, reconciling back any changes that a user may do to these configurations. How ever Kuadrant operator will not reconcile fields that are given above.  An example of this is the <code>image</code> field on the Authorino CR. This field allows a user to set the image that Authorino is deployed with. The feature is meant for dev and testing purposes.  If a user wishes to use a different image, they can. Kuadrant assumes they know what they are doing but requires the user to set the change on the component directly.</p> <p>Only the sub component operator will be responsible for actioning the configurations pasted from the Kuadrant CR to the sub components CR. This ensure no extra changes will be required in the sub operators to meet the needs of Kuadrant.</p> <p>Status errors related to the configuration of the sub components should be reported back to the Kuadrant CR. The errors messages in Kuadrant state what components are currently having issue and which resource to review for more details.</p>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#reference-level-explanation","title":"Reference-level explanation","text":"<p>All the fields in the Authorino and Limitador CRs that are configurable in the Kuadrant CR are optional and have sound defaults. Kuadrant needs to remain installable with out having to set any spec in the Kuadrant CR.</p> <p>The Kuadrant operator should only reconcile the spec that is given.  This would mean if the user states the number of replicas to be used in one of the components only the replica field for that component should be reconciled. As the other fields would be blank at this stage, blank fields would not be reconciled to the component CR. By this behaviour a few things are being achieved. Component controllers define the defaults to be used in the components. Optional fields in the component CRs never get set with blank values. Blank values in the component CR could override the defaults of the components causing unexpected behaviour. Existing Kuadrant users may already have custom fields set in the component CRs. By only reconciling the fields set in the kuadrant CR this allows time for a user to migrate their custom configuration from the component CR to the Kuadrant CR.</p>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#fields-to-reconcile","title":"Fields to reconcile","text":"<p>Fields being reconcile can be classified into different groups. These classifications are based around the tasks a user is achieve.</p> <ul> <li>Kubernetes native, setting that affect how Kubernetes handles the resource.</li> <li>Observability, configuration settings that allow insights into how the applications are operation. This can be Kubernetes native or external tooling.</li> <li>Application Settings, setting targeting the application and how it connects to external services.</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#authorino-spec","title":"Authorino Spec","text":""},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#kubernetes-native","title":"Kubernetes native","text":"<ul> <li>replicas</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#observability","title":"Observability","text":"<ul> <li>healthz</li> <li>logLevel</li> <li>metrics</li> <li>tracing</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#application-settings","title":"Application Settings","text":"<ul> <li>evaluatorCacheSize</li> <li>listener</li> <li>oidcServer</li> <li>volumes</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#limitador-spec","title":"Limitador Spec","text":""},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#kubernetes-native_1","title":"Kubernetes native","text":"<ul> <li>afffinity</li> <li>pdb</li> <li>replicas</li> <li>resourceRequirements</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#application-settings_1","title":"Application Settings","text":"<ul> <li>listener</li> <li>storage</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#fields-not-reconciled","title":"Fields not reconciled","text":"<p>There are a number of fields in both Authorino and Limitador that are not reconciled. Reasons for doing this are:</p> <p>It is better to start with a sub set of features and expand to include more at a later date. Removing feature support is far harder than adding it.</p> <p>There are four classifications the unreconciled fields fail into.</p> <ul> <li>Deprecated, fields that are deprecated and/or have plans to be removed from the spec in the future.</li> <li>Unsupported, the features would have hard coded or expected defaults in the Kuadrant operator.  Work would be required to all the custom configurations options.</li> <li>Dev/Testing focused, features that should only be used during development &amp; testing and not recommended for production. The defaults would for the fields are the production recommendations.</li> <li>Reconciled by others, this mostly affects Limitador as the deployment configuration and runtime configuration are in the same CR. In the case of Kuadrant the runtime configuration for Limitador is added via the RateLimitingPolicy CR.</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#authorino-spec_1","title":"Authorino Spec","text":""},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#unsupported","title":"Unsupported","text":"<ul> <li>clusterWide</li> <li>authConfigLabelSelectors</li> <li>secretLabelSelectors</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#devtesting-focused","title":"Dev/Testing focused","text":"<ul> <li>image</li> <li>imagePullPolicy</li> <li>logMode</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#limitador-spec_1","title":"Limitador Spec","text":""},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#unsupported_1","title":"Unsupported","text":"<ul> <li>RateLimitHeaders</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#reconciled-by-others","title":"Reconciled by others","text":"<ul> <li>Limits</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#deprecated","title":"Deprecated","text":"<ul> <li>version</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#drawbacks","title":"Drawbacks","text":"<p>As the Kuadrant CR spec will be a sub set of the features that can be configured in the sub components spec, extra maintenances will be required to ensure specs are in sync.</p> <p>New features of a component will not be accessible in Kuadrant initially. This is both a pro and a con.</p> <p>Documentation becomes harder, as the sub component should be documenting their own features but in Kuadrant the user does not configure the feature in sub component. This has the risk of confusing new users.</p>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<ul> <li>Why is this design the best in the space of possible designs?</li> <li>What other designs have been considered and what is the rationale for not choosing them?</li> <li>What is the impact of not doing this?</li> </ul> <p>One alternative that was being looked at was allowing the user to bring their own Limitador instances by stating which Limitador CR Kuadrant should use.  A major point of issue with this approach was knowing what limits the user had configured and what limits Kuadrant configured.  Sharing global counters is a valid reason to want to share Limitador instances.  How ever it this case Limitador would not be using one replica and therefore would have a back-end storage configured. It is the back-end storage that needs to be shared across instances. This can be done with adding the configuration in the Kuadrant CR.</p>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#prior-art","title":"Prior art","text":"<p>Discuss prior art, both the good and the bad, in relation to this proposal. A few examples of what this can include are:</p> <ul> <li>Does another project have a similar feature?</li> <li>What can be learned from it? What's good? What's less optimal?</li> <li>Papers: Are there any published papers or great posts that discuss this? If you have some relevant papers to refer to, this can serve as a more detailed theoretical background.</li> </ul> <p>This section is intended to encourage you as an author to think about the lessons from other tentatives - successful or not, provide readers of your RFC with a fuller picture.</p> <p>Note that while precedent set by other projects is some motivation, it does not on its own motivate an RFC.</p>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>What parts of the design do you expect to resolve through the RFC process before this gets merged?</li> <li>What parts of the design do you expect to resolve through the implementation of this feature before stabilization?</li> <li>What related issues do you consider out of scope for this RFC that could be addressed in the future independently of the solution that comes out of this RFC?</li> </ul> <ul> <li>Is there a need to add validation on the configuration?</li> <li>If a valid configuration is add to the Kuadrant CR and this configuration is pass to the sub components CR but there is a error trying to setting up the configuration. How is this error reported back to the user?  An example of this is configuring Redis as the back-end in Limitador, this requires stating the name and namespace of a configmap. The Limitador CR will have an error if the configmap does not exist and as the user only configures the Kuadrant CR this error may go unnoticed. This is only one example but there is a need for good error reporting back to the user, where they would expect to see the error.</li> </ul>"},{"location":"architecture/rfcs/0006-kuadrant_sub_components_configurations/#future-possibilities","title":"Future possibilities","text":"<p>Think about what the natural extension and evolution of your proposal would be and how it would affect the platform and project as a whole. Try to use this section as a tool to further consider all possible interactions with the project and its components in your proposal. Also consider how this all fits into the roadmap for the project and of the relevant sub-team.</p> <p>This is also a good place to \"dump ideas\", if they are out of scope for the RFC you are writing but otherwise related.</p> <p>Note that having something written down in the future-possibilities section is not a reason to accept the current or a future RFC; such notes should be in the section on motivation or rationale in this or subsequent RFCs. The section merely provides additional information.</p> <p>The implementation stated here allows the user to state spec fields in the component CRs or the Kuadrant CR (Kuadrant CR overrides the component CRs). A future possibility would be to warn the user if they add configuration to the components CRs that would get overridden if the same spec fields are configured in the Kuadrant CR.</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/","title":"RFC - Policy Sync","text":"<ul> <li>Feature Name: <code>policy_sync_v1</code></li> <li>Start Date: 2023-10-10</li> <li>RFC PR: Kuadrant/architecture#0000</li> <li>Issue tracking: https://github.com/Kuadrant/architecture/issues/26</li> </ul>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#summary","title":"Summary","text":"<p>The ability for the Multicluster Gateway Controller to sync policies defined in the hub cluster downstream to the spoke clusters, therefore allowing all policies to be defined in the same place. These policies will be reconciled by the downstream policy controller(s).</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#nomenclature","title":"Nomenclature","text":"<ul> <li> <p>Policy: When refering to a Policy, this document is refering to a Gateway API   policy as defined in the Policy Attachment Model. The Multicluster Gateway Controller   relies on OCM as a Multicluster solution, which defines its own unrelated   set of Policies and Policy Framework. Unless explicitely mentioned, this document   refers to Policies as Gateway API Policies.</p> </li> <li> <p>Policy overriding: The concept of policy overriding is mentioned in this document. It refers to the proposed ability of the downstream Gateway implementation to prioritise downstream Policies against synced Policies in case of conflicts.</p> </li> </ul>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#motivation","title":"Motivation","text":"<p>Currently, Kuadrant's support for the Policy Attachment Model can be divided in two categories:</p> <ul> <li>Policies targeting the Multicluster Gateway, defined in the hub cluster and   reconciled by the Multicluster Gateway Controller</li> <li>Policies targeting the downstream Gateway, defined in the spoke clusters and   reconciled by the downstream Gateway controllers.</li> </ul> <p>In a realistic multicluster scenario where multiple spoke clusters are present, the management of these policies can become tedious and error-prone, as policies have to be defined in the hub cluster, as well as replicated in the multiple spoke clusters.</p> <p>As Kuadrant users:</p> <ul> <li>Gateway-admin has a set of homogeneous clusters and needs to apply per cluster rate limits across the entire set.</li> <li>Platform-admin with a set of clusters with rate limits applied needs to change rate limit for one particular cluster. </li> </ul>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#guide-level-explanation","title":"Guide-level explanation","text":"<p>The policy sync feature will allow a gateway-admin to configure, via GatewayClass parameters, a set of Policy GVRs to be synced by the Multicluster Gateway Controller.</p> <p>The <code>policiesToSync</code> field in the parameters defines those GVRs. For example, in order to configure the controller to sync AuthPolicies:</p> <pre><code>\"policiesToSync\": [\n  {\n    \"group\": \"kuadrant.io\",\n    \"version\": \"v1beta1\",\n    \"resource\": \"authpolicies\" \n  }\n]\n</code></pre> <p>The support for resources that the controller can sync is limited by the following:</p> <ul> <li>The controller ServiceAccount must have permission to watch, list, and get the   resource to be synced</li> <li>The resource must implement the Policy schema:<ul> <li>Have a <code>.spec.targetRef</code> field</li> </ul> </li> </ul> <p>When a Policy is configured to be synced in a GatewayClass, the Multicluster Gateway Controller starts watching events on the resources, and propagates changes by placing the policy in the spoke clusters, with the following mutations:</p> <ul> <li>The <code>TargetRef</code> of the policy is changed to reference the downstream Gateway</li> <li>The <code>kuadrant.io/policy-synced</code> annotation is set</li> </ul> <p>The upstream policy is annotated with a reference to the name and namespace of the downstream policies:   <pre><code>annotations:\n  \"kuadrant.io/policies-synced\": \"[{\\\"cluster\\\": \\\"...\\\", \\\"name\\\": \\\"...\\\", \\\"namespace\\\": \\\"...\\\"}]\"\n</code></pre></p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"architecture/rfcs/0007-policy-sync-v1/#process-overview","title":"Process overview","text":""},{"location":"architecture/rfcs/0007-policy-sync-v1/#dynamic-policy-watches","title":"Dynamic Policy watches","text":"<p>The Multicluster Gateway Controller reconciles parameters referenced by the GatewayClass of a Gateway. A new field is added to the parameters that allows the configuration of a set of GVRs of Policies to be synced.</p> <p>The GatewayClass reconciler validates that:</p> <ul> <li>The GVRs reference existing resource definitions</li> <li>The GVRs reference resources that implement the Policy schema.</li> </ul> <p>Validation failures are reported as part of the status of the GatewayClass</p> <p>The Gateway reconciler sets up dynamic watches to react to events on the configured Policies, calling the PolicySyncer component with the updated Policy as well as the associated Gateway.</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#policysyncer-component","title":"PolicySyncer component","text":"<p>The PolicySyncer component is in charge of reconciling Policy watch events to apply the necessary changes and place the Policies in the spoke clusters.</p> <p>This component is injected in the event source and called when a change is made to a hub Policy that has been configured to be synced.</p> <p>The PolicySyncer implementation uses OCM ManifestWorks to place the policies in the spoke clusters. Through the ManifestWorks, OCM allows to:</p> <ul> <li>Place the Policy in each spoke cluster</li> <li>Report the desired status back to the hub using JSON feedback rules</li> </ul>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#policy-hierarchy","title":"Policy Hierarchy","text":"<p>In order to avoid conflict with Policies created directly in the spoke clusters, a hierarchy must be defined to prioritise those Policies.</p> <p>The controller will set the <code>kuadrant.io/policy-synced</code> annotation on the policy when placing it in the spoke cluster.</p> <p>The Kuadrant operator will be aware of the presence of this annotation, and, in case of conflicts, override Policies that contain this annotation. When a policy is overriden due to conflicts, the <code>Enforced</code> status will be set to <code>False</code>, with the reason being <code>Overriden</code> and a human readable message explaining the reason why the policy was overriden. See Policy Status RFC</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#drawbacks","title":"Drawbacks","text":""},{"location":"architecture/rfcs/0007-policy-sync-v1/#third-party-policy-support","title":"Third party Policy support","text":"<p>In order for a Policy to be supported for syncing, the MGC must have permissions to watch/list/get the resource, and the implementation of the downstream Gateway controller must be aware of the <code>policy-synced</code> annotation.</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#rationale-and-alternatives","title":"Rationale and alternatives","text":""},{"location":"architecture/rfcs/0007-policy-sync-v1/#alternatives","title":"Alternatives","text":"<p>Different technology stacks are available to sync resources across clusters. However, adoption of these technologies for the purpose of the goal this RFC intends to achieve, implies adding another dependency to the current stack, with the cost of added complexity and maintainance effort.</p> <p>The MGC currently uses OCM to place Gateways across clusters. Relying on OCM for the purpose of placing Policies is the most straightforward alternative from a design and implementation point of view.</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#consequences-of-not-implementing","title":"Consequences of not implementing","text":"<p>Gateway-admins will have no centralized system for handling spoke-level policies targeting a gateway created there from the hub.</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#ocms-policy-framework-will-not-be-used-to-complete-this-objective","title":"OCMs Policy Framework will not be used to complete this objective:","text":"<p>OCMs Policy Framework is a system designed to make assertions about the state of a spoke, and potentially take actions based on that state, as such it is not a suitable replacement for manifestworks in the case of syncing resources to a spoke.</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#potential-migration-from-manifestworks-to-manifestworkreplicasets","title":"Potential migration from ManifestWorks to ManifestWorkReplicaSets","text":"<p>ManifestWorkPeplicaSets may be a future improvement that the MGC could support to simplify the placement of related resources, but beyond the scope of this RFC.</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#prior-art","title":"Prior art","text":"<p>No applicable prior art.</p>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#unresolved-questions","title":"Unresolved questions","text":""},{"location":"architecture/rfcs/0007-policy-sync-v1/#status-reporting","title":"Status reporting","text":"<p>While the controller can assume common status fields among the Policies that it syncs, there might be a scenario where certain policies use custom status fields that are not handled by the controller. In order to support this, two alternatives are identified:</p> <ol> <li> <p>Configurable rules.</p> <p>An extra field is added in the GatewayClass params that configures the policies to sync, to specify custom fields that the controller must propagate back from the spokes to the hub.</p> </li> <li> <p>Hard-coded support.</p> <p>The PolicySync component can identify the Policy type and select which extra status fields are propagated </p> </li> </ol>"},{"location":"architecture/rfcs/0007-policy-sync-v1/#future-possibilities","title":"Future possibilities","text":"<p>If OCMs Policy Framework is updated to enable syncing of resources status back to the hub, it could be an opportunity to refactor the MGC to use this framework in place of the current approach of creating ManifestWorks directly.</p> <p>This system could mutate over time to dynamically sync more CRDs than policies to spoke clusters.</p>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/","title":"Kuadrant Release Process","text":"<ul> <li>Feature Name: <code>kuadrant-release-process</code></li> <li>Start Date: 2024-01-11</li> <li>RFC PR: Kuadrant/architecture#46</li> <li>Issue tracking: Kuadrant/architecture#59</li> </ul>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#summary","title":"Summary","text":"<p>Kuadrant is a set of components whose artifacts are built and delivered independently. This RFC aims to define every aspect of the event of releasing a new version of the whole, in terms of versioning, cadence, communication, channels, handover to other teams, etc.</p>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#motivation","title":"Motivation","text":"<p>At the time being, there's no clear process nor guidelines to follow when releasing a new version of Kuadrant, which leads to confusion and lack of transparency. We are currently relying on internal communication and certain people in charge of the release process, which is not ideal.</p>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#guide-level-explanation","title":"Guide-level explanation","text":"<p>First, we need to define what releasing Kuadrant means, in a clear and transparent way that communicates to the community what's happening and what to expect. The Kuadrant suite is composed of several components, each of them with its own set of artifacts and versioning scheme. Defining the release process of the whole suite is a complex task, and it's not only about the technical details of releasing the components, but also about the communication and transparency with the community, the definition of the frequency of the releases, and when it's ready to be handover to other teams like QA. This section aims to provide guidelines for the different aspects of the release process.</p>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#components-and-versioning","title":"Components and versioning","text":"<p>The set of components that are part of the Kuadrant suite are the following:</p> <ul> <li>Authorino: Kubernetes-native authorization service for tailor-made Zero Trust API security.</li> <li>Authorino Operator: A Kubernetes Operator to manage Authorino instances.</li> <li>Limitador: A generic rate-limiter written in Rust.</li> <li>Limitador Operator: A Kubernetes Operator to manage Limitador deployments.</li> <li>Wasm Shim: A Proxy-Wasm module written in Rust, acting as a shim between Envoy and Limitador. connectivity and global load balancing.</li> <li>DNS Operator: A Kubernetes Operator to manage DNS in single and multi-cluster environments.</li> <li>Kuadrant Operator: The Operator to install and manage the lifecycle   of the Kuadrant components deployments. Example alerts and dashboards are also included as optional.</li> <li>kuadrantctl: A CLI tool for managing Kuadrant configurations and resources.</li> </ul> <p>Each of them needs to be versioned independently, and the versioning scheme should follow Semantic Versioning. At the time of cutting a release for any of them, it's important to keep in mind what section of the version to bump, given a version number MAJOR.MINOR.PATCH, increment the:</p> <ul> <li>MAJOR version when you make incompatible API changes</li> <li>MINOR version when you add functionality in a backward compatible manner</li> <li>PATCH version when you make backward compatible bug fixes</li> </ul> <p>Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.</p> <p>A more detailed explanation of the versioning scheme can be found in the Semantic Versioning website.</p> <p>By releasing a new version of Kuadrant, we mean releasing the set of components with their corresponding semantic versioning, some of them maybe freshly released, or others still using versioning from the previous one, and being the version of the Kuadrant Operator the one that defines the version of the whole suite.</p> <pre><code>Kuadrant Suite vx.y.z = Kuadrant Operator vx.y.z +  Authorino Operator va.b.c + Limitador Operator vd.e.f + DNS Operator vg.h.i + MGC Controller vj.k.l + Wasm Shim vm.n.o\n</code></pre> <p>The technical details of how to release each component are out of the scope of this RFC and could be found in the Kuadrant components CI/CD RFC.</p>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#qa-sanity-check","title":"QA Sanity Check","text":"<p>Probably the most important and currently missing step in the release process is the green flagging from the Quality Assurance (QA) team. The QA team is responsible for testing the different components of the Kuadrant suite, and they need to be aware of the new version of the suite that is going to be released, what are the changes that are included, bug fixes and new features in order they can plan their testing processes accordingly. This check is not meant to be a fully fledged assessment from the QA team when it's handover to them, it's aimed to not take more than 1-2 days, and ideally expected to be fully automated. This step will happen once the release candidate has no PRs pending to be merged, and it has been tested by the Engineering team. The QA team should work closely to the engineering throughout the process, both teams aiming for zero handover time and continuous delivery mindset, so immediate testing can be triggered on release candidates once handed over. This process should happen without the need of formal communication between the teams or any overhead in general, but by keeping constant synergy between quality and product engineering instead.</p> <p>There is an ideal time to hand over to the QA team for testing, especially since we are using GitHub for orchestration, we could briefly define it in the following steps:</p> <ol> <li>Complete Development Work: The engineering team completes their work included in the milestone.</li> <li>Create Release Candidate: The engineering team creates Release Candidate builds and manifests for all components required for the release</li> <li>Flagging/Testing: The QA team do the actual assertion/testing of the release candidate, checking for any obvious bugs or issues. Then QA reports all the bugs as GitHub issues and communicates testing status back publicly on Slack and/or email.</li> <li>Iterate: Based on the feedback from the QA team, the Engineering team makes any necessary adjustments and repeats the process until the release candidate is deemed ready for production.</li> <li>Publish Release: Once QA communicates that the testing has been successfully finished, the engineering team will publish the release both on Github and in the corresponding registries, updates documentation for the new release, and communicates it to all channels specified in Communication section.</li> </ol>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#cadence","title":"Cadence","text":"<p>Once the project is stable enough, and its adoption increases, the community will be expecting a certain degree of commitment from the maintainers, and that includes a regular release cadence. The frequency of the releases of the different components could vary depending on the particular component needs. However, the Kuadrant Operator it's been discussed in the past that it should be released every 3-4 weeks initially, including the latest released version of every component in the suite. There's another RFC that focuses on the actual frequency of each component, one could refer to the Kuadrant Release Cadence RFC.</p> <p>There are a few reasons for this:</p> <ul> <li>Delivering Unparalleled Value to Users: Regular releases can provide users with regular updates and improvements.   These updates can include new features and essential bug fixes, thus enhancing the overall value delivered to the users.</li> <li>Resource Optimization: By releasing software at regular intervals, teams can align their activities with   available resources and environments, ensuring optimal utilization. This leads to increased efficiency in the deployment   process and reduces the risk of resource wastage.</li> <li>Risk Management: Regular releases can help identify and fix issues early, reducing the risk of major failures that could   affect users.</li> <li>Feedback Cycle: Regular releases allow for quicker feedback cycles. This means that any issues or improvements   identified by users can be addressed promptly, leading to a more refined product over time.</li> <li>Synchronization: Regular releases can help synchronize work across different teams or departments, creating a more   reliable, dependable solution development and delivery process.</li> <li>Reduced Complexity: Managing a smaller number of releases can reduce complexity. For example, having many different   releases out in the field can lead to confusion and management overhead.</li> </ul> <p>By committing to a release cadence, software projects can benefit from improved efficiency, risk management, faster feedback cycles, synchronization, and reduced complexity.</p>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#repositories-and-hubs","title":"Repositories and Hubs","text":"<p>Every component in Kuadrant has its own repository, and the source code is hosted in GitHub, mentioned in the previous section. However, the images built and manifests generated are hosted in different registries, depending on the component. The following table shows the different registries used by each component:</p> Component Artifacts Registry / Hub Authorino authorino images Quay.io Authorino Operator authorino-operator images Quay.io authorino-operator-bundle images Quay.io authorino-operator-catalog images Quay.io authorino-operator manifests OperatorHub.io Limitador limitador server images Quay.io limitador crate Crates.io Limitador Operator limitador-operator images Quay.io limitador-operator-bundle images Quay.io limitador-operator-catalog images Quay.io limitador-operator manifests OperatorHub.io Wasm Shim wasm-shim images Quay.io DNS Operator dns-operator images Quay.io dns-operator-bundle images Quay.io dns-operator-catalog images Quay.io Kuadrant Operator kuadrant-operator images Quay.io kuadrant-operator-bundle images Quay.io kuadrant-operator-catalog images Quay.io kuadrant-operator manifests OperatorHub.io kuadrant-operator source (includes example dashboards and alerts) Github Releases kuadrantctl kuadrantctl CLI Github Releases"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#documentation","title":"Documentation","text":"<p>It's important to  note that keeping the documentation up to date is a responsibility of the component maintainers, and it needs to be done before releasing a new version of the component. The importance of keeping a clear and up-to-date documentation is crucial for the success of the project.</p> <p>The documentation for the Kuadrant suite is compiled and available on the Kuadrant website. One can find the source of the documentation within each component repository, in the <code>docs</code> directory. However, making this information available on the website is a manual process, and should be done by the maintainers of the project. The process of updating the documentation is simple and consists of the following steps:</p> <ol> <li>Update the documentation in the corresponding component repository.</li> <li>Follow the instruction in https://github.com/Kuadrant/docs.kuadrant.io/ to update the Docs pointers to the tag or branch of the component repository that contains the updated documentation.</li> <li>Once the changes are merged to main, the workflow that updates the website will be triggered, and the documentation will be updated.</li> <li>If for some reason it's needed to trigger the workflow manually, one can do it from the GitHub Actions tab in the docs.kuadrant.io (<code>Actions &gt; ci &gt; Run Workflow</code>).</li> </ol>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#communication","title":"Communication","text":"<p>Another important aspect of releasing a new version of the Kuadrant suite is the communication with the community and other teams within the organization. A few examples of the communication channels that need to be updated are:</p> <ul> <li>Changelog generation</li> <li>Release notes</li> <li>Github Release publication</li> <li>Slack channel in Kubernetes workspace</li> <li>Blog post, if applicable</li> <li>Social media, if applicable</li> </ul>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>The alternative to the proposal is to keep the current process, which is not ideal and leads to confusion and lack of transparency.</p>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#prior-art","title":"Prior art","text":"<p>There's been an organically grown process for releasing new versions of the Kuadrant suite, which is not documented and it's been changing over time. However, there are some documentation for some of the components, worth mentioning:</p> <ul> <li>Authorino release process</li> <li>Authorino Operator release process</li> <li>Limitador release process</li> <li>DNS Operator release process</li> </ul>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>What would be Kuadrant support policy?</li> <li>How many version are we going to back-port security and bug fixes to?</li> <li>What other teams need to be involved in the release process?</li> </ul>"},{"location":"architecture/rfcs/0008-kuadrant-release-process/#future-possibilities","title":"Future possibilities","text":"<p>Once the release process is accepted and battle-tested, we could aim to automate the process as much as possible.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/","title":"Defaults &amp; Overrides","text":"<ul> <li>Feature Name: <code>defaults-and-overrides</code></li> <li>Start Date: 2024-02-15</li> <li>RFC PR: Kuadrant/architecture#58</li> <li>Issue tracking: Kuadrant/kuadrant-operator#431</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#summary","title":"Summary","text":"<p>This is a proposal for extending the Kuadrant Policy APIs to fully support use cases of Defaults &amp; Overrides (D/O) for Inherited Policies, including the base use cases of full default and full override, and more specific nuances that involve merging individual policy rules (as defaults or overrides), declaring constraints and unsetting defaults.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#motivation","title":"Motivation","text":"<p>As of Kuadrant Operator v0.6.0, Kuadrant policy resources that have hierarchical effect across the tree of network objects (Gateway, HTTPRoute), or what is known as Inherited Policies, provide only limited support for setting defaults and no support for overrides at all.</p> <p>The above is notably the case of the AuthPolicy and the RateLimitPolicy v1beta2 APIs, shipped with the aforementioned version of Kuadrant. These kinds of policies can be attached to Gateways or to HTTPRoutes, with cascading effects through the hierarchy that result in one effective policy per gateway-route combination. This effective policy is either the policy attached to the Gateway or, if present, the one attached to the HTTRoute, thus conforming with a strict case of implicit defaults set at the level of the gateway.</p> <p>Enhancing the Kuadrant Inherited Policy CRDs, so the corresponding policy instances can declare <code>defaults</code> and <code>overrides</code> stanzas, is imperative:</p> <ol> <li>to provide full support for D/O along the lines proposed by GEP-713 (to be superseded by GEP-2649<sup>1</sup>) of the Kubernetes Gateway API special group (base use cases);</li> <li>to extend D/O support to other derivative cases, learnt to be just as important for platform engineers and app developers who require more granular policy interaction on top of the base cases;</li> <li>to support more sophisticated hierarchies with other kinds of network objects and/or multiples policies targetting at the same level of the hierarchy (possibly, in the future.)</li> </ol>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#guide-level-explanation","title":"Guide-level explanation","text":""},{"location":"architecture/rfcs/0009-defaults-and-overrides/#conceptualization-and-user-story","title":"Conceptualization and User story","text":"<p>The base use cases for Defaults &amp; Overrides (D/O) are:</p> <ul> <li>Defaults (D): policies declared lower in the hierarchy supersede ones set (as \"defaults\") at a higher level, or \"more specific beats less specific\"</li> <li>Overrides (O): policies declared higher in the hierarchy (as \"overrides\") supersede ones set at the lower levels, or \"less specific beats more specific\"</li> </ul> <p>The base cases are expanded with the following additional derivative cases and concepts:</p> <ul> <li>Merged defaults (DR): \"higher\" default policy rules that are merged into more specific \"lower\" policies (as opposed to an atomic less specific set of rules that is activated only when another more specific one is absent)</li> <li>Merged overrides (OR): \"higher\" override policy rules that are merged into more specific \"lower\" policies (as opposed to an atomic less specific set of rules that is activated fully replacing another more specific one that is present)</li> <li>Constraints (C): specialization of an override that, rather than declaring concrete values, specify higher level constraints (e.g., min value, max value, enums) for lower level values, with the semantics of \"clipping\" lower level values so they are enforced, in an override fashion, to be the boundaries dictated by the constraints; typically employed for constraining numeric values and regular patterns (e.g. limited sets)</li> <li>Unsetting (U): specialization that completes a merge default use case by allowing lower level policies to disable (\"unset\") individual defaults set a higher level (as opposed to superseding those defaults with actual, more specific, policy rules with proper meaning)</li> </ul> <p>Together, these concepts relate to solve the following user stories:</p> User story Group Unique ID As a Platform Engineer, when configuring a Gateway, I want to set a default policy for all routes linked to my Gateway, that can be fully replaced with more specific ones(*). D gateway-default-policy As a Platform Engineer, when configuring a Gateway, I want to set default policy rules (parts of a policy) for all routes linked to my Gateway, that can be individually replaced and/or expanded by more specific rules(*). DR gateway-default-policy-rule As a Platform Engineer, when defining a policy that configures a Gateway, I want to set constraints (e.g. minimum/maximum value, enumerated options, etc) for more specific policy rules that are declared(*) with the purpose of replacing the defaults I set for the routes linked to my Gateway. C policy-constraints As a Platform Engineer, when configuring a Gateway, I want to set a policy for all routes linked to my Gateway, that cannot be replaced nor expanded by more specific ones(*). O gateway-override-policy As a Platform Engineer, when configuring a Gateway, I want to set policy rules (parts of a policy) for all routes linked to my Gateway, that cannot be individually replaced by more specific ones(*), but only expanded with additional more specific rules(*). OR gateway-override-policy-rule As an Application Developer, when managing an application, I want to set a policy for my application, that fully replaces any default policy that may exist for the application at the level of the Gateway, without having to know about the existence of the default policy. D route-replace-policy As an Application Developer, when managing an application, I want to expand a default set of policy rules set for my application at the level of the gateway, without having to refer to those existing rules by name. D/O route-add-policy-rule As an Application Developer, when managing an application, I want to unset an individual default rule set for my application at the level of the gateway. U route-unset-policy-rule <p><sup>(*) declared in the past or in the future, by myself or any other authorized user.</sup></p> <p>The interactive nature of setting policies at levels in the hierarchy and by different personas, make that the following additional user stories arise. These are stories here grouped under the Observability (Ob) aspect of D/O, but referred to as well in relation to the \"Discoverability Problem\" described by Gateway API.</p> User story Group Unique ID As one who has read access to Kuadrant policies, I want to view the effective policy enforced at the traffic routed to an application, considering all active defaults and overrides at different policies(*). Ob view-effective-policy As a Platform Engineer, I want to view all default policy rules that may have been replaced by more specific ones(*). Ob view-policy-rule-status As a Policy Manager, I want to view all gateways and/or routes whose traffic is subject to enforcement of a particular policy rule referred by name. Ob view-policy-rule-reach <p><sup>(*) declared in the past or in the future, by myself or any other authorized user.</sup></p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#writing-do-enabled-kuadrant-policies","title":"Writing D/O-enabled Kuadrant Policies","text":"<p>Writing a Kuadrant policy enabled for Defaults &amp; Overrides (D/O), to be attached to a network object, involves declaring the following fields at the first level of the spec:</p> <ul> <li><code>targetRef</code> (required): the reference to a hierarchical network object targeted by the policy, typed as a Gateway API <code>PolicyTargetReference</code> or <code>PolicyTargetReferenceWithSectionName</code> type</li> <li><code>defaults</code>: a block of default policy rules with further specification of a strategy (atomic set of rules or individual rules to be merged into lower policies), and optional conditions for applying the defaults down through the hierarchy</li> <li><code>overrides</code>: a block of override policy rules with further specification of a strategy (atomic set of rules or individual rules to be merged into lower policies), and optional conditions for applying the overrides down through the hierarchy</li> <li>the bare policy rules block without further qualification as a default or override set of rules \u2013 e.g. the <code>rules</code> field in a Kuadrant AuthPolicy, the <code>limits</code> field in a RateLimitPolicy.</li> </ul> <p>Between the following mutually exclusive options, either one or the other shall be used in a policy:</p> <ol> <li><code>defaults</code> and/or <code>overrides</code> blocks; or</li> <li>the bare set of policy rules (without further qualification as neither defaults nor overrides.)</li> </ol> <p>In case the bare set of policy rules is used, it is treated implicitly as a block of defaults.</p> <p>Supporting specifying the bare set of policy rules at the first level of the spec, alternatively to the <code>defaults</code> and <code>overrides</code> blocks, is a strategy that aims to provide:</p> <ol> <li>more natural usability, especially for those who write policies attached to the lowest level of the hierarchy supported; as well as</li> <li>backward compatibility for policies that did not support explicit D/O and later on have moved to doing so.</li> </ol>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#inherited-policies-that-declare-an-intent","title":"Inherited Policies that declare an intent","text":"<p>A policy that does not specify D/O fields (<code>defaults</code>, <code>overrides</code>) is a policy that declares an intent.</p> <p>One who writes a policy without specifying <code>defaults</code> or <code>overrides</code>, but only the bare set of policy rules, may feel like declaring a Direct Policy. Depending on the state of other policies indirectly affecting the same object or not, the final outcome can be the same as writing a direct policy. This is especially true when the policy that declares the intent targets an object whose kind is the lowest kind accepted by Kuadrant in the hierarchy of network resources, and there are no other policies with lower precedence.</p> <p>Nevertheless, because other policies can affect the final behavior of the target (e.g. by injecting defaults, by overriding rules, by adding more definitions beneath), policies that simply declare an intent, conceptually, are still Inherited Policies.</p> <p>Compared to the inherited policy that misses D/O blocks, these other policies affecting the behavior may be declared:</p> <ul> <li>at higher levels in the hierarchy,</li> <li>at lower levels in hierarchy, or even</li> <li>at the same level in the hierarchy but happening to have lower precedence (if such case is allowed by the kind of policy.)</li> </ul> <p>At any time, any one of these policies can be created and therefore the final behavior of a target should never be assumed to be equivalent to the intent declared by any individual policy in particular, but always collectively determined by the combination of all intents, defaults and overrides from all inherited policies affecting the target.</p> <p>From GEP-2649:</p> <p>If a Policy can be used as an Inherited Policy, it MUST be treated as an Inherited Policy, regardless of whether a specific instance of the Policy is only affecting a single object.</p> <p>An inherited policy that simply declares an intent (i.e. without specifying D/O) will be treated as a policy that implicitly declares an atomic set of defaults, whether the policy targets higher levels in the hierarchy or lower ones. In the absence of any other conflicting policy affecting the same target, the behavior equals the defaults which equal the intent.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#inherited-policies-that-modify-an-intent","title":"Inherited Policies that modify an intent","text":"<p>A policy that specifies D/O fields (<code>defaults</code>, <code>overrides</code>) is a policy explicitly declared to modify an intent.</p> <p>Without any other policy with lower precedence, there is no special meaning in choosing whether defaults or overrides in a inherited policy that targets an object whose kind is the lowest kind accepted by Kuadrant in the hierarchy of network resources. The sets of rules specified in these policies affect indistinctively the targeted objects, regardless of how they are qualified.</p> <p>However, because other policies may ocasionally be declared with lower precedence (i.e. targeting lower levels in the hierarchy or due to ordering, see Conflict Resolution), one who declares a policy to modify an intent must carefuly choose between <code>defaults</code> and/or <code>overrides</code> blocks to organize the policy rules, regardless if the targeted object is of a kind that is the lowest kind in the hierarchy of network resources accepted by Kuadrant.</p> <p>Even in the cases where no more than one policy of a kind is allowed to target a same object (1:1 relationship) and thus there should never exist two policies affecting a target from a same level of the hierarchy simultaneaously (or equivalently a policy with lower precedence than another, both at the lowest level of the hierarchy), users must assume that this constraint may change (i.e. N:1 relationship between policies of a kind and target become allowed.)</p> <p>In all cases, defaults and overrides must be used with the semantics of declaring rules that modify an intent.</p> <ul> <li>When an intent does not specify a rule for which there is a higher default declared, the default modifies the intent by setting the value specified by the default.</li> <li>For an intent that whether specifies or omits a rule for which there is a higher override declared, the override modifies the intent by setting the value specified by the override.</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#identifying-inherited-policy-kinds","title":"Identifying inherited policy kinds","text":"<p>All Custom Resource Definitions (CRDs) that define a Kuadrant inherited policy must be labeled <code>gateway.networking.k8s.io/policy: inherited</code>.</p> <p>Users can rely on the presence of that label to identify policy kinds whose instances are treated as inhertied policies.</p> <p>In some exceptional cases, there may be kinds of Kuadrant policies that do not specify <code>defaults</code> and <code>overrides</code> blocks, but that are still labeled as inherited policy kinds. Instances of these kinds of policies implicitly declare an atomic sets of defaults, similarly to described in Inherited Policies that declare an intent.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#examples-of-do-enabled-kuadrant-policy","title":"Examples of D/O-enabled Kuadrant policy","text":"<p>Example 1. Atomic defaults</p> <pre><code>kind: AuthPolicy\nmetadata:\n  name: gw-policy\nspec:\n  targetRef:\n    kind: Gateway\n  defaults:\n    rules:\n      authentication:\n        \"a\": {\u2026}\n      authorization:\n        \"b\": {\u2026}\n    strategy: atomic\n</code></pre> <p>The above is a proper Inherited Policy that sets a default atomic set of auth rules that will be set at lower objects in case those lower object do not have policies attached of their own at all.</p> <p>The following is a sligthly different example that defines auth rules that will be individually merged into lower objects, evaluated one by one if already defined at the \"lower\" (more specific) level and therefore should take precedence, or if otherwise is missing at the lower level and therefore the default should be activated.</p> <p>Example 2. Merged defaults</p> <pre><code>kind: AuthPolicy\nmetadata:\n  name: gw-policy\nspec:\n  targetRef:\n    kind: Gateway\n  defaults:\n    rules:\n      authentication:\n        \"a\": {\u2026}\n      authorization:\n        \"b\": {\u2026}\n    strategy: merge\n</code></pre> <p>Similarly, a set of <code>overrides</code> policy rules could be specified, instead or alongside with the <code>defaults</code> set of policy rules.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#atomic-vs-individually-merged-policy-rules","title":"Atomic vs. individually merged policy rules","text":"<p>There are 2 supported strategies for applying proper Inherited Policies down to the lower levels of the herarchy:</p> <ul> <li>Atomic policy rules: the bare set of policy rules in a <code>defaults</code> or <code>overrides</code> block is applied as an atomic piece; i.e., a lower object than the target of the policy, that is evaluated to be potentially affected by the policy, also has an atomic set of rules if another policy is attached to this object, therefore either the entire set of rules declared by the higher (less specific) policy is taken or the entire set of rules declared by the lower (more specific) policy is taken (depending if it's <code>defaults</code> or <code>overrides</code>), but the two sets are never merged into one.</li> <li>Merged policy rules: each individual policy rule within a <code>defaults</code> or <code>overrides</code> block is compared one to one against lower level policy rules and, when they conflict (i.e. have the same key with different values), either one or the other (more specific or less specific) is taken (depending if it's <code>defaults</code> or <code>overrides</code>), in a way that the final effective policy is a merge between the two policies.</li> </ul> <p>Each block of <code>defaults</code> and <code>overrides</code> must specify a <code>strategy</code> field whose value is set to either <code>atomic</code> or <code>merge</code>. If omitted, <code>atomic</code> is assumed.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#level-of-granularity-of-compared-policy-rules","title":"Level of granularity of compared policy rules","text":"<p>Atomic versus merge strategies, as a specification of the <code>defaults</code> and <code>overrides</code> blocks, imply that there are only two levels of granularity for comparing policies vis-a-vis.</p> <ul> <li> <p><code>atomic</code> means that the level of granularity is the entire set of policy rules within the <code>defaults</code> or <code>overrides</code> block. I.e., the policy is atomic, or, equivalently, the final effective policy will be either one indivisible (\"atomic\") set of rules (\"policy\") or the other.</p> </li> <li> <p>For the <code>merge</code> strategy, on the other hand, the granularity is of each named policy rule, where the name of the policy rule is the key and the value is an atomic object that specifies that policy rule. The final effective policy will be a merge of two policies.</p> </li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#matrix-of-do-strategies-and-effective-policy","title":"Matrix of D/O strategies and Effective Policy","text":"<p>When two policies are compared to compute a so-called Effective Policy out of their sets of policy rules and given default or override semantics, plus specified <code>atomic</code> or <code>merge</code> strategies, the following matrix applies:</p> Atomic (entire sets of rules) Merge (individual policy rules at a given granularity) Defaults More specific entire set of rules beats less specific entire set of rules \u2192 takes all the rules from the lower policy More specific individual policy rules beat less specific individual set of rules \u2192 compare one by one each pair of policy rules and take the lower one if they conflict Overrides Less specific entire set of rules beats more specific entire set of rules \u2192 takes all the rules from the higher policy Less specific individual policy rules beat more specific individual set of rules \u2192 compare one by one each pair of policy rules and take the higher one if they conflict <p>The order of the policies, from less specific (or \"higher\") to more specific (or \"lower), is determined according to the Gateway API hierarchy of network resources, based on the kind of the object targeted by the policy. The policy that sets higher in the hierarchy dictates the strategy to be applied.</p> <p>For a more detailed reference, including how to resolve conflicts in case of policies targeting objects at the same level, see GEP-713's section Hierarchy and Conflict Resolution.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#unsetting-inherited-defaults","title":"Unsetting inherited defaults","text":"<p>In some cases, it may be desirable to be able to unset, at a lower policy, a merged default that is inherited from a higher one. In fact, some inherited defaults could be harmful to an application, at the same time as they are unfeasible to remove from scope for all applications altogether, and therefore require an exception.</p> <p>Unsetting defaults via specification at lower level policies provides users who own policy rules at different levels of the hirarchy the option of not having to coordinate those exceptions \"offline\", nor having to accept the addition of special cases (conditions) at the higher level to exempt only specific lower policies from being affected by a particular default, which otherwise would configure a violation of the inheritance pattern, as well as an imposition of additional cognitive complexity for one who reads a higher policy with too many conditions.</p> <p>Instead, users should continue to be able to declare their intents through policies, and redeem an entitlement to unset unapplicable defaults, without any leakage of lower level details upwards at the higher policies.</p> <p>The option of unsetting inherited defaults is presented as part of the volition implied by the inheritance of policy rules, which are tipically specified for the more general case (e.g. at the level of a gateway, for all routes), though not necessarily applicable for all special cases beneath. If enabled, this feature helps disambiguate the concept of \"default\", which should not be understood strictly as the option to set values that protect the system in case of lack of specialisation. Rather, by its property of volition and changeability. I.e., by definition, every default policy rule is opt-out and specifies a value that is modifiable.</p> <p>In constrast, a policy rule that is neither opt-out nor modifiable better fits the definition of an override. While a policy rule that is not opt-out, nor it sets a concrete default value to be enforced in the lack of specialisation, defines a requirement.</p> <p>Finally, for the use case where users want to set defaults that cannot be unset (though still modifable), the very feature of unsetting defaults itself should be configurable, at least at the level of the system. This can be achieved with feature switches and policy validation, including backed by the cluster's RBAC if needed.</p> <p>The capability of unsetting inherited defaults from an effective policy can be identified by the presence of the <code>spec.unset</code> field in a policy. The value is a list of default named policy rules to be unset.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#conditionally-applying-do","title":"Conditionally applying D/O","text":"<p>Users should be able to specify conditions for applying their blocks of <code>defaults</code> and <code>overrides</code>. These conditions aim to support exceptional cases where the blocks cannot be simply applied downwards, but rather depend on specifics found in the lower policies, while still defined in generic terms \u2013 as opposed to conditions that leak details of individual lower policies upwards.</p> <p>Between a higher and a lower set of policy rules, the higher level dictates the conditions for its rules to be applied (either as defaults or as overrides) over the lower level, and never the other way around.</p> <p>D/O conditions are identfied by the presence of the <code>spec.defaults.when</code> or <code>spec.overrides.when</code> fields in a policy. Those should be defined using Common Expression Language (CEL), evaluated in the control plane against the lower level specification that the higher level is being applied to. I.e. <code>self</code> in the CEL expression is the lower policy.</p> <p>A concrete useful application for conditionally enforcing a block of D/O is for specifying constraints for lower values. E.g. if a lower policy tries to set a value on a numeric field that is greater (or lower) than a given threshold, apply an override that sets that field value to equal to the threshold; otherwise, use the value declared by the lower policy.</p> <p>In contrast, an example of trivially redundant application of D/O conditions would be specifying a default block of rules that is only applied when the lower level does not declare a more specific replacement. Since this is natural semantics of a default, one does not have to use conditions for that.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#examples-of-do-cases","title":"Examples of D/O cases","text":"<p>The following sets of examples generalize D/O applications for the presented user stories, regardless of details about specific personas and kinds of targeted resources. They illustrate the expected behavior for different cases involving defaults, overrides, constraints and unsetting.</p> Examples Highlighted user stories A. Default policy entirely replaced by another at lower level gateway-default-policy, route-replace-policy B. Default policy rules merged into policies at lower level gateway-default-policy-rule, route-add-policy-rule C. Override policy entirely replacing other at lower level gateway-override-policy D. Override policy rules merged into other at lower level gateway-override-policy-rule E. Override policy rules setting constraints to other at lower level policy-constraints F. Policy rule that unsets a default from higher level route-unset-policy-rule <p>In all the examples, a Gateway and a HTTPRoute objects are targeted by two policies, and an effective policy is presented highlighting the expected outcome. This poses no harm to generalizations involving same or different kinds of targeted resources, multiples policies targeting a same object, etc.</p> <p>The leftmost YAML is always the \"higher\" (less specific) policy; the one in the middle, separated from the leftmost one by a \"+\" sign, is the \"lower\" (more specific) policy; and the rightmost YAML is the expected Effective Policy.</p> <p>For a complete reference of the order of hierarchy, from least specific to most specific kinds of resources, as well as how to resolve conflicts of hierarchy in case of policies targeting objects at the same level, see Gateway API's Hierarchy definition for Policy Attachment and Conflict Resolution.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#examples-a-default-policy-entirely-replaced-by-another-at-lower-level","title":"Examples A - Default policy entirely replaced by another at lower level","text":"<p>Example A1. A default policy that is replaced entirely if another one is set at a lower level</p> <p></p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#examples-b-default-policy-rules-merged-into-policies-at-lower-level","title":"Examples B - Default policy rules merged into policies at lower level","text":"<p>Example B1. A default policy whose rules are merged into other policies at a lower level, where individual default policy rules can be overridden or unset - without conflict</p> <p></p> <p>Example B2. A default policy whose rules are merged into other policies at a lower level, where individual default policy rules can be overridden or unset - with conflict</p> <p></p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#examples-c-override-policy-entirely-replacing-other-at-lower-level","title":"Examples C - Override policy entirely replacing other at lower level","text":"<p>Example C1. An override policy that replaces any other that is set at a lower level entirely</p> <p></p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#examples-d-override-policy-rules-merged-into-other-at-lower-level","title":"Examples D - Override policy rules merged into other at lower level","text":"<p>Example D1. An override policy whose rules are merged into other policies at a lower level, overriding individual policy rules with same identification - without conflict</p> <p></p> <p>Example D2. An override policy whose rules are merged into other policies at a lower level, overriding individual policy rules with same identification - with conflict</p> <p></p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#examples-e-override-policy-rules-setting-constraints-to-other-at-lower-level","title":"Examples E - Override policy rules setting constraints to other at lower level","text":"<p>The examples in this section introduce the proposal for a new <code>when</code> field for the <code>defaults</code> and <code>overrides</code> blocks. This field dictates the conditions to be found in a lower policy that would make a higher policy or policy rule to apply, according to the corresponding <code>defaults</code> or <code>overrides</code> semantics and <code>atomic</code> or <code>merge</code> strategy.</p> <p>Combined with a simple case of override policy (see Examples C), the <code>when</code> condition field allows modeling for use cases of setting constraints for lower-level policies.</p> <p>As here proposed, the value of the <code>when</code> condition field must be a valid Common Expression Language (CEL) expression.</p> <p>Example E1. An override policy whose rules set constraints to field values of other policies at a lower level, overriding individual policy values of rules with same identification if those values violate the constraints - lower policy is compliant with the constraint</p> <p></p> <p>Example E2. An override policy whose rules set constraints to field values of other policies at a lower level, overriding individual policy values of rules with same identification if those values violate the constraints - lower level violates the constraint</p> <p></p> <p>Example E3. An override policy whose rules set constraints to field values of other policies at a lower level, overriding individual policy values of rules with same identification if those values violate the constraints - merge granularity problem</p> <p>The following example illustrates the possibly unintended consequences of enforcing D/O at strict levels of granularity, and the flip side of the <code>strategy</code> field offering a closed set of options (<code>atomic</code>, <code>merge</code>).</p> <p>On one hand, the API is simple and straightforward, and there are no deeper side effects to be concerned about, other than at the two levels provided (atomic sets or merged individual policy rules.) On the other hand, this design may require more offline interaction between the actors who manage conflicting policies.</p> <p></p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#examples-f-policy-rule-that-unsets-a-default-from-higher-level","title":"Examples F - Policy rule that unsets a default from higher level","text":"<p>The examples in this section introduce a new field <code>unset: []string</code> at the same level as the bare set of policy rules. The value of this field, provided as a list, dictates the default policy rules declared at a higher level to be removed (\"unset\") from the effective policy, specified by name of the policy rules.</p> <p>Example F1. A policy that unsets a default policy rule set at a higher level</p> <p></p> <p>Example F2. A policy that tries to unset an override policy rule set a higher level</p> <p></p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#status-reporting-and-policy-discoverability","title":"Status reporting and Policy discoverability","text":""},{"location":"architecture/rfcs/0009-defaults-and-overrides/#possible-statuses-of-an-inherited-policy","title":"Possible statuses of an inherited policy","text":"<p>An inherited policy can be at any of the following conditions (RFC 0004):</p> Type Status Reason Message Accepted True \"Accepted\" \"Policy has been accepted\" False \"Conflicted\" \"Policy is conflicted by &lt;policy-ns/policy-name&gt;\" False \"Invalid\" \"Policy is invalid\" False \"TargetNotFound\" \"Policy target &lt;resource-name&gt; was not found\" Enforced True \"Enforced\" \"Policy has been successfuly enforced[. The following defaults have been added by : x, y]\" True \"PartiallyEnforced\" \"Policy has been successfuly enforced. The following rules have been overridden by : a, b[; the following defaults have been added by : x, y]\" False \"Overridden\" \"Policy has been overridden by &lt;policy-ns/policy-name&gt;\" False \"Unknown\" \"Policy has encountered some issues\""},{"location":"architecture/rfcs/0009-defaults-and-overrides/#policy-discoverability-and-effective-policy","title":"Policy discoverability and Effective policy","text":"<p>A special condition must be added to every object that is targeted by a Kuadrant inherited policy if the policy's <code>Enforced</code> status condition is <code>True</code>.</p> <p>This special condition to be added to the target object is <code>kuadrant.io/xPolicyAffected</code>, where \"xPolicy\" is the kind of the inherited policy (e.g. AuthPolicy, RateLimitPolicy.)</p> <p>The possible statuses of an object regarding its sensitivity to one or more inherited policies are:</p> Type Status Reason Message xPolicyAffected False \"Unaffected\" \"The object is not affected by any xPolicy\" True \"Affected\" \"The object is affected by xPolicy &lt;policy-ns/policy-name&gt;\" True \"PartiallyAffected\" \"The following sections of the object are affected by xPolicy &lt;policy-ns/policy-name&gt;: rules.0, rules.2\" <p>The presence of the <code>PolicyAffected</code> status condition helps identify that an object is sensitive to one of more policies of a kind, and gives some specifics about the scope of that effect (entire object or selected sections.) In many cases, this should be enough for inferring the actual policy rules being enforced for that object.</p> <p>For other cases where any of the following situations hold, a more detailed view of the final Effective Policy must be provided to the user:</p> <ul> <li>If the rules of the policy cannot be inferred by the name of the policy and/or the user lacks permission to read the policy object;</li> <li>If the object is affected by more than one policy.</li> </ul> <p>To help visualize the effective policy for a given target object in that situation, at least one of the following options must be provided to the user:</p> <ol> <li>A read-only <code>EffectivePolicy</code> custom resource, defined for each kind of inherited policy, and with an instance created for each affected object, that is reconciled and updated by the policy controller.</li> <li>A HTTP endpoint of the policy controller that users can consume to read the effective policy.</li> <li>A CLI tool that offers a command that queries the cluster and returns the effective policy \u2013 either by leveraging any of the methods above or computing the effective policy \"on-the-fly\" in the same fashion as the policy controller does.</li> </ol>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#reference-level-explanation","title":"Reference-level explanation","text":""},{"location":"architecture/rfcs/0009-defaults-and-overrides/#applying-policies","title":"Applying policies","text":"<p>The following diagrams are a high level model to guide the process of applying a set of policies of a kind for a given Gateway object, where the Gateway object is considered the root of a hierarchy, and for all objects beneath, being the xRoute objects the leaves of the hierarchical tree.</p> <p>As presented, policies can target either Gateways of route objects (HTTPRoutes, GRPCRoutes), with no restriction regarding the number of policies of a kind that target a same particular object. I.e. N:1 relationship allowed. Without any loss of generality, 1:1 relationship between policies of a kind and targeted objects can be imposed if preferred as a measure to initially reduce the blast of information for the user and corresponding cognitive load.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#apply-policies-to-a-gateway-root-object-and-all-objects-beneath","title":"Apply policies to a Gateway (root object) and all objects beneath","text":"<pre><code>%%{ init: { \"theme\": \"neutral\" } }%%\nflowchart LR\n    start([For a Gateway &lt;i&gt;g&lt;/i&gt;&lt;br&gt;and policy kind &lt;i&gt;pk&lt;/i&gt;]) --&gt;\n    list-routes[List all routes&lt;br&gt;accepted by &lt;i&gt;g&lt;/i&gt; as &lt;i&gt;R&lt;/i&gt;] --&gt;\n    apply-policies-for-r\n    subgraph for-each-route[For each &lt;i&gt;r in R&lt;/i&gt;]\n        apply-policies-for-r[[Apply policies&lt;br&gt;of kind &lt;i&gt;pk&lt;/i&gt;&lt;br&gt;scoped for &lt;i&gt;r&lt;/i&gt;]] --&gt;\n        apply-policies-for-r\n    end\n    for-each-route --&gt;\n    build-virtual-route[Build a virtual route &lt;i&gt;vr&lt;/i&gt;&lt;br&gt;with all route rules not&lt;br&gt;target by any policy] --&gt;\n    apply-policies-for-vr[[Apply policies&lt;br&gt;of kind &lt;i&gt;pk&lt;/i&gt;&lt;br&gt;scoped for &lt;i&gt;vr&lt;/i&gt;]] --&gt;\n    finish(((END)))</code></pre>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#apply-policies-of-a-kind-for-an-object","title":"Apply policies of a kind for an object","text":"<pre><code>%%{ init: { \"theme\": \"neutral\" } }%%\nflowchart LR\n    apply-policies-for-o-start([Apply policies of kind &lt;i&gt;pk&lt;/i&gt;&lt;br&gt;scoped for an object &lt;i&gt;o&lt;/i&gt;]) --&gt;\n    list-policies[Make &lt;i&gt;P&lt;/i&gt; \u2190 all policies &lt;br&gt;of kind &lt;i&gt;pk&lt;/i&gt; that&lt;br&gt;affect &lt;i&gt;o&lt;/i&gt;] --&gt;\n    sort-policies[Sort &lt;i&gt;P&lt;/i&gt; from&lt;br&gt;lowest to highest] --&gt;\n    build-effective-policy[Build an effective&lt;br&gt;policy &lt;i&gt;ep&lt;/i&gt; without&lt;br&gt;any policy rules] --&gt;\n    merge-p-into-ep\n    subgraph for-each-policy[For each policy &lt;i&gt;p in P&lt;/i&gt;]\n        merge-p-into-ep[[Merge &lt;i&gt;p into &lt;i&gt;ep&lt;/i&gt;]] --&gt;\n        merge-p-into-ep\n    end\n    for-each-policy --&gt;\n    reconcile-ep[Reconcile resources&lt;br&gt;for &lt;i&gt;ep&lt;/i&gt;] --&gt;\n    apply-policies-for-o-finish(((END)))</code></pre>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#merging-two-policies-together","title":"Merging two policies together","text":"<pre><code>%%{ init: { \"theme\": \"neutral\" } }%%\nflowchart LR\n    merge-p1-into-p2-start([Merge policy &lt;i&gt;p1&lt;/i&gt;&lt;br&gt;into policy &lt;i&gt;p2&lt;/i&gt;]) --&gt;\n    p1-format{Explicit&lt;br&gt;&lt;i&gt;defaults&lt;/i&gt; or &lt;i&gt;overrides&lt;/i&gt;&lt;br&gt;declared in &lt;i&gt;p1&lt;/i&gt;?}\n    p1-format -- Yes --&gt; merge-defaults-for-r[[\"Merge &lt;b&gt;defaults&lt;/b&gt; block&lt;br&gt;of policy rules&lt;br&gt;of &lt;i&gt;p1&lt;/i&gt; into &lt;i&gt;p2&lt;/i&gt;\"]] --&gt; merge-overrides-for-r[[\"Merge &lt;b&gt;overrides&lt;/b&gt; block&lt;br&gt;of policy rules&lt;br&gt;of &lt;i&gt;p1&lt;/i&gt; into &lt;i&gt;p2&lt;/i&gt;\"]] --&gt; merge-p1-into-p2-finish(((Return &lt;i&gt;p2&lt;/i&gt;)))\n    p1-format -- No --&gt; merge-bare-rules-for-r[[\"Merge ungrouped&lt;br&gt;block of policy rules&lt;br&gt;of &lt;i&gt;p1&lt;/i&gt; into &lt;i&gt;p2&lt;/i&gt;&lt;br&gt;(as &lt;b&gt;defaults&lt;/b&gt;)\"]] --&gt; merge-p1-into-p2-finish</code></pre>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#merging-a-generic-block-of-policy-rules-defaults-or-overrides-into-a-policy-with-conditions","title":"Merging a generic block of policy rules (defaults or overrides) into a policy with conditions","text":"<pre><code>%%{ init: { \"theme\": \"neutral\" } }%%\nflowchart LR\n    merge-block-of-rules-into-p-start([Merge block of&lt;br&gt;policy rules &lt;i&gt;B&lt;/i&gt;&lt;br&gt;into policy &lt;i&gt;p&lt;/i&gt;]) --&gt;\n    r-conditions-match{\"&lt;i&gt;B.when(p)&lt;/i&gt;\"}\n    r-conditions-match -- \"Conditions do not match\" --&gt; merge-block-of-rules-into-p-finish(((Return &lt;i&gt;p&lt;/i&gt;)))\n    r-conditions-match -- \"Conditions match\" --&gt; block-semantics{Merge &lt;i&gt;B&lt;/i&gt; as}\n    block-semantics -- \"Defaults\" --&gt; merge-default-block-into-p[[Merge default block&lt;br&gt;of policy rules &lt;i&gt;B&lt;/i&gt;&lt;br&gt;into policy &lt;i&gt;p&lt;/i&gt;]] --&gt; merge-block-of-rules-into-p-finish\n    block-semantics -- \"Overrides\" --&gt; merge-override-block-into-p[[Merge override block&lt;br&gt;of policy rules &lt;i&gt;B&lt;/i&gt;&lt;br&gt;into policy &lt;i&gt;p&lt;/i&gt;]] --&gt; merge-block-of-rules-into-p-finish</code></pre>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#merge-a-defaults-block-of-policy-rules-into-a-policy","title":"Merge a <code>defaults</code> block of policy rules into a policy","text":"<pre><code>%%{ init: { \"theme\": \"neutral\" } }%%\nflowchart LR\n    merge-default-block-into-p-start([Merge default block&lt;br&gt;of policy rules &lt;i&gt;B&lt;/i&gt;&lt;br&gt;into policy &lt;i&gt;p&lt;/i&gt;]) --&gt;\n    unset-unwanted-policy-rules[Remove from &lt;i&gt;B&lt;/i&gt;&lt;br&gt;all policy rules&lt;br&gt;listed in &lt;i&gt;p.unset&lt;/i&gt;] --&gt;\n    p-empty{&lt;i&gt;p.empty?&lt;/i&gt;}\n    p-empty -- \"Yes\" --&gt; full-replace-p-with-defaut-block[&lt;i&gt;p.rules \u2190 B&lt;/i&gt;] --&gt; merge-default-block-into-p-finish(((Return &lt;i&gt;p&lt;/i&gt;)))\n    p-empty -- \"No\" --&gt; default-block-strategy{&lt;i&gt;B.strategy&lt;/i&gt;}\n    default-block-strategy -- \"Atomic\" --&gt; merge-default-block-into-p-finish\n    default-block-strategy -- \"Merge\" --&gt; default-p-r-exists\n    subgraph for-each-default-policy-rule[\"For each &lt;i&gt;r in B&lt;i&gt;\"]\n        default-p-r-exists{\"&lt;i&gt;p[r.id].exists?&lt;/i&gt;\"}\n        default-p-r-exists -- \"Yes\" --&gt; default-p-r-exists\n        default-p-r-exists -- \"No\" --&gt; default-replace-pr[\"&lt;i&gt;p[r.id] \u2190 r&lt;/i&gt;\"] --&gt; default-p-r-exists\n    end\n    for-each-default-policy-rule --&gt;\n    merge-default-block-into-p-finish</code></pre>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#merge-an-overrides-block-of-policy-rules-into-a-policy","title":"Merge an <code>overrides</code> block of policy rules into a policy","text":"<pre><code>%%{ init: { \"theme\": \"neutral\" } }%%\nflowchart LR\n    merge-override-block-into-p-start([Merge override block&lt;br&gt;of policy rules &lt;i&gt;B&lt;/i&gt;&lt;br&gt;into policy &lt;i&gt;p&lt;/i&gt;]) --&gt;\n    override-block-strategy{&lt;i&gt;B.strategy&lt;/i&gt;}\n    override-block-strategy -- \"Atomic\" --&gt; full-replace-p-with-override-block[&lt;i&gt;p.rules \u2190 B&lt;/i&gt;] --&gt; merge-override-block-into-p-finish(((Return &lt;i&gt;p&lt;/i&gt;)))\n    override-block-strategy -- \"Merge\" --&gt; override-replace-pr\n    subgraph for-each-override-policy-rule[\"For each &lt;i&gt;r in B&lt;i&gt;\"]\n        override-replace-pr[\"&lt;i&gt;p[r.id] \u2190 r&lt;/i&gt;\"] --&gt; override-replace-pr\n    end\n    for-each-override-policy-rule --&gt;\n    merge-override-block-into-p-finish</code></pre>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#implementation-tiers","title":"Implementation tiers","text":"<p>This section proposes a possible path for the implementation of this RFC for Kuadrant's existing kinds of policies that are affected by D/O \u2013 notably AuthPolicy and RateLimitPolicy.</p> <p>The path is divided in 3 tiers that could be delivered in steps, additionaly to a series of enhancements &amp; refactoring.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#tier-1","title":"Tier 1","text":"<ul> <li>Atomic defaults (currently supported; missing addition of the <code>defaults</code> field to the APIs)</li> <li>Atomic overrides</li> <li>Policy status and Policy discoverability (i.e. PolicyAffected status on target objects)</li> <li>CRD labels <code>gateway.networking.k8s.io/policy: inherited | direct</code></li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#tier-2","title":"Tier 2","text":"<ul> <li>D/O <code>when</code> conditions (and support for \"constraints\")</li> <li>Merge strategy</li> <li>Reporting of effective policy</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#tier-3","title":"Tier 3","text":"<ul> <li>Unsetting (<code>unset</code>)</li> <li>Metrics for D/O policies (control plane)</li> <li>Docs: possible approaches for \"requirements\"</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#enhancements-and-refactoring","title":"Enhancements and refactoring","text":"<ul> <li>Extract generic part of D/O implementation to Kuadrant/gateway-api-machinery.</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#drawbacks","title":"Drawbacks","text":"<p>See Mutually exclusive API designs &gt; Design option: <code>strategy</code> field.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#rationale-and-alternatives","title":"Rationale and alternatives","text":""},{"location":"architecture/rfcs/0009-defaults-and-overrides/#mutually-exclusive-api-designs","title":"Mutually exclusive API designs","text":"<p>The following alternatives were considered for the design of the API spec to support D/O:</p> <ol> <li><code>strategy</code> field - RECOMMENDED</li> <li><code>granularity</code> field</li> <li><code>when</code> conditions (at any level of the spec)</li> <li>CEL functions (at any level of the spec)</li> <li>\u201cpath-keys\u201d</li> <li>JSON patch-like</li> </ol> <p>All the examples in the RFC are based on API design <code>strategy</code> field.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#design-option-strategy-field","title":"Design option: <code>strategy</code> field","text":"<p>Each block of <code>defaults</code> and <code>overrides</code> specify a field <code>strategy: atomic | merge</code>, with <code>atomic</code> assumed if the field is omitted.</p> <p>All the examples in the RFC are based on this design for the API spec.</p> <p>Some of the implications of the design are explained in the section Atomic vs. individually merged policy rules, with highlights to the support for specifying the level of atomicity of the rules in the policy based on only 2 granularities \u2013 entire set of policy rules (<code>atomic</code>) or to the level of each named policy rule (<code>merge</code>.)</p> \u2705 Pros \u274c Cons <ul> <li>Same schema as a normal policy without D/O</li> <li>Declarative</li> <li>Safe against \"unmergeable objects\" (e.g. two rules declaring different one-of options)</li> <li>Strong types</li> <li>Extensible (by adding more fields, e.g.: to support unsetting defaults)</li> <li>Easy to learn</li> </ul> <ul> <li>2 levels of granularity only \u2013 either all (\u2018atomic\u2019) or policy rule (\u2018merge\u2019)</li> <li>1 granularity declaration per D/O block \u2192 declaring both \u2018atomic\u2019 and \u2018merge\u2019 simultaneously requires 2 separate policies targeting the same object</li> </ul> <p>The design option based on the <code>strategy</code> field is the RECOMMENDED design for the implementation of Kuadrant Policies enabled for D/O. This is due to the pros above, plus the fact that this design can evolve to other, more versatile forms, such as <code>granularity</code> field, <code>when</code> conditions or CEL functions, in the future, while the opposite would be harder to achieve.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#design-option-granularity-field","title":"Design option: <code>granularity</code> field","text":"<p>Each block of <code>defaults</code> and <code>overrides</code> would specify a <code>granularity</code> field, set to a numeric integer value that describes which level of the policy spec, from the root of the set of policy rules until that number of levels down, to treat as the key, and the rest as the atomic value.</p> <p>Example:</p> <pre><code>kind: AuthPolicy\nmetadata:\n  name: gw-policy\nspec:\n  targetRef:\n    kind: Gateway\n  defaults:\n    rules:\n      authentication:\n        \"a\": {\u2026}\n      authorization:\n        \"b\": {\u2026}\n    granularity: 0 # the entire spec (\"rules\") is an atomic value\n  overrides:\n    rules:\n      metadata:\n        \"c\": {\u2026}\n      response:\n        \"d\": {\u2026}\n    granularity: 2 # each policy rule (\"c\", \"d\") is an atomic value\n</code></pre> \u2705 Pros \u274c Cons <ul> <li>Same as design option <code>strategy</code> field</li> <li>Unlimited levels of granularity (values can be pointed as atomic at any level)</li> </ul> <ul> <li>1 granularity declaration per D/O block \u2192 N levels simultaneously require N policies</li> <li>Granularity specified as a number - user needs to count the levels</li> <li>Setting a deep level of granularity can cause merging \"unmergeable objects\"</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#design-option-when-conditions-at-any-level-of-the-spec","title":"Design option: <code>when</code> conditions (at any level of the spec)","text":"<p>Inspired by the extension of the API for D/O with an additional <code>when</code> field (see Examples E), this design alternative would use the presence of this field to signal the granularity of the atomic operation of default or override.</p> <p>Example:</p> <pre><code>kind: AuthPolicy\nmetadata:\n  name: gw-policy\nspec:\n  targetRef:\n    kind: Gateway\n  defaults:\n    rules:\n      authentication:\n        \"a\": {\u2026}\n        when: CEL # level 1 - entire \"authentication\" block\n      authorization:\n        \"b\":\n          \"prop-1\": {\u2026}\n          when: CEL # level 2 - \"b\" authorization policy rule\n</code></pre> \u2705 Pros \u274c Cons <ul> <li>Same as <code>granularity</code> field</li> <li>As many granularity declarations per D/O block as complex objects in the policy</li> <li>Granularity specified \u201cin-place\u201d</li> </ul> <ul> <li>Setting a deep level of granularity can cause merging \"unmergeable objects\"</li> <li>Implementation nightmare - hard to define the API from existing types</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#design-option-cel-functions-at-any-level-of-the-spec","title":"Design option: CEL functions (at any level of the spec)","text":"<p>This design option leans on the power of Common Expression Language (CEL), extrapolating the design alternative with <code>when</code> conditions beyond declaring a CEL expression just to determine if a statically declared value should apply. Rather, it proposes the use of CEL functions that outputs the value to default to or to ovrride with, taking the conflicting \"lower\" value as input, with or without a condition as part of the CEL expression. The value of a key set to a CEL function indicates the level of granularity of the D/O operation.</p> <p>Example:</p> <pre><code>kind: AuthPolicy\nmetadata:\n  name: gw-policy\nspec:\n  targetRef:\n    kind: Gateway\n  defaults:\n    rules:\n      authentication:\n        \"a\": {\u2026} # static value\n        \"b\": \"cel:self.value &gt; 3 ? AuthenticationRule{value: 3} : self\"\n      authorization: |\n        cel:Authorization{\n          c: AuthorizationRule{prop1: \"x\"}\n        }\n</code></pre> \u2705 Pros \u274c Cons <ul> <li>Unlimited levels of granularity</li> <li>Granularity specified \u201cin-place\u201d</li> <li>Extremely powerful</li> <li>Elegant and simple implementation-wise</li> </ul> <ul> <li>Weakly typed</li> <li>Implementation completely new \u2013 cannot reuse current API types</li> <li>Requires all types to be defined as protobufs</li> <li>Without strong guardrails, users can easily shoot themselves in the foot</li> <li>Validation likely requires complex functions for parsing the CEL expressions</li> <li>Non-declarative</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#design-option-path-keys","title":"Design option: \u201cpath-keys\u201d","text":"<p>A more radical alternative considered consisted of defining <code>defaults</code> and <code>overrides</code> blocks whose schemas would not match the ones of a normal policy without D/O. Instead, these blocks would consist of simple key-value pairs, where the keys specify the paths in an affected policy where to apply the value atomically.</p> <p>Example:</p> <pre><code>kind: AuthPolicy\nmetadata:\n  name: gw-policy\nspec:\n  targetRef:\n    kind: Gateway\n  defaults:\n    \"rules.authentication\":\n      \"a\": {G}\n    \"rules.authorization.b\": {G}\n</code></pre> \u2705 Pros \u274c Cons <ul> <li>D/O as simple key-value sets (keys: where to apply, values: what to apply)</li> <li>Declarative</li> <li>Unlimited levels of granularity (values can be pointed as atomic at any level)</li> <li>Unlimited merge declarations per D/O block</li> <li>Intuitive, easy-to-learn</li> </ul> <ul> <li>Not same schema as the normal policy (without D/O) - not very GWAPI-like</li> <li>Weakly typed (i.e. <code>map[string]any)</code></li> <li>Not extensible (e.g., cannot add other fields to the API)</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#design-option-json-patch-like","title":"Design option: JSON patch-like","text":"<p>Similar to the path-keys design option, inspired by JSON patch operations, to provide more kinds of operations and extensibility.</p> <p>Example:</p> <pre><code>kind: AuthPolicy\nmetadata:\n  name: gw-policy\nspec:\n  targetRef:\n    kind: Gateway\n  defaults:\n\n  - path: rules.authentication\n    operation: add\n    value: { \"a\": {G} }\n  - path: rules.authorization.b\n    operation: remove\n  - path: |\n      rules.authentication.a.\n      value\n    operation: le\n    value: 50\n</code></pre> \u2705 Pros \u274c Cons <ul> <li>Same as \"path-keys\" field</li> <li>Extensible, all kinds of operations supported (add, remove, constraint)</li> </ul> <ul> <li>Not same schema as the normal policy (without D/O) - not very GWAPI-like</li> <li>Less declarative</li> <li>Weakly typed (i.e. <code>value: any)</code></li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#prior-art","title":"Prior art","text":"<p>Other than the primitive support only for implicit atomic defaults provided by Kuadrant for the AuthPolicy and RateLimitPolicy, other real-life implementations of D/O along the lines proposed by Gateway API are currently unknown.</p> <p>Some orientative examples provided in:</p> <ul> <li>GEP-2649 - search for \"CDNCachingPolicy\" as well as \"Merging into existing spec fields\";</li> <li><code>gwctl</code> effective policy calculation for inherited policies - see policy manager's merge test cases.</li> </ul>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#out-of-scope","title":"Out of scope","text":""},{"location":"architecture/rfcs/0009-defaults-and-overrides/#policy-requirements","title":"Policy requirements","text":"<p>A use case often described in association with D/O is the one for declaring policy requirements. These are high level policies that declare requirements to be fulfilled by more specific (lower level) policies without specifying concrete default or override values nor constraints. E.g.: \"an authentication policy must be enforced, but none is provided by default.\"</p> <p>A typical generic policy requirement user story is:</p> <p>As a Platform Engineer, when configuring a Gateway, I want to set policy requirements to be fulfilled by one who manages an application/route linked to my Gateway, so all interested parties, including myself, can be aware of applications deployed to the cluster that lack a particular policy protection being enforced.</p> <p>Policy requirements as here described are out of scope of this RFC.</p> <p>We believe policy requirement use cases can be stated and solved as an observability problem, by defining metrics and alerts that cover for missing policies or policy rules, without necessarily having to write a policy of the same kind to express such requirement to be fulfilled.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#unresolved-questions","title":"Unresolved questions","text":""},{"location":"architecture/rfcs/0009-defaults-and-overrides/#merging-policies-with-references-to-external-objects","title":"Merging policies with references to external objects","text":"<p>How to handle merges of policies from different namespaces that contain references to other objects (e.g. Secrets)?</p> <p>Often policies rules include references to other Kubernetes objects, such as Secrets, typically defined in the same namespace as the policy object. When merging policies from different namespaces, these references need to be taken into account.</p> <p>If not carried along with the derivative resources (e.g. Authorino AuthConfig objects) that are created from a merge of policies (or from the computed effective policy), composed out of definitions from different namespaces, and that depend on those references, these references to external objects can be broken.</p> <p>This is not much of a problem for atomic D/O only, as the derivative objects that depend on the references could be forced to be created in the same namespace as the policy that wins against all the others \u2013 and therefore in the same namespace of the winning referents as well. However, when merging policies, we can run into a situation where final effective policies (thus also other derivative resources) contain references to objects inherited from definitions from other namespaces.</p> <p>Possible solutions to this problem include:</p> <ol> <li>Copying the referenced objects into the namespace where the derivative resources will be created.</li> <li>Involves maintaining (watching and reconciling) those referenced objects</li> <li>May raise security concerns</li> <li>Allowing derivative resources (e.g. Authorino AuthConfigs) to reference objects across namespaces, as well as giving permissions to the components that process those references (e.g. Authorino) to read across namespaces</li> <li>May raise security concerns</li> <li>Should probably be restricted to derivative resources created by Kuadrant and not allowed to users who create the derivative resources themselves</li> </ol>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#policy-spec-resembling-more-the-target-spec","title":"Policy spec resembling more the target spec","text":"<p>Should Kuadrant's inherited policy specs resemble more the specs of the objects they target?</p> <p>The UX for one who writes a Kuadrant policy of the inherited class of policies is arguably not very different from writing any custom resource that happens to specify a <code>targetRef</code> field. Other than name and kind of target object, there is nothing much in a Kuadrant policy custom resource that provides the user with an experience almost close to be \"adding fields\" in the target object.</p> <p>With the exception of a few types reused for the route selectors, the spec of a Kuadrant policy is very different from the spec of the object that ultimately the policy augments, i.e. the spec of the route object. This remains basically unchanged after this RFC. However, another way to think on the design of those APIs is one where, in contrast, the specs of the policies partially mirror the spec of the route, so users can write policies in a more intuitive fashion, as if the definitions of the policy would look like extensions of the routes they target (directly or by targeting gateways the routes are attached to.)</p> <p>E.g.:</p> <pre><code>kind: HTTPRoute\nmetadata:\n  name: my-route\nspec:\n  rules:\n\n  - name: rule-1\n    matches:\n    - method: GET\n    backendRef: {\u2026}\n  - name: rule-2\n    backendRef: {\u2026}\n</code></pre> <p>An inherited policy that targets the HTTPRoute above could otherwise look like the following:</p> <pre><code>kind: Policy\nmetadata:\n  name: my-policy\nspec:\n  targetRef:\n    kind: HTTPRoute\n    name: my-route\n  defaults: # mirrors the spec of the httproute object\n    policySpecificDef: {\u2026} # augments the entire httproute object\n  overrides: # mirrors the spec of the httproute object\n    rules:\n\n    - name: rule-2\n      policySpecificDef: {\u2026} # augments only httprouterule rule-2 of the httproute object\n</code></pre> <p>The above already is somewhat closer to being true for the AuthPolicy API, than it is for the RateLimitPolicy one. However, that is strictly coincidental, because the AuthPolicy's spec happens to specify a <code>rules</code> field, where the equivalent at the same level in RateLimitPolicy is called <code>limits</code>.</p> <p>This alternative design could make writing policies more like defining filters in an HTTPRoute, with the difference that policies are external to the target they extend (while filters are internal.) At the same time, it could be a replacement for Kuadrant route selectors, where the context of applicability of a policy rule is given by the very structure within the spec how the policy rule is declared (resembling the one of the target), thus also would shaping context for D/O.</p> <p>One caveat of this design though is that each policy specific definition (i.e. the rule specification that extends the object at a given point defined by the very structure of the spec) is exclusive of that given point in the structure of the object. I.e., one cannot specify a single policy rule that augments N &gt; 1 specific rules of a target HTTPRoute.</p> <p>Due to its relevance to the design of the API that enables D/O, this was left as an unresolved question. To be nonetheless noticed that, as a pattern, this alternative API design extends beyond inherited policies, impacting as well the direct policy kinds DNSPolicy and TLSPolicy.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#future-possibilities","title":"Future possibilities","text":""},{"location":"architecture/rfcs/0009-defaults-and-overrides/#n1-policy-target-relationship","title":"N:1 policy-target relationship","text":"<p>Although this proposal was thought to keep options open for multiple policies of a kind targeting a same network resource, this is currently not the state of things for Kuadrant. Instead, Kuadrant enforces 1:1 relationship between policies of a kind and target resources.</p> <p>Supporting N:1 relationships could enable use cases such as of App Developers defining D/O for each other at the same level of a shared xRoute, as well as Platform Engineers setting different policy rules on the same Gateway.</p> <p>This could provide an alternative to achieving separation of concerns for complex policy kinds such as the AuthPolicy, where different users could be responsible for authentication and authorization, without necessarily depending on defining new kinds of policies.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#route-rule-name-and-targetrefsectionname","title":"Route rule <code>name</code> and <code>targetRef.sectionName</code>","text":"<p>If Gateway API's GEP-995 is accepted (i.e. kubernetes-sigs/gateway-api#2593 gets merged) and the <code>name</code> field for route rules implemented in the APIs (HTTPRoute and GRPCRoute), this could impact how Kuadrant delivers D/O. Although the semantics could remain the same, the users specify the scope for a given set of policy rules could simplify significantly.</p> <p>As of today, Kuadrant's AuthPolicy and RateLimitPolicy APIs allow users to target sections of a HTTPRoute based on route selectors, and thus all the conflict resolution involved in handling D/O must take that logics into account.</p> <p>With named route rules supported by Gateway API, either route selectors could be redefined in a simpler form where each selector consists of a list of names of rules and/or entire policies could be scoped for a section of a resource, by defining the <code>targetRef</code> field based on the <code>PolicyTargetReferenceWithSectionName</code> type.</p> <p>To be noted GEP-2649's recommendation of not defining inherited policies that allow for <code>sectionName</code> in the <code>targetRef</code>. Nonetheless, this is a general rule from the spec said to be acceptable to be broken in the spirit of offering better functionality to users, provided it can deal with the associated discoverability and complexity problems of this feature.</p>"},{"location":"architecture/rfcs/0009-defaults-and-overrides/#use-listmaptype-instead-of-maps-of-policy-rules","title":"Use listMapType instead of maps of policy rules","text":"<p>Despite having recently modified the AuthPolicy and RateLimitPolicy APIs to use maps for declaring policy rules instead of lists (RFC 0001), reverting this design in future versions of these APIs, plus treating those lists as <code>listMapType</code>, could let us leverage the API server's strategic merge type to handle merges between policy objects.</p> <p>In the Policy CRDs, the policy rule types must specify a <code>name</code> field (required). The list of rules type (i.e. <code>[]Rule</code>) must then speficy the following Kubebuilder CRD processing annotations:</p> <pre><code>// +listType=map\n// +listMapKey=name\n</code></pre> <ol> <li> <p>As the time of writing, GEP-713 (Kubernetes Gateway API, SIG-NETWORK) is under revision, expected to be split into two separate GEPs, one for Direct Policies (GEP-2648) and one for Inherited Policies (GEP-2649.) Once these new GEPs supersede GEP-713, all references to the previous GEP in this document must be updated to GEP-2649.\u00a0\u21a9</p> </li> </ol>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/","title":"Gateway API Metrics Exporter","text":"<ul> <li>Feature Name: gateway-api-metrics-exporter</li> <li>Start Date: 2024-07-26</li> <li>RFC PR: Kuadrant/architecture#101</li> <li>Issue tracking: kuadrant-operator/issues/675</li> </ul>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#summary","title":"Summary","text":"<p>A new sub-project for a prometheus exporter that exports metrics about the state of Gateway API resources in a Kubernetes cluster.</p>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#motivation","title":"Motivation","text":"<p>Allow additional stateful information about Gateway API resources to be made available via metrics. Currently a set of metrics are made available via the gateway-api-state-metrics project. However, there are limitations with what resource information can be exposed using the underlying kube-state-metrics project. Additional stateful information would include:</p> <ul> <li>Individual listener status within a Gateway</li> <li>HTTPRoute status</li> </ul> <p>For example, the individual status listener information from a Gateway:</p> <pre><code>  status:\n    listeners:\n\n    - attachedRoutes: 1\n      conditions:\n      - lastTransitionTime: \"2023-08-15T13:22:06Z\"\n        message: No errors found\n        observedGeneration: 1\n        reason: Ready\n        status: \"True\"\n        type: Ready\n      - lastTransitionTime: \"2023-08-15T13:22:06Z\"\n        message: No errors found\n        observedGeneration: 1\n        reason: ResolvedRefs\n        status: \"True\"\n        type: ResolvedRefs\n      name: api\n</code></pre> <p>and HTTPRoute parents status conditions:</p> <pre><code>  status:\n    parents:\n\n    - conditions:\n      - lastTransitionTime: \"2024-05-16T16:17:38Z\"\n        message: Object affected by AuthPolicy default/toystore\n        observedGeneration: 1\n        reason: Accepted\n        status: \"True\"\n        type: kuadrant.io/AuthPolicyAffected\n      - lastTransitionTime: \"2024-05-16T16:18:51Z\"\n        message: Object affected by RateLimitPolicy default/toystore\n        observedGeneration: 1\n        reason: Accepted\n        status: \"True\"\n        type: kuadrant.io/RateLimitPolicyAffected\n      controllerName: kuadrant.io/policy-controller\n      parentRef:\n        group: gateway.networking.k8s.io\n        kind: Gateway\n        name: api-gateway\n        namespace: kuadrant-system\n    - conditions:\n      - lastTransitionTime: \"2024-05-16T16:17:38Z\"\n        message: Object affected by AuthPolicy default/toystore\n        observedGeneration: 1\n        reason: Accepted\n        status: \"True\"\n        type: kuadrant.io/AuthPolicyAffected\n      - lastTransitionTime: \"2024-05-16T16:18:51Z\"\n        message: Object affected by RateLimitPolicy default/toystore\n        observedGeneration: 1\n        reason: Accepted\n        status: \"True\"\n        type: kuadrant.io/RateLimitPolicyAffected\n      - lastTransitionTime: \"2024-05-20T11:45:33Z\"\n        message: Route was valid\n        observedGeneration: 1\n        reason: Accepted\n        status: \"True\"\n        type: Accepted\n      - lastTransitionTime: \"2024-05-20T11:45:33Z\"\n        message: All references resolved\n        observedGeneration: 1\n        reason: ResolvedRefs\n        status: \"True\"\n        type: ResolvedRefs\n      controllerName: istio.io/gateway-controller\n      parentRef:\n        group: gateway.networking.k8s.io\n        kind: Gateway\n        name: api-gateway\n        namespace: kuadrant-system\n</code></pre>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#guide-level-explanation","title":"Guide-level explanation","text":"<p>First, implement the existing Gateway API metrics that are part of the gateway-api-state-metrics project. This will allow the new prometheus exporter to replace that project as a whole. The metrics will be backwards compatible with the gateway-api-state-metrics project, with the addition of new metrics.</p> <p>Second, implement new metrics, as per the examples below, to capture the additional status information:</p> <p><pre><code>gatewayapi_gateway_status_listeners_conditions{namespace=\"&lt;NAMESPACE&gt;\",name=\"&lt;GATEWAY&gt;\",listener_name=\"&lt;LISTENER_NAME&gt;\",type=\"&lt;ResolvedRefs|Ready|Other&gt;} 1\n</code></pre> This metric captures the status condition types of individual listeners in a Gateway. It will allow the status of individual named listeners to be queried, graphed and alerted on via metrics. The health status of listeners can then be visualised in a stat panel in Grafana, showing healthy and unhealthy listeners. This expands the debugging path beyond just the overall health of a Gateway.</p> <p><pre><code>gatewayapi_httproute_status_parents_conditions{namespace=\"&lt;NAMESPACE&gt;\",name=\"&lt;GATEWAY&gt;\",controller_name=\"&lt;CONTROLLER_NAME&gt;\",\"parent_group=\"&lt;PARENT_GROUP&gt;\",parent_kind=\"&lt;PARENT_KIND&gt;\",parent_name=\"&lt;PARENT_NAME&gt;\",parent_namespace=\"&lt;PARENT_NAMESPACE&gt;\",type=\"&lt;ResolvedRefs|Accepted|Other&gt;} 1\n</code></pre> This metric captures the condition types for each parent of a HTTPRoute. The <code>type</code> field would also record any custom types set by a controller. For example, <code>kuadrant.io/AuthPolicyAffected</code> and <code>kuadrant.io/RateLimitPolicyAffected</code>. This will allow the health of HTTPRoutes to be reported via metrics. A HTTPRoute that has an <code>type</code> of Accepted and value of 1 means the HTTPRoute is accepted by the Gateway and can be considered healthy. It will also allow policy specific information about a HTTPRoute to be represented in metrics. For example, alerting on any HTTPRoutes that don't have the <code>kuadrant.io/AuthPolicyAffected</code> type with a value of 1 i.e. HTTPRoutes without an AuthPolicy.</p> <p>Tests will be added directly to the project in a similar manner to the redis-exporter. The test environment will bring up a kind cluster, create the Gateway API CRDs, example Gateway &amp; HTTPRoute resources, then test the scrape endpoint. This will be the same as how metrics are tested for the gateway-api-state-metrics project. There is a separate test function for each resource.</p> <p>Existing example dashboards in the gateway-api-state-metrics project will be copied over to the exporter project and continue to work as before. However, initially it will just be the Gateway, GatewayClass and HTTPRoute dashboards as those will be the metrics that are implemented first.</p>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#reference-level-explanation","title":"Reference-level explanation","text":"<p>The exporter will be written in golang and follow the guidelines from https://prometheus.io/docs/instrumenting/writing_exporters/. Other exporters like the https://github.com/prometheus/node_exporter/tree/master and https://github.com/oliver006/redis_exporter will be referenced for patterns and library usage. Metrics will only be pulled from the kubernetes API when Prometheus scrapes them. That is, the exporter will not perform scrapes based on its own timers. All scrapes will be synchronous.</p> <p>The client-go library will be used for all kubernetes API calls. As the number of Gateways and HTTPRoutes could vary greatly, there is a performance consideration with these API calls if there are a lot of resources. To allow for this, a single list of all resources of a kind will used rather than 1 by 1. If in future there are issues with performance, there is an option to cache responses to expensive queries.</p> <p>A 'gateway_metrics_up` metric will be included, as per https://prometheus.io/docs/instrumenting/writing_exporters/#failed-scrapes such that the exporter can continue to respond in a standard way if there are issues with some aspects of scraping. The scrape response should include all metrics that have information available at that time of scraping.</p>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#drawbacks","title":"Drawbacks","text":"<p>This is an additional library to maintain. However, it will supersede the gateway-api-state-metrics project and dependency on kube-state-metrics.</p>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>In theory it should be possible to get the desired functionality from the kube-state-metrics project if the proposed change in https://github.com/kubernetes/kube-state-metrics/pull/2059 is accepted and subsequently implemented. However, that proposal has been open since May 2023. I have ruled out the possibility of helping with the implementation of this change in that project due to:</p> <ul> <li>lack of detailed knowledge of the current implementation of selectors in kube-state-metrics</li> <li>potential complexity of implementing generic CEL support in that project</li> <li>it not being core to the Kuadrant project goals, combined with the ongoing maintenance commitment after implementation. It wouldn't be fair to land the change we need without following up on maintenance after</li> </ul> <p>The proposed design is a more focused solution on the needs of the Kuadrant project from Gateway API resources in the form of metrics. There are plenty of examples of exporters out there that we can reference and follow established patterns.</p> <p>If we don't make this change, we are limited to having just the overall Gateway status available via metrics, and no HTTPRoute status information on which we can visualise and alert.</p>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#prior-art","title":"Prior art","text":"<p>The primary prior art are the kube-state-metrics project, and the gateway-api-state-metrics projects. The gateway-api-state-metrics project uses the CustomResourceStateMetrics configuration feature of kube-state-metrics to configure what fields in which resources should be made available via metrics.</p>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#unresolved-questions","title":"Unresolved questions","text":"<p>n/a</p>"},{"location":"architecture/rfcs/0010-gateway-api-metrics-exporter/#future-possibilities","title":"Future possibilities","text":"<p>Although this exporter is intended to replace the gateway-api-state-metrics project, it will likely take a phased approach to get to that point. The initial goal is to get 'like for like' functionality from a Kuadrant project point of view (Gateways, GatewayClasses and HTTPRoutes), followed by the new status functionality as detailed in this RFC. Other resources, such as TLSRoute, UDPRoute etc.. can be added later.</p>"},{"location":"architecture/rfcs/0011-policy-machinery/","title":"Policy Machinery for reconciliation","text":"<ul> <li>Feature Name: <code>policy_machinery</code></li> <li>Start Date: 2024-07-03</li> <li>RFC PR: Kuadrant/architecture#95</li> <li>Issue tracking: Kuadrant/architecture#29</li> </ul>"},{"location":"architecture/rfcs/0011-policy-machinery/#summary","title":"Summary","text":"<p>Explain how Kuadrant's Policy Machinery can be used for reconciliation.</p>"},{"location":"architecture/rfcs/0011-policy-machinery/#motivation","title":"Motivation","text":"<p>The Policy Machinery project (repo, pkg.go) offers a set of types and functions for implementing Gateway API policies \u2013 i.e.</p> <ul> <li>highly flexible representation of topologies of targetable resources;</li> <li>calculating effective policies based on custom or default merge strategies;</li> <li>tooling to watch and reconcile resources based on cluster events.</li> </ul> <p>These can be used for tailoring implemention of Kuadrant policies and Kuadrant instances. See example provided.</p> <p>Leveraging the Policy Machinery can be key to:</p> <ol> <li>Improve flow control of concurrent reconciliation events</li> <li>Simplification of the calculation of effective policies respectively to the topological routing path of the requests</li> <li>Correct implementation of Defaults &amp; Overrides' <code>merge</code> strategy (RFC 0009)</li> <li>Supporting multiple policies targeting a same resource</li> <li>Supporting targeting sections of a resource (e.g. Gateway listeners, HTTPRouteRules)</li> <li>Supporting multiple targetRefs in a policy</li> <li>Extending policies to target other kinds of resources (e.g. GatewayClass, Service, Namespace) -\u2013 future</li> </ol>"},{"location":"architecture/rfcs/0011-policy-machinery/#guide-level-explanation","title":"Guide-level explanation","text":"<p>Although essentially an implementation detail of the Kuadrant Operator, levering the Policy Machinery may introduce the following user-perceived features:</p> <ul> <li>Acknowledgement of the topological routing path of the request respectively to applicable effective policies</li> <li>New form of targeting sections of a resource with a policy</li> <li>Elevated meaning of uniquely identifiable concepts across policy resources (e.g. named policy rules)</li> <li>Possibility of multiple policies of a kind targeting a same resource</li> <li>(Window of opportunity for) introducing plural targetRefs</li> </ul>"},{"location":"architecture/rfcs/0011-policy-machinery/#user-acknowledgeable-reference-of-the-topological-routing-path-of-the-request","title":"User-acknowledgeable reference of the topological routing path of the request","text":"<p>One who specifies Kuadrant policies targeting resources at any levels of the hierarchy Gateway \u2192 Listener \u2192 HTTPRoute \u2192 HTTPRouteRule<sup>1</sup> shall expect the effect of such policies to be reported always respectively to the lowest level of the hierarchy that the kind of policy allows targeting. E.g.:</p> <ul> <li>A DNSPolicy that allows targeting a Gateway hypothetically with or without specifying a <code>sectionName</code> actually targets gateway listeners; the user wants to reason about the state of DNSPolicies regarding their effect on each listeners specified in the Gateway. In a context with 2+ DNSPolicies, simultaneously targeting both a Gateway and specific listeners, DNS records for some listener hostnames may have been reconciled according to the specification from one policy or another, occasionally no policy at all.</li> <li>A RateLimitPolicy that allows targeting a Gateway, a HTTPRoute or specific HTTPRouteRule actually targets (directly or indirectly) HTTPRouteRule objects; the user wants to reason about the state of all RateLimitPolicies with respect to each HTTPRouteRule, where some HTTPRouteRules may be protected by one RateLimitPolicy, a combination of multiple RateLimitPolicies, or occasionally no RateLimitPolicy at all.</li> </ul> <p>In the specific case of policy kinds that allow targeting HTTPRouteRules, due to complex network topologies supported by Gateway API, including in particular HTTPRoutes with multiple Gateway parents, a same HTTPRouteRule may or may not be affected by a policy, depending on which routing path in the network topology a request flows. Therefore, ultimately users will reason about policies and effective policies in terms of the paths between at least gateways and the lowest levels targeted by the policies that a request can flow. Possibly, in terms of all possible paths between Gateways and Services.</p> <p>Kuadrant shall provide users with such visibility. Leveraging Policy Machinery is an implementation detail that nonetheless makes achieving this goal easier.</p>"},{"location":"architecture/rfcs/0011-policy-machinery/#user-facing-changes-to-the-policy-apis","title":"User-facing changes to the policy APIs","text":""},{"location":"architecture/rfcs/0011-policy-machinery/#targeting-sections-of-network-resource","title":"Targeting sections of network resource","text":"<p>Leveraging Policy Machinery may also motivate some user-facing changes. In particular, replacing AuthPolicy's and RateLimitPolicy's <code>routeSelectors</code> for a <code>targetRef</code> with optional <code>sectionName</code> (made possible since kubernetes-sigs/gateway-api#2895.)</p> <p>This change would cause a policy of AuthPolicy or RateLimitPolicy kind to always be attached to its targets entirely, i.e. without having rules that attach to some sections and other rules to other sections or no section at all. This differs from current situation where a policy of those kinds can be attached to a HTTPRoute and some of the policy's rules more specifically attached to individual HTTPRouteRules only, including with multiple policy rules attached to different HTTPRouteRules of the same targeted HTTPRoute. Instead, attaching a policy must be a cohesive, unambiguous operation, that occasionally requires users to specify more fine-grained policy objects to be attached only to sections of a resource.</p>"},{"location":"architecture/rfcs/0011-policy-machinery/#identity-of-concepts-across-multiple-policy-objects","title":"Identity of concepts across multiple policy objects","text":"<p>In some cases, splitting policy objects for the purpose of targeting sections of a network resource, without breaking the semantics of having a single set of policy objects cohesively defined, also implies that definitions about a same entity or concept within a policy (e.g. a limit definition), repeated at multiple policy objects, may have a way to represent to refer to the same thing (e.g. same set of counters).</p> <p>This is the case, for example, of limit definitions in a RateLimitPolicy as well as cache configs in an AuthPolicy. To avoid creating multiple rate-limit counter namespaces (analogously, multiple authorization rule cache entries) for definitions that are effectively about the same entity, despite specified at multiple policy objects, the APIs must provide a way for users to convey one of the other intent: definitions refer to the same thing versus definitions refer to different things.<sup>2</sup></p>"},{"location":"architecture/rfcs/0011-policy-machinery/#other-user-facing-changes","title":"Other user-facing changes","text":"<p>The following possible (non-required) other user-facing changes can be enabled leveraging Policy Machinery, without marginal implementation cost:</p> <ol> <li>Plural <code>targetRefs</code>.</li> <li>Multiple policies of a kind targeting a same network resource/resource section (\"horizontal Defaults &amp; Overrides.\")</li> <li>Aesthetical difference between Direct versus Inherited policies, implied by the merge strategies implemented by each kind of policy, rather than a necessary distinction.</li> </ol>"},{"location":"architecture/rfcs/0011-policy-machinery/#reference-level-explanation","title":"Reference-level explanation","text":"<p>Usage of the Policy Machinery consists of importing two packages:</p> <ul> <li><code>machinery</code>: provides the types and abstractions to build Gateway API topologies of targetable network resources, policies and adjacent objects;</li> <li><code>controller</code>: offers tools for implementing topology-based custom controllers of reconciliation logic.</li> </ul> <p>From that on, the following steps drive leveraging the Policy Machinery in the Kuadrant Operator:</p> <ol> <li> <p>Implement the <code>machinery.Policy</code> interface for all kinds of policies.</p> <p>Example provided for the DNSPolicy, TLSPolicy, AuthPolicy and RateLimitPolicy kinds.</p> </li> <li> <p>Define wrappers that implement the <code>machinery.Object</code> interface for any kind of adjacent object whose unique identifier as a node in the topology graph cannot be based on the default <code>controller.RuntimeObject</code> type provided (if any.)</p> </li> <li> <p>Implement the linking functions for all kinds of adjacent objects and corresponding parents and children in the topology graph, including types such as <code>Kuadrant</code>, Istio's <code>WasmPlugin</code>, <code>ConfigMap</code>, etc.</p> <p>The <code>Kuadrant</code> custom resources shall be the roots of a directed acyclic graph (DAG) from which an entired topology of targetable network resources, adjacent objects and policies are connected.</p> </li> <li> <p>Start a <code>controller.Controller</code> that:</p> <ol> <li>Watches for all kinds of objects to be represented in the topology.</li> <li>Triggers a <code>controller.Workflow</code> on events related to any of the watched resources.</li> </ol> </li> <li> <p>At every reconciliation event<sup>3</sup>:</p> <ol> <li> <p>Reconcile the internal objects for setting up the environment for a Kuadrant instance (deployments, gateway controller configs, etc).</p> </li> <li> <p>For each kind of policy and applicable path in the topology graph relevant for the policy kind:</p> </li> <li> <p>Compute an effective policy and give it a unique identifier.</p> </li> <li>Perform (or delegate) the policy-specific configuration (DNS, TLS, Auth, RL) of the effective policy with the policy decision/enforcement point<sup>4</sup>.</li> <li>For policy kinds enforced at request time (data-plane policies), configure the gateway to call the policy decision point (PDP) on requests that match the attributes of the path<sup>5</sup>, passing in the payload to the PDP the identifier of the effective policy.</li> <li> <p>Update the status stanzas of all targetables in the topology whose paths were configured for an effective policy (or lack of such), with a map that allows users to inspect, for a given path, what effective policy (if any) will be enforced.        &gt; Note: If unsuitable for the status stanza of the object, the details of the effective policies may require additional tooling to be inspected by the users and the mapping must be to the unique identifier of the effective policy.</p> </li> <li> <p>Store a DOT representation of the topology graph in a ConfigMap.</p> </li> </ol> </li> </ol>"},{"location":"architecture/rfcs/0011-policy-machinery/#drawbacks","title":"Drawbacks","text":"<p>Part of the work consists on refactoring, without value perceived by the user.</p>"},{"location":"architecture/rfcs/0011-policy-machinery/#rationale-and-alternatives","title":"Rationale and alternatives","text":""},{"location":"architecture/rfcs/0011-policy-machinery/#annotations","title":"Annotations","text":"<p>Use of annnotations to track back references from targeted objects to policies. This approach has been slowly deprecated to favour the use of an in-memory directed acyclic graph (DAG) representing the relationship between network objects and policies<sup>6</sup>.</p>"},{"location":"architecture/rfcs/0011-policy-machinery/#bottom-up-reconciliation","title":"Bottom-up reconciliation","text":"<p>Bottom-up reconciliation by default, focusing on the policy resources first. This approach has been slowly refactored to using mappers (event handlers) that often multiply a lower-level event into multiple top-down ones, occasionally with the occurrence of repetitive events.</p>"},{"location":"architecture/rfcs/0011-policy-machinery/#dag-10","title":"DAG 1.0","text":"<p>Preliminary version of the topology DAG<sup>6</sup> that:</p> <ol> <li>is bootstrapped at every reconciliation event (though leveraging k8s.io/apimachinery's and sigs.k8s.io/controller-runtime's caches);</li> <li>does not include all kinds of targetables \u2013 missing object sections in particular;</li> <li>does not include internal configuration objects;</li> <li>was designed for one single kind of policy in each instance of the topology.</li> </ol>"},{"location":"architecture/rfcs/0011-policy-machinery/#effective-policy-less-reconciliation","title":"Effective policy-less reconciliation","text":"<p>Configuration of internal resources for implementing effective policy behavior:</p> <ol> <li>tailored for each specific kind of policy, without leveraging generic and resusable merge strategy functions;</li> <li>not organically integrated with the topology DAG;</li> <li>decoupled from the rather user-acknowledgeable reference of the topological routing path of the request.</li> </ol>"},{"location":"architecture/rfcs/0011-policy-machinery/#prior-art","title":"Prior art","text":""},{"location":"architecture/rfcs/0011-policy-machinery/#envoy-gateway-state-of-the-world-reconciliation","title":"Envoy Gateway state-of-the-world reconciliation","text":"<p>Envoy Gateway has implemented a custom controller for Gateway API and provider-specific resources with the following characteristics similar to the Policy Machinery <code>controller</code> package's approach:</p> <ol> <li>Based on controller-runtime</li> <li>Single <code>Reconcile</code> function that:<ol> <li>lists all watched resources from the cluster at every reconciliation event;</li> <li>rebuilds and updates a long-living watchable map of all the resources;</li> <li>trigger reconciliation logic subscribed to changes to the map \u2013 <code>goroutines</code> decoupled from controller-runtime.</li> </ol> </li> </ol>"},{"location":"architecture/rfcs/0011-policy-machinery/#unresolved-questions","title":"Unresolved questions","text":"<ul> <li>The fanout problem, especially of status reconciliation.</li> <li>~~How to avoid changes performed by the reconciliation function to loop back in the form of multiple other (no-op) reconciliation events.~~ \u21e8 issue state-modifying actions against the API server directly and safe-guard against create/update/delete events for states already reflected in the topology</li> <li>~~How to compact multiple equifinal reconciliation events waiting in the queue into a single one, thus avoiding unnecessary loops.~~ \u21e8 rely on controller-runtime event coalescing</li> <li>~~What to do in case of reconciliation failures without retry~~ \u21e8 always move the system to a final state, with proper status updating, and wait until state-of-the-world reconciliation kicks in again on the next event</li> </ul>"},{"location":"architecture/rfcs/0011-policy-machinery/#future-possibilities","title":"Future possibilities","text":"<ul> <li>Extending policies to target other kinds of resources (e.g. GatewayClass, Service, Namespace.)</li> </ul> <ol> <li> <p>Gateway listeners and HTTPRouteRules can be targeted by specifying in a policy their main Gateway and HTTPRoute objects as targets, in combination with either a <code>sectionName</code> (supported in the <code>targetRef</code> field of the policy) or via <code>routeSelectors</code> (in the policy spec proper), respectively. Not all kinds of policies support targeting all 4 kinds of targetables of the Gateway \u2192 Listener \u2192 HTTPRoute \u2192 HTTPRouteRule hierarchy; some kinds of policies may support targeting only a few of those.\u00a0\u21a9</p> </li> <li> <p>In the context of rate-limit, this problem is also referred to as the problem of the identity of a limit.\u00a0\u21a9</p> </li> <li> <p>Specific steps can be filtered by type of event.\u00a0\u21a9</p> </li> <li> <p>While the DNS operator as well as the configuration performed by the Kuadrant Operator for a TLSPolicy are closer to the enforcement of the specifications in the DNS and TLS policy objects, Authorino and Limitador are policy decision points (PDP) rather. Indistinctively, control-plane operations that configure a service based on the specification of a policy, as well as the data-plane protection services that perform at request-time along with the gateways are all part of the policy enforcement.\u00a0\u21a9</p> </li> <li> <p>The attributes of a path in the topology from a Gateway to a HTTPRouteRule object typically include a hostname and the set of HTTPRouteMatches specified in the HTTPRouteRule.\u00a0\u21a9</p> </li> <li> <p>See kuadrant-operator#530.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"architecture/rfcs/dns-policy-api-changes/","title":"RFC DNSPolicy v1 changes and improvements","text":"<ul> <li>Feature Name: (<code>dns_policy_api_changes</code>)</li> <li>Start Date: (2024-09-11)</li> <li>RFC PR: Kuadrant/architecture#0000</li> <li>Issue tracking: https://github.com/Kuadrant/architecture/issues/104</li> </ul>"},{"location":"architecture/rfcs/dns-policy-api-changes/#summary","title":"Summary","text":"<p>DNSPolicy is soon to go GA. There are several improvement we have identified over time that will enhance the GA of this API</p> <ul> <li> <p>Remove the need for labels on Gateways for GEO and custom weighting values</p> </li> <li> <p>Reduce the verbosity of GEO and Weighting definitions</p> </li> <li> <p>Remove the need for a strategy to be chosen as part of the policy definition.</p> </li> </ul>"},{"location":"architecture/rfcs/dns-policy-api-changes/#motivation","title":"Motivation","text":"<p>We want to simplify and improve the DNSPolicy API and remove some of the legacy structures that have hung on since its original inception, as this involves some breaking changes we want these before we create a v1 API.</p> <p>Weighting and GEO attributes:</p> <p>The loadbalancing options we provide were first designed as part of an API that was intended to work with OCM (open cluster management). This provided multiple views of gateways across multiple clusters. So in order to understand the GEO context or individual weighing needed for a given cluster, we needed that context applying separately from the DNSPolicy spec that for legacy reasons targeted a \"template\" Gateway in the hub cluster.</p> <p>Now DNSPolicy is created on the same cluster as the actual Gateway and we do not use OCM or hub clusters, the need to label individual objects and Gateways with specific annotations and labels is now redundant and makes for a more complex and awkward API interaction.</p> <p>routingStrategy:</p> <p>We have also identified that the routingStrategy option in the DNSPolicy spec is redundant. When added we expected there to be more than two strategies. This has not emerged and so it is another awkward piece of the API that is not needed.</p>"},{"location":"architecture/rfcs/dns-policy-api-changes/#guide-level-explanation","title":"Guide-level explanation","text":"<p>You will no longer need to apply labels to Gateways in order to specify the GEO or Weighting for that Gateway. The policy targets a given Gateway and you will now just specify those values in the policy spec directly.</p> <p>You will no longer need to specify what routingStrategy you want to use. Instead you will either specify a loadbalancing section (meaning it is a loadbalanced strategy) or you will leave it empty (meaning it has no loadbalancing).</p>"},{"location":"architecture/rfcs/dns-policy-api-changes/#reference-level-explanation","title":"Reference-level explanation","text":"<p>Below is an example of what is currently needed to setup GEO and Custom Weighting with the existing API</p> <p><pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: ingress-gateway\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  routingStrategy: loabalanced  \n  loadBalancing:\n    weighted:\n      defaultWeight: 120\n      custom: # &lt;--- New Custom Weights being added\n\n        - weight: 255\n          selector:\n            matchLabels:\n              kuadrant.io/lb-attribute-custom-weight: AWS # slects gateways to apply it to (when there can only be one)\n    geo: \n      defaultGeo: US #catch all geo              \n</code></pre> So here to apply a custom weighting, you have to specify the weighting under the custom section and then apply the <code>kuadrant.io/lb-attribute-custom-weight: AWS</code> label to the gateway that is already being targeted by the policy. </p> <p>To change the GEO for the targeted cluster, you need to apply a different label to the gateway: <code>kuadrant.io/lb-attribute-geo-code: EU</code> for example. </p> <p>On top of this you also have to specify that it is a load balanced DNSPolicy even though you have specified a load balancing section. </p> <p>This is an awkward and disconnected API that evolved from the legacy requirements called out above.</p> <p>Instead the new API to achieve the same goal will be:</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: ingress-gateway\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  loadBalancing:\n    weight: 100 #weight for listeners targeted \n    geo: US # geo for listeners targeted \n    defaultGEO: true # should this be consisdered the default GEO for the listener hosts\n  providerRefs:\n\n    - name: aws-credential-secret    \n</code></pre> <p>So no longer do you need to specify whether the policy is a load balanced one or not via the redundant <code>routingStrategy</code> field</p> <p>Now you simplify specify the weight you want to use for the listeners in the gateway, the geo you want to use and whether it should be used as a default GEO or not (this is used by some cloud providers as a catch-all option if a user from a none specified GEO does a DNS lookup.). Each of the fields under \"loadbalancing\" will now be required.</p> <p>From an implementation perspective, all changes will happen in the Kuadarant Operator, where it will no longer look for the attribute labels on the gateways but instead will simply use the spec of the DNSPolicy. The resulting DNSRecord will not change in structure. </p> <p>To setup a simple DNS structure (single A or CNAME record), the API would now look like:</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: ingress-gateway\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:\n\n    - name: aws-credential-secret    \n</code></pre> <p>Again no need for the redundant strategy field. </p>"},{"location":"architecture/rfcs/dns-policy-api-changes/#drawbacks","title":"Drawbacks","text":"<p>Introduces a breaking change to the API.</p>"},{"location":"architecture/rfcs/dns-policy-api-changes/#rationale-and-alternatives","title":"Rationale and alternatives","text":"<p>These are breaking changes and we are about to move to v1. Changes like these should land pre v1. These changes provide a much simpler and better user experience.</p>"},{"location":"architecture/rfcs/dns-policy-api-changes/#prior-art","title":"Prior art","text":"<p>NA</p>"},{"location":"architecture/rfcs/dns-policy-api-changes/#unresolved-questions","title":"Unresolved questions","text":"<p>NA</p>"},{"location":"architecture/rfcs/dns-policy-api-changes/#future-possibilities","title":"Future possibilities","text":"<p>NA</p>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/","title":"DNSRecordStructure","text":"<p>DNSRecord is our API for expressing DNS endpoints via a kube CRD based API. It is managed by the multi-cluster gateway controller based on the desired state expressed in higher level APIs such as the Gateway or a DNSPolicy. In order to provide our feature set, we need to carefully consider how we structure our records and the types of records we need. This document proposes a particular structure based on the requirements and feature set we have.</p>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#requirements","title":"Requirements","text":"<p>We want to be able to support Gateway definitions that use the following listener definitions:</p> <ul> <li>wildcard: <code>*.example.com</code> and fully qualified listener host <code>www.example.com</code> definitions with the notable exception of fully wildcarded ie <code>*</code> as we cannot provide any DNS or TLS for something with no defined hostname.</li> <li>listeners that have HTTPRoute defined on less than all the clusters where the listener is available. IE we don't want to send traffic to clusters where there is no HTTPRoute attached to the listener.</li> <li>Gateway instances that provide IPs that are deployed alongside instances on different infra that provide host names causing the addresses types on each of gateway instance to be different (IPAddress or HostAddress). </li> <li>We want to provide GEO based DNS as a feature of DNSPolicy and so our DNSRecord structure must support this.</li> <li>We want to offer default weighted and custom weighted DNS as part of DNSPolicy</li> <li>We want to allow root or apex domain to be used as listener hosts</li> </ul>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#diagram","title":"Diagram","text":"<p>https://lucid.app/lucidchart/2f95c9c9-8ddf-4609-af37-48145c02ef7f/edit?viewport_loc=-188%2C-61%2C2400%2C1183%2C0_0&amp;invitationId=inv_d5f35eb7-16a9-40ec-b568-38556de9b568</p>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#proposal","title":"Proposal","text":"<p>For each listener defined in a gateway, we will create a set of records with the following rules.</p> <p>none apex domain:</p> <p>We will have a generated lb (load balancer) dns name that we will use as a CNAME for the listener hostname. This DNS name is not intended for use within a HTTPRoute but is instead just a DNS construct. This will allow us to set up additional CNAME records for that DNS name in the future that are returned based a GEO location. These DNS records will also be CNAMES pointing to specific gateway dns names, this will allow us to setup a weighted response. So the first layer CNAME handles balancing based on geo, the second layer handles balancing based on weighting. </p> <pre><code>                                        shop.example.com\n                                        |             |\n                                      (IE)          (AUS)\n                                CNAME lb.shop..      lb.shop..\n                                    |     |         |      |\n                                 (w 100) (w 200)   (w 100) (w100)\n                                CNAME g1.lb.. g2.lb..   g3.lb..  g4.lb..\n                                A 192..   A 81..  CNAME  aws.lb   A 82..\n</code></pre> <p>When there is no geo strategy defined within the DNSPolicy, we will put everything into a default geo (IE a catch-all record) <code>default.lb-{guid}.{listenerHost}</code> but set the routing policy to GEO allowing us to add more geo based records in the future if the gateway admin decides to move to a geo strategy as their needs grow. </p> <p>To ensure this lb dns name is unique and does not clash we will use a short guid as part of the subdomain so <code>lb-{guid}.{listenerHost}.</code> this guid will be based on the gateway name and gateway namespace in the control plane.</p> <p>For a geo strategy we will add a geo record with a prefix to the lb subdomain based on the geo code. When there is no geo we will use <code>default</code> as the prefix. <code>{geo-code}.lb-{guid}.{listenerHost}</code>. Finally, for each gateway instance on a target cluster we will add a <code>{spokeClusterName}.lb-{guid}.{listenerHost}</code></p> <p>To allow for a mix of hostname and IP address types, we will always use a CNAME . So we will create a dns name for IPAddress with the following structure: <code>{guid}.lb-{guid}.{listenerHost}</code> where the first guid will be based on the cluster name where the gateway is placed.</p>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#apex-domains","title":"Apex Domains","text":"<p>An apex domain is the domain at the apex or root of a zone. These are handled differently by DNS as they often have NS and SOA records. Generally it is not possible to set up a CNAME for apex domain (although some providers allow it).</p> <p>If a listener is added to a gateway that is an apex domain, we can only add A records for that domain to keep ourselves compliant with as many providers as possible. If a listener is the apex domain, we will setup A records for that domain (favouring gateways with an IP address or resolving the IP behind a host) but there will be no special balancing/weighting done. Instead, we will expect that the owner of that will setup a HTTPRoute with a 301 permanent redirect sending users from the apex domain e.g. example.com to something like: www.example.com where the www subdomain based listener would use the rules of the none apex domains and be where advanced geo and weighted strategies are applied.</p> <ul> <li>gateway listener host name : example.com <ul> <li>example.com A 81.17.241.20</li> </ul> </li> </ul>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#geo-agnostic-everything-is-in-a-default-geo-catch-all","title":"Geo Agnostic (everything is in a default * geo catch all)","text":"<p>This is the type of DNS Record structure that would back our default DNSPolicy.</p> <ul> <li> <p>gateway listener host name : www.example.com </p> <p>DNSRecords:</p> <ul> <li>www.example.com CNAME lb-1ab1.www.example.com </li> <li>lb-1ab1.www.example.com CNAME geolocation * default.lb-1ab1.www.example.com </li> <li>default.lb-1ab1.www.example.com CNAME weighted 100 1bc1.lb-1ab1.www.example.com</li> <li>default.lb-1ab1.www.example.com CNAME weighted 100 aws.lb.com</li> <li>1bc1.lb-1ab1.www.example.com A 192.22.2.1</li> </ul> </li> </ul> <p>So in the above example working up from the bottom, we have a mix of hostname and IP based addresses for the gateway instance. We have 2 evenly weighted records that balance between the two available gateways, then next we have the geo based record that is set to a default catch all as no geo has been specified then finally we have the actual listener hostname that points at our DNS based load balancer name.</p> <p>DNSRecord Yaml</p> <pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: {gateway-name}-{listenerName}\n  namespace: multi-cluster-gateways\nspec:\n  dnsName: www.example.com\n  managedZone:\n    name: mgc-dev-mz\n  endpoints:\n\n    - dnsName: www.example.com\n      recordTTL: 300\n      recordType: CNAME\n      targets:\n        - lb-1ab1.www.example.com\n    - dnsName: lb-1ab1.www.example.com\n      recordTTL: 300\n      recordType: CNAME\n      setIdentifier: mygateway-multicluster-gateways\n      providerSpecific:\n        - name: \"geolocation-country-code\"\n          value: \"*\"\n      targets:\n        - default.lb-1ab1.www.example.com\n    - dnsName: default.lb-1ab1.www.example.com\n      recordTTL: 300\n      recordType: CNAME\n      setIdentifier: cluster1\n      providerSpecific:\n        - name: \"weight\"\n          value: \"100\"\n      targets:\n        - 1bc1.lb-1ab1.www.example.com\n    - dnsName: default.lb-a1b2.shop.example.com\n      recordTTL: 300\n      recordType: CNAME\n      setIdentifier: cluster2\n      providerSpecific:\n        - name: \"weight\"\n          value: \"100\"\n      targets:\n        - aws.lb.com\n    - dnsName: 1bc1.lb-1ab1.www.example.com\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 192.22.2.1\n</code></pre>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#geo-specific","title":"geo specific","text":"<p>Once the end user selects to use a geo strategy via the DNSPolicy, we then need to restructure our DNS to add in our geo specific records. Here the default record</p> <p>lb short code is {gw name + gw namespace} gw short code is {cluster name}</p> <ul> <li> <p>gateway listener host : shop.example.com  </p> <p>DNSRecords:</p> <ul> <li>shop.example.com CNAME lb-a1b2.shop.example.com </li> <li>lb-a1b2.shop.example.com  CNAME geolocation ireland ie.lb-a1b2.shop.example.com </li> <li>lb-a1b2.shop.example.com  geolocation australia aus.lb-a1b2.shop.example.com </li> <li>lb-a1b2.shop.example.com  geolocation default ie.lb-a1b2.shop.example.com  (set by the default geo option)</li> <li>ie.lb-a1b2.shop.example.com   CNAME weighted 100 ab1.lb-a1b2.shop.example.com </li> <li>ie.lb-a1b2.shop.example.com   CNAME weighted 100 aws.lb.com</li> <li>aus.lb-a1b2.shop.example.com  CNAME weighted 100 ab2.lb-a1b2.shop.example.com </li> <li>aus.lb-a1b2.shop.example.com  CNAME weighted 100 ab3.lb-a1b2.shop.example.com </li> <li>ab1.lb-a1b2.shop.example.com  A 192.22.2.1 192.22.2.5</li> <li>ab2.lb-a1b2.shop.example.com  A 192.22.2.3</li> <li>ab3.lb-a1b2.shop.example.com  A 192.22.2.4</li> </ul> </li> </ul> <p>In the above example we move from a default catch all to geo specific setup. Based on a DNSPolicy that specifies IE as the default geo location. We leave the <code>default</code> subdomain in place to allow for clients that may still be using that and set up geo specific subdomains that allow us to route traffic based on its origin. In this example we are load balancing across 2 geos and 4 clusters</p>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#wildcards","title":"WildCards","text":"<p>In the examples we have used fully qualified domain names, however sometimes it may be required to use a wildcard subdomain. example:</p> <ul> <li>gateway listener host : *.example.com  </li> </ul> <p>To support these we need to change the name of the DNSRecord away from the name of the listener as the k8s resource does not allow * in the name. </p> <p>To do this we will set the dns record resource name to be a combination of <code>{gateway-name}-{listenerName}</code></p> <p>to keep a record of the host this is for we will set a top level property named <code>dnsName</code>. You can see an example in the DNSRecord above.</p>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#pros","title":"Pros","text":"<p>This setup allows us a powerful set of features and flexibility</p>"},{"location":"architecture/rfcs/0003-dns-policy-assets/DNSRecordStructure/#cons","title":"Cons","text":"<p>With this CNAME based approach we are increasing the number of DNS lookups required to get to an IP which will increase the cost and add a small amount of latency. To counteract this, we will set a reasonably high TTL (at least 5 mins) for our CNAMES and (2 mins) for A records</p>"},{"location":"api-quickstart/","title":"API Quickstart","text":""},{"location":"api-quickstart/#introduction","title":"Introduction","text":"<p>This document details how to setup a local reference architecture, and design and deploy an API. This will show the following API management features in a kube native environment using Kuadrant and other open source tools:</p> <ul> <li>API design</li> <li>API security and access control</li> <li>API monitoring</li> <li>Traffic management and scalability</li> </ul> <p>The sections in this document are grouped by the persona that is typically associated with the steps in that section. The 3 personas are:</p> <ul> <li>The platform engineer, who provides and maintains a platform for application developers,</li> <li>the application developer, who designs, builds and maintains applications and APIs,</li> <li>and the api consumer, who makes API calls to the API</li> </ul>"},{"location":"api-quickstart/#pre-requisities","title":"Pre-requisities","text":"<ul> <li><code>docker</code>: https://www.docker.com/products/docker-desktop/</li> <li><code>kind</code>: https://kind.sigs.k8s.io/</li> <li><code>kubectl</code>: https://kubernetes.io/docs/reference/kubectl/</li> <li><code>kustomize</code>: https://kustomize.io/</li> <li><code>helm</code>: https://helm.sh/docs/intro/install/</li> <li><code>operator-sdk</code>: https://sdk.operatorframework.io/docs/installation/</li> <li>An AWS account with a Secret Access Key and Access Key ID. You will also need to a Route 53 zone.</li> </ul>"},{"location":"api-quickstart/#platform-engineer-platform-setup","title":"(Platform engineer) Platform Setup","text":"<p>Export the following env vars:</p> <pre><code>export KUADRANT_AWS_ACCESS_KEY_ID=&lt;key_id&gt;\nexport KUADRANT_AWS_SECRET_ACCESS_KEY=&lt;secret&gt;\nexport KUADRANT_AWS_REGION=&lt;region&gt;\nexport KUADRANT_AWS_DNS_PUBLIC_ZONE_ID=&lt;zone&gt;\nexport KUADRANT_ZONE_ROOT_DOMAIN=&lt;domain&gt;\n</code></pre> <p>Clone the api-quickstart repo and run the quickstart script:</p> <pre><code>git clone git@github.com:Kuadrant/api-quickstart.git &amp;&amp; cd api-quickstart\n./quickstart.sh\n</code></pre> <p>This will take several minutes as 3 local kind clusters are started and configured in a hub and spoke architecture. The following components will be installed on the clusters:</p> <ul> <li>Hub</li> <li>Open Cluster Management, as a 'hub' cluster</li> <li>Kuadrant Multi Cluster Gateway Controller, for managing a Gateway in multiple clusters centrally</li> <li>Gatekeeper, for constraints on Gateway Policy requirements</li> <li>Thanos, for receiving metrics centrally</li> <li>Grafana, for visualising API &amp; Gateway metrics</li> <li>Spoke x2</li> <li>Open Cluster Management, as a 'spoke' cluster</li> <li>Kuadrant Operator, for auth and rate limiting policies attached to a HTTPRoute</li> <li>Istio, with the Gateway API CRDs as the Gateway for ingress trafic</li> <li>MetalLB, for exposing the Gateway service on the local network</li> <li>Prometheus, for scraping and federating metrics to the hub</li> </ul>"},{"location":"api-quickstart/#verify-the-gateway-and-configuration","title":"Verify the Gateway and configuration","text":"<p>View the ManagedZone, Gateway and TLSPolicy. The ManagedZone and TLSPolicy should have a Ready status of true. The Gateway should have a Programmed status of True.</p> <pre><code>kubectl --context kind-api-control-plane get managedzone,tlspolicy,gateway -n multi-cluster-gateways\n</code></pre>"},{"location":"api-quickstart/#guard-rails-constraint-warnings-about-missing-policies-dns-tls","title":"Guard Rails: Constraint warnings about missing policies ( DNS, TLS)","text":"<p>Running the quick start script above will bring up Gatekeeper and the following constraints: </p> <ul> <li>Gateways must have a TLSPolicy targeting them</li> <li>Gateways must have a DNSPolicy targeting them</li> </ul> <p>To view the above constraints in kubernetes, run this command: <pre><code>kubectl --context kind-api-control-plane get constraints\n</code></pre></p> <p>Info</p> <p>Since a gateway has been created automatically, along with a <code>TLSPolicy</code>, the violation for a missing <code>DNSPolicy</code> will be active until one is created.</p>"},{"location":"api-quickstart/#grafana-dashboard-view","title":"Grafana dashboard view","text":"<p>To get a top level view of the constraints in violation, the <code>Stitch: Platform Engineer Dashboard</code> can be used. This can be accessed by at https://grafana.172.31.0.2.nip.io</p> <p>Grafana has a default username and password of <code>admin</code>. You can find the <code>Stitch: Platform Engineer Dashboard</code> dashboard in the <code>Default</code> folder.</p>"},{"location":"api-quickstart/#create-the-missing-dnspolicy","title":"Create the missing DNSPolicy","text":"<p>Create a DNSPolicy that targets the Gateway with the following command:</p> <pre><code>kubectl --context kind-api-control-plane apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1alpha1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: multi-cluster-gateways\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  loadBalancing:\n    geo:\n      defaultGeo: EU\nEOF\n</code></pre>"},{"location":"api-quickstart/#platform-overview","title":"Platform Overview","text":"<p>Since we have created all the policies that Gatekeeper had the guardrails around, you should no longer see any constraints in violation. This can be seen back in the <code>Stitch: Platform Engineer Dashboard</code> in Grafana at https://grafana.172.31.0.2.nip.io</p>"},{"location":"api-quickstart/#application-developer-app-setup","title":"(Application developer) App setup","text":""},{"location":"api-quickstart/#api-design","title":"API Design","text":"<p>Fork and/or clone the Petstore App at https://github.com/Kuadrant/api-petstore</p> <pre><code>git clone git@github.com:kuadrant/api-petstore &amp;&amp; cd api-petstore\n# Or if you forked the repository:\n# git clone git@github.com:&lt;your_github_username&gt;/api-petstore &amp;&amp; cd api-petstore\n</code></pre> <p>Then deploy it to the first workload cluster:</p> <pre><code>kustomize build ./resources/ | envsubst | kubectl --context kind-api-workload-1 apply -f-\n</code></pre> <p>This will deploy:</p> <ul> <li>A <code>petstore</code> Namespace</li> <li>A <code>Secret</code>, containing a static API key that we'll use later for auth</li> <li>A <code>Service</code> and <code>Deployment</code> for our petstore app</li> <li>A Gateway API <code>HTTPRoute</code> for our petstore app</li> </ul>"},{"location":"api-quickstart/#route-53-dns-zone","title":"Route 53 DNS Zone","text":"<p>When the DNS Policy has been created, and the previously created <code>HTTPRoute</code> has been attached, a DNS record custom resource will also be created in the cluster resulting in records being created in your AWS Route53. Navigate to Route53 and you should see some new records in the zone.</p>"},{"location":"api-quickstart/#configuring-the-region-label","title":"Configuring the region label","text":"<p>Configure the app <code>REGION</code> to be <code>eu</code>:</p> <pre><code>kubectl --context kind-api-workload-1 apply -k ./resources/eu-cluster/\n</code></pre>"},{"location":"api-quickstart/#exploring-the-open-api-specification","title":"Exploring the Open API Specification","text":"<p>The raw Open API spec can be found in the root of the repo:</p> <pre><code>cat openapi.yaml\n# ---\n# openapi: 3.0.2\n# info:\n#   title: Stitch API Petstore\n#   version: 1.0.18\n</code></pre>"},{"location":"api-quickstart/#application-developer-api-security","title":"(Application developer) API security","text":"<p>We've included a number of sample <code>x-kuadrant</code> extensions in the OAS spec already:</p> <ul> <li>At the top-level of our spec, we've defined an <code>x-kuadrant</code> extension to detail the Gateway API Gateway associated with our app:</li> </ul> <pre><code>  x-kuadrant:\n    route:\n      name: petstore\n      namespace: petstore\n      labels:\n        deployment: petstore\n        owner: cferreir\n      hostnames:\n\n      - petstore.$KUADRANT_ZONE_ROOT_DOMAIN\n      parentRefs:\n      - name: prod-web\n        namespace: kuadrant-multi-cluster-gateways\n        kind: Gateway\n</code></pre> <ul> <li>In <code>/user/login</code>, we have a Gateway API <code>backendRef</code> set and a <code>rate_limit</code> set. The rate limit policy for this endpoint restricts usage of this endpoint to 2 requests in a 10 second window:     <pre><code>x-kuadrant:\n  backendRefs:\n  - name: petstore\n    namespace: petstore\n    port: 8080\n  rate_limit:\n  rates:\n  - limit: 2\n    duration: 10\n    unit: second\n</code></pre></li> <li>In <code>/store/inventory</code>, we have also have a Gateway API <code>backendRef</code>set and a <code>rate_limit</code> set. The rate limit policy for the endpoint restricts usage of this endpoint to 10 requests in a 10 second window:     <pre><code>x-kuadrant:\n  backendRefs:\n  - name: petstore\n    namespace: petstore\n    port: 8080\n  rate_limit:\n    rates:\n    - limit: 10\n      duration: 10\n      unit: second\n</code></pre></li> <li>Finally, we have a <code>securityScheme</code> setup for apiKey auth, powered by Authorino. We'll show this in more detail a little later:   <pre><code>securitySchemes:\n  api_key:\n    type: apiKey\n    name: api_key\n    in: header\n</code></pre></li> </ul> <p>These extensions allow us to automatically generate Kuadrant Kubernetes resources, including AuthPolicies, RateLimitPolicies and Gateway API resources such as HTTPRoutes.</p>"},{"location":"api-quickstart/#kuadrantctl","title":"kuadrantctl","text":"<p><code>kuadrantctl</code> is a cli that supports the generation of various Kubernetes resources via OAS specs. Let's run some commands to generate some of these resources. If you forked the api-pestore repo, you can check them in also. Let's apply these to our running workload to implement rate limiting and auth.</p>"},{"location":"api-quickstart/#installing-kuadrantctl","title":"Installing <code>kuadrantctl</code>","text":"<p>Download <code>kuadrantctl</code> from the <code>v0.2.0</code> release artifacts:</p> <p>https://github.com/Kuadrant/kuadrantctl/releases/tag/v0.2.0</p> <p>Drop the <code>kuadrantctl</code> binary somewhere into your $PATH (e.g. <code>/usr/local/bin/</code>).</p> <p>For this next part of the tutorial, we recommend installing <code>yq</code> to pretty-print YAML resources.</p>"},{"location":"api-quickstart/#generating-kuadrant-resources-with-kuadrantctl","title":"Generating Kuadrant resources with <code>kuadrantctl</code>","text":"<p>We'll generate an <code>AuthPolicy</code> to implement API key auth, per the <code>securityScheme</code> in our OAS spec:</p> <pre><code># Generate this resource and save:\nkuadrantctl generate kuadrant authpolicy --oas openapi.yaml | yq -P | tee resources/authpolicy.yaml\n\n# Apply this resource to our cluster:\nkubectl --context kind-api-workload-1 apply -f ./resources/authpolicy.yaml\n</code></pre> <p>Next we'll generate a <code>RateLimitPolicy</code>, to protect our APIs with the limits we have setup in our OAS spec:</p> <pre><code># Generate this resource and save:\nkuadrantctl generate kuadrant ratelimitpolicy --oas openapi.yaml | yq -P | tee resources/ratelimitpolicy.yaml\n\n# Apply this resource to our cluster:\nkubectl --context kind-api-workload-1 apply -f ./resources/ratelimitpolicy.yaml\n</code></pre> <p>Lastly, we'll generate a Gateway API <code>HTTPRoute</code> to service our APIs:</p> <pre><code># Generate this resource and save:\nkuadrantctl generate gatewayapi httproute --oas openapi.yaml | yq -P | tee resources/httproute.yaml\n\n# Apply this resource to our cluster, setting the hostname in via the KUADRANT_ZONE_ROOT_DOMAIN env var:\nkustomize build ./resources/ | envsubst | kubectl --context kind-api-workload-1 apply -f-\n</code></pre>"},{"location":"api-quickstart/#check-our-applied-policies","title":"Check our applied policies","text":"<p>Navigate to your app's Swagger UI:</p> <pre><code>echo https://petstore.$KUADRANT_ZONE_ROOT_DOMAIN/docs/\n</code></pre>"},{"location":"api-quickstart/#ratelimitpolicy","title":"RateLimitPolicy","text":"<p>Let's check that our <code>RateLimitPolicy</code> for the <code>/store/inventory</code> has been applied and works correctly. Recall, our OAS spec had the following limits applied:</p> <p><pre><code>x-kuadrant:\n  ...\n  rate_limit:\n    rates:\n\n    - limit: 10\n      duration: 10\n      unit: second\n</code></pre> Navigate to the <code>/store/inventory</code> API, click <code>Try it out</code>, and <code>Execute</code>.</p> <p>You'll see a response similar to:</p> <pre><code>{\n  \"available\": 10,\n  \"pending\": 5,\n  \"sold\": 3\n}\n</code></pre> <p>This API has a rate limit applied, so if you send more than 10 requests in a 10 second window, you will see a <code>429</code> HTTP Status code from responses, and a \"Too Many Requests\" message in the response body. Click <code>Execute</code> quickly in succession to see your <code>RateLimitPolicy</code> in action.</p>"},{"location":"api-quickstart/#authpolicy","title":"AuthPolicy","text":"<p>Let's check that our <code>AuthPolicy</code> for the <code>/store/admin</code> endpoint has been applied and works correctly. Recall, our OAS spec had the following securitySchemes applied:</p> <pre><code>  securitySchemes:\n    api_key:\n      type: apiKey\n      name: api_key\n      in: header\n</code></pre> <p>Navigate to the <code>/store/admin</code> API, click <code>Try it out</code>, and <code>Execute</code>. You'll get a 401 response.</p> <p>You can set a value for the <code>api_key</code> header by clicking <code>Authorize</code> at the top of the page. Set a value of <code>secret</code>. This api key value is stored in the <code>petstore-api-key</code> Secret in the <code>petstore</code> namespace. Try the <code>/store/admin</code> endpoint again and you should get a 200 response with the following:</p> <pre><code>{\"message\":\"You are an admin!\"}\n</code></pre>"},{"location":"api-quickstart/#policy-adjustments","title":"Policy Adjustments","text":"<p>Run the Swagger UI editor to explore the OAS spec and make some tweaks:</p> <pre><code>docker run -p 8080:8080 -v $(pwd):/tmp -e SWAGGER_FILE=/tmp/openapi.yaml swaggerapi/swagger-editor\n</code></pre> <p>You should be able to access the Swagger Editor at http://localhost:8080. Our <code>/store/inventory</code> API needs some additonal rate limiting. This is one of our slowest, most expensive services, so we'd like to rate limit it further.</p> <p>In your <code>openapi.yaml</code>, navigate to the <code>/store/inventory</code> endpoint in the <code>paths</code> block. Modify the rate_limit block to further restrict the amount of requests this endpoint can serve to 2 requests per 10 seconds:</p> <pre><code>x-kuadrant:\n  ...\n  rate_limit:\n    rates:\n\n    - limit: 2\n      duration: 10\n      unit: second\n</code></pre> <p>Save your updated spec - <code>File</code> &gt; <code>Save as YAML</code> &gt; and update your existing <code>openapi.yaml</code>. You may need to copy the file from your Downloads folder to the location of the petstore repository.</p> <p>Next we'll re-generate our <code>RateLimitPolicy</code> with <code>kuadrantctl</code>:</p> <pre><code># Generate this resource and save:\nkuadrantctl generate kuadrant ratelimitpolicy --oas openapi.yaml | yq -P | tee resources/ratelimitpolicy.yaml\n\n# Apply this resource to our cluster:\nkubectl --context kind-api-workload-1 apply -f ./resources/ratelimitpolicy.yaml\n</code></pre> <p>At this stage you can optionally check in all the changes to the repo if you forked it.</p> <pre><code># Optionally add, commit &amp; push the changes to your fork\ngit add resources\ngit commit -am \"Generated AuthPolicy,RateLimitPolicy &amp; HTTPRoute\"\ngit push # You may need to set an upstream as well\n</code></pre> <p>In your app's Swagger UI:</p> <pre><code>echo https://petstore.$KUADRANT_ZONE_ROOT_DOMAIN/docs/\n</code></pre> <p>Navigate to the <code>/store/inventory</code> API one more, click <code>Try it out</code>, and <code>Execute</code>.</p> <p>You'll see the effects of our new <code>RateLimitPolicy</code> applied. If you now send more than 2 requests in a 10 second window, you'll be rate-limited.</p> <p>Note:  It may take a few minutes for the updated RateLimitPolicy to be configured with the modified rate limit.</p>"},{"location":"api-quickstart/#application-developer-scaling-the-application","title":"(Application developer) Scaling the application","text":"<p>Deploy the petstore to the 2nd cluster:</p> <pre><code>kustomize build ./resources/ | envsubst | kubectl --context kind-api-workload-2 apply -f-\nkubectl --context kind-api-workload-2 apply -f ./resources/authpolicy.yaml\nkubectl --context kind-api-workload-2 apply -f ./resources/ratelimitpolicy.yaml\n</code></pre> <p>Configure the app <code>REGION</code> to be <code>us</code>:</p> <pre><code>kubectl --context kind-api-workload-2 apply -k ./resources/us-cluster/\n</code></pre>"},{"location":"api-quickstart/#platform-engineer-scaling-the-gateway-and-traffic-management","title":"(Platform engineer) Scaling the gateway and traffic management","text":"<p>Deploy the Gateway to the 2nd cluster:</p> <pre><code>kubectl --context kind-api-control-plane patch placement http-gateway --namespace multi-cluster-gateways --type='json' -p='[{\"op\": \"replace\", \"path\": \"/spec/numberOfClusters\", \"value\":2}]'\n</code></pre> <p>Label the 1st cluster as being in the 'EU' region, and the 2nd cluster as being in the 'US' region. These labels are used by the DNSPolicy for configuring geo DNS.</p> <pre><code>kubectl --context kind-api-control-plane label managedcluster kind-api-workload-1 kuadrant.io/lb-attribute-geo-code=EU --overwrite\nkubectl --context kind-api-control-plane label managedcluster kind-api-workload-2 kuadrant.io/lb-attribute-geo-code=US --overwrite\n</code></pre>"},{"location":"api-quickstart/#api-consumer-accessing-the-api-from-multiple-regions","title":"(API consumer) Accessing the API from multiple regions","text":"<p>Info</p> <p>This section is optional. If you'd rather skip this part, you can skip forward to the \"(App developer) API traffic monitoring\" section.</p> <p></p>"},{"location":"api-quickstart/#pre-requisites","title":"Pre-requisites","text":"<ul> <li><code>python3</code> and <code>pip3</code>: these are required for this part of the walkthrough</li> </ul> <p>To demonstrate traffic management by geographical region, we'll use a tool called 'geosight'. This tool resolves hostnames from different regions, fetches a website from the resulting DNS record address and takes a screenshot. The petstore app has been configured to serve a flag image based on which region it is running in. In the 1st cluster, the EU flag is used. In the 2nd cluster, the US flag is used.</p> <p>To install 'geosight', run the following commands:</p> <pre><code>git clone git@github.com:jasonmadigan/geosight.git &amp;&amp; cd geosight\npip3 install -r requirements.txt\nplaywright install\n</code></pre> <p>Then run it using:</p> <pre><code>python3 app.py\n</code></pre> <p>Access the webapp at http://127.0.0.1:5001/. In the input box, type the address from below and click the <code>Fetch</code> button:</p> <pre><code>echo https://petstore.$KUADRANT_ZONE_ROOT_DOMAIN/server/details\n</code></pre> <p>After a moment you should see dns results for different regions, and a corresponding screenshot.</p> <p>If you want to experiment with other regions, check out the Configuration section for geosight and the Kuadrant docs for geo loadbalancing.</p>"},{"location":"api-quickstart/#app-developer-api-traffic-monitoring","title":"(App developer) API traffic monitoring","text":"<p>To view the App developer dashboard, the same Grafana will be used from the platform engineer steps above: <code>https://grafana.172.31.0.2.nip.io</code></p> <p>The most relevant for a app developer is <code>Stitch: App Developer Dashboard</code> You should see panels about API's including:</p> <ul> <li>Request and error rates</li> <li>API summaries</li> <li>API request summaries</li> <li>API duration</li> </ul> <p>All corresponding to our HTTPRoute coming from our OAS spec</p>"},{"location":"api-quickstart/#platform-engineer-apis-summary-view","title":"(Platform Engineer) APIs summary view","text":"<p>Now that the app developer has deployed their app, new metrics and data is now available in the platform engineer dashboard seen in the previous step <code>https://grafana.172.31.0.2.nip.io</code>:</p> <ul> <li>Gateways, routes and policies</li> <li>Constraints &amp; Violations (there should be no violations present)</li> <li>APIs Summary</li> </ul>"},{"location":"api-quickstart/#summary","title":"Summary","text":"<p>You now have a local environment with a reference architecture to design and deploy an API in a kube native way, using Kuadrant and other open source tools.</p>"},{"location":"api-quickstart/#cleanup","title":"Cleanup","text":"<p>To destroy the previously created <code>kind</code> clusters, run:</p> <pre><code>./cleanup.sh\n</code></pre> <p>Info</p> <p>DNS records in AWS will remain after cleanup - you can remove these from your zone manually.</p>"},{"location":"kuadrantctl/","title":"kuadrantctl","text":"<p><code>kuadrantctl</code> is a CLI tool for managing Kuadrant configurations and resources.</p>"},{"location":"kuadrantctl/#installing","title":"Installing","text":"<p><code>kuadrantctl</code> can be installed either by downloading pre-compiled binaries or by compiling from source. For most users, downloading the binary is the easiest and recommended method.</p>"},{"location":"kuadrantctl/#installing-pre-compiled-binaries","title":"Installing Pre-compiled Binaries","text":"<ol> <li>Download the latest binary for your platform from the <code>kuadrantctl</code> Releases page.</li> <li>Unpack the binary.</li> <li>Move it to a directory in your <code>$PATH</code> so that it can be executed from anywhere.</li> </ol>"},{"location":"kuadrantctl/#compiling-from-source","title":"Compiling from Source","text":"<p>If you prefer to compile from source or are contributing to the project, you can install <code>kuadrantctl</code> using  <code>make install</code>. This method requires Golang 1.21 or newer.</p> <p>It is possible to use the make target <code>install</code> to compile from source. From root of the repository, run </p> <pre><code>make install\n</code></pre> <p>This will compile <code>kuadrantctl</code> and install it in the <code>bin</code> directory at root of directory. It will also ensure the correct version of the binary is displayed . It can be ran using <code>./bin/kuadrantctl</code> .  </p>"},{"location":"kuadrantctl/#usage","title":"Usage","text":"<p>Below is a high-level overview of its commands, along with links to detailed documentation for more complex commands.</p>"},{"location":"kuadrantctl/#general-syntax","title":"General Syntax","text":"<pre><code>kuadrantctl [command] [subcommand] [flags]\n</code></pre>"},{"location":"kuadrantctl/#commands-overview","title":"Commands Overview","text":"Command Description <code>completion</code> Generate autocompletion scripts for the specified shell <code>generate</code> Commands related to Kubernetes Gateway API and Kuadrant resource generation from OpenAPI 3.x specifications <code>help</code> Help about any command <code>version</code> Print the version number of <code>kuadrantctl</code>"},{"location":"kuadrantctl/#flags","title":"Flags","text":"Flag Description <code>-h</code>, <code>--help</code> Help for <code>kuadrantctl</code> <code>-v</code>, <code>--verbose</code> Enable verbose output"},{"location":"kuadrantctl/#commands-detail","title":"Commands Detail","text":""},{"location":"kuadrantctl/#completion","title":"<code>completion</code>","text":"<p>Generate an autocompletion script for the specified shell.</p> Subcommand Description <code>bash</code> Generate script for Bash <code>fish</code> Generate script for Fish <code>powershell</code> Generate script for PowerShell <code>zsh</code> Generate script for Zsh"},{"location":"kuadrantctl/#generate","title":"<code>generate</code>","text":"<p>Commands related to Kubernetes Gateway API and Kuadrant resource generation from OpenAPI 3.x specifications.</p> Subcommand Description <code>gatewayapi</code> Generate Gateway API resources <code>kuadrant</code> Generate Kuadrant resources"},{"location":"kuadrantctl/#generate-gatewayapi","title":"<code>generate gatewayapi</code>","text":"<p>Generate Gateway API resources from an OpenAPI 3.x specification</p> Subcommand Description Flags <code>httproute</code> Generate Gateway API HTTPRoute from OpenAPI 3.0.X <code>--oas string</code> Path to OpenAPI spec file (in JSON or YAML format), URL, or '-' to read from standard input (required). <code>-o</code> Output format: 'yaml' or 'json'. (default \"yaml\")"},{"location":"kuadrantctl/#generate-kuadrant","title":"<code>generate kuadrant</code>","text":"<p>Generate Kuadrant resources from an OpenAPI 3.x specification</p> Subcommand Description Flags <code>authpolicy</code> Generate a Kuadrant AuthPolicy from an OpenAPI 3.0.x specification <code>--oas string</code> Path to OpenAPI spec file (in JSON or YAML format), URL, or '-' to read from standard input (required). <code>-o</code> Output format: 'yaml' or 'json'. (default \"yaml\") <code>ratelimitpolicy</code> Generate Kuadrant RateLimitPolicy from an OpenAPI 3.0.x specification <code>--oas string</code> Path to OpenAPI spec file (in JSON or YAML format), URL, or '-' to read from standard input (required). <code>-o</code> Output format: 'yaml' or 'json'. (default \"yaml\")"},{"location":"kuadrantctl/#version","title":"<code>version</code>","text":"<p>Print the version number of <code>kuadrantctl</code>.</p> <p>No additional flags or subcommands.</p>"},{"location":"kuadrantctl/#additional-guides","title":"Additional Guides","text":""},{"location":"kuadrantctl/#generating-gateway-api-httproute-objects","title":"Generating Gateway API HTTPRoute Objects","text":"<ul> <li>Generates Gateway API HTTPRoute objects from an OpenAPI Specification (OAS) 3.x.</li> <li>Supports reading from a file, URL, or stdin.</li> <li>Example usages and more information can be found in the detailed guide.</li> </ul>"},{"location":"kuadrantctl/#generating-kuadrant-authpolicy-objects","title":"Generating Kuadrant AuthPolicy Objects","text":"<ul> <li>Generates Kuadrant AuthPolicy objects for managing API authentication.</li> <li>Supports <code>openIdConnect</code> and <code>apiKey</code> types from the OpenAPI Security Scheme Object.</li> <li>Example usages and more information can be found in the detailed guide.</li> </ul>"},{"location":"kuadrantctl/#generating-kuadrant-ratelimitpolicy-objects","title":"Generating Kuadrant RateLimitPolicy Objects","text":"<ul> <li>Generates Kuadrant RateLimitPolicy objects for managing API rate limiting.</li> <li>Supports reading from a file, URL, or stdin.</li> <li>Example usages and more information can be found in the detailed guide.</li> </ul> <p>For more detailed information about each command, including options and usage examples, use <code>kuadrantctl [command] --help</code>.</p>"},{"location":"kuadrantctl/#using-with-github-actions","title":"Using with GitHub Actions","text":"<pre><code>- name: Install kuadrantctl\n  uses: jaxxstorm/action-install-gh-release@v1.10.0\n  with: # Grab the latest version\n    repo: Kuadrant/kuadrantctl\n</code></pre>"},{"location":"kuadrantctl/#commands","title":"Commands","text":"<ul> <li>Generate Gateway API HTTPRoute objects from OpenAPI 3.X</li> <li>Generate Kuadrant RateLimitPolicy from OpenAPI 3.X</li> <li>Generate Kuadrant AuthPolicy from OpenAPI 3.X</li> </ul>"},{"location":"kuadrantctl/#contributing","title":"Contributing","text":"<p>The Development guide describes how to build the kuadrantctl CLI and how to test your changes before submitting a patch or opening a PR.</p>"},{"location":"kuadrantctl/#licensing","title":"Licensing","text":"<p>This software is licensed under the Apache 2.0 license.</p> <p>See the LICENSE and NOTICE files that should have been provided along with this software for details.</p>"},{"location":"kuadrantctl/doc/RELEASE/","title":"RELEASE","text":""},{"location":"kuadrantctl/doc/RELEASE/#release","title":"Release","text":"<p>The release process follows a streamlined approach, no release branches involved. New releases can be major, minor or patch based releases, but always incrementing digits regarding the latest release version.</p>"},{"location":"kuadrantctl/doc/RELEASE/#new-majorminorpatch-version","title":"New Major.Minor.Patch version","text":"<ol> <li>Create a new minor release branch from the HEAD of main: <pre><code>git checkout -b release-vX.Y.Z\n</code></pre></li> <li>Update version (prefixed with \"v\"): <pre><code>make prepare-release VERSION=vX.Y.Z\n</code></pre></li> <li>Verify local changes: <pre><code>make install\nbin/kuadrantctl version\n</code></pre> The output should be the new version, for example : <pre><code>kuadrantctl v0.3.0 (ff779a1-dirty)\n</code></pre></li> <li>Commit and push: <pre><code>git add .\ngit commit -m \"prepare-release: release-vX.Y.Z\"\ngit push origin release-vX.Y.Z\n</code></pre></li> <li>Create git tag: <pre><code>git tag -s -m vX.Y.Z vX.Y.Z\ngit push origin vX.Y.Z\n</code></pre></li> <li> <p>In Github, create release.</p> </li> <li> <p>Pick recently pushed git tag</p> </li> <li>Automatically generate release notes from previous released tag</li> <li> <p>Set as the latest release</p> </li> <li> <p>Verify that the build Release workflow is triggered and completes for the new tag</p> </li> </ol>"},{"location":"kuadrantctl/doc/RELEASE/#verify-new-release-is-available","title":"Verify new release is available","text":"<ol> <li>Download the latest binary for your platform from the <code>kuadrantctl</code> Latest Releases page.</li> <li>Unpack the binary.</li> <li>Move it to a directory in your <code>$PATH</code> so that it can be executed from anywhere.</li> <li>Check the version: <pre><code>kuadrantctl version\n</code></pre> The output should be the new version, for example : <pre><code>kuadrantctl v0.3.0 (eec318b2e11e7ea5add5e550ff872bde64555d8f)\n</code></pre></li> </ol>"},{"location":"kuadrantctl/doc/development/","title":"Development Guide","text":""},{"location":"kuadrantctl/doc/development/#technology-stack-required-for-development","title":"Technology stack required for development","text":"<ul> <li>git</li> <li>go version 1.21+</li> </ul>"},{"location":"kuadrantctl/doc/development/#build-the-cli","title":"Build the CLI","text":"<pre><code>$ git clone https://github.com/kuadrant/kuadrantctl.git\n$ cd kuadrantctl &amp;&amp; make install\n$ bin/kuadrantctl version\n{\"level\":\"info\",\"ts\":\"2023-11-08T23:44:57+01:00\",\"msg\":\"kuadrantctl version: latest\"}\n</code></pre>"},{"location":"kuadrantctl/doc/development/#quick-steps-to-contribute","title":"Quick steps to contribute","text":"<ul> <li>Fork the project.</li> <li>Download your fork to your PC (<code>git clone https://github.com/your_username/kuadrantctl &amp;&amp; cd kuadrantctl</code>)</li> <li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li> <li>Make changes and run tests (<code>make test</code>)</li> <li>Add them to staging (<code>git add .</code>)</li> <li>Commit your changes (<code>git commit -m 'Add some feature'</code>)</li> <li>Push to the branch (<code>git push origin my-new-feature</code>)</li> <li>Create new pull request</li> </ul>"},{"location":"kuadrantctl/doc/generate-gateway-api-httproute/","title":"Generating Gateway API HTTPRoutes","text":""},{"location":"kuadrantctl/doc/generate-gateway-api-httproute/#generate-gateway-api-httproute-object-from-openapi-3","title":"Generate Gateway API HTTPRoute object from OpenAPI 3","text":"<p>The <code>kuadrantctl generate gatewayapi httproute</code> command generates an Gateway API HTTPRoute from your OpenAPI Specification (OAS) 3.x powered with kuadrant extensions.</p>"},{"location":"kuadrantctl/doc/generate-gateway-api-httproute/#openapi-specification","title":"OpenAPI specification","text":"<p>An OpenAPI document resource can be provided to the cli by one of the following channels:</p> <ul> <li>Filename in the available path.</li> <li>URL format (supported schemes are HTTP and HTTPS). The CLI will try to download from the given address.</li> <li>Read from stdin standard input stream.</li> </ul>"},{"location":"kuadrantctl/doc/generate-gateway-api-httproute/#usage","title":"Usage","text":"<pre><code>$ kuadrantctl generate gatewayapi httproute -h\nGenerate Gateway API HTTPRoute from OpenAPI 3.0.X\n\nUsage:\n  kuadrantctl generate gatewayapi httproute [flags]\n\nFlags:\n  -h, --help          help for httproute\n  --oas string        Path to OpenAPI spec file (in JSON or YAML format), URL, or '-' to read from standard input (required)\n  -o Output format:   'yaml' or 'json'. (default \"yaml\")\n\nGlobal Flags:\n  -v, --verbose   verbose output\n</code></pre> <p>Under the example folder there are examples of OAS 3 that can be used to generate the resources</p> <p>As an AuthPolicy and RateLimitPolicy both require a HTTPRoute to target, the user guides for generating those policies include examples of running the <code>kuadrantctl generate gatewayapi httproute</code> command.</p> <p>You can find those guides here:</p> <ul> <li>Generate Kuadrant AuthPolicy</li> <li>Generate Kuadrant RateLimitPolicy</li> </ul>"},{"location":"kuadrantctl/doc/generate-kuadrant-auth-policy/","title":"Generating Kuadrant AuthPolicies","text":""},{"location":"kuadrantctl/doc/generate-kuadrant-auth-policy/#generate-kuadrant-authpolicy-object-from-openapi-3","title":"Generate Kuadrant AuthPolicy object from OpenAPI 3","text":"<p>The <code>kuadrantctl generate kuadrant authpolicy</code> command generates an Kuadrant AuthPolicy from your OpenAPI Specification (OAS) 3.x powered with kuadrant extensions.</p>"},{"location":"kuadrantctl/doc/generate-kuadrant-auth-policy/#openapi-specification","title":"OpenAPI specification","text":"<p>An OpenAPI document resource can be provided to the cli by one of the following channels:</p> <ul> <li>Filename in the available path.</li> <li>URL format (supported schemes are HTTP and HTTPS). The CLI will try to download from the given address.</li> <li>Read from stdin standard input stream.</li> </ul> <p>OpenAPI Security Scheme Object types</p> Types Implemented <code>openIdConnect</code> YES <code>apiKey</code> YES <code>http</code> NO <code>oauth2</code> NO"},{"location":"kuadrantctl/doc/generate-kuadrant-auth-policy/#openidconnect-type-description","title":"<code>openIdConnect</code> Type Description","text":"<p>The following OAS example has one protected endpoint <code>GET /dog</code> with <code>openIdConnect</code> security scheme type.</p> <pre><code>paths:\n  /dog:\n    get:\n      operationId: \"getDog\"\n      security:\n\n        - securedDog: []\n      responses:\n        405:\n          description: \"invalid input\"\ncomponents:\n  securitySchemes:\n    securedDog:\n      type: openIdConnect\n      openIdConnectUrl: https://example.com/.well-known/openid-configuration\n</code></pre> <p>Running the command</p> <pre><code>kuadrantctl generate kuadrant authpolicy --oas ./petstore-openapi.yaml  | yq -P\n</code></pre> <p>The generated authpolicy (only relevan fields shown here):</p> <pre><code>kind: AuthPolicy\napiVersion: kuadrant.io/v1beta2\nmetadata:\n  name: petstore\n  namespace: petstore\n  creationTimestamp: null\nspec:\n  routeSelectors:\n\n    - matches:\n        - path:\n            type: Exact\n            value: /api/v1/dog\n          method: GET\n  rules:\n    authentication:\n      getDog_securedDog:\n        credentials: {}\n        jwt:\n          issuerUrl: https://example.com/.well-known/openid-configuration\n        routeSelectors:\n          - matches:\n              - path:\n                  type: Exact\n                  value: /api/v1/dog\n                method: GET\n</code></pre>"},{"location":"kuadrantctl/doc/generate-kuadrant-auth-policy/#apikey-type-description","title":"<code>apiKey</code> Type Description","text":"<p>The following OAS example has one protected endpoint <code>GET /dog</code> with <code>apiKey</code> security scheme type.</p> <pre><code>paths:\n  /dog:\n    get:\n      operationId: \"getDog\"\n      security:\n\n        - securedDog: []\n      responses:\n        405:\n          description: \"invalid input\"\ncomponents:\n  securitySchemes:\n    securedDog:\n      type: apiKey\n      name: dog_token\n      in: query\n</code></pre> <p>Running the command</p> <pre><code>kuadrantctl generate kuadrant authpolicy --oas ./petstore-openapi.yaml  | yq -P\n</code></pre> <p>The generated authpolicy (only relevan fields shown here):</p> <pre><code>kind: AuthPolicy\napiVersion: kuadrant.io/v1beta2\nmetadata:\n  name: petstore\n  namespace: petstore\n  creationTimestamp: null\nspec:\n  routeSelectors:\n\n    - matches:\n        - path:\n            type: Exact\n            value: /dog\n          method: GET\n  rules:\n    authentication:\n      getDog_securedDog:\n        credentials:\n          queryString:\n            name: dog_token\n          apiKey:\n            selector:\n              matchLabels:\n                kuadrant.io/apikeys-by: securedDog\n        routeSelectors:\n          - matches:\n              - path:\n                  type: Exact\n                  value: /dog\n                method: GET\n</code></pre> <p>In this particular example, the endpoint <code>GET /dog</code> will be protected. The token needs to be in the query string of the request included in a parameter named <code>dog_token</code>. Kuadrant will validate received tokens against tokens found in kubernetes secrets with label <code>kuadrant.io/apikeys-by: ${sec scheme name}</code>. In this particular example the label selector will be: <code>kuadrant.io/apikeys-by: securedDog</code>.</p> <p>Like the following example:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    kuadrant.io/apikeys-by: securedDog\nstringData:\n  api_key: MYSECRETTOKENVALUE\ntype: Opaque\n</code></pre> <p>Note: Kuadrant validates tokens against api keys found in secrets. The label selector format <code>kuadrant.io/apikeys-by: ${sec scheme name}</code> is arbitrary and designed for this CLI command.</p> <p>For more information about Kuadrant auth based on api key: https://docs.kuadrant.io/latest/authorino/docs/user-guides/api-key-authentication/</p>"},{"location":"kuadrantctl/doc/generate-kuadrant-auth-policy/#usage","title":"Usage","text":"<pre><code>Generate Kuadrant AuthPolicy from OpenAPI 3.0.X\n\nUsage:\n  kuadrantctl generate kuadrant authpolicy [flags]\n\nFlags:\n  -h, --help         help for authpolicy\n  --oas string        Path to OpenAPI spec file (in JSON or YAML format), URL, or '-' to read from standard input (required)\n  -o Output format:   'yaml' or 'json'. (default \"yaml\")\n\nGlobal Flags:\n  -v, --verbose   verbose output\n</code></pre> <p>Under the example folder there are examples of OAS 3 that can be used to generate the resources</p>"},{"location":"kuadrantctl/doc/generate-kuadrant-auth-policy/#user-guide","title":"User Guide","text":"<p>The verification steps will lead you to the process of deploying and testing the following api with endpoints protected using different security schemes:</p> Operation Security Scheme <code>GET /api/v1/cat</code> public (not auth) <code>POST /api/v1/cat</code> ApiKey in header <code>GET /api/v1/dog</code> OpenIdConnect <code>GET /api/v1/snake</code> OpenIdConnect OR ApiKey in query string <ul> <li>[Optional] Setup SSO service supporting OIDC. For this example, we will be using keycloak.</li> <li>Create a new realm <code>petstore</code></li> <li>Create a client <code>petstore</code>. In the Client Protocol field, select <code>openid-connect</code>.</li> <li>Configure client settings. Access Type to public. Direct Access Grants Enabled to ON (for this example password will be used directly to generate the token).</li> <li>Add a user to the realm<ul> <li>Click the Users menu on the left side of the window.  Click Add user.</li> <li>Type the username <code>bob</code>, set the Email Verified switch to ON, and click Save.</li> <li>On the Credentials tab, set the password <code>p</code>. Enter the password in both the fields, set the Temporary switch to OFF to avoid the password reset at the next login, and click <code>Set Password</code>.</li> </ul> </li> </ul> <p>Now, let's run local cluster to test the kuadrantctl new command to generate authpolicy.</p> <ul> <li>Clone the repo</li> </ul> <pre><code>git clone https://github.com/Kuadrant/kuadrantctl.git\ncd kuadrantctl\n</code></pre> <ul> <li>Setup a cluster, Istio and Gateway API CRDs and Kuadrant</li> </ul> <p>Use our single-cluster quick start script - this will install Kuadrant in a local <code>kind</code> cluster: https://docs.kuadrant.io/latest/getting-started-single-cluster/</p> <ul> <li>Build and install CLI in <code>bin/kuadrantctl</code> path</li> </ul> <pre><code>make install\n</code></pre> <ul> <li>Deploy petstore backend API</li> </ul> <pre><code>kubectl create namespace petstore\nkubectl apply -n petstore -f examples/petstore/petstore.yaml\n</code></pre> <ul> <li>Let's create Petstore's OpenAPI spec</li> </ul> <pre><code>cat &lt;&lt;EOF &gt;petstore-openapi.yaml\n---\nopenapi: \"3.1.0\"\ninfo:\n  title: \"Pet Store API\"\n  version: \"1.0.0\"\nx-kuadrant:\n  route:\n    name: \"petstore\"\n    namespace: \"petstore\"\n    hostnames:\n\n      - example.com\n    parentRefs:\n      - name: istio-ingressgateway\n        namespace: istio-system\nservers:\n  - url: https://example.io/api/v1\npaths:\n  /cat:\n    x-kuadrant:\n      backendRefs:\n        - name: petstore\n          port: 80\n          namespace: petstore\n    get:  # No sec requirements\n      operationId: \"getCat\"\n      responses:\n        405:\n          description: \"invalid input\"\n    post:  # API key\n      operationId: \"postCat\"\n      security:\n        - cat_api_key: []\n      responses:\n        405:\n          description: \"invalid input\"\n  /dog:\n    x-kuadrant:\n      backendRefs:\n        - name: petstore\n          port: 80\n          namespace: petstore\n    get:  # OIDC\n      operationId: \"getDog\"\n      security:\n        - oidc:\n          - read:dogs\n      responses:\n        405:\n          description: \"invalid input\"\n  /snake:\n    x-kuadrant:\n      backendRefs:\n        - name: petstore\n          port: 80\n          namespace: petstore\n    get:  # OIDC or API key\n      operationId: \"getSnake\"\n      security:\n        - oidc: [\"read:snakes\"]\n        - snakes_api_key: []\n      responses:\n        405:\n          description: \"invalid input\"\ncomponents:\n  securitySchemes:\n    cat_api_key:\n      type: apiKey\n      name: api_key\n      in: header\n    oidc:\n      type: openIdConnect\n      openIdConnectUrl: https://${KEYCLOAK_PUBLIC_DOMAIN}/auth/realms/petstore\n    snakes_api_key:\n      type: apiKey\n      name: snake_token\n      in: query\nEOF\n</code></pre> <p>Replace <code>${KEYCLOAK_PUBLIC_DOMAIN}</code> with your SSO instance domain</p> <ul> <li> <p>Create an API key only valid for <code>POST /api/v1/cat</code> endpoint <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: cat-api-key-1\n  namespace: petstore\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    kuadrant.io/apikeys-by: cat_api_key\nstringData:\n  api_key: I_LIKE_CATS\ntype: Opaque\nEOF\n</code></pre></p> <p>Note: the label's value of <code>kuadrant.io/apikeys-by: cat_api_key</code> is the name of the sec scheme of the OpenAPI spec.</p> </li> <li> <p>Create an API key only valid for <code>GET /api/v1/snake</code> endpoint</p> </li> </ul> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: snake-api-key-1\n  namespace: petstore\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    kuadrant.io/apikeys-by: snakes_api_key\nstringData:\n  api_key: I_LIKE_SNAKES\ntype: Opaque\nEOF\n</code></pre> <p>Note: the label's value of <code>kuadrant.io/apikeys-by: snakes_api_key</code> is the name of the sec scheme of the OpenAPI spec.</p> <ul> <li>Create the HTTPRoute using the CLI</li> </ul> <pre><code>bin/kuadrantctl generate gatewayapi httproute --oas petstore-openapi.yaml | kubectl apply -n petstore -f -\n</code></pre> <ul> <li>Create Kuadrant's Auth Policy</li> </ul> <pre><code>bin/kuadrantctl generate kuadrant authpolicy --oas petstore-openapi.yaml | kubectl apply -n petstore -f -\n</code></pre> <p>Now, we are ready to test OpenAPI endpoints </p> <ul> <li><code>GET /api/v1/cat</code> -&gt; It's a public endpoint, hence should return 200 Ok</li> </ul> <pre><code>curl  -H \"Host: example.com\" -i \"http://127.0.0.1:9080/api/v1/cat\"\n</code></pre> <ul> <li><code>POST /api/v1/cat</code> -&gt; It's a protected endpoint with apikey</li> </ul> <p>Without any credentials, it should return <code>401 Unauthorized</code></p> <pre><code>curl  -H \"Host: example.com\" -X POST -i \"http://127.0.0.1:9080/api/v1/cat\"\n</code></pre> <pre><code>HTTP/1.1 401 Unauthorized\nwww-authenticate: Bearer realm=\"getDog_oidc\"\nwww-authenticate: Bearer realm=\"getSnake_oidc\"\nwww-authenticate: snake_token realm=\"getSnake_snakes_api_key\"\nwww-authenticate: api_key realm=\"postCat_cat_api_key\"\nx-ext-auth-reason: {\"postCat_cat_api_key\":\"credential not found\"}\ndate: Tue, 28 Nov 2023 22:28:44 GMT\nserver: istio-envoy\ncontent-length: 0\n</code></pre> <p>The reason headers tell that <code>credential not found</code>. Credentials satisfying <code>postCat_cat_api_key</code> authentication is needed.</p> <p>According to the OpenAPI spec, it should be a header named <code>api_key</code>. What if we try a wrong token? one token assigned to other endpoint, i.e. <code>I_LIKE_SNAKES</code> instead of the valid one <code>I_LIKE_CATS</code>. It should return <code>401 Unauthorized</code>.</p> <pre><code>curl  -H \"Host: example.com\" -H \"api_key: I_LIKE_SNAKES\" -X POST -i \"http://127.0.0.1:9080/api/v1/cat\"\n</code></pre> <pre><code>HTTP/1.1 401 Unauthorized\nwww-authenticate: Bearer realm=\"getDog_oidc\"\nwww-authenticate: Bearer realm=\"getSnake_oidc\"\nwww-authenticate: snake_token realm=\"getSnake_snakes_api_key\"\nwww-authenticate: api_key realm=\"postCat_cat_api_key\"\nx-ext-auth-reason: {\"postCat_cat_api_key\":\"the API Key provided is invalid\"}\ndate: Tue, 28 Nov 2023 22:32:55 GMT\nserver: istio-envoy\ncontent-length: 0\n</code></pre> <p>The reason headers tell that <code>the API Key provided is invalid</code>. Using valid token (from the secret <code>cat-api-key-1</code> assigned to <code>POST /api/v1/cats</code>) in the <code>api_key</code> header should return 200 Ok</p> <pre><code>curl  -H \"Host: example.com\" -H \"api_key: I_LIKE_CATS\" -X POST -i \"http://127.0.0.1:9080/api/v1/cat\"\n</code></pre> <ul> <li><code>GET /api/v1/dog</code> -&gt; It's a protected endpoint with oidc (assigned to our keycloak instance and <code>petstore</code> realm)</li> </ul> <p>without credentials, it should return <code>401 Unauthorized</code></p> <pre><code>curl -H \"Host: example.com\" -i \"http://127.0.0.1:9080/api/v1/dog\"\n</code></pre> <p>To get the authentication token, this example is using Direct Access Grants oauth2 grant type (also known as Client Credentials grant type). When configuring the Keycloak (OIDC provider) client settings, we enabled Direct Access Grants to enable this procedure. We will be authenticating as <code>bob</code> user with <code>p</code> password. We previously created <code>bob</code> user in Keycloak in the <code>petstore</code> realm.</p> <pre><code>export ACCESS_TOKEN=$(curl -k -H \"Content-Type: application/x-www-form-urlencoded\" \\\n        -d 'grant_type=password' \\\n        -d 'client_id=petstore' \\\n        -d 'scope=openid' \\\n        -d 'username=bob' \\\n        -d 'password=p' \"https://${KEYCLOAK_PUBLIC_DOMAIN}/auth/realms/petstore/protocol/openid-connect/token\" | jq -r '.access_token')\n</code></pre> <p>Replace <code>${KEYCLOAK_PUBLIC_DOMAIN}</code> with your SSO instance domain</p> <p>With the access token in place, let's try to get those puppies</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: example.com' http://127.0.0.1:9080/api/v1/dog -i\n</code></pre> <p>it should return 200 OK</p> <ul> <li><code>GET /api/v1/snake</code> -&gt; It's a protected endpoint with oidc (assigned to our keycloak instance and <code>petstore</code> realm) OR with apiKey</li> </ul> <p>This example is to show that multiple security requirements (with OR semantics) can be specified for an OpenAPI operation.</p> <p>Without credentials, it should return <code>401 Unauthorized</code></p> <pre><code>curl -H \"Host: example.com\" -i \"http://127.0.0.1:9080/api/v1/snake\"\n</code></pre> <p>With the access token in place, it should return 200 OK (unless the token has expired).</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -H 'Host: example.com' http://127.0.0.1:9080/api/v1/snake -i\n</code></pre> <p>With apiKey it should also work. According to the OpenAPI spec security scheme, it should be a query string named <code>snake_token</code> and the token needs to be valid token (from the secret <code>snake-api-key-1</code> assigned to <code>GET /api/v1/snake</code>)</p> <pre><code>curl -H 'Host: example.com' -i \"http://127.0.0.1:9080/api/v1/snake?snake_token=I_LIKE_SNAKES\"\n</code></pre>"},{"location":"kuadrantctl/doc/generate-kuadrant-rate-limit-policy/","title":"Generating Kuadrant RateLimitPolicies","text":""},{"location":"kuadrantctl/doc/generate-kuadrant-rate-limit-policy/#generate-kuadrant-ratelimitpolicy-object-from-openapi-3","title":"Generate Kuadrant RateLimitPolicy object from OpenAPI 3","text":"<p>The <code>kuadrantctl generate kuadrant ratelimitpolicy</code> command generates a Kuadrant RateLimitPolicy from your OpenAPI Specification (OAS) 3.x document powered with Kuadrant extensions.</p>"},{"location":"kuadrantctl/doc/generate-kuadrant-rate-limit-policy/#openapi-specification","title":"OpenAPI specification","text":"<p>An OpenAPI document resource can be provided to the Kuadrant CLI in one of the following ways:</p> <ul> <li>Filename in the available path.</li> <li>URL format (supported schemes are HTTP and HTTPS). The CLI will try to download from the given address.</li> <li>Read from <code>stdin</code> standard input stream.</li> </ul>"},{"location":"kuadrantctl/doc/generate-kuadrant-rate-limit-policy/#usage","title":"Usage","text":"<pre><code>Generate Kuadrant RateLimitPolicy from OpenAPI 3.0.x\n\nUsage:\n  kuadrantctl generate kuadrant ratelimitpolicy [flags]\n\nFlags:\n  -h, --help         help for ratelimitpolicy\n  --oas string        Path to OpenAPI spec file (in JSON or YAML format), URL, or '-' to read from standard input (required)\n  -o Output format:   'yaml' or 'json'. (default \"yaml\")\n\nGlobal Flags:\n  -v, --verbose   verbose output\n</code></pre> <p>Note: The <code>kuadrantctl/examples</code> directory in GitHub includes sample OAS 3 files that you can use to generate the resources.</p>"},{"location":"kuadrantctl/doc/generate-kuadrant-rate-limit-policy/#procedure","title":"Procedure","text":"<ol> <li> <p>Clone the Git repository as follows:  <pre><code>git clone https://github.com/Kuadrant/kuadrantctl.git\ncd kuadrantctl\n ```\n2. Set up a cluster, Istio and Gateway API CRDs, and Kuadrant as follows: \n\n\n* Use the single-cluster quick start script to install Kuadrant in a local `kind` cluster: https://docs.kuadrant.io/latest/getting-started-single-cluster/.\n\n\n3. Build and install the CLI in `bin/kuadrantctl` path as follows:\n```bash\nmake install\n</code></pre></p> </li> <li> <p>Deploy the Petstore backend API as follows: <pre><code>kubectl create namespace petstore\nkubectl apply -n petstore -f examples/petstore/petstore.yaml\n</code></pre></p> </li> <li> <p>Create the Petstore OpenAPI definition as follows:</p> </li> </ol> <pre><code>cat &lt;&lt;EOF &gt;petstore-openapi.yaml\n---\nopenapi: \"3.0.3\"\ninfo:\n  title: \"Pet Store API\"\n  version: \"1.0.0\"\nx-kuadrant:  ## Root-level Kuadrant extension\n  route:\n    name: \"petstore\"\n    namespace: \"petstore\"\n    hostnames:\n\n      - example.com\n    parentRefs:\n      - name: istio-ingressgateway\n        namespace: istio-system\nservers:\n  - url: https://example.io/v1\npaths:\n  /cat:\n    x-kuadrant:  ## Path-level Kuadrant extension\n      backendRefs:\n        - name: petstore\n          port: 80\n          namespace: petstore\n      rate_limit:\n        rates:\n          - limit: 1\n            duration: 10\n            unit: second\n        counters:\n          - request.headers.x-forwarded-for\n    get:  # Added to the route and rate limited\n      operationId: \"getCat\"\n      responses:\n        405:\n          description: \"invalid input\"\n    post:  # NOT added to the route\n      x-kuadrant: \n        disable: true\n      operationId: \"postCat\"\n      responses:\n        405:\n          description: \"invalid input\"\n  /dog:\n    get:  # Added to the route and rate limited\n      x-kuadrant:  ## Operation-level Kuadrant extension\n        backendRefs:\n          - name: petstore\n            port: 80\n            namespace: petstore\n        rate_limit:\n          rates:\n            - limit: 3\n              duration: 10\n              unit: second\n          counters:\n            - request.headers.x-forwarded-for\n      operationId: \"getDog\"\n      responses:\n        405:\n          description: \"invalid input\"\n    post:  # Added to the route and NOT rate limited\n      x-kuadrant:  ## Operation-level Kuadrant extension\n        backendRefs:\n          - name: petstore\n            port: 80\n            namespace: petstore\n      operationId: \"postDog\"\n      responses:\n        405:\n          description: \"invalid input\"\nEOF\n</code></pre> <p>Note: The <code>servers</code> base path is not included. This is work-in-progress in follow-up PRs.</p> Operation Applied configuration <code>GET /cat</code> Should return 200 OK and be rate limited (1 req / 10 seconds). <code>POST /cat</code> Not added to the HTTPRoute. Should return 404 Not Found. <code>GET /dog</code> Should return 200 OK and be rate limited (3 req / 10 seconds). <code>POST /dog</code> Should return 200 OK and NOT rate limited. <ol> <li> <p>Create the HTTPRoute by using the CLI as follows: <pre><code>bin/kuadrantctl generate gatewayapi httproute --oas petstore-openapi.yaml | kubectl apply -n petstore -f -\n</code></pre></p> </li> <li> <p>Create the rate limit policy as follows: <pre><code>bin/kuadrantctl generate kuadrant ratelimitpolicy --oas petstore-openapi.yaml | kubectl apply -n petstore -f -\n</code></pre></p> </li> <li> <p>Test the OpenAPI endpoints as follows:</p> </li> <li> <p><code>GET /cat</code> - Should return 200 OK and be rate limited (1 req / 10 seconds). <pre><code>curl --resolve example.com:9080:127.0.0.1 -v \"http://example.com:9080/cat\"\n</code></pre></p> </li> <li><code>POST /cat</code> - Not added to the HTTPRoute. Should return 404 Not Found. <pre><code>curl --resolve example.com:9080:127.0.0.1 -v -X POST \"http://example.com:9080/cat\"\n</code></pre></li> <li><code>GET /dog</code> - Should return 200 OK and be rate limited (3 req / 10 seconds).</li> </ol> <pre><code>curl --resolve example.com:9080:127.0.0.1 -v \"http://example.com:9080/dog\"\n</code></pre> <ul> <li><code>POST /dog</code> - Should return 200 OK and NOT rate limited.</li> </ul> <pre><code>curl --resolve example.com:9080:127.0.0.1 -v -X POST \"http://example.com:9080/dog\"\n</code></pre>"},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/","title":"kuadrantctl - CI/CD with Tekton and Argo CD","text":"<p>This guide demonstrates setting up a CI/CD pipeline by using Tekton to deploy Kubernetes Gateway API and Kuadrant resources generated by <code>kuadrantctl</code>, from an OpenAPI definition. In this example, these resources are applied directly to the cluster where Tekton is running.</p>"},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kuadrant, and all of its prerequisites, installed on a Kubernetes or OpenShift cluster.</li> <li>Tekton Pipelines installed on your cluster.</li> <li><code>kubectl</code> configured with access to communicate with your cluster.</li> <li>Optional: Tekton CLI <code>tkn</code> for easier interaction with Tekton resources.</li> </ul>"},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/#procedure","title":"Procedure","text":""},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/#step-1-set-up-your-namespace","title":"Step 1 - Set up your namespace","text":"<p>Create a dedicated namespace as follows:</p> <pre><code>kubectl create namespace petstore\n</code></pre>"},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/#step-2-create-a-persistent-volume-claim","title":"Step 2 - Create a Persistent Volume Claim","text":"<p>For this example, to store associated Tekton build artifacts, create a Persistent Volume Claim (PVC) in the <code>petstore</code> namespace as follows:</p> <pre><code>kubectl apply -n petstore -f - &lt;&lt;EOF\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: tekton-kuadrantctl-pvc\n  namespace: petstore\nspec:\n  accessModes:\n\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 1Gi\nEOF\n</code></pre>"},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/#step-3-define-the-tekton-task","title":"Step 3 - Define the Tekton Task","text":"<p>Define the task that outlines steps to clone a repository, generate Kuadrant and Kubernetes resources by using <code>kuadrantctl</code>, and apply them directly to the cluster as follows:</p> <pre><code>kubectl apply -f - &lt;&lt;'EOF'\napiVersion: tekton.dev/v1beta1\nkind: Task\nmetadata:\n  name: run-kuadrantctl\n  namespace: petstore\nspec:\n  params:\n\n    - name: gitRepoUrl\n      description: URL of the git repository to clone\n    - name: gitRevision\n      description: Git revision to checkout (branch, tag, sha)\n  workspaces:\n    - name: source\n      description: Workspace to checkout the git repo\n    - name: kubeconfig\n      description: Workspace containing kubeconfig for Kubernetes cluster access\n  steps:\n    - name: clean-workspace\n      image: alpine:latest\n      script: |\n        sh -c 'rm -rf $(workspaces.source.path)/* $(workspaces.source.path)/.[!.]* $(workspaces.source.path)/..?*'\n    - name: clone\n      image: alpine/git:latest\n      script: |\n        git clone $(params.gitRepoUrl) $(workspaces.source.path)\n        cd $(workspaces.source.path)\n        git checkout $(params.gitRevision)\n    - name: download-kuadrantctl\n      image: curlimages/curl:latest\n      script: |\n        ARCH=$(uname -m)\n        case $ARCH in\n        x86_64) BIN_ARCH=\"amd64\";;\n        arm64) BIN_ARCH=\"arm64\";;\n        aarch64) BIN_ARCH=\"arm64\";;\n        *) echo \"Unsupported architecture: $ARCH\" &amp;&amp; exit 1 ;;\n        esac\n        cd $(workspaces.source.path)\n        curl -LO \"https://github.com/Kuadrant/kuadrantctl/releases/download/v0.2.3/kuadrantctl-v0.2.3-linux-$BIN_ARCH.tar.gz\"\n        tar -xzf kuadrantctl-v0.2.3-linux-$BIN_ARCH.tar.gz\n    - name: run-kuadrantctl\n      image: alpine:latest\n      script: |\n        cd $(workspaces.source.path)\n        mkdir -p generated-resources\n        ./kuadrantctl generate kuadrant authpolicy --oas openapi.yaml | tee generated-resources/authpolicy.yaml\n        ./kuadrantctl generate kuadrant ratelimitpolicy --oas openapi.yaml |  tee generated-resources/ratelimitpolicy.yaml\n        ./kuadrantctl generate gatewayapi httproute --oas openapi.yaml | tee generated-resources/httproute.yaml\n    - name: apply-resources\n      image: bitnami/kubectl\n      script: |\n        cd $(workspaces.source.path)\n        export KUADRANT_ZONE_ROOT_DOMAIN=example.com # domain name used in the HTTPRoute for the petstore sample app\n        for file in ./generated-resources/*.yaml; do\n          envsubst &lt; \"$file\" | kubectl apply -n petstore -f - \n        done\nEOF\n</code></pre> <p>Note: This example uses Tekton with <code>kubectl</code> to apply resources to a cluster. It is best to use a tool such as Argo CD to implement continuous delivery by using a GitOps approach. In this scenario, you would do the following:</p> <ul> <li>Use <code>kuadrantctl</code> to generate Kubernetes and Kuadrant resources as part a Tekton pipeline.</li> <li>Commit these new resources to a Git repository.</li> <li>Use ArgoCD to sync these changes from the Git repository to a Kubernetes or OpenShift cluster.</li> </ul>"},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/#step-4-create-a-kubeconfig-secret","title":"Step 4 - Create a Kubeconfig secret","text":"<p>Important: While this guide uses a <code>kubeconfig</code> secret for simplicity, do not use this in production environments. Instead, use a service account for enhanced security.</p> <p>This example uses a <code>kubeconfig</code> secret and role bindings to demonstrate how to provide access for pushing generated resources to a cluster. However, for production setups, employing a service account is best.</p> <p>To proceed, create a <code>kubeconfig</code> secret in the <code>petstore</code> namespace to provide Tekton with access to your Kubernetes cluster as follows:</p> <pre><code>kubectl create secret generic kubeconfig-secret --from-file=kubeconfig=/path/to/.kube/config -n petstore\n</code></pre> <p>Create an associated <code>ClusterRole</code> and <code>ClusterRoleBinding</code> as follows:</p> <pre><code>kubectl apply -n petstore -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: kuadrant-ci-example-full-access\nrules:\n\n- apiGroups: [\"*\"]\n  resources: [\"*\"]\n  verbs: [\"*\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: kuadrant-ci-example-full-access-binding\nsubjects:\n- kind: ServiceAccount\n  name: default\n  namespace: petstore\nroleRef:\n  kind: ClusterRole\n  name: kuadrant-ci-example-full-access\n  apiGroup: rbac.authorization.k8s.io\nEOF\n</code></pre>"},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/#step-5-trigger-the-taskrun","title":"Step 5 - Trigger the TaskRun","text":"<p>Execute the task from the <code>petstore</code> namespace, referencing the <code>kubeconfig</code> secret for cluster access as follows:</p> <p>This example runs this task with the Kuadrant Petstore app: https://github.com/kuadrant/api-petstore.</p> <pre><code>kubectl apply -n petstore -f - &lt;&lt;EOF\napiVersion: tekton.dev/v1beta1\nkind: TaskRun\nmetadata:\n  name: run-kuadrantctl-taskrun\n  namespace: petstore\nspec:\n  taskRef:\n    name: run-kuadrantctl\n  params:\n\n    - name: gitRepoUrl\n      value: \"https://github.com/kuadrant/api-petstore.git\"\n    - name: gitRevision\n      value: \"main\"\n  workspaces:\n    - name: source\n      persistentVolumeClaim:\n        claimName: tekton-kuadrantctl-pvc\n    - name: kubeconfig\n      secret:\n        secretName: kubeconfig-secret\nEOF\n</code></pre> <p>If you have <code>tkn</code> installed, you can easily view the progress of the pipe run as follows:</p> <pre><code>tkn taskrun list -n petstore\nNAME                      STARTED          DURATION   STATUS\nrun-kuadrantctl-taskrun   12 seconds ago   ---        Running(Pending)\n</code></pre> <pre><code>tkn taskrun logs -n petstore -f\n\n\n[clone] Cloning into '/workspace/source'...\n[clone] Already on 'main'\n[clone] Your branch is up to date with 'origin/main'.\n\n[download-kuadrantctl]   % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n[download-kuadrantctl]                                  Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\n100 21.4M  100 21.4M    0     0  6601k      0  0:00:03  0:00:03 --:--:-- 8756k\n\n[run-kuadrantctl] {\"kind\":\"AuthPolicy\",\"apiVersion\":\"kuadrant.io/v1beta2\",\"metadata\":{\"name\":\"petstore\",\"namespace\":\"petstore\",\"creationTimestamp\":null,\"labels\":{\"deployment\":\"petstore\",\"owner\":\"jbloggs\"}},\"spec\":{\"targetRef\":{\"group\":\"gateway.networking.k8s.io\",\"kind\":\"HTTPRoute\",\"name\":\"petstore\",\"namespace\":\"petstore\"},\"routeSelectors\":[{\"matches\":[{\"path\":{\"type\":\"Exact\",\"value\":\"/api/v3/store/admin\"},\"method\":\"GET\"}]}],\"rules\":{\"authentication\":{\"storeAdmin_api_key\":{\"credentials\":{\"customHeader\":{\"name\":\"api_key\"}},\"apiKey\":{\"selector\":{\"matchLabels\":{\"kuadrant.io/apikeys-by\":\"api_key\"}}},\"routeSelectors\":[{\"matches\":[{\"path\":{\"type\":\"Exact\",\"value\":\"/api/v3/store/admin\"},\"method\":\"GET\"}]}]}}}},\"status\":{}}\n[run-kuadrantctl] {\"kind\":\"RateLimitPolicy\",\"apiVersion\":\"kuadrant.io/v1beta2\",\"metadata\":{\"name\":\"petstore\",\"namespace\":\"petstore\",\"creationTimestamp\":null,\"labels\":{\"deployment\":\"petstore\",\"owner\":\"jbloggs\"}},\"spec\":{\"targetRef\":{\"group\":\"gateway.networking.k8s.io\",\"kind\":\"HTTPRoute\",\"name\":\"petstore\",\"namespace\":\"petstore\"},\"limits\":{\"getInventory\":{\"routeSelectors\":[{\"matches\":[{\"path\":{\"type\":\"Exact\",\"value\":\"/api/v3/store/inventory\"},\"method\":\"GET\"}]}],\"rates\":[{\"limit\":10,\"duration\":10,\"unit\":\"second\"}]},\"loginUser\":{\"routeSelectors\":[{\"matches\":[{\"path\":{\"type\":\"Exact\",\"value\":\"/api/v3/user/login\"},\"method\":\"GET\"}]}],\"rates\":[{\"limit\":2,\"duration\":10,\"unit\":\"second\"}]}}},\"status\":{}}\n[run-kuadrantctl] {\"kind\":\"HTTPRoute\",\"apiVersion\":\"gateway.networking.k8s.io/v1beta1\",\"metadata\":{\"name\":\"petstore\",\"namespace\":\"petstore\",\"creationTimestamp\":null,\"labels\":{\"deployment\":\"petstore\",\"owner\":\"jbloggs\"}},\"spec\":{\"parentRefs\":[{\"kind\":\"Gateway\",\"namespace\":\"kuadrant-multi-cluster-gateways\",\"name\":\"prod-web\"}],\"hostnames\":[\"petstore.${KUADRANT_ZONE_ROOT_DOMAIN}\"],\"rules\":[{\"matches\":[{\"path\":{\"type\":\"Exact\",\"value\":\"/api/v3/user/login\"},\"method\":\"GET\"}],\"backendRefs\":[{\"name\":\"petstore\",\"namespace\":\"petstore\",\"port\":8080}]},{\"matches\":[{\"path\":{\"type\":\"Exact\",\"value\":\"/api/v3/store/admin\"},\"method\":\"GET\"}],\"backendRefs\":[{\"name\":\"petstore\",\"namespace\":\"petstore\",\"port\":8080}]},{\"matches\":[{\"path\":{\"type\":\"Exact\",\"value\":\"/api/v3/store/inventory\"},\"method\":\"GET\"}],\"backendRefs\":[{\"name\":\"petstore\",\"namespace\":\"petstore\",\"port\":8080}]}]},\"status\":{\"parents\":null}}\n\n[apply-resources] authpolicy.kuadrant.io/petstore created\n[apply-resources] httproute.gateway.networking.k8s.io/petstore created\n[apply-resources] ratelimitpolicy.kuadrant.io/petstore created\n</code></pre>"},{"location":"kuadrantctl/doc/kuadrantctl-ci-cd/#step-6-cleanup","title":"Step 6 - Cleanup","text":"<p>Clean up your resources as follows:</p> <ol> <li>Remove the <code>petstore</code> namespace:</li> <li><code>kubectl delete ns petstore</code></li> <li>Remove the <code>ClusterRole</code> and <code>ClusterRoleBinding</code>:</li> <li><code>kubectl delete clusterrole kuadrant-ci-example-full-access</code></li> <li><code>kubectl delete clusterrolebinding kuadrant-ci-example-full-access-binding</code></li> </ol>"},{"location":"kuadrantctl/doc/openapi-apicurio/","title":"Using Apicurio Studio with Kuadrant OAS extensions","text":"<p>You can use OpenAPI extensions to define extra functionality beyond what is covered by the standard OpenAPI specification. Extensions typically start with the <code>x-</code> prefix, for example, <code>x-codegen</code>. Kuadrant OpenAPI extensions start with the <code>x-kuadrant</code> prefix, and allow you to configure Kuadrant policy information alongside your API.</p> <p>Apicurio Studio is a UI tool for visualizing and editing OpenAPI designs and definitions, which can visualize security details and custom extensions specified in your OpenAPI definition.</p>"},{"location":"kuadrantctl/doc/openapi-apicurio/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have Apicurio Studio installed and running. For more information, see the Apicurio Studio documentation. </li> </ul>"},{"location":"kuadrantctl/doc/openapi-apicurio/#procedure","title":"Procedure","text":""},{"location":"kuadrantctl/doc/openapi-apicurio/#step-1-access-your-openapi-definition-in-apicurio-studio","title":"Step 1 - Access your OpenAPI definition in Apicurio Studio","text":"<p>Open or import your OpenAPI definition in Apicurio Studio. On the Design tab, select the VENDOR-EXTENSiONS section to add an extension. Alternatively, you can use the Source tab to edit the API definition directly.</p>"},{"location":"kuadrantctl/doc/openapi-apicurio/#step-2-add-kuadrant-extensions-to-your-api-definition","title":"Step 2 - Add Kuadrant extensions to your API definition","text":"<p>The following configuration and extension points are supported by Apicurio Studio and the <code>kuadrantctl</code> CLI:</p>"},{"location":"kuadrantctl/doc/openapi-apicurio/#generate-an-http-route","title":"Generate an HTTP route","text":"<p>To generate an HTTPRoute for the API, add the following <code>x-kuadrant</code> block to your API definition in Apicurio Studio, replacing values to match your API details and the location of your Gateway:</p> <pre><code>x-kuadrant:\n    route:\n        name: petstore\n        namespace: petstore\n        hostnames:\n\n            - 'petstore.example.com'\n        parentRefs:\n            -   name: prod-web\n                namespace: kuadrant-multi-cluster-gateways\n                kind: Gateway\n</code></pre> <p>For more details, see Generate Gateway API HTTPRoute object from OpenAPI 3.</p>"},{"location":"kuadrantctl/doc/openapi-apicurio/#generate-an-authpolicy","title":"Generate an AuthPolicy","text":"<p>To generate an AuthPolicy, add a <code>securityScheme</code> to the <code>components</code> block in your API definition. The following <code>securityScheme</code> requires that an API key header is set:</p> <pre><code>    securitySchemes:\n        api_key:\n            type: apiKey\n            name: api_key\n            in: header\n</code></pre> <p>Although <code>securityScheme</code> is not an OpenAPI extension, it is used by <code>kuadrantctl</code> like the other extensions mentioned in this document.</p> <p>When added, Apicurio Studio will display the following update in the SECURITY SCHEMES section:</p> <p></p> <p>For more details, see Generate Kuadrant AuthPolicy object from OpenAPI 3.</p>"},{"location":"kuadrantctl/doc/openapi-apicurio/#generate-a-ratelimitpolicy","title":"Generate a RateLimitPolicy","text":"<p>To generate a RateLimitPolicy for the API, add the following <code>x-kuadrant</code> block to a path in your API definition, replacing values to match your API details.</p> <pre><code>paths:\n    /:\n        x-kuadrant:\n            backendRefs:\n                -\n                    name: petstore\n                    namespace: petstore\n                    port: 8080\n            rate_limit:\n                rates:\n                    -\n                        limit: 10\n                        duration: 10\n                        unit: second\n</code></pre> <p>When added, Apicurio Studio  will display the following update in the VENDOR-EXTENSiONS section for that specific path:</p> <p></p> <p>For more details, see Generate Kuadrant RateLimitPolicy object from OpenAPI 3.</p>"},{"location":"kuadrantctl/doc/openapi-apicurio/#additional-resources","title":"Additional resources","text":"<ul> <li>OpenAPI 3.0.x Kuadrant Extensions in the kuadrantctl documentation.</li> <li>Apicurio Studio - Now with OpenAPI Vendor Extensions. </li> </ul>"},{"location":"kuadrantctl/doc/openapi-kuadrant-extensions/","title":"OpenAPI 3.0.x Kuadrant extensions","text":"<p>This reference information shows examples of how to add Kuadrant extensions at the root, path, or operation level in an OpenAPI 3.0.x definition. </p>"},{"location":"kuadrantctl/doc/openapi-kuadrant-extensions/#root-level-kuadrant-extension","title":"Root-level Kuadrant extension","text":"<p>You can add a Kuadrant extension at the root level of an OpenAPI definition. The following example shows an extension added for a <code>petstore</code> app:</p> <pre><code>x-kuadrant:\n  route:  ## HTTPRoute metadata\n    name: \"petstore\"\n    namespace: \"petstore\"\n    labels:  ## map[string]string\n      deployment: petstore\n    hostnames:  ## []gateway.networking.k8s.io/v1beta1.Hostname\n\n      - example.com\n    parentRefs:  ## []gateway.networking.k8s.io/v1beta1.ParentReference\n      - name: apiGateway\n        namespace: gateways\n</code></pre>"},{"location":"kuadrantctl/doc/openapi-kuadrant-extensions/#path-level-kuadrant-extension","title":"Path-level Kuadrant extension","text":"<p>You can add a Kuadrant extension at the path level of an OpenAPI definition. This configuration at the path level is the default when there is no operation-level configuration.  The following example shows an extension added for a <code>/cat</code> path:</p> <pre><code>paths:\n  /cat:\n    x-kuadrant:  ## Path-level Kuadrant extension\n      disable: true  ## Remove from the HTTPRoute. Optional. Default: false\n      pathMatchType: Exact ## Specifies how to match against the path value. Valid values: [Exact;PathPrefix]. Optional. Default: Exact\n      backendRefs:  ## Backend references to be included in the HTTPRoute. []gateway.networking.k8s.io/v1beta1.HTTPBackendRef. Optional.\n\n        - name: petstore\n          port: 80\n          namespace: petstore\n      rate_limit:  ## Rate limit configuration. Optional.\n        rates:   ## Kuadrant API []github.com/kuadrant/kuadrant-operator/api/v1beta2.Rate\n          - limit: 1\n            duration: 10\n            unit: second\n        counters:   ## Kuadrant API []github.com/kuadrant/kuadrant-operator/api/v1beta2.CountextSelector\n          - auth.identity.username\n        when:   ## Kuadrant API []github.com/kuadrant/kuadrant-operator/api/v1beta2.WhenCondition\n          - selector: metadata.filter_metadata.envoy\\.filters\\.http\\.ext_authz.identity.userid\n            operator: eq\n            value: alice\n</code></pre>"},{"location":"kuadrantctl/doc/openapi-kuadrant-extensions/#operation-level-kuadrant-extension","title":"Operation-level Kuadrant extension","text":"<p>You can add a Kuadrant extension at the operation level of an OpenAPI definition. This extension uses the same schema as the path-level Kuadrant extension. The following example shows an extension added for a <code>get</code> operation:</p> <pre><code>paths:\n  /cat:\n    get:\n      x-kuadrant:  ## Operation-level Kuadrant extension\n        disable: true  ## Remove from the HTTPRoute. Optional. Default: path level \"disable\" value.\n        pathMatchType: Exact ## Specifies how to match against the path value. Valid values: [Exact;PathPrefix]. Optional. Default: Exact.\n        backendRefs:  ## Backend references to be included in the HTTPRoute. Optional.\n\n          - name: petstore\n            port: 80\n            namespace: petstore\n        rate_limit:  ## Rate limit configuration. Optional.\n          rates:   ## Kuadrant API github.com/kuadrant/kuadrant-operator/api/v1beta2.Rate\n            - limit: 1\n              duration: 10\n              unit: second\n          counters:   ## Kuadrant API github.com/kuadrant/kuadrant-operator/api/v1beta2.CountextSelector\n            - auth.identity.username\n          when:   ## Kuadrant API github.com/kuadrant/kuadrant-operator/api/v1beta2.WhenCondition\n            - selector: metadata.filter_metadata.envoy\\.filters\\.http\\.ext_authz.identity.userid\n              operator: eq\n              value: alice\n</code></pre>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/","title":"Integrating Kuadrant OAS extensions with Red Hat OpenShift Dev Spaces","text":"<p>OpenAPI extensions enhance the standard OpenAPI specification by adding custom functionality. Kuadrant OpenAPI extensions are identified by the <code>x-kuadrant</code> prefix. You can use OpenAPI extensions to integrate Kuadrant policies directly into your API definitions.</p> <p>Red Hat OpenShift Dev Spaces provides a browser-based, cloud-native IDE that supports rapid and decentralized development in container-based environments. This tutorial demonstrates how to use OpenShift Dev Spaces to modify an OpenAPI definition by incorporating Kuadrant policies, and then use the <code>kuadrantctl</code> CLI to create Kubernetes resources for both Gateway API and Kuadrant.</p>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>You must have access to one of the following Dev Spaces instances:</p> </li> <li> <p>A self-hosted OpenShift Dev Spaces instance.</p> </li> <li>An OpenShift Dev Spaces instance provided by the Red Hat Developer Sandbox.</li> </ul>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#procedure","title":"Procedure","text":""},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#step-1-setting-up-your-workspace","title":"Step 1 - Setting up your workspace","text":"<p>Create a workspace in Dev Spaces for your project as follows:</p> <ol> <li>Fork the following repository: https://github.com/Kuadrant/blank-petstore.</li> <li>In Dev Spaces, select Create Workspace, and enter the URL of your forked repository. For example: <code>https://github.com/&lt;your-username&gt;/blank-petstore.git</code>.</li> <li>Click Create &amp; Open.</li> </ol>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#step-2-configuring-vs-code-in-dev-spaces","title":"Step 2 - Configuring VS Code in Dev Spaces","text":"<p>For this tutorial, you will perform the following tasks:</p> <ul> <li>Install <code>kuadrantctl</code> in your workspace to demonstrate Kubernetes resource generation from your modified OpenAPI definition.</li> <li>Optional: Configure Git with your username and email to enable pushing changes back to your repository.</li> </ul>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#install-the-kuadrantctl-cli","title":"Install the kuadrantctl CLI","text":"<p>To install <code>kuadrantctl</code> in your Dev Spaces workspace, enter the following command:</p> <pre><code>curl -sL \"https://github.com/kuadrant/kuadrantctl/releases/download/v0.2.3/kuadrantctl-v0.2.3-linux-amd64.tar.gz\" | tar xz -C /home/user/.local/bin\n</code></pre> <p>This command installs <code>kuadrantctl</code> in <code>/home/user/.local/bin</code>, which is included in the container's <code>$PATH</code> by default.</p>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#optional-configuring-git","title":"Optional: Configuring Git","text":"<p>If you plan to push changes back to your repository, configure your Git username and email as follows:</p> <pre><code>git config --global user.email \"foo@example.com\"\ngit config --global user.name \"Foo Example\"\n</code></pre>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#step-3-adding-kuadrant-policies-to-your-openapi-definition","title":"Step 3 - Adding Kuadrant policies to your OpenAPI definition","text":"<p>After creating your workspace, Dev Spaces will launch VS Code loaded with your forked repository. Navigate to the <code>openapi.yaml</code> file in the sample app to begin modifications.</p>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#kuadrant-policies-overview","title":"Kuadrant policies overview","text":"<p>You will enhance your API definition by applying Kuadrant policies to the following endpoints:</p> <ul> <li><code>/pet/findByStatus</code></li> <li><code>/user/login</code></li> <li><code>/store/inventory</code></li> </ul> <p>In this tutorial, you will add Kuadrant policies to your API definition as follows:</p> <ul> <li>Generate an <code>HTTPRoute</code> to expose these three routes for an existing <code>Gateway</code>.</li> <li>Add API key authentication for the <code>/user/login</code> route, using a Kuadrant <code>AuthPolicy</code> and OAS <code>securitySchemes</code>.</li> <li>Add a Kuadrant <code>RateLimitPolicy</code> to the <code>/store/inventory</code> endpoint, to limit the amount of requests this endpoint can receive.</li> </ul>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#defining-a-gateway","title":"Defining a Gateway","text":"<p>Use the <code>x-kuadrant</code> extension in the root level to specify a <code>Gateway</code>. This information will be used to generate <code>HTTPRoute</code>s at the path level. For example:</p> <pre><code>x-kuadrant:\n  route:  ## HTTPRoute metadata\n    name: \"petstore\"\n    namespace: \"petstore\"\n    labels:  ## map[string]string\n      deployment: petstore\n    hostnames:  ## []gateway.networking.k8s.io/v1beta1.Hostname\n\n      - example.com\n    parentRefs:  ## []gateway.networking.k8s.io/v1beta1.ParentReference\n      - name: apiGateway\n        namespace: gateways\n</code></pre>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#specifying-httproutes-for-each-path","title":"Specifying HTTPRoutes for each path","text":"<p>For each path, add an <code>x-kuadrant</code> extension with <code>backendRefs</code> to link your routes to your paths as follows:</p> <pre><code>  /pet/findByStatus:\n    x-kuadrant:\n      backendRefs:\n\n      - name: petstore\n        namespace: petstore\n        port: 8080\n    get:\n      # ...\n</code></pre> <pre><code>  /user/login:\n    x-kuadrant:\n      backendRefs:\n\n      - name: petstore\n        namespace: petstore\n        port: 8080\n    get:\n      # ...\n</code></pre> <pre><code>  /store/inventory:\n    x-kuadrant:\n      backendRefs:\n\n      - name: petstore\n        namespace: petstore\n        port: 8080\n    get:\n      # ...\n</code></pre> <p>Note: The <code>x-kuadrant</code> extension at the path level applies to all HTTP methods defined in the path. For method-specific policies, move the extension inside the relevant HTTP method block, for example, <code>get</code> or <code>post</code>.</p>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#implementing-authpolicy-and-security-schemes","title":"Implementing AuthPolicy and security schemes","text":"<p>To secure the <code>/user/login</code> endpoint with API key authentication, use the following configuration:</p> <pre><code>  /user/login:\n    # ...\n    get:\n      security:\n\n      - api_key: []\n</code></pre> <pre><code>components:\n  schemas:\n    # ...\n  securitySchemes:\n    api_key:\n      type: apiKey\n      name: api_key\n      in: header\n</code></pre> <p>This configuration generates an <code>AuthPolicy</code> that references an API key stored in a labeled <code>Secret</code>:</p> <p><pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: petstore-api-key\n  namespace: petstore\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    kuadrant.io/apikeys-by: api_key\nstringData:\n  api_key: secret\ntype: Opaque\n</code></pre> For simplicity, this example uses a simple, static API key for your app.</p>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#applying-a-ratelimitpolicy-to-an-endpoint","title":"Applying a RateLimitPolicy to an endpoint","text":"<p>To enforce rate limiting on the <code>/store/inventory</code> endpoint, add the following <code>x-kuadrant</code> extension:</p> <pre><code>  /store/inventory:\n    get:\n      # ...\n      x-kuadrant:\n        backendRefs:\n          # ...\n        rate_limit:\n          rates:\n\n          - limit: 10\n            duration: 10\n            unit: second\n</code></pre> <p>This limits to 10 requests every 10 seconds for the <code>/store/inventory</code> endpoint.</p>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#step-4-generate-kubernetes-resources-by-using-kuadrantctl","title":"Step 4 - Generate Kubernetes resources by using kuadrantctl","text":"<p>With your extensions in place, you can use <code>kuadrantctl</code> to generate the follollowing Kubernetes resources:</p> <ul> <li>An <code>HTTPRoute</code> for your <code>petstore</code> app for each of your endpoints.</li> <li>An <code>AuthPolicy</code> with a simple, static API key from a secret for the <code>/user/login</code> endpoint.</li> <li>A <code>RateLimitPolicy</code> with a rate limit of 10 requests every 10 seconds for the <code>/store/inventory</code> endpoint.</li> </ul> <p>In Dev Spaces, select \u2630 &gt; Terminal &gt; New Terminal, and run the following commands:</p>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#generate-an-httproute","title":"Generate an HTTPRoute","text":"<pre><code>kuadrantctl generate gatewayapi httproute --oas openapi.yaml\n</code></pre> <p>This command outputs the following <code>HTTPRoute</code>:</p> <pre><code>kind: HTTPRoute\napiVersion: gateway.networking.k8s.io/v1beta1\nmetadata:\n  name: petstore\n  namespace: petstore\n  creationTimestamp: null\n  labels:\n    deployment: petstore\nspec:\n  parentRefs:\n\n    - namespace: gateways\n      name: apiGateway\n  hostnames:\n    - example.com\n  rules:\n    - matches:\n        - path:\n            type: Exact\n            value: /api/v3/pet/findByStatus\n          method: GET\n      backendRefs:\n        - name: petstore\n          namespace: petstore\n          port: 8080\n    - matches:\n        - path:\n            type: Exact\n            value: /api/v3/store/inventory\n          method: GET\n      backendRefs:\n        - name: petstore\n          namespace: petstore\n          port: 8080\n    - matches:\n        - path:\n            type: Exact\n            value: /api/v3/user/login\n          method: GET\n      backendRefs:\n        - name: petstore\n          namespace: petstore\n          port: 8080\nstatus:\n  parents: null\n</code></pre>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#generate-an-authpolicy","title":"Generate an AuthPolicy","text":"<pre><code>kuadrantctl generate kuadrant authpolicy --oas openapi.yaml\n</code></pre> <p>This command outputs the following <code>AuthPolicy</code>:</p> <pre><code>apiVersion: kuadrant.io/v1beta2\nkind: AuthPolicy\nmetadata:\n  name: petstore\n  namespace: petstore\n  creationTimestamp: null\n  labels:\n    deployment: petstore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: petstore\n    namespace: petstore\n  routeSelectors:\n\n    - matches:\n        - path:\n            type: Exact\n            value: /api/v3/user/login\n          method: GET\n  rules:\n    authentication:\n      GETuserlogin_api_key:\n        credentials:\n          customHeader:\n            name: api_key\n        apiKey:\n          selector:\n            matchLabels:\n              kuadrant.io/apikeys-by: api_key\n        routeSelectors:\n          - matches:\n              - path:\n                  type: Exact\n                  value: /api/v3/user/login\n                method: GET\nstatus: {}\n</code></pre>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#generate-a-ratelimitpolicy","title":"Generate a RateLimitPolicy","text":"<pre><code>kuadrantctl generate kuadrant ratelimitpolicy --oas openapi.yaml\n</code></pre> <p>This command outputs the following <code>RateLimitPolicy</code>:</p> <pre><code>apiVersion: kuadrant.io/v1beta2\nkind: RateLimitPolicy\nmetadata:\n  name: petstore\n  namespace: petstore\n  creationTimestamp: null\n  labels:\n    deployment: petstore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: petstore\n    namespace: petstore\n  limits:\n    GETstoreinventory:\n      routeSelectors:\n\n        - matches:\n            - path:\n                type: Exact\n                value: /api/v3/store/inventory\n              method: GET\n      rates:\n        - limit: 10\n          duration: 10\n          unit: second\nstatus: {}\n</code></pre>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#step-5-applying-resources-to-the-app","title":"Step 5 - Applying resources to the app","text":"<p>Note: By default, the <code>oc</code> and <code>kubectl</code> commands in Dev Spaces target the cluster running Dev Spaces. If you want to apply resources to another cluster, you must log in with <code>oc</code> or <code>kubectl</code> to another cluster, and pass a different <code>--context</code> to these commands to apply resources to another cluster.</p> <p>You can now apply these policies to a running app by using <code>kubectl</code> or <code>oc</code>. If Dev Spaces is running on a cluster where Kuadrant is also installed, you can apply these resources as follows:</p> <pre><code>kuadrantctl generate gatewayapi httproute --oas openapi.yaml | kubectl apply -f -\nkuadrantctl generate kuadrant authpolicy --oas openapi.yaml | kubectl apply -f -\nkuadrantctl generate kuadrant ratelimitpolicy --oas openapi.yaml | kubectl apply -f -\n</code></pre> <p>Alternatively, you can use <code>kuadrantctl</code> as part of a CI/CD pipeline. For more details, see the kuadrantctl CI/CD guide.</p> <p>If you completed the optional Git configuration step, you can enter <code>git commit</code> to commit the these changes and push them to your fork.</p>"},{"location":"kuadrantctl/doc/openapi-openshift-dev-spaces/#additional-resources","title":"Additional resources","text":"<p>For more details, see the following documentation on using <code>x-kuadrant</code> OAS extensions with <code>kuadrantctl</code>:</p> <ul> <li>OpenAPI 3.0.x Kuadrant extensions</li> <li>Generate Gateway API HTTPRoutes with <code>kuadrantctl</code></li> <li>Generate Kuadrant AuthPolicy with <code>kuadrantctl</code></li> <li>Generate Kuadrant RateLimitPolicy with <code>kuadrantctl</code></li> <li>kuadrantctl CI/CD guide</li> </ul>"},{"location":"dns-operator/","title":"DNS Operator","text":"<p>The DNS Operator is a kubernetes based controller responsible for reconciling DNS Record custom resources. It interfaces with cloud DNS providers such as AWS and Google to bring the DNS zone into the state declared in these CRDs. One of the key use cases the DNS operator solves, is allowing complex DNS routing strategies such as Geo and Weighted to be expressed allowing you to leverage DNS as the first layer of traffic management. In order to make these strategies valuable, it also works across multiple clusters allowing you to use a shared domain name balance traffic based on your requirements.</p>"},{"location":"dns-operator/#getting-started","title":"Getting Started","text":""},{"location":"dns-operator/#pre-setup","title":"Pre Setup","text":""},{"location":"dns-operator/#add-dns-provider-configuration","title":"Add DNS provider configuration","text":"<p>NOTE: You can optionally skip this step but at least one DNS Provider Secret will need to be configured with valid credentials to use the DNS Operator.</p>"},{"location":"dns-operator/#aws-provider-route53","title":"AWS Provider (Route53)","text":"<p><pre><code>make local-setup-aws-clean local-setup-aws-generate AWS_ACCESS_KEY_ID=&lt;My AWS ACCESS KEY&gt; AWS_SECRET_ACCESS_KEY=&lt;My AWS Secret Access Key&gt;\n</code></pre> More details about the AWS provider can be found here</p>"},{"location":"dns-operator/#gcp-provider","title":"GCP Provider","text":"<p><pre><code>make local-setup-gcp-clean local-setup-gcp-generate GCP_GOOGLE_CREDENTIALS='&lt;My GCP Credentials.json&gt;' GCP_PROJECT_ID=&lt;My GCP PROJECT ID&gt;\n</code></pre> More details about the GCP provider can be found here</p>"},{"location":"dns-operator/#azure-provider","title":"AZURE Provider","text":"<pre><code>make local-setup-azure-clean local-setup-azure-generate KUADRANT_AZURE_CREDENTIALS='&lt;My Azure Credentials.json&gt;'\n</code></pre> <p>Info on generating service principal credentials here</p> <p>Get your resource group ID like so: <pre><code>az group show --resource-group &lt;resource group name&gt; | jq \".id\" -r\n</code></pre></p> <p>Also give traffic manager contributor role: <pre><code>az role assignment create --role \"Traffic Manager Contributor\" --assignee $EXTERNALDNS_SP_APP_ID --scope &lt;RESOURCE_GROUP_ID&gt;\n</code></pre></p> <p>Getting the zone ID can be achieved using the below command: <pre><code>az network dns zone show --name &lt;my domain name&gt; --resource-group &lt;my resource group&gt; --query \"{id:id,domain:name}\"\n</code></pre></p>"},{"location":"dns-operator/#running-controller-locally-default","title":"Running controller locally (default)","text":"<ol> <li> <p>Create local environment(creates kind cluster) <pre><code>make local-setup\n</code></pre></p> </li> <li> <p>Run your controller (this will run in the foreground, so switch to a new terminal if you want to leave it running):</p> </li> </ol> <pre><code>make run\n</code></pre>"},{"location":"dns-operator/#running-controller-on-the-cluster","title":"Running controller on the cluster","text":"<ol> <li> <p>Create local environment(creates kind cluster) <pre><code>make local-setup DEPLOY=true\n</code></pre></p> </li> <li> <p>Verify controller deployment <pre><code>kubectl logs -f deployments/dns-operator-controller-manager -n dns-operator-system\n</code></pre></p> </li> </ol>"},{"location":"dns-operator/#running-controller-on-existing-cluster","title":"Running controller on existing cluster","text":"<p>You\u2019ll need a Kubernetes cluster to run against. You can use KIND to get a local cluster for testing, or run against a remote cluster. Note: Your controller will automatically use the current context in your kubeconfig file (i.e. whatever cluster <code>kubectl cluster-info</code> shows).</p> <ol> <li> <p>Apply Operator manifests <pre><code>kustomize build config/default | kubectl apply -f -\n</code></pre></p> </li> <li> <p>Verify controller deployment <pre><code>kubectl logs -f deployments/dns-operator-controller-manager -n dns-operator-system\n</code></pre></p> </li> </ol>"},{"location":"dns-operator/#development","title":"Development","text":""},{"location":"dns-operator/#e2e-test-suite","title":"E2E Test Suite","text":"<p>The e2e test suite can be executed against any cluster running the DNS Operator with configuration added for any supported provider.</p> <pre><code>make test-e2e TEST_DNS_ZONE_DOMAIN_NAME=&lt;My domain name&gt; TEST_DNS_PROVIDER_SECRET_NAME=&lt;My provider secret name&gt; TEST_DNS_NAMESPACES=&lt;My test namespace(s)&gt;\n</code></pre> Environment Variable Description TEST_DNS_PROVIDER_SECRET_NAME Name of the provider secret to use. If using local-setup provider secrets zones, one of [dns-provider-credentials-aws; dns-provider-credentials-gcp;dns-provider-credentials-azure] TEST_DNS_ZONE_DOMAIN_NAME The Domain name to use in the test. Must be a zone accessible with the (TEST_DNS_PROVIDER_SECRET_NAME) credentials with the same domain name TEST_DNS_NAMESPACES The namespace(s) where the provider secret(s) can be found"},{"location":"dns-operator/#modifying-the-api-definitions","title":"Modifying the API definitions","text":"<p>If you are editing the API definitions, generate the manifests such as CRs or CRDs using:</p> <pre><code>make manifests\n</code></pre> <p>NOTE: Run <code>make --help</code> for more information on all potential <code>make</code> targets</p> <p>More information can be found via the Kubebuilder Documentation</p>"},{"location":"dns-operator/#logging","title":"Logging","text":"<p>Logs are following the general guidelines: </p> <ul> <li><code>logger.Info()</code> describe a high-level state of the resource such as creation, deletion and which reconciliation path was taken.  </li> <li><code>logger.Error()</code> describe only those errors that are not returned in the result of the reconciliation. If error is occurred there should be only one error message. </li> <li><code>logger.V(1).Info()</code> debug level logs to give information about every change or event caused by the resource as well as every update of the resource.</li> </ul> <p>The <code>--zap-devel</code> argument will enable debug level logs for the output. Otherwise, all <code>V()</code> logs are ignored.</p>"},{"location":"dns-operator/#common-metadata","title":"Common metadata","text":"<p>Not exhaustive list of metadata for DNSRecord controller:</p> <ul> <li><code>level</code> - logging level. Values are: <code>info</code>,<code>debug</code> or <code>error</code></li> <li><code>ts</code> - timestamp</li> <li><code>logger</code> - logger name</li> <li><code>msg</code></li> <li><code>controller</code> and <code>controllerKind</code> - controller name, and it's kind respectively to output the log</li> <li><code>DNSRecord</code> - name and namespace of the DNS Record CR that is being reconciled</li> <li><code>reconcileID</code></li> <li><code>ownerID</code> - ID the of owner of the DNS Record </li> <li><code>txtPrefix</code>/<code>txtSuffix</code> - prefix and suffix of the TXT record in provider. </li> <li><code>zoneEndpoints</code> - endpoints that exist in the provider</li> <li><code>specEdnoinds</code> - endpoints defined in the spec</li> <li><code>statusEndpoints</code> - endpoints that were processed previously</li> </ul> <p>Note that not all the metadata values are present at each of the logs statements. </p>"},{"location":"dns-operator/#examples","title":"Examples","text":"<p>To query logs locally you can use <code>jq</code>. For example: Retrieve logs by  <pre><code>kubectl get deployments -l app.kubernetes.io/part-of=dns-operator -A\n\nNAMESPACE             NAME                              READY \ndns-operator-system   dns-operator-controller-manager   1/1   \n</code></pre> And query them. For example: <pre><code>kubectl logs -l control-plane=dns-operator-controller-manager -n dns-operator-system --tail -1 | sed '/^{/!d' | jq 'select(.controller==\"dnsrecord\" and .level==\"info\")'\n</code></pre> or  <pre><code>kubectl logs -l control-plane=dns-operator-controller-manager -n dns-operator-system --tail -1 | sed '/^{/!d' | jq 'select(.controller==\"dnsrecord\" and .DNSRecord.name==\"test\" and .reconcileID==\"2be16b6d-b90f-430e-9996-8b5ec4855d53\")' | jq '.level, .msg, .zoneEndpoints, .specEndpoints, .statusEndpoints '\n</code></pre> You could use selector in the <code>jq</code> with <code>and</code>/<code>not</code>/<code>or</code> to restrict.</p>"},{"location":"dns-operator/#license","title":"License","text":"<p>Copyright 2024.</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p></p>"},{"location":"dns-operator/docs/RELEASE/","title":"RELEASE","text":""},{"location":"dns-operator/docs/RELEASE/#release","title":"Release","text":""},{"location":"dns-operator/docs/RELEASE/#new-majorminor-version","title":"New Major.Minor version","text":"<ol> <li>Create a new minor release branch from the HEAD of main: <pre><code>git checkout -b release-0.2\n</code></pre></li> <li>Run prepare release: <pre><code>make prepare-release IMG_TAG=release-0.2 VERSION=0.2.0-dev CHANNELS=alpha REPLACES_VERSION=0.1.0\n</code></pre></li> <li>Verify local changes, commit and push: <pre><code>git add .\ngit commit -m \"prepare-release: release-0.2\"\ngit push upstream release-0.2\n</code></pre></li> <li> <p>Verify that the build image workflow is triggered and completes for the new branch</p> </li> <li> <p>Do any final testing and bug fixing against the release branch, see Verify OLM Deployment</p> </li> <li> <p>Run prepare release for final version <pre><code>make prepare-release VERSION=0.2.0 CHANNELS=stable REPLACES_VERSION=0.1.0\n</code></pre></p> </li> <li>Verify local changes, commit, push and tag: <pre><code>git add .\ngit commit -m \"prepare-release: v0.2.0\"\ngit tag v0.2.0\ngit push upstream release-0.2\ngit push upstream v0.2.0\n</code></pre></li> <li> <p>Verify that the build release tag workflow is triggered and completes for the new tag</p> </li> <li> <p>Verify the new version can be installed from the catalog image, see Verify OLM Deployment</p> </li> <li> <p>Release to the community operator index catalogs.</p> </li> </ol>"},{"location":"dns-operator/docs/RELEASE/#new-patch-version","title":"New Patch version","text":"<ol> <li>Checkout minor release branch: <pre><code>git checkout release-0.2\n</code></pre></li> <li>Run prepare release: <pre><code>make prepare-release VERSION=0.2.1 CHANNELS=stable REPLACES_VERSION=0.2.0\n</code></pre></li> <li>Verify local changes, commit and push: <pre><code>git add .\ngit commit -m \"prepare-release: v0.2.1\"\ngit tag v0.2.1\ngit push upstream release-0.2\ngit push upstream v0.2.1\n</code></pre></li> <li> <p>Verify that the build release tag workflow is triggered and completes for the new tag</p> </li> <li> <p>Verify the new version can be installed from the catalog image, see Verify OLM Deployment</p> </li> <li> <p>Release to the community operator index catalogs.</p> </li> </ol>"},{"location":"dns-operator/docs/RELEASE/#verify-olm-deployment","title":"Verify OLM Deployment","text":"<ol> <li> <p>Deploy the OLM catalog image: <pre><code>make local-setup install-olm deploy-catalog\n</code></pre></p> </li> <li> <p>Wait for deployment: <pre><code>kubectl -n dns-operator-system wait --timeout=60s --for=condition=Available deployments --all\ndeployment.apps/dns-operator-controller-manager condition met\n</code></pre></p> </li> <li> <p>Check the logs: <pre><code>kubectl -n dns-operator-system logs -f deployment/dns-operator-controller-manager\n</code></pre></p> </li> <li> <p>Check the version: <pre><code>$ kubectl -n dns-operator-system get deployment dns-operator-controller-manager --show-labels\nNAME                              READY   UP-TO-DATE   AVAILABLE   AGE     LABELS\ndns-operator-controller-manager   1/1     1            1           5m42s   app.kubernetes.io/component=manager,app.kubernetes.io/created-by=dns-operator,\napp.kubernetes.io/instance=controller-manager,app.kubernetes.io/managed-by=kustomize,app.kubernetes.io/name=deployment,app.kubernetes.io/part-of=dns-operator,\ncontrol-plane=dns-operator-controller-manager,olm.deployment-spec-hash=1jPe8AuMpSKHh51nnDs4j25ZgoUrKhF45EP0Wa,olm.managed=true,olm.owner.kind=ClusterServiceVersion,\nolm.owner.namespace=dns-operator-system,olm.owner=dns-operator.v0.2.0-dev,operators.coreos.com/dns-operator.dns-operator-system=\n</code></pre></p> </li> </ol>"},{"location":"dns-operator/docs/RELEASE/#community-operator-index-catalogs","title":"Community Operator Index Catalogs","text":"<ul> <li>Operatorhub Community Operators</li> <li>Openshift Community Operators</li> </ul>"},{"location":"dns-operator/docs/provider/","title":"Configuring a DNS Provider","text":"<p>In order to be able to interact with supported DNS providers, Kuadrant needs a credential that it can use.</p>"},{"location":"dns-operator/docs/provider/#supported-providers","title":"Supported Providers","text":"<p>Kuadrant Supports the following DNS providers currently</p> <ul> <li>AWS Route 53 (aws)</li> <li>Google Cloud DNS (gcp)</li> <li>Azure (azure)</li> </ul>"},{"location":"dns-operator/docs/provider/#aws-route-53-provider","title":"AWS Route 53 Provider","text":"<p>Kuadrant expects a <code>Secret</code> with a credential. Below is an example for AWS Route 53. It is important to set the secret type to <code>aws</code>:</p> <pre><code>kubectl create secret generic my-aws-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=XXXX \\\n  --from-literal=AWS_REGION=eu-west-1 \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=XXX\n</code></pre> Key Example Value Description <code>AWS_REGION</code> <code>eu-west-1</code> AWS Region <code>AWS_ACCESS_KEY_ID</code> <code>XXXX</code> AWS Access Key ID (see note on permissions below) <code>AWS_SECRET_ACCESS_KEY</code> <code>XXXX</code> AWS Secret Access Key"},{"location":"dns-operator/docs/provider/#aws-iam-permissions-required","title":"AWS IAM Permissions Required","text":"<p>We have tested using the available policy <code>AmazonRoute53FullAccess</code> however it should also be possible to restrict the credential down to a particular zone. More info can be found in the AWS docs:</p> <p>https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/access-control-managing-permissions.html</p> <p>By default, Kuadrant will list the available zones and find the matching zone based on the listener host in the gateway listener. If it finds more than one matching zone for a given listener host, it will not update any of those zones.  When providing a credential you should limit that credential down to just have write access to the zones you want Kuadrant to manage. Below is an example of a an AWS policy for doing this type of thing:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListTagsForResources\",\n                \"route53:GetHealthCheckLastFailureReason\",\n                \"route53:GetHealthCheckStatus\",\n                \"route53:GetChange\",\n                \"route53:GetHostedZone\",\n                \"route53:ChangeResourceRecordSets\",\n                \"route53:ListResourceRecordSets\",\n                \"route53:GetHealthCheck\",\n                \"route53:UpdateHostedZoneComment\",\n                \"route53:UpdateHealthCheck\",\n                \"route53:CreateHealthCheck\",\n                \"route53:DeleteHealthCheck\",\n                \"route53:ListTagsForResource\",\n                \"route53:ListHealthChecks\",\n                \"route53:GetGeoLocation\",\n                \"route53:ListGeoLocations\",\n                \"route53:ListHostedZonesByName\",\n                \"route53:GetHealthCheckCount\"\n            ],\n            \"Resource\": [\n                \"arn:aws:route53:::hostedzone/Z08187901Y93585DDGM6K\",\n                \"arn:aws:route53:::healthcheck/*\",\n                \"arn:aws:route53:::change/*\"\n            ]\n        },\n        {\n            \"Sid\": \"VisualEditor1\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListHostedZones\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"dns-operator/docs/provider/#google-cloud-dns-provider","title":"Google Cloud DNS Provider","text":"<p>Kuadant expects a secret with a credential. Below is an example for Google DNS. It is important to set the secret type to <code>gcp</code>:</p> <pre><code>kubectl create secret generic my-test-gcp-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/gcp \\\n  --from-literal=PROJECT_ID=xxx \\\n  --from-file=GOOGLE=$HOME/.config/gcloud/application_default_credentials.json\n</code></pre> Env Var Example Value Description <code>GOOGLE</code> <code>{\"client_id\": \"***\",\"client_secret\": \"***\",\"refresh_token\": \"***\",\"type\": \"authorized_user\"}</code> This is the JSON created from either the credential created by the <code>gcloud</code> CLI, or the JSON from the Service account <code>PROJECT_ID</code> <code>my_project_id</code> ID to the Google project"},{"location":"dns-operator/docs/provider/#google-cloud-dns-access-permissions-required","title":"Google Cloud DNS Access permissions required","text":"<p>We have tested with the <code>dns.admin</code> role. See for more details:</p> <p>https://cloud.google.com/dns/docs/access-control#dns.admin</p>"},{"location":"dns-operator/docs/provider/#azure-cloud-dns-provider","title":"Azure Cloud DNS Provider","text":"<p>Kuadrant expects a <code>Secret</code> with a credential. Below is an example for Azure. It is important to set the secret type to <code>azure</code>:</p> <p>We recommend creating a new service principal for managing DNS. Azure Service Principal Docs</p> <pre><code># Create the service principal\n$ DNS_NEW_SP_NAME=kuadrantDnsPrincipal\n$ DNS_SP=$(az ad sp create-for-rbac --name $DNS_NEW_SP_NAME)\n$ DNS_SP_APP_ID=$(echo $DNS_SP | jq -r '.appId')\n$ DNS_SP_PASSWORD=$(echo $DNS_SP | jq -r '.password')\n</code></pre>"},{"location":"dns-operator/docs/provider/#azure-cloud-dns-access-permissions-required","title":"Azure Cloud DNS Access permissions required","text":"<p>You will need to grant read and contributor access to the zone(s) you want managed for the service principal you are using.</p> <p>1)  fetch DNS id used to grant access to the service principal</p> <pre><code>DNS_ID=$(az network dns zone show --name example.com \\\n --resource-group ExampleDNSResourceGroup --query \"id\" --output tsv)\n\n# get yor resource group id\n\nRESOURCE_GROUP_ID=az group show --resource-group ExampleDNSResourceGroup | jq \".id\" -r\n</code></pre>"},{"location":"dns-operator/docs/provider/#provide-reader-access-to-the-resource-group","title":"provide reader access to the resource group","text":"<p>$ az role assignment create --role \"Reader\" --assignee $DNS_SP_APP_ID --scope $DNS_ID</p>"},{"location":"dns-operator/docs/provider/#provide-contributor-access-to-dns-zone-itself","title":"provide contributor access to DNS Zone itself","text":"<p>$ az role assignment create --role \"Contributor\" --assignee $DNS_SP_APP_ID --scope $DNS_ID</p> <p>As we are setting up advanced traffic rules for GEO and Weighted responses you will also need to grant traffic manager access:</p> <pre><code>az role assignment create --role \"Traffic Manager Contributor\" --assignee $DNS_SP_APP_ID --scope $RESOURCE_GROUP_ID\n</code></pre> <pre><code>cat &lt;&lt;-EOF &gt; /local/path/to/azure.json\n{\n  \"tenantId\": \"$(az account show --query tenantId -o tsv)\",\n  \"subscriptionId\": \"$(az account show --query id -o tsv)\",\n  \"resourceGroup\": \"ExampleDNSResourceGroup\",\n  \"aadClientId\": \"$DNS_SP_APP_ID\",\n  \"aadClientSecret\": \"$DNS_SP_PASSWORD\"\n}\nEOF\n</code></pre> <p>Finally setup the secret with the credential azure.json file</p> <pre><code>kubectl create secret generic my-test-azure-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/azure \\\n  --from-file=azure.json=/local/path/to/azure.json\n</code></pre>"},{"location":"dns-operator/docs/RFC/distributed-dns/dnsrecord-lifecycle/","title":"List of issues","text":"<ul> <li>Re-queue validation intermittently GH-36</li> <li>Re-queue DNS Record whenever a write to the Cloud Provider occurs GH-35</li> <li>Schedule removal of finalizer from DNS Records GH-38</li> <li>Record write attempts in status for current generation GH-34</li> </ul>"},{"location":"dns-operator/docs/RFC/distributed-dns/dnsrecord-lifecycle/#the-idea","title":"The idea","text":"<p>We now will constantly reconcile DNS records. The reasoning is that other controllers may override/change records in the DNS provider so there is a need to requeue the DNS Record from time to time even when no local changes are introduced.</p>"},{"location":"dns-operator/docs/RFC/distributed-dns/dnsrecord-lifecycle/#details","title":"Details","text":"<p>There are a few new fields on the DNS Record status:</p> <ul> <li>QueuedAt is a time when the DNS record was received for the reconciliation</li> <li>ValidFor indicates the duration since the last reconciliation we consider data in the record to be valid</li> <li>WriteCounter represents a number of consecutive write attempts on the same generation of the record. It is being reset to 0 when the generation changes or there are no changes to write.</li> </ul> <p>There is an option to override the <code>ValidFor</code> and <code>DefaultRequeueTime</code> with <code>valid-for</code> and <code>requeue-time</code> flags respectively.</p> <p>The <code>DefaultRequeueTime</code> is the duration between successful validation and the next reconciliation to ensure that the record is still up-to-date.</p> <p>The <code>ValidFor</code> is used to determine if we should do a full reconciliation when we get the record. If the record is still valid we will only update finalizers and validate the record itself. It will not perform anything that involves a DNS provider.</p>"},{"location":"dns-operator/docs/RFC/distributed-dns/dnsrecord-lifecycle/#dns-record-normal-lifecycle","title":"DNS Record normal lifecycle","text":"<p>Once we enqueue the DNS record, controller will compile a list of changes to the DNS provider and will apply it. After this, the record is enqueued with the <code>validationRequeueTime</code> and the <code>Ready</code> condition will be marked as <code>false</code> with a message <code>Awaiting Validation</code>. When the record is received again and the controller ensures there are no changes needed (the ones applied are present in the DNS Provider) it sets the <code>Ready</code> condition to <code>true</code> and enqueues it with the <code>defaultRequeueTime</code>.</p> <p>Upon deletion, the process will be similar. The controller will determine the changes needed to the DNS provider and will apply them. The record will be requeued with the <code>validationRequeueTime</code>. Once we receive it back and ensure that there are no changes needed for the DNS provider we remove the finalizer from the record.</p> <p>The <code>validationRequeueTime</code> duration is randomized +/- 50%.</p>"},{"location":"dns-operator/docs/RFC/distributed-dns/dnsrecord-lifecycle/#when-things-go-south","title":"When things go south","text":"<p>If the record is received prematurely - the <code>ValidFor</code> + <code>QueuedAt</code> is more than the current time - we requeue it again for the <code>ValidFor</code> duration.</p> <p>When we encounter an error during the reconciliation we will not requeue the record and will put in an appropriate error message in the log and on the record. In order for it to reconcile again there must be a change to the DNS Record CR.</p> <p>It is possible for a user to mess with the timestamps field or the <code>ValidFor</code> field. Kubernetes will not let setting an invalid value to the timestamp fields. Once the timestamp fields are set manually it will trigger reconciliation since there is a change in the record CR. The only one that could impact the controller is the <code>QueuedAt</code> field and the controller will believe that to be the last time the record was reconciled. As for the <code>ValidFor</code>: since it is a simple string it is possible to set an incorrect value. If we fail to parse it we treat the <code>ValidFor</code> as 0. This means that the controller will believe that the information in the record is expired and will probe the DNS provider for an update. If a valid value is provided controller will obey it. Eventually, the controller will naturally enqueue the record and those values will be overridden.</p> <p>In case the controller fails to retain changes in the DNS Provider: write are successful, but the validation fails again and the <code>WriteCounter</code> reaches the <code>WriteCounterLimit</code> we give up on the reconciliation. The appropriate message will be put under the <code>Ready - false</code> condition as well as in the logs of the controller. The reconciliation will resume once the generation of the DNS Record is changed.</p>"},{"location":"dns-operator/docs/RFC/distributed-dns/dnsrecord-lifecycle/#metrics","title":"Metrics","text":"<p>There is a metric emitted from the controller: <code>dns_provider_write_counter</code>. It reflects the <code>WriteCounter</code> field in the status of the record.</p>"},{"location":"dns-operator/docs/reference/dnsrecord/","title":"The DNSRecord Custom Resource Definition (CRD)","text":"<ul> <li>DNSRecord</li> <li>DNSRecordSpec</li> <li>DNSRecordStatus</li> </ul>"},{"location":"dns-operator/docs/reference/dnsrecord/#dnsrecord","title":"DNSRecord","text":"Field Type Required Description <code>spec</code> DNSRecordSpec Yes The specification for DNSRecord custom resource <code>status</code> DNSRecordStatus No The status for the custom resource"},{"location":"dns-operator/docs/reference/dnsrecord/#dnsrecordspec","title":"DNSRecordSpec","text":"Field Type Required Description <code>ownerID</code> String No Unique string used to identify the owner of this record. If unset an ownerID will be generated based on the record UID <code>rootHost</code> String Yes Single root host of all endpoints in a DNSRecord <code>providerRef</code> ProviderRef Yes Reference to a DNS Provider Secret <code>endpoints</code> []ExternalDNS Endpoint No Endpoints to manage in the dns provider <code>healthCheck</code> HealthCheckSpec No Health check configuration"},{"location":"dns-operator/docs/reference/dnsrecord/#providerref","title":"ProviderRef","text":"Field Type Required Description <code>name</code> String Yes Name of a dns provider secret"},{"location":"dns-operator/docs/reference/dnsrecord/#healthcheckspec","title":"HealthCheckSpec","text":"Field Type Required Description <code>endpoint</code> String Yes Endpoint is the path to append to the host to reach the expected health check <code>port</code> Number Yes Port to connect to the host on <code>protocol</code> String Yes Protocol to use when connecting to the host, valid values are \"HTTP\" or \"HTTPS\" <code>failureThreshold</code> Number Yes FailureThreshold is a limit of consecutive failures that must occur for a host to be considered unhealthy"},{"location":"dns-operator/docs/reference/dnsrecord/#dnsrecordstatus","title":"DNSRecordStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define the status of the resource <code>queuedAt</code> Kubernetes meta/v1.Time QueuedAt is a time when DNS record was received for the reconciliation <code>validFor</code> String ValidFor indicates duration since the last reconciliation we consider data in the record to be valid <code>writeCounter</code> Number WriteCounter represent a number of consecutive write attempts on the same generation of the record <code>endpoints</code> []ExternalDNS Endpoint Endpoints are the last endpoints that were successfully published by the provider <code>healthCheck</code> HealthCheckStatus Health check status <code>ownerID</code> String Unique string used to identify the owner of this record"},{"location":"dns-operator/docs/reference/dnsrecord/#healthcheckstatus","title":"HealthCheckStatus","text":"Field Type Description <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the health checks <code>probes</code> []HealthCheckStatusProbe Health check Probe status"},{"location":"dns-operator/docs/reference/dnsrecord/#healthcheckstatusprobe","title":"HealthCheckStatusProbe","text":"Field Type Description <code>id</code> String The health check id <code>ipAddress</code> String The ip address being monitored <code>host</code> String The host being monitored <code>synced</code> Boolean Synced <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the probe"}]}