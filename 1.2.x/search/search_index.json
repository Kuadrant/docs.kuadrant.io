{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Kuadrant combines Gateway API with gateway providers like Istio and Envoy Gateway to enhance application connectivity. It enables platform engineers and application developers to easily connect, secure, and protect their services and infrastructure across multiple clusters with policies for TLS, DNS, application authentication &amp; authorization, and rate limiting. Additionally, Kuadrant offers observability templates to further support infrastructure management.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>For a quick setup of Kuadrant, see our Getting Started guide. Alternatively, explore the architecture in our Architectural Overview.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide let's you quickly evaluate Kuadrant. You will need a Kubernetes cluster to try out Kuadrant. If you prefer, you can use the following steps to set up a local kind cluster.</p>"},{"location":"getting-started/#kind-cluster-setup","title":"Kind Cluster Setup","text":"<pre><code>kind create cluster\n</code></pre> <p>To use Kuadrant, the <code>LoadBalancer</code> service type is required for Gateways. kind does not have any built-in way to provide IP addresses to these service types. You can follow this guide to set up a LoadBalancer provider for kind.</p>"},{"location":"getting-started/#installation-options","title":"Installation Options","text":"<ul> <li>Install with Helm</li> <li>Install with OLM</li> </ul>"},{"location":"getting-started/#further-reading","title":"Further Reading","text":"<p>The documentation on this site follows the Di\u00e1taxis framework to better serve you, our users. This approach also helps us create new content and maintain existing material effectively. Under this framework, all content falls into one of four categories, accessible from the side navigation:</p> <ul> <li>Concepts - (also called 'Explanations') Deepens and broadens your understanding of Kuadrant.</li> <li>APIs &amp; Reference - Provides concise descriptions of Kuadrant APIs for quick consultation.</li> <li>Tutorials - Offers practical, step-by-step activities for you to safely try out.</li> <li>Guides - Delivers goal-oriented instructions to help you solve specific problems in any environment.</li> </ul>"},{"location":"install-helm/","title":"Install with Helm","text":""},{"location":"install-helm/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with support for services of type <code>LoadBalancer</code></li> <li>kubectl CLI</li> </ul>"},{"location":"install-helm/#basic-installation","title":"Basic Installation","text":"<p>The latest helm installation instructions for the kuadrant operator are maintained at https://artifacthub.io/packages/helm/kuadrant/kuadrant-operator.</p> <p>After installing the operator, you can create a Kuadrant resource to install the operand components.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant\n  namespace: kuadrant-system\nEOF\n</code></pre> <p>If everything went well, the status of the resource should be <code>Ready</code></p> <pre><code>kubectl get kuadrant kuadrant -n kuadrant-system -o=jsonpath='{.status.conditions[?(@.type==\"Ready\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"install-helm/#next-steps","title":"Next Steps","text":"<ul> <li>Try out our Secure, protect, and connect guide</li> </ul>"},{"location":"install-olm/","title":"Install and Configure Kuadrant and Sail via OLM using the kubectl CLI","text":"<p>This document will walk you through setting up the required configuration to install kaudrant using kustomize or a tool that leverages kustomize such as kubectl along with OLM. It will also go through more advanced configuration options to enable building up a resilient configuration. You can view the full configuration built here: Full AWS Example.</p> <ol> <li> <p>Basic Install</p> </li> <li> <p>Configure DNS and TLS integration</p> </li> <li> <p>External Redis for Rate Limit Counters</p> </li> <li> <p>Limitador Resilient Configuration</p> </li> <li> <p>Authorino Resilient Configuration</p> </li> <li> <p>[OpenShift Specific] Setup Observability </p> </li> </ol>"},{"location":"install-olm/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes (or OpenShift) cluster with support for services of type <code>LoadBalancer</code></li> <li>kubectl CLI</li> <li>OLM installed - (operator lifecycle manager releases)</li> <li>Gateway provider installed<ul> <li>If you don't have a Gateway provider installed, steps are included in this guide to install the Sail Operator that will configure and install an Istio installation. Kuadrant is intended to work with Istio or Envoy Gateway.  </li> </ul> </li> <li>(Optional) cert-manager for automated TLS capabilities:<ul> <li>cert-manager Operator for Red Hat OpenShift</li> <li>installing cert-manager via OperatorHub</li> </ul> </li> <li>(Optional) Access to AWS, Azure or GCP with DNS service.</li> <li>(Optional) Access to a Redis instance, for persistent storage for your rate limit counters.</li> </ul> <p>Note: for multiple clusters, it would make sense to do the installation via a tool like argocd. For other methods of addressing multiple clusters take a look at the kubectl docs</p>"},{"location":"install-olm/#basic-installation","title":"Basic Installation","text":"<p>This first step will install just Kuadrant at a given released version (post v1.x) in the <code>kuadrant-system</code> namespace and the Sail Operator. There will be no credentials/dns providers configured (This is the most basic setup but means TLSPolicy and DNSPolicy will not be able to be used). </p> <p>Start by creating the following <code>kustomization.yaml</code> in a directory locally. For the purpose of this doc, we will use: <code>~/kuadrant/</code> directory.</p> <pre><code>export KUADRANT_DIR=~/kuadrant\nmkdir -p $KUADRANT_DIR/install\ntouch $KUADRANT_DIR/install/kustomization.yaml\n</code></pre> <p>Add the below kustomisation CR to the kustomization.yaml created above:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n  # choose the cluster preference that matches your scenario below. Set the version by adding ?ref=v1.0.1. Change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/standard?ref=v1.0.1 \n  # - https://github.com/Kuadrant/kuadrant-operator//config/install/openshift?ref=v1.0.1\n\npatches: # remove this subscription patch if you are installing a development version. It will then use the \"preview\" channel\n\n  - patch: |-\n      apiVersion: operators.coreos.com/v1alpha1\n      kind: Subscription\n      metadata:\n        name: kuadrant\n      spec:\n        source: kuadrant-operator-catalog\n        sourceNamespace: kuadrant-system\n        name: kuadrant-operator\n        channel: 'stable' #set to preview if not using a release (for example if using main)\n</code></pre> <p>And execute the following to apply it to a cluster:</p> <pre><code># change the location depending on where you created the kustomization.yaml\nkubectl apply -k $KUADRANT_DIR/install\n</code></pre>"},{"location":"install-olm/#verify-the-operators-are-installed","title":"Verify the operators are installed:","text":"<p>OLM should begin installing the dependencies for Kuadrant. To wait for them to be ready, run:</p> <pre><code>kubectl -n kuadrant-system wait --timeout=160s --for=condition=Available deployments --all\n</code></pre> <p>Note: you may see <code>no matching resources found</code> if the deployments are not yet present.</p> <p>Once OLM has finished installing the operators (this can take several minutes). You should see the following in the kuadrant-system namespace:</p> <pre><code>kubectl get deployments -n kuadrant-system\n\n## Output\n# NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE\n# authorino-operator                      1/1     1            1           83m\n# dns-operator-controller-manager         1/1     1            1           83m\n# kuadrant-console-plugin                 1/1     1            1           83m\n# kuadrant-operator-controller-manager    1/1     1            1           83m\n# limitador-operator-controller-manager   1/1     1            1           83m\n</code></pre> <p>You can also view the subscription for information about the install:</p> <pre><code>kubectl get subscription -n kuadrant-system -o=yaml\n</code></pre>"},{"location":"install-olm/#install-the-operand-components","title":"Install the operand components","text":"<p>Kuadrant has 2 additional operand components that it manages: <code>Authorino</code> that provides data plane auth integration and <code>Limitador</code> that provides data plane rate limiting. To set these up lets add a new <code>kustomization.yaml</code> in a new sub directory. We will re-use this later for further configuration. We do this as a separate step as we want to have the operators installed first.</p> <p>Add the following to your local directory.  For the purpose of this doc, we will use: <code>$KUADRANT_DIR/configure/kustomization.yaml</code>.</p> <pre><code>mkdir -p $KUADRANT_DIR/configure\ntouch $KUADRANT_DIR/configure/kustomization.yaml\n</code></pre> <p>Add the following to the new kustomization.yaml:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/configure/standard?ref=v1.0.1 #change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n</code></pre> <p>Lets apply this to your cluster:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure\n</code></pre>"},{"location":"install-olm/#verify-kuadrant-is-installed-and-ready","title":"Verify Kuadrant is installed and ready:","text":"<pre><code>kubectl get kuadrant kuadrant -n kuadrant-system -o=jsonpath='{.status.conditions[?(@.type==\"Ready\")].message}{\"\\n\"}'\n</code></pre> <p>You should see the message <code>kuadrant is ready</code>.</p>"},{"location":"install-olm/#verify-istio-is-configured-and-ready","title":"Verify Istio is configured and ready:","text":"<pre><code>kubectl wait istio/default --for=condition=ready=true\n</code></pre> <p>At this point Kuadrant is installed and ready to be used as is Istio as the gateway provider. This means AuthPolicy and RateLimitPolicy can now be configured and used to protect any Gateways you create. </p>"},{"location":"install-olm/#configure-dns-and-tls-integration","title":"Configure DNS and TLS integration","text":"<p>In this section will build on the previous steps and expand the <code>kustomization.yaml</code> we created in <code>$KUADRANT_DIR/configure</code>. </p> <p>In order for cert-manager and the Kuadrant DNS operator to be able to access and manage DNS records and setup TLS certificates and provide external connectivity for your endpoints, you need to setup a credential for these components. To do this, we will use a Kubernetes secret via a kustomize secret generator. You can find other example overlays for each supported cloud provider under the  configure directory.</p> <p>An example lets-encrypt certificate issuer is provided, but for more information on certificate issuers take a look at the cert-manager documentation.</p> <p>Lets modify our existing local kustomize overlay to setup these secrets and the cluster certificate issuer:</p> <p>First you will need to setup the required <code>.env</code> file specified in the kuztomization.yaml file in the same directory as your existing configure kustomization. Below is an example for AWS:</p> <p><pre><code>touch $KUADRANT_DIR/configure/aws-credentials.env\n</code></pre> Add the following to your new file</p> <pre><code>AWS_ACCESS_KEY_ID=xxx\nAWS_SECRET_ACCESS_KEY=xxx\nAWS_REGION=eu-west-1\n</code></pre> <p>With this setup, lets update our configure kustomization to generate the needed secrets. We will also define a TLS ClusterIssuer (see below). The full <code>kustomization.yaml</code> file should look like:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/configure/standard?ref=v1.0.1 #change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n  - cluster-issuer.yaml #(comment if you dont want to use it. The issuer yaml is defined below). Ensure you name the file correctly.\n\n\ngeneratorOptions:\n  disableNameSuffixHash: true\n  labels:\n    app.kubernetes.io/part-of: kuadrant\n    app.kubernetes.io/managed-by: kustomize\n\nsecretGenerator:\n\n  - name: aws-provider-credentials\n    namespace: cert-manager # assumes cert-manager namespace exists.\n    envs:\n      - aws-credentials.env # notice this matches the .env file above. You will need to setup this file locally\n    type: 'kuadrant.io/aws'\n  - name: aws-provider-credentials\n    namespace: gateway-system # this is the namespace where your gateway will be provisioned\n    envs:\n      - aws-credentials.env #notice this matches the .env file above. you need to set up this file locally first. \n    type: 'kuadrant.io/aws'\n</code></pre> <p>Below is an example Lets-Encrypt Cluster Issuer that uses the aws credential we setup above. Create this in the same directory as the configure kustomization.yaml:</p> <pre><code>touch $KUADRANT_DIR/configure/cluster-issuer.yaml\n</code></pre> <p>Add the following to this new file:</p> <pre><code># example lets-encrypt cluster issuer that will work with the credentials we will add\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: lets-encrypt-aws\nspec:\n  acme:\n    privateKeySecretRef:\n      name: le-secret\n    server: https://acme-v02.api.letsencrypt.org/directory\n    solvers:\n\n      - dns01:\n          route53:\n            accessKeyIDSecretRef:\n              key: AWS_ACCESS_KEY_ID\n              name: aws-provider-credentials #notice this matches the name of the secret we created.\n            region: us-east-1 #override if needed\n            secretAccessKeySecretRef:\n              key: AWS_SECRET_ACCESS_KEY\n              name: aws-provider-credentials\n</code></pre> <p>To apply our changes (note this doesn't need to be done in different steps, but is done so here to illustrate how you can build up your configuration of Kuadrant) execute:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure\n</code></pre> <p>The cluster issuer should become ready:</p> <pre><code>kubectl wait clusterissuer/lets-encrypt-aws --for=condition=ready=true\n</code></pre> <p>We create two credentials. One for use with <code>DNSPolicy</code> in the gateway-system namespace and one for use by cert-manager in the <code>cert-manager</code> namespace. With these credentials in place and the cluster issuer configured. You are now ready to start using DNSPolicy and TLSPolicy to secure and connect your Gateways.</p>"},{"location":"install-olm/#use-an-external-redis","title":"Use an External Redis","text":"<p>To connect <code>Limitador</code> (the component responsible for rate limiting requests) to redis so that its counters are stored and can be shared with other limitador instances follow these steps:</p> <p>Again we will build on the kustomization we started. In the same way we did for the cloud provider credentials, we need to setup a <code>redis-credential.env</code> file in the same directory as the kustomization.</p> <pre><code>touch $KUADRANT_DIR/configure/redis-credentials.env\n</code></pre> <p>Add the redis connection string to this file in the following format:</p> <pre><code>URL=redis://xxxx\n</code></pre> <p>Next we need to add a new secret generator to our existing configure file at <code>$KUADRANT_DIR/configure/kustomization.yaml</code> add it below the other <code>secretGenerators</code></p> <pre><code>  - name: redis-credentials\n    namespace: kuadrant-system\n    envs:\n      - redis-credentials.env\n    type: 'kuadrant.io/redis'\n</code></pre> <p>We also need to patch the existing <code>Limitador</code> resource. Add the following to the <code>$KUADRANT_DIR/configure/kustomization.yaml</code></p> <pre><code>patches:\n\n  - patch: |-\n      apiVersion: limitador.kuadrant.io/v1alpha1\n      kind: Limitador\n      metadata:\n        name: limitador\n        namespace: kuadrant-system\n      spec:\n        storage:\n          redis:\n            configSecretRef:\n              name: redis-credentials\n</code></pre> <p>Your full <code>kustomize.yaml</code> will now be:</p> <pre><code>apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nresources:\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/configure/standard?ref=v1.0.1 #change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n  - cluster-issuer.yaml #(comment if you dont want to use it. The issuer yaml is defined below). Ensure you name the file correctly.\n\n\ngeneratorOptions:\n  disableNameSuffixHash: true\n  labels:\n    app.kubernetes.io/part-of: kuadrant\n    app.kubernetes.io/managed-by: kustomize\n\nsecretGenerator:\n\n  - name: aws-provider-credentials\n    namespace: cert-manager # assumes cert-manager namespace exists.\n    envs:\n      - aws-credentials.env # notice this matches the .env file above. You will need to setup this file locally\n    type: 'kuadrant.io/aws'\n  - name: aws-provider-credentials\n    namespace: gateway-system # this is the namespace where your gateway will be provisioned\n    envs:\n      - aws-credentials.env #notice this matches the .env file above. you need to set up this file locally first.\n    type: 'kuadrant.io/aws'\n  - name: redis-credentials\n    namespace: kuadrant-system\n    envs:\n      - redis-credentials.env\n    type: 'kuadrant.io/redis'\n\npatches:\n\n  - patch: |-\n      apiVersion: limitador.kuadrant.io/v1alpha1\n      kind: Limitador\n      metadata:\n        name: limitador\n        namespace: kuadrant-system\n      spec:\n        storage:\n          redis:\n            configSecretRef:\n              name: redis-credentials\n</code></pre> <p>Re-Apply the configuration to setup the new secret and configuration:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure/\n</code></pre> <p>Limitador is now configured to use the provided redis connection URL as a data store for rate limit counters. Limitador will become temporarily unavailable as it restarts.</p>"},{"location":"install-olm/#validate","title":"Validate","text":"<p>Validate Kuadrant is in a ready state as before:</p> <pre><code>kubectl get kuadrant kuadrant -n kuadrant-system -o=wide\n\n# NAME       STATUS   AGE\n# kuadrant   Ready    61m\n</code></pre>"},{"location":"install-olm/#resilient-deployment-of-data-plane-components","title":"Resilient Deployment of data plane components","text":""},{"location":"install-olm/#limitador-topologyconstraints-poddisruptionbudget-and-resource-limits","title":"Limitador: TopologyConstraints, PodDisruptionBudget and Resource Limits","text":"<p>To set limits, replicas and a <code>PodDisruptionBudget</code> for limitador you can add the following to the existing limitador patch in your local <code>limitador</code> in the <code>$KUADRANT_DIR/configure/kustomize.yaml</code> spec:</p> <pre><code>pdb:\n  maxUnavailable: 1\nreplicas: 2\nresourceRequirements:\n    requests:\n      cpu: 10m\n      memory: 10Mi # set these based on your own needs.\n</code></pre> <p>re-apply the configuration. This will result in two instances of limitador becoming available and a <code>podDisruptionBudget</code> being setup:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure/\n</code></pre> <p>For topology constraints, you will need to patch the limitador deployment directly:</p> <p>add the below <code>yaml</code> to a <code>limitador-topoloy-patch.yaml</code> file under a <code>$KUADRANT_DIR/configure/patches</code> directory:</p> <pre><code>mkdir -p $KUADRANT_DIR/configure/patches\ntouch $KUADRANT_DIR/configure/patches/limitador-topoloy-patch.yaml\n</code></pre> <pre><code>spec:\n  template:\n    spec:\n      topologySpreadConstraints:\n\n        - maxSkew: 1\n          topologyKey: kubernetes.io/hostname\n          whenUnsatisfiable: ScheduleAnyway\n          labelSelector:\n            matchLabels:\n              limitador-resource: limitador\n        - maxSkew: 1\n          topologyKey: kubernetes.io/zone\n          whenUnsatisfiable: ScheduleAnyway\n          labelSelector:\n            matchLabels:\n              limitador-resource: limitador\n</code></pre> <p>Apply this to the existing limitador deployment</p> <pre><code>kubectl patch deployment limitador-limitador -n kuadrant-system --patch-file $KUADRANT_DIR/configure/patches/limitador-topoloy-patch.yaml\n</code></pre>"},{"location":"install-olm/#authorino-topologyconstraints-poddisruptionbudget-and-resource-limits","title":"Authorino: TopologyConstraints, PodDisruptionBudget and Resource Limits","text":"<p>To increase the number of replicas for Authorino add a new patch to the <code>$KUADRANT_DIR/configure/kustomization.yaml</code></p> <pre><code>  - patch: |-\n      apiVersion: operator.authorino.kuadrant.io/v1beta1\n      kind: Authorino\n      metadata:\n        name: authorino\n        namespace: kuadrant-system\n      spec:\n        replicas: 2\n</code></pre> <p>and re-apply the configuration:</p> <pre><code>kubectl apply -k $KUADRANT_DIR/configure/\n</code></pre> <p>To add resource limits and or topology constraints to Authorino. You will need to patch the Authorino deployment directly: Add the below <code>yaml</code> to a <code>authorino-topoloy-patch.yaml</code> under the <code>$KUADRANT_DIR/configure/patches</code> directory:</p> <pre><code>touch $KUADRANT_DIR/configure/patches/authorino-topoloy-patch.yaml\n</code></pre> <pre><code>spec:\n  template:\n    spec:\n      containers:\n\n        - name: authorino\n          resources:\n            requests:\n              cpu: 10m # set your own needed limits here\n              memory: 10Mi # set your own needed limits here\n      topologySpreadConstraints:\n        - maxSkew: 1\n          topologyKey: kubernetes.io/hostname\n          whenUnsatisfiable: ScheduleAnyway\n          labelSelector:\n            matchLabels:\n              authorino-resource: authorino\n        - maxSkew: 1\n          topologyKey: kubernetes.io/zone\n          whenUnsatisfiable: ScheduleAnyway\n          labelSelector:\n            matchLabels:\n              authorino-resource: authorino\n</code></pre> <p>Apply the patch:</p> <pre><code>kubectl patch deployment authorino -n kuadrant-system --patch-file $KUADRANT_DIR/configure/patches/authorino-topoloy-patch.yaml\n</code></pre> <p>Kuadrant is now installed and ready to use and the data plane components are configured to be distributed and resilient.</p> <p>For reference the full configure kustomization should look like: <pre><code>kind: Kustomization\nresources:\n\n  - https://github.com/Kuadrant/kuadrant-operator//config/install/configure/standard?ref=v1.0.1 #change this version as needed (see https://github.com/Kuadrant/kuadrant-operator/releases)\n  - cluster-issuer.yaml\ngeneratorOptions:\n  disableNameSuffixHash: true\n  labels:\n    app.kubernetes.io/part-of: kuadrant\n    app.kubernetes.io/managed-by: kustomize\n\nsecretGenerator:\n\n  - name: aws-provider-credentials\n    namespace: cert-manager # assumes cert-manager namespace exists.\n    envs:\n      - aws-credentials.env # notice this matches the .env file above. You will need to setup this file locally\n    type: 'kuadrant.io/aws'\n  - name: aws-provider-credentials\n    namespace: gateway-system # this is the namespace where your gateway will be provisioned\n    envs:\n      - aws-credentials.env #notice this matches the .env file above. you need to set up this file locally first.\n    type: 'kuadrant.io/aws'\n  - name: redis-credentials\n    namespace: kuadrant-system\n    envs:\n      - redis-credentials.env\n    type: 'kuadrant.io/redis'\n\npatches:\n\n  - patch: |-\n      apiVersion: limitador.kuadrant.io/v1alpha1\n      kind: Limitador\n      metadata:\n        name: limitador\n        namespace: kuadrant-system\n      spec:\n        pdb:\n          maxUnavailable: 1\n        replicas: 2\n        resourceRequirements:\n          requests:\n            cpu: 10m\n            memory: 10Mi # set these based on your own needs.\n        storage:\n          redis:\n            configSecretRef:\n              name: redis-credentials\n  - patch: |-\n      apiVersion: operator.authorino.kuadrant.io/v1beta1\n      kind: Authorino\n      metadata:\n        name: authorino\n        namespace: kuadrant-system\n      spec:\n        replicas: 2\n</code></pre> The configure directory should contain the following:</p> <pre><code>configure/\n\u251c\u2500\u2500 aws-credentials.env\n\u251c\u2500\u2500 cluster-issuer.yaml\n\u251c\u2500\u2500 kustomization.yaml\n\u251c\u2500\u2500 patches\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 authorino-topoloy-patch.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 limitador-topoloy-patch.yaml\n\u2514\u2500\u2500 redis-credentials.env\n</code></pre>"},{"location":"install-olm/#set-up-observability-openshift-only","title":"Set up observability (OpenShift Only)","text":"<p>Verify that user workload monitoring is enabled in your Openshift cluster. If it not enabled, check the Openshift documentation for how to do this.</p> <pre><code>kubectl get configmap cluster-monitoring-config -n openshift-monitoring -o jsonpath='{.data.config\\.yaml}'|grep enableUserWorkload\n# (expected output)\n# enableUserWorkload: true\n</code></pre> <p>Install the gateway &amp; Kuadrant metrics components and configuration, including Grafana.</p> <pre><code># change the version as needed\nkubectl apply -k https://github.com/Kuadrant/kuadrant-operator//config/install/configure/observability?ref=v1.0.1\n</code></pre> <p>Configure the Openshift thanos-query instance as a data source in Grafana.</p> <pre><code>TOKEN=\"Bearer $(oc whoami -t)\"\nHOST=\"$(kubectl -n openshift-monitoring get route thanos-querier -o jsonpath='https://{.status.ingress[].host}')\"\necho \"TOKEN=$TOKEN\" &gt; config/observability/openshift/grafana/datasource.env\necho \"HOST=$HOST\" &gt;&gt; config/observability/openshift/grafana/datasource.env\nkubectl apply -k config/observability/openshift/grafana\n</code></pre> <p>Create the example dashboards in Grafana</p> <pre><code>kubectl apply -k https://github.com/Kuadrant/kuadrant-operator/examples/dashboards?ref=v1.0.1\n</code></pre> <p>Access the Grafana UI, using the default user/pass of root/secret. You should see the example dashboards in the 'monitoring' folder. For more information on the example dashboards, check out the documentation.</p> <pre><code>kubectl -n monitoring get routes grafana-route -o jsonpath=\"https://{.status.ingress[].host}\"\n</code></pre>"},{"location":"install-olm/#next-steps","title":"Next Steps","text":"<ul> <li>Try out our Secure, protect, and connect guide</li> </ul>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/","title":"Configure mTLS between the Gateway and Kuadrant components","text":""},{"location":"kuadrant-operator/doc/install/mtls-configuration/#overview","title":"Overview","text":"<p>This guide includes manual steps to enable mTLS between an Istio provided gateway and the Kuadrant components. If you use an AuthPolicy or RateLimitPolicy, there will be communication between the gateway and the respective Kuadrant components at request time. This communication happens between the Wasm plugin in Envoy proxy, and Authorino or Limitador. At the time of writing there is an RFC discussing how to add mTLS capabilities as a feature of the Kuadrant operator. If you are interested in having that feature or influencing how it is delivered, please engage on that pull request.</p> <p>Note</p> <p>This method currently only works if the Gateway is provided by Istio, with service mesh capabilities enabled across the cluster. For example, the Istio CNI agent is running on each node.</p>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have installed Kuadrant in a Kubernetes cluster.</li> <li>Additionally, you have at least 1 AuthPolicy or RateLimitPolicy attached to your Gateway or HTTPRoute.</li> </ul>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#enabling-mtls","title":"Enabling mTLS","text":""},{"location":"kuadrant-operator/doc/install/mtls-configuration/#kuadrant-components","title":"Kuadrant components","text":"<p>As the Kuadrant components (Authorino &amp; Limitador) are already part of the service mesh in Istio, mTLS can be enabled after an Envoy proxy sidecar is deployed alongside them. To do this, apply the Istio sidecar label to both Deployment templates.</p> <pre><code>kubectl -n kuadrant-system patch deployment authorino \\\n  -p '{\"spec\":{\"template\":{\"metadata\":{\"labels\":{\"sidecar.istio.io/inject\":\"true\"}}}}}'\n\nkubectl -n kuadrant-system patch deployment limitador-limitador \\\n  -p '{\"spec\":{\"template\":{\"metadata\":{\"labels\":{\"sidecar.istio.io/inject\":\"true\"}}}}}'\n</code></pre> <p>You should see the number of containers in either pod increase from 1 to 2, as the <code>istio-proxy</code> is added to the pods. This change will force all traffic to those pods to go through the proxy. However, mTLS is not enabled yet.</p>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#envoy-filter","title":"Envoy Filter","text":"<p>The next step enables mTLS for traffic originating in the gateway (where the Wasm plugin executes), going to the Kuadrant components. This requires modifying the EnvoyFilters directly.</p> <p>Note</p> <p>Any changes to the EnvoyFilters may be reverted by the Kuadrant operator when related resources like Gateways, HTTPRoutes or policies are modified. It is recommended to automate the next step, for example via a job or GitOps controller, to ensure the changes persist.</p> <p>The EnvoyFilter resources will typically have a name prefix of <code>kuadrant-</code> in the same namespace as your Gateway. Add the snippet below to the <code>spec.configPatches[].patch.value</code> value in each EnvoyFilter.</p> <pre><code>        transport_socket:\n          name: envoy.transport_sockets.tls\n          typed_config:\n            '@type': type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n            common_tls_context:\n              tls_certificate_sds_secret_configs:\n\n              - name: default\n                sds_config:\n                  api_config_source:\n                    api_type: GRPC\n                    grpc_services:\n                    - envoy_grpc:\n                        cluster_name: sds-grpc\n              validation_context_sds_secret_config:\n                name: ROOTCA\n                sds_config:\n                  api_config_source:\n                    api_type: GRPC\n                    grpc_services:\n                    - envoy_grpc:\n                        cluster_name: sds-grpc\n</code></pre> <p>The <code>envoy.transport_sockets.tls</code> transport socket name tells Envoy to use the built-in TLS transport socket, enabling TLS encryption. The <code>@type</code> specifies that the configuration follows the <code>UpstreamTlsContext</code> message from Envoy's TLS transport socket extension. This is used for client-side TLS settings. The <code>tls_certificate_sds_secret_configs</code> configures Envoy to obtain client certificates and private keys via the Secret Discovery Service (SDS) over GRPC. The <code>validation_context_sds_secret_config</code> configures Envoy to obtain the root CA certificates via SDS (over GRPC) to validate the server's certificate.</p>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#istio-configuration","title":"Istio configuration","text":"<p>The last step is to ensure Authorino and Limitador are configured to require and accept mTLS connections. In Istio, this is done by creating a PeerAuthentication resource where the <code>mtls</code> mode is set to <code>STRICT</code>. The below command will enable STRICT mode on all pods with Istio sidecar injection in the <code>kuadrant-system</code> namespace.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: security.istio.io/v1\nkind: PeerAuthentication\nmetadata:\n  name: default\n  namespace: kuadrant-system\nspec:\n  mtls:\n    mode: STRICT\nEOF\n</code></pre> <p>If you prefer to only enable mTLS for a specific component, you can modify just the EnvoyFilter and Deployment for that component. Then, when creating the <code>PeerAuthentication</code> resource, you can be more specific about what pods the mTLS mode apply to. For example, the following resource would enable STRICT mode just for the Limitador component.</p> <pre><code>apiVersion: security.istio.io/v1\nkind: PeerAuthentication\nmetadata:\n  name: limitador-mtls\n  namespace: kuadrant-system\nspec:\n  selector:\n    matchLabels:\n      app: limitador\n  mtls:\n    mode: STRICT\n</code></pre>"},{"location":"kuadrant-operator/doc/install/mtls-configuration/#disabling-mtls","title":"Disabling mTLS","text":"<p>To disable mTLS, remove the <code>transport_socket</code> changes from any EnvoyFilters. Then you can either set the mTLS mode to PERMISSIVE in the <code>PeerAuthentication</code> resource:</p> <pre><code>kubectl patch peerauthentication default -n kuadrant-system --type='merge' -p '{\"spec\":{\"mtls\":{\"mode\":\"PERMISSIVE\"}}}'\n</code></pre> <p>Or delete the resource:</p> <pre><code>kubectl delete peerauthentication -n kuadrant-system default\n</code></pre> <p>You don't have to remove the sidecar from the Kuadrant components, but it is safe to do so by removing the <code>sidecar.istio.io/inject</code> label:</p> <pre><code>kubectl -n kuadrant-system patch deployment authorino \\\n  --type='json' \\\n  -p='[{\"op\": \"remove\", \"path\": \"/spec/template/metadata/labels/sidecar.istio.io~1inject\"}]'\n\nkubectl -n kuadrant-system patch deployment limitador-limitador \\\n  --type='json' \\\n  -p='[{\"op\": \"remove\", \"path\": \"/spec/template/metadata/labels/sidecar.istio.io~1inject\"}]'\n</code></pre> <p>Or set the value to <code>false</code>:</p> <pre><code>kubectl -n kuadrant-system patch deployment authorino \\\n  -p '{\"spec\":{\"template\":{\"metadata\":{\"labels\":{\"sidecar.istio.io/inject\":\"false\"}}}}}'\n\n\nkubectl -n kuadrant-system patch deployment limitador-limitador \\\n  -p '{\"spec\":{\"template\":{\"metadata\":{\"labels\":{\"sidecar.istio.io/inject\":\"false\"}}}}}'\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/examples/","title":"Example Dashboards and Alerts","text":"<p>Explore a variety of starting points for monitoring your Kuadrant installation with our examples folder. These dashboards and alerts are ready-to-use and easily customizable to fit your environment.</p> <p>There are some example dashboards uploaded to Grafana.com . You can use the ID's listed below to import these dashboards into Grafana:</p> Name ID App Developer Dashboard <code>21538</code> Business User Dashboard <code>20981</code> Platform Engineer Dashboard <code>20982</code> DNS Operator Dashboard <code>22695</code>"},{"location":"kuadrant-operator/doc/observability/examples/#dashboards","title":"Dashboards","text":""},{"location":"kuadrant-operator/doc/observability/examples/#importing-dashboards-into-grafana","title":"Importing Dashboards into Grafana","text":"<p>For more details on how to import dashboards into Grafana, visit the import dashboards page. </p> <ul> <li>UI Method:<ul> <li>JSON -  Use the 'Import' feature in the Grafana UI to upload dashboard JSON files directly.</li> <li>ID - Use the 'Import' feature in the Grafana UI to import via Grafana.com using a Dashboard ID. </li> </ul> </li> <li>ConfigMap Method: Automate dashboard provisioning by adding files to a ConfigMap, which should be mounted at <code>/etc/grafana/provisioning/dashboards</code>.</li> </ul> <p>Datasources are configured as template variables, automatically integrating with your existing data sources. Metrics for these dashboards are sourced from Prometheus. For more details on the metrics used, visit the metrics documentation page.</p>"},{"location":"kuadrant-operator/doc/observability/examples/#alerts","title":"Alerts","text":""},{"location":"kuadrant-operator/doc/observability/examples/#setting-up-alerts-in-prometheus","title":"Setting Up Alerts in Prometheus","text":"<p>You can integrate the example alerts into Prometheus as <code>PrometheusRule</code> resources. Feel free to adjust alert thresholds to suit your specific operational needs.</p> <p>Additionally, Service Level Objective (SLO) alerts generated with Sloth are included. A benefit of these alerts is the ability to integrate them with this SLO dashboard, which utilizes generated labels to comprehensively overview your SLOs.</p> <p>Further information on the metrics used for these alerts can be found on the metrics page.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/","title":"Metrics","text":"<p>This is a reference page for some of the different metrics used in example dashboards and alerts. It is not an exhaustive list. The documentation for each component may provide more details on a per-component basis. Some of the metrics are sourced from components outside the Kuadrant project, for example, Envoy. The value of this reference is showing some of the more widely desired metrics, and how to join the metrics from different sources together in a meaningful way.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#metrics-sources","title":"Metrics sources","text":"<ul> <li>Kuadrant components</li> <li>Istio</li> <li>Envoy</li> <li>Kube State Metrics</li> <li>Gateway API State Metrics</li> <li>Kubernetes metrics</li> </ul>"},{"location":"kuadrant-operator/doc/observability/metrics/#resource-usage-metrics","title":"Resource usage metrics","text":"<p>Resource metrics, like CPU, memory and disk usage, primarily come from the Kubernetes metrics components. These include <code>container_cpu_usage_seconds_total</code>, <code>container_memory_working_set_bytes</code> and <code>kubelet_volume_stats_used_bytes</code>. A stable list of metrics is maintained in the Kubernetes repository. These low-level metrics typically have a set of recording rules that aggregate values by labels and time ranges. For example, <code>node_namespace_pod_container:container_cpu_usage_seconds_total:sum_irate</code> or <code>namespace_workload_pod:kube_pod_owner:relabel</code>. If you have deployed the kube-prometheus project, you should have the majority of  these metrics being scraped.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#networking-metrics","title":"Networking metrics","text":"<p>Low-level networking metrics like <code>container_network_receive_bytes_total</code> are also available from the Kubernetes metrics components. HTTP &amp; GRPC traffic metrics with higher level labels are available from Istio. One of the main metrics would be <code>istio_requests_total</code>, which is a counter incremented for every request handled by an Istio proxy. Latency metrics are available via the <code>istio_request_duration_milliseconds</code> metric, with buckets for varying response times.</p> <p>Some example dashboards have panels that make use of the request URL path. The path is not added as a label to Istio metrics by default, as it has the potential to increase metric cardinality, and thus storage requirements. If you want to make use of the path in your queries or visualisations, you can enable the request path metric via the Telemetry resource in istio:</p> <pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: namespace-metrics\n  namespace: gateway-system\nspec:\n  metrics:\n\n  - providers:\n    - name: prometheus\n    overrides:\n    - match:\n        metric: REQUEST_COUNT\n      tagOverrides:\n        request_url_path:\n          value: \"request.url_path\"\n    - match:      \n        metric: REQUEST_DURATION\n      tagOverrides:\n        request_url_path:\n          value: \"request.url_path\"\n</code></pre>"},{"location":"kuadrant-operator/doc/observability/metrics/#state-metrics","title":"State metrics","text":"<p>The kube-state-metrics project exposes the state of various kuberenetes resources as metrics and labels. For example, the ready <code>status</code> of a <code>Pod</code> is available as <code>kube_pod_status_ready</code>, with labels for the pod <code>name</code> and <code>namespace</code>. This can be useful for linking lower level container metrics back to a meaningful resource in the Kubernetes world.</p>"},{"location":"kuadrant-operator/doc/observability/metrics/#joining-metrics","title":"Joining metrics","text":"<p>Metric queries can be as simple as just the name of the metric, or can be complex with joining &amp; grouping. A lot of the time it can be useful to tie back low level metrics to more meaningful Kubernetes resources. For example, if the memory usage is maxed out on a container and that container is constantly being OOMKilled, it can be useful to get the Deployment and Namespace of that container for debugging. Prometheus query language (or promql) allows vector matching or results (sometimes called joining).</p> <p>When using Gateway API and Kuadrant resources like HTTPRoute and RateLimitPolicy, the state metrics can be joined to Istio metrics to give a meaningful result set. Here's an example that queries the number of requests per second, and includes the name of the HTTPRoute that the traffic is for.</p> <pre><code>sum(\n    rate(\n        istio_requests_total{}[5m]\n    )\n) by (destination_service_name)\n\n\n* on(destination_service_name) group_right \n    label_replace(gatewayapi_httproute_labels{}, \\\"destination_service_name\\\", \\\"$1\\\",\\\"service\\\", \\\"(.+)\\\")\n</code></pre> <p>Breaking this query down, there are 2 parts. The first part is getting the rate of requests hitting the Istio gateway, aggregated to 5m intervals:</p> <pre><code>sum(\n    rate(\n        destination_service_name{}[5m]\n    )\n) by (destination_service_name)\n</code></pre> <p>The result set here will include a label for the destination service name (i.e. the Service in Kubernetes). This label is key to looking up the HTTPRoute this traffic belongs to.</p> <p>The 2nd part of the query uses the <code>gatewayapi_httproute_labels</code> metric and the <code>label_replace</code> function. The <code>gatewayapi_httproute_labels</code> metric gives a list of all httproutes, including any labels on them. The HTTPRoute in this example has a label called 'service', set to be the same as the Istio service name. This allows us to join the 2 results set. However, because the label doesn't match exactly (<code>destination_service_name</code> and <code>service</code>), we can replace the label so that it does match. That's what the <code>label_replace</code> does.</p> <pre><code>    label_replace(gatewayapi_httproute_labels{}, \\\"destination_service_name\\\", \\\"$1\\\",\\\"service\\\", \\\"(.+)\\\")\n</code></pre> <p>The 2 parts are joined together using vector matching.</p> <pre><code>* on(destination_service_name) group_right \n</code></pre> <ul> <li><code>*</code> is the binary operator i.e. multiplication (gives join like behaviour)</li> <li><code>on()</code> specifies which labels to \"join\" the 2 results with</li> <li><code>group_right</code> enables a one to many matching.</li> </ul> <p>See the Prometheus documentation for further details on matching.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/","title":"Enabling tracing with a central collector","text":""},{"location":"kuadrant-operator/doc/observability/tracing/#introduction","title":"Introduction","text":"<p>This guide outlines the steps to enable tracing in Istio and Kuadrant components (Authorino and Limitador), directing traces to a central collector for improved observability and troubleshooting. We'll also explore a typical troubleshooting flow using traces and logs.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kubernetes cluster with Istio and Kuadrant installed.</li> <li>A trace collector (e.g., Jaeger or Tempo) configured to support OpenTelemetry (OTel).</li> </ul>"},{"location":"kuadrant-operator/doc/observability/tracing/#configuration-steps","title":"Configuration Steps","text":""},{"location":"kuadrant-operator/doc/observability/tracing/#istio-tracing-configuration","title":"Istio Tracing Configuration","text":"<p>Enable tracing in Istio by using the Telemetry API. Depending on your method for installing Istio, you will need to configure a tracing <code>extensionProvider</code> in your MeshConfig, Istio or IstioOperator resource as well. Here is an example Telemetry and Istio config to sample 100% of requests, if using the Istio Sail Operator.</p> <pre><code>apiVersion: telemetry.istio.io/v1alpha1\nkind: Telemetry\nmetadata:\n  name: mesh-default\n  namespace: gateway-system\nspec:\n  tracing:\n\n  - providers:\n    - name: tempo-otlp\n    randomSamplingPercentage: 100\n---\napiVersion: operator.istio.io/v1alpha1\nkind: Istio\nmetadata:\n  name: default\nspec:\n  namespace: gateway-system\n  values:\n    meshConfig:\n      defaultConfig:\n        tracing: {}\n      enableTracing: true\n      extensionProviders:\n      - name: tempo-otlp\n        opentelemetry:\n          port: 4317\n          service: tempo.tempo.svc.cluster.local\n</code></pre> <p>Important:</p> <p>The OpenTelemetry collector protocol should be explicitly set in the service port <code>name</code> or <code>appProtocol</code> fields as per the Istio documentation. For example, when using gRPC, the port <code>name</code> should begin with <code>grpc-</code> or the <code>appProtocol</code> should be <code>grpc</code>.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#kuadrant-tracing-configuration","title":"Kuadrant Tracing Configuration","text":"<p>The Authorino and Limitador components have request tracing capabilities. Here is an example configuration to enable and send traces to a central collector. Ensure the collector is the same one that Istio is sending traces so that they can be correlated later.</p> <pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  tracing:\n    endpoint: rpc://tempo.tempo.svc.cluster.local:4317\n    insecure: true\n---\napiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador\nspec:\n  tracing:\n    endpoint: rpc://tempo.tempo.svc.cluster.local:4317\n</code></pre> <p>Once the changes are applied, the authorino and limitador components will be redeployed tracing enabled.</p> <p>Note:</p> <p>There are plans to consolidate the tracing configuration to a single location i.e. the Kuadrant CR. This will eventually eliminate the need to configure tracing in both the Authorino and Limitador CRs.</p> <p>Important:</p> <p>Currently, trace IDs do not propagate to wasm modules in Istio/Envoy, affecting trace continuity in Limitador. This means that requests passed to limitador will not have the relavant 'parent' trace ID in its trace information. If however the trace initiation point is outside of Envoy/Istio, the 'parent' trace ID will be available to limitador and included in traces passed to the collector. This has an impact on correlating traces from limitador with traces from authorino, the gateway and any other components in the path of requests.</p>"},{"location":"kuadrant-operator/doc/observability/tracing/#troubleshooting-flow-using-traces-and-logs","title":"Troubleshooting Flow Using Traces and Logs","text":"<p>Using a tracing interface like the Jaeger UI or Grafana, you can search for trace information by the trace ID. You may get the trace ID from logs, or from a header in a sample request you want to troubleshoot. You can also search for recent traces, filtering by the service you want to focus on.</p> <p>Here is an example trace in the Grafana UI showing the total request time from the gateway (Istio), the time to check the curent rate limit count (and update it) in limitador and the time to check auth in Authorino:</p> <p></p> <p>In limitador, it is possible to enable request logging with trace IDs to get more information on requests. This requires the log level to be increased to at least debug, so the verbosity must be set to 3 or higher in the Limitador CR. For example:</p> <pre><code>apiVersion: limitador.kuadrant.io/v1alpha1\nkind: Limitador\nmetadata:\n  name: limitador\nspec:\n  verbosity: 3\n</code></pre> <p>A log entry will look something like this, with the <code>traceparent</code> field holding the trace ID:</p> <pre><code>\"Request received: Request { metadata: MetadataMap { headers: {\"te\": \"trailers\", \"grpc-timeout\": \"5000m\", \"content-type\": \"application/grpc\", \"traceparent\": \"00-4a2a933a23df267aed612f4694b32141-00f067aa0ba902b7-01\", \"x-envoy-internal\": \"true\", \"x-envoy-expected-rq-timeout-ms\": \"5000\"} }, message: RateLimitRequest { domain: \"default/toystore\", descriptors: [RateLimitDescriptor { entries: [Entry { key: \"limit.general_user__f5646550\", value: \"1\" }, Entry { key: \"metadata.filter_metadata.envoy\\\\.filters\\\\.http\\\\.ext_authz.identity.userid\", value: \"alice\" }], limit: None }], hits_addend: 1 }, extensions: Extensions }\"\n</code></pre> <p>If you centrally aggregate logs using something like promtail and loki, you can jump between trace information and the relevant logs for that service:</p> <p></p> <p>Using a combination of tracing and logs, you can visualise and troubleshoot reuqest timing issues and drill down to specific services. This method becomes even more powerful when combined with metrics and dashboards to get a more complete picture of your users traffic.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/","title":"Kuadrant Auth","text":"<p>A Kuadrant AuthPolicy custom resource:</p> <ol> <li>Targets Gateway API networking resources HTTPRoute and Gateway, using these to obtain the auth context, i.e., on which traffic workload (HTTP attributes, hostnames, user attributes, etc) to enforce auth.</li> <li>Supports targeting subsets (sections) of a network resource to apply the auth rules to, i.e. specific listeners of a Gateway or HTTP route rules of an HTTPRoute.</li> <li>Abstracts the details of the underlying external authorization protocol and configuration resources, that have a much broader remit and surface area.</li> <li>Enables platform engineers to set defaults that govern behavior at the lower levels of the network, until a more specific policy is applied.</li> <li>Enables platform engineers to set overrides over policies and/or individual policy rules specified at the lower levels of the network.</li> </ol>"},{"location":"kuadrant-operator/doc/overviews/auth/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#integration","title":"Integration","text":"<p>Kuadrant integrates an External Authorization service (\"Authorino\") that is triggered on matching HTTP contexts.</p> <p>The workflow per request goes:</p> <ol> <li>On incoming request, the gateway checks the matching rules for enforcing the auth rules, as stated in the AuthPolicy custom resources and targeted Gateway API networking objects</li> <li>If the request matches, the gateway sends a CheckRequest to Authorino.</li> <li>The external auth service responds with a CheckResponse back to the gateway with either an <code>OK</code> or <code>DENIED</code> response code.</li> </ol> <p>An AuthPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external auth service.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#the-authpolicy-custom-resource","title":"The AuthPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#overview","title":"Overview","text":"<p>The <code>AuthPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>Authentication/authorization scheme (<code>spec.rules</code>)</li> <li>Top-level additional conditions (<code>spec.when</code>)</li> <li>List of named patterns (<code>spec.patterns</code>)</li> </ul> <p>The auth scheme specify rules for:</p> <ul> <li>Authentication (<code>spec.rules.authentication</code>)</li> <li>External auth metadata fetching (<code>spec.rules.metadata</code>)</li> <li>Authorization (<code>spec.rules.authorization</code>)</li> <li>Custom response items (<code>spec.rules.response</code>)</li> <li>Callbacks (<code>spec.rules.callbacks</code>)</li> </ul> <p>Each auth rule can declare specific <code>when</code> conditions for the rule to apply.</p> <p>The auth scheme (<code>rules</code>), as well as conditions and named patterns can be declared at the top-level level of the spec (with the semantics of defaults) or alternatively within explicit <code>defaults</code> or <code>overrides</code> blocks.</p> <p>Check out the API reference for a full specification of the AuthPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#using-the-authpolicy","title":"Using the AuthPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/auth/#targeting-a-httproute-networking-resource","title":"Targeting a HTTPRoute networking resource","text":"<p>When targeting a HTTPRoute, an AuthPolicy can be enforced on:</p> <ul> <li>all traffic routed by any rule specified in the HTTPRoute; or</li> <li>only traffic routed by a specific set of rules as stated in a selected HTTPRouteRule of the HTTPRoute, by specifying the <code>sectionName</code> field in the target reference (<code>spec.targetRef</code>) of the policy.</li> </ul> <p>Either way, the policy applies across all hostnames (<code>spec.hostnames</code>) and Gateways (<code>spec.parentRefs</code>) referenced in the HTTPRoute, provided the route is properly attached to the corresponding Gateway listeners.</p> <p>Additional filters for applying the policy can be set by specifying top-level conditions in the policy (<code>spec.rules.when</code>).</p> <p>Example 1 - Targeting an entire HTTPRoute</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: my-route\n  rules: { \u2026 }\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (Gateway namespace) \u2502            \u2502   (App namespace)   \u2502\n\u2502                     \u2502            \u2502                     \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502 parentRefs \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502    \u2502 Gateway \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 HTTPRoute  \u2502     \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502            \u2502  | (my-route) \u2502     |\n\u2502                     \u2502            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                     \u2502            \u2502        \u25b2            \u2502\n\u2502                     \u2502            \u2502        \u2502            \u2502\n\u2502                     \u2502            \u2502        \u2502 targetRef  \u2502\n\u2502                     \u2502            \u2502        \u2502            \u2502\n\u2502                     \u2502            \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502                     \u2502            \u2502  \u2502 AuthPolicy \u2502     \u2502\n\u2502                     \u2502            \u2502  \u2502 (my-auth)  \u2502     \u2502\n\u2502                     \u2502            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Example 2 - Targeting a specific set of rules of a HTTPRoute</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-route-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: my-route\n    sectionName: rule-2\n  rules: { \u2026 }\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (Gateway namespace) \u2502            \u2502    (App namespace)   \u2502\n\u2502                     \u2502            \u2502                      \u2502\n\u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502 parentRefs \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502    \u2502 Gateway \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 HTTPRoute  \u2502      \u2502\n\u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502            \u2502  | (my-route) \u2502      |\n\u2502                     \u2502            \u2502  |------------\u2502      |\n\u2502                     \u2502            \u2502  | - rule-1   \u2502      |\n\u2502                     \u2502            \u2502  | - rule-2   \u2502      |\n\u2502                     \u2502            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n\u2502                     \u2502            \u2502        \u25b2             \u2502\n\u2502                     \u2502            \u2502        \u2502             \u2502\n\u2502                     \u2502            \u2502        \u2502 targetRef   \u2502\n\u2502                     \u2502            \u2502        \u2502             \u2502\n\u2502                     \u2502            \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502                     \u2502            \u2502  \u2502   AuthPolicy    \u2502 \u2502\n\u2502                     \u2502            \u2502  \u2502 (my-route-auth) \u2502 \u2502\n\u2502                     \u2502            \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/auth/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>An AuthPolicy that targets a Gateway, without overrides, will be enforced to all HTTP traffic hitting the gateway, unless a more specific AuthPolicy targeting a matching HTTPRoute exists. Any new HTTPRoute referrencing the gateway as parent will be automatically covered by the gateway-targeting AuthPolicy, as well as changes in the existing HTTPRoutes.</p> <p>Target a Gateway HTTPRoute by setting the <code>spec.targetRef</code> field of the AuthPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-gw-auth\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: my-gw\n  defaults: # alternatively: `overrides`\n    rules: { \u2026 }\n</code></pre> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (Infra namespace) \u2502             \u2502    (App namespace)   \u2502\n\u2502                   \u2502             \u2502                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502  parentRefs \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502\n\u2502  \u2502 Gateway \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2524 HTTPRoute \u2502       \u2502\n\u2502  | (my-gw) |      \u2502             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502             \u2502        \u25b2             \u2502\n\u2502       \u25b2           \u2502             \u2502        |             \u2502\n\u2502       \u2502           \u2502             \u2502        \u2502             \u2502\n\u2502       \u2502 targetRef \u2502             \u2502        \u2502 targetRef   \u2502\n\u2502       \u2502           \u2502             \u2502        \u2502             \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502             \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502 \u2502  AuthPolicy  \u2502  \u2502             \u2502  \u2502   AuthPolicy    \u2502 \u2502\n\u2502 | (my-gw-auth) |  \u2502             \u2502  \u2502 (my-route-auth) \u2502 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502             \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/auth/#defaults-and-overrides","title":"Defaults and Overrides","text":"<p>Kuadrant AuthPolicies support Defaults &amp; Overrides essentially as specified in Gateway API GEP-2649.</p> <p>An AuthPolicy can declare a block of defaults (<code>spec.defaults</code>) or a block of overrides (<code>spec.overrides</code>). By default, policies that do not specify neither <code>defaults</code> nor <code>overrides</code>, act implicitly as if specifying <code>defaults</code>. A default set of policy rules are enforced until a more specific set supersedes them. In contrast, a set of overrides wins over any more specific set of rules.</p> <p>Setting default AuthPolicies provide, e.g., platform engineers with the ability to protect the infrastructure against unplanned and malicious network traffic attempt, such as by setting preemptive \"deny-all\" policies at the level of the gateways that block access on all routes attached to the gateway. Later on, application developers can define more specific auth rules at the level of the HTTPRoutes, opening access to individual routes.</p> <p>Inversely, a gateway policy that specify overrides declares a set of rules that is enforced on all routes attached to the gateway, thus atomically replacing any more specific policy occasionally attached to any of those routes.</p> <p>Although typical examples involve specifying <code>defaults</code> and <code>overrides</code> at the level of the Gateway object which interact with sets of policy rules defined at the more specific context (HTTPRoute), Defaults &amp; Overrides are actually transversal to object kinds. One can define AuthPolicies with <code>defaults</code> or <code>overrides</code> at any level of the following hierarchy and including multiple policies at the same level:</p> <ol> <li>Gateway</li> <li>Gateway listener (by targeting a Gateway with <code>sectionName</code>)</li> <li>HTTPRoute</li> <li>HTTPRouteRule (by targeting a HTTPRoute with <code>sectionName</code>)</li> </ol> <p>The final set of policy rules to enforce for a given request, known as \"effective policy\", is computed based on the basic principles stated in the Hierarchy section of GEP-2649 and Conflict Resolution of its predecessor GEP-713, for the hierarchical levels above.</p> <p>Kuadrant AuthPolicies extend Gateway API's Defaults &amp; Overrides with additional merge strategies for allowing users to specify sets of policy rules under <code>defaults</code> and/or <code>overrides</code> blocks that can be either atomically applied or merged into a composition of policy rules from the multiple AuthPolicies affecting a hierarchy of newtworking objects. The name of the policy rule is used for detecting conflicts.</p> <p>For details of the behavior of Defaults &amp; Overrides for the AuthPolicies covering all supported merge strategies, see RFC-0009.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#hostnames-and-wildcards","title":"Hostnames and wildcards","text":"<p>If an AuthPolicy targets a route defined for a hostname wildcard <code>*.com</code> and a second AuthPolicy targets another route for a hostname <code>api.com</code>, without any overrides nor merges in place, the policies will be enforced according to the principle of \"the more specific wins\". E.g., a request coming for <code>api.com</code> will be protected according to the rules from the AuthPolicy that targets the route for <code>api.com</code>, while a request for <code>other.com</code> will be protected with the rules from the AuthPolicy targeting the route for <code>*.com</code>. One should not expect both set of policy rules to be enforced on requests to <code>api.com</code> simply because both hostname and wildcard match.</p> <p>Example with 3 AuthPolicies and 3 HTTPRoutes, without merges nor overrides in place:</p> <ul> <li>AuthPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>)</li> <li>AuthPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>)</li> <li>AuthPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 AuthPolicy A will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 AuthPolicy B will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 AuthPolicy W will be enforced</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/auth/#when-conditions","title":"<code>when</code> conditions","text":"<p><code>when</code> conditions can be used to scope an AuthPolicy or auth rule within an AuthPolicy (i.e. to filter the traffic to which a policy or policy rule applies) without any coupling to the underlying network topology.</p> <p>Use <code>when</code> conditions to conditionally activate policies and policy rules based on attributes that cannot be expressed in the HTTPRoutes' <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or in general in AuthPolicies that target a Gateway.</p> <p><code>when</code> conditions in an AuthPolicy are compatible with Authorino conditions, thus supporting complex boolean expressions with AND and OR operators, as well as grouping.</p> <p>The selectors within the <code>when</code> conditions of an AuthPolicy are a subset of Kuadrant's Well-known Attributes (RFC 0002). Check out the reference for the full list of supported selectors.</p> <p>Authorino JSON path string modifiers can also be applied to the selectors within the <code>when</code> conditions of an AuthPolicy.</p>"},{"location":"kuadrant-operator/doc/overviews/auth/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of protecting services with Kuadrant:</p> <ul> <li>Enforcing authentication &amp; authorization with Kuadrant AuthPolicy, for app developers and platform engineers</li> <li>Authenticated Rate Limiting for Application Developers</li> <li>Authenticated Rate Limiting with JWTs and Kubernetes RBAC</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/auth/#known-limitations","title":"Known limitations","text":"<ul> <li>AuthPolicies can only target HTTPRoutes/Gateways defined within the same namespace of the AuthPolicy.</li> <li>AuthPolicies that reference other Kubernetes objects (typically <code>Secret</code>s) require those objects to the created in the same namespace as the <code>Kuadrant</code> custom resource managing the deployment. This is the case of AuthPolicies that define API key authentication with <code>allNamespaces</code> option set to <code>false</code> (default), where the API key Secrets must be created in the Kuadrant CR namespace and not in the AuthPolicy namespace.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/dns/","title":"Kuadrant DNS","text":"<p>A Kuadrant DNSPolicy custom resource:</p> <p>Targets Gateway API networking resources Gateways to provide dns management by managing the lifecycle of dns records in external dns providers such as AWS Route53 and Google DNS.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#how-it-works","title":"How it works","text":"<p>A DNSPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external DNS service. The needed dns names are gathered from the listener definitions and the IPAdresses | CNAME hosts are gathered from the status block of the gateway resource.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#the-dnspolicy-custom-resource","title":"The DNSPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/dns/#overview","title":"Overview","text":"<p>The <code>DNSPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>LoadBalancing specification (<code>spec.loadBalancing</code>)</li> <li>HealthCheck specification (<code>spec.healthCheck</code>)</li> </ul> <p>Check out the API reference for a full specification of the DNSPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#using-the-dnspolicy","title":"Using the DNSPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/dns/#dns-provider-setup","title":"DNS Provider Setup","text":"<p>A DNSPolicy acts against a target Gateway by processing its listeners for hostnames that it can create dns records for. In order for it to do this, it must know about the dns provider. This is done through the creation of dns provider secrets containing the credentials and configuration for the dns provider account.</p> <p>If for example a Gateway is created with a listener with a hostname of <code>echo.apps.hcpapps.net</code>:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: my-gw\nspec:\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: echo.apps.hcpapps.net\n      port: 80\n      protocol: HTTP\n</code></pre> <p>In order for the DNSPolicy to act upon that listener, a DNS provider Secret must exist for that hostnames' domain.</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: my-aws-credentials\n  namespace: &lt;Gateway Namespace&gt;\ndata:\n  AWS_ACCESS_KEY_ID: &lt;AWS_ACCESS_KEY_ID&gt;\n  AWS_REGION: &lt;AWS_REGION&gt;\n  AWS_SECRET_ACCESS_KEY: &lt;AWS_SECRET_ACCESS_KEY&gt;\ntype: kuadrant.io/aws\n</code></pre> <p>By default, Kuadrant will list the available zones and find the matching zone based on the listener host in the gateway listener. If it finds more than one matching zone for a given listener host, it will not update any of those zones. When providing a credential you should limit that credential down to just have write access to the zones you want Kuadrant to manage. Below is an example of a an AWS policy for doing this type of thing:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListTagsForResources\",\n                \"route53:GetHealthCheckLastFailureReason\",\n                \"route53:GetHealthCheckStatus\",\n                \"route53:GetChange\",\n                \"route53:GetHostedZone\",\n                \"route53:ChangeResourceRecordSets\",\n                \"route53:ListResourceRecordSets\",\n                \"route53:GetHealthCheck\",\n                \"route53:UpdateHostedZoneComment\",\n                \"route53:UpdateHealthCheck\",\n                \"route53:CreateHealthCheck\",\n                \"route53:DeleteHealthCheck\",\n                \"route53:ListTagsForResource\",\n                \"route53:ListHealthChecks\",\n                \"route53:GetGeoLocation\",\n                \"route53:ListGeoLocations\",\n                \"route53:ListHostedZonesByName\",\n                \"route53:GetHealthCheckCount\"\n            ],\n            \"Resource\": [\n                \"arn:aws:route53:::hostedzone/Z08187901Y93585DDGM6K\",\n                \"arn:aws:route53:::healthcheck/*\",\n                \"arn:aws:route53:::change/*\"\n            ]\n        },\n        {\n            \"Sid\": \"VisualEditor1\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListHostedZones\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>When a DNSPolicy targets a Gateway, the policy will be enforced on all gateway listeners.</p> <p>Target a Gateway by setting the <code>spec.targetRef</code> field of the DNSPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: &lt;DNSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#targeting-a-specific-listener-of-a-gateway","title":"Targeting a specific Listener of a gateway","text":"<p>A DNSPolicy can target a specific listener in a gateway using the <code>sectionName</code> property of the targetRef configuration. When you set the <code>sectionName</code>, the DNSPolicy will only affect that listener and no others. If you also have another DNSPolicy targeting the entire gateway, the more specific policy targeting the listerner will be the policy that is applied.</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: &lt;DNSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n    sectionName: &lt;myListenerName&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#dnsrecord-resource","title":"DNSRecord Resource","text":"<p>The DNSPolicy will create a DNSRecord resource for each listener hostname. The DNSPolicy resource uses the status of the Gateway to determine what dns records need to be created based on the clusters it has been placed onto.</p> <p>Given the following multi cluster gateway status:</p> <pre><code>status:\n  addresses:\n\n    - type: kuadrant.io/MultiClusterIPAddress\n      value: kind-mgc-workload-1/172.31.201.1\n    - type: kuadrant.io/MultiClusterIPAddress\n      value: kind-mgc-workload-2/172.31.202.1\n  listeners:\n    - attachedRoutes: 1\n      conditions: []\n      name: kind-mgc-workload-1.api\n      supportedKinds: []\n    - attachedRoutes: 1\n      conditions: []\n      name: kind-mgc-workload-2.api\n      supportedKinds: []\n</code></pre> <p>A DNSPolicy targeting this gateway would create an appropriate DNSRecord based on the routing strategy selected.</p>"},{"location":"kuadrant-operator/doc/overviews/dns/#loadbalanced","title":"loadbalanced","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: echo.apps.hcpapps.net\n  namespace: &lt;Gateway Namespace&gt;\nspec:\n  endpoints:\n\n    - dnsName: 24osuu.lb-2903yb.echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.202.1\n    - dnsName: default.lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: weight\n          value: \"120\"\n      recordTTL: 60\n      recordType: CNAME\n      setIdentifier: 24osuu.lb-2903yb.echo.apps.hcpapps.net\n      targets:\n        - 24osuu.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: default.lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: weight\n          value: \"120\"\n      recordTTL: 60\n      recordType: CNAME\n      setIdentifier: lrnse3.lb-2903yb.echo.apps.hcpapps.net\n      targets:\n        - lrnse3.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: echo.apps.hcpapps.net\n      recordTTL: 300\n      recordType: CNAME\n      targets:\n        - lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: lb-2903yb.echo.apps.hcpapps.net\n      providerSpecific:\n        - name: geo-country-code\n          value: '*'\n      recordTTL: 300\n      recordType: CNAME\n      setIdentifier: default\n      targets:\n        - default.lb-2903yb.echo.apps.hcpapps.net\n    - dnsName: lrnse3.lb-2903yb.echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.201.1\n  providerRefs:\n    - name: my-aws-credentials\n</code></pre> <p>After DNSRecord reconciliation the listener hostname should be resolvable through dns:</p> <pre><code>dig echo.apps.hcpapps.net +short\nlb-2903yb.echo.apps.hcpapps.net.\ndefault.lb-2903yb.echo.apps.hcpapps.net.\nlrnse3.lb-2903yb.echo.apps.hcpapps.net.\n172.31.201.1\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#simple","title":"simple","text":"<pre><code>apiVersion: kuadrant.io/v1alpha1\nkind: DNSRecord\nmetadata:\n  name: echo.apps.hcpapps.net\n  namespace: &lt;Gateway Namespace&gt;\nspec:\n  endpoints:\n\n    - dnsName: echo.apps.hcpapps.net\n      recordTTL: 60\n      recordType: A\n      targets:\n        - 172.31.201.1\n        - 172.31.202.1\n  providerRefs:\n    - name: my-aws-credentials\n</code></pre> <p>After DNSRecord reconciliation the listener hostname should be resolvable through dns:</p> <pre><code>dig echo.apps.hcpapps.net +short\n172.31.201.1\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#known-limitations","title":"Known limitations","text":"<ul> <li>One Gateway can only be targeted by one DNSPolicy unless subsequent DNSPolicies choose to specific a sectionName in their targetRef.</li> <li>DNSPolicies can only target Gateways defined within the same namespace of the DNSPolicy.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/dns/#troubleshooting","title":"Troubleshooting","text":""},{"location":"kuadrant-operator/doc/overviews/dns/#understanding-status","title":"Understanding status","text":"<p>The <code>Status.Conditions</code> on DNSPolicy mostly serves as an aggregation of the DNSRecords conditions.  The DNSPolicy conditions: </p> <ul> <li><code>Accepted</code> indicates that policy was validated and is accepted by the controller for the reconciliation. </li> <li><code>Enforced</code> indicates that the controller acted upon the policy. If DNSRecords were created as the result this condition will reflect the <code>Ready</code> condition on the record. This condition is removed if <code>Accepted</code> is false. If partially enforced, the condition will be set to <code>True</code></li> <li><code>SubResourcesHealthy</code> reflects <code>Healthy</code> conditions of sub-resources. This condition is removed if <code>Accepted</code> is false. If partially healthy, the condition will be set to <code>False</code> </li> </ul> <p>The <code>Status.Conditions</code> on the DNSRecord are as follows: </p> <ul> <li><code>Ready</code> indicates that the record was successfully published to the provider. </li> <li><code>Healthy</code> indicates that dnshealthcheckprobes are healthy. If not all probes are healthy, the condition will be set to <code>False</code></li> </ul>"},{"location":"kuadrant-operator/doc/overviews/dns/#logs","title":"Logs","text":"<p>To increase the log level of the <code>kuadran-operator</code> refer to this logging doc.</p> <p>To increase the log level of the <code>dns-operator-controller-manager</code> and for the examples on log queries refer to the logging section in the DNS Operator readme </p>"},{"location":"kuadrant-operator/doc/overviews/dns/#debugging","title":"Debugging","text":"<p>This section will provide the typical sequence of actions during the troubleshooting.  It is meant to be a reference to identifying the problem rather than SOP. </p>"},{"location":"kuadrant-operator/doc/overviews/dns/#list-policies-to-identify-the-failing-one","title":"List policies to identify the failing one","text":"<pre><code>kubectl get dnspolicy -A -o wide\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/dns/#inspect-the-failing-policy","title":"Inspect the failing policy","text":"<p><pre><code>kubectl get dnspolicy &lt;dnspolicy-name&gt; -n &lt;dnspolicy-namespace&gt; -o yaml | yq '.status.conditions'\n</code></pre> The output will show which DNSRecords and for what reasons are failing. For example:  <pre><code>- lastTransitionTime: \"2024-12-04T09:46:22Z\"\n  message: DNSPolicy has been accepted\n  reason: Accepted\n  status: \"True\"\n  type: Accepted\n- lastTransitionTime: \"2024-12-04T09:46:29Z\"\n  message: 'DNSPolicy has been partially enforced. Not ready DNSRecords are: test-api '\n  reason: Enforced\n  status: \"True\"\n  type: Enforced\n- lastTransitionTime: \"2024-12-04T09:46:27Z\"\n  message: 'DNSPolicy has encountered some issues: not all sub-resources of policy are passing the policy defined health check. Not healthy DNSRecords are: test-api '\n  reason: Unknown\n  status: \"False\"\n  type: SubResourcesHealthy\n</code></pre> This example indicates that the policy was accepted and one of the DNSRecords - <code>test-api</code> DNSRecord - is not ready and not healthy </p>"},{"location":"kuadrant-operator/doc/overviews/dns/#locate-sub-records-to-confirm-conditions","title":"Locate sub-records to confirm conditions","text":"<p>This ensures that the Kuadrand operator propagated status correctly. The names of the DNSRecords are composed of the Gateway name followed by a listener name and are created in the DNSPolicy namespace. <pre><code>kubectl get dnsrecord -n &lt;dnspolicy-namespace&gt; \n</code></pre></p>"},{"location":"kuadrant-operator/doc/overviews/dns/#inspect-the-record-to-get-more-detailed-information-on-the-failure","title":"Inspect the record to get more detailed information on the failure","text":"<p><pre><code>kubectl get dnsrecord &lt;dnsrecord-name&gt; -n &lt;dnspolicy-namespace&gt; -o yaml | yq '.status'\n</code></pre> Most of the time the <code>conditions</code> will hold all necessary information.  However, it is advised to pay attention to the <code>queuedAt</code> and <code>validFor</code> field  to understand when the record was processed and when controller expects it to be reconciled again. </p>"},{"location":"kuadrant-operator/doc/overviews/dns/#inspect-health-check-probes","title":"Inspect health check probes","text":"<p>We create a probe per address per dns record. The name of the probe is DNSRecord name followed by an address.  <pre><code># list probes \nkubectl get dnshealthcheckprobe -n &lt;dnspolicy-namespace&gt;\n# inspect the probe \nkubectl get dnshealthcheckprobe &lt;probe-name&gt; -n &lt;dnspolicy-namespace&gt; -o yaml | yq '.status'\n</code></pre></p>"},{"location":"kuadrant-operator/doc/overviews/dns/#identify-what-in-logs-to-look-for","title":"Identify what in logs to look for","text":"<p>There are two operators to look into and a number of controllers. The commands above should provide an understanding of what component/process is failing.  Use the following to identify the correct controller:</p> <ul> <li>If the problem in the status propagation from the DNSRecord to the DNSPolicy or in the creation of the DNSRecord: <code>kuadrant-operator</code> logs under <code>kuadrant-operator.EffectiveDNSPoliciesReconciler</code> reconciler</li> <li>If the problem is in publishing DNSRecord or reacting to the healtcheckprobe CR: <code>dns-operator-controller-manager</code> logs under <code>dnsrecord_controller</code> reconciler</li> <li>If the problem in creation of the probes: <code>dns-operator-controller-manager</code> logs under <code>dnsrecord_controller.healthchecks</code> reconciler</li> <li>If the problem is in the execution of the healthchecks: <code>dns-operator-controller-manager</code> logs under <code>dnsprobe_controller</code> reconciler</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/","title":"Kuadrant Rate Limiting","text":"<p>A Kuadrant RateLimitPolicy custom resource, often abbreviated \"RateLimitPolicy\":</p> <ol> <li>Targets Gateway API networking resources such as HTTPRoutes and Gateways, using these resources to obtain additional context, i.e., which traffic workload (HTTP attributes, hostnames, user attributes, etc) to rate limit.</li> <li>Supports targeting subsets (sections) of a network resource to apply the limits to.</li> <li>Abstracts the details of the underlying Rate Limit protocol and configuration resources, that have a much broader remit and surface area.</li> <li>Enables cluster operators to set defaults that govern behavior at the lower levels of the network, until a more specific policy is applied.</li> </ol>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#envoys-rate-limit-service-protocol","title":"Envoy's Rate Limit Service Protocol","text":"<p>Kuadrant's Rate Limit implementation relies on the Envoy's Rate Limit Service (RLS) protocol. The workflow per request goes:</p> <ol> <li>On incoming request, the gateway checks the matching rules for enforcing rate limits, as stated in the RateLimitPolicy custom resources and targeted Gateway API networking objects</li> <li>If the request matches, the gateway sends one RateLimitRequest to the external rate limiting service (\"Limitador\").</li> <li>The external rate limiting service responds with a RateLimitResponse back to the gateway with either an <code>OK</code> or <code>OVER_LIMIT</code> response code.</li> </ol> <p>A RateLimitPolicy and its targeted Gateway API networking resource contain all the statements to configure both the ingress gateway and the external rate limiting service.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#the-ratelimitpolicy-custom-resource","title":"The RateLimitPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#overview","title":"Overview","text":"<p>The <code>RateLimitPolicy</code> spec includes, basically, two parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> <li>Limit definitions (<code>spec.limits</code>)</li> </ul> <p>Each limit definition includes:</p> <ul> <li>A set of rate limits (<code>spec.limits.&lt;limit-name&gt;.rates[]</code>)</li> <li>(Optional) A set of dynamic counter qualifiers (<code>spec.limits.&lt;limit-name&gt;.counters[]</code>)</li> <li>(Optional) A set of additional dynamic conditions to activate the limit (<code>spec.limits.&lt;limit-name&gt;.when[]</code>)</li> </ul> <p>The limit definitions (<code>limits</code>) can be declared at the top-level level of the spec (with the semantics of defaults) or alternatively within explicit <code>defaults</code> or <code>overrides</code> blocks.</p> Check out Kuadrant RFC 0002 to learn more about the Well-known Attributes that can be used to define counter qualifiers (<code>counters</code>) and conditions (<code>when</code>). <p>Check out the API reference for a full specification of the RateLimitPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#using-the-ratelimitpolicy","title":"Using the RateLimitPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#targeting-a-httproute-networking-resource","title":"Targeting a HTTPRoute networking resource","text":"<p>When a RateLimitPolicy targets a HTTPRoute, the policy is enforced to all traffic routed according to the rules and hostnames specified in the HTTPRoute, across all Gateways referenced in the <code>spec.parentRefs</code> field of the HTTPRoute.</p> <p>Target a HTTPRoute by setting the <code>spec.targetRef</code> field of the RateLimitPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: &lt;RateLimitPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: &lt;HTTPRoute Name&gt;\n  limits: { \u2026 }\n</code></pre> <p></p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#hostnames-and-wildcards","title":"Hostnames and wildcards","text":"<p>If a RateLimitPolicy targets a route defined for <code>*.com</code> and another RateLimitPolicy targets another route for <code>api.com</code>, the Kuadrant control plane will not merge these two RateLimitPolicies. Unless one of the policies declare an overrides set of limites, the control plane will configure to mimic the behavior of gateway implementation by which the \"most specific hostname wins\", thus enforcing only the corresponding applicable policies and limit definitions.</p> <p>E.g., by default, a request coming for <code>api.com</code> will be rate limited according to the rules from the RateLimitPolicy that targets the route for <code>api.com</code>; while a request for <code>other.com</code> will be rate limited with the rules from the RateLimitPolicy targeting the route for <code>*.com</code>.</p> <p>See more examples in Overlapping Gateway and HTTPRoute RateLimitPolicies.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>A RateLimitPolicy that targets a Gateway can declare a block of defaults (<code>spec.defaults</code>) or a block of overrides (<code>spec.overrides</code>). As a standard, gateway policies that do not specify neither defaults nor overrides, act as defaults.</p> <p>When declaring defaults, a RateLimitPolicy which targets a Gateway will be enforced to all HTTP traffic hitting the gateway, unless a more specific RateLimitPolicy targeting a matching HTTPRoute exists. Any new HTTPRoute referrencing the gateway as parent will be automatically covered by the default RateLimitPolicy, as well as changes in the existing HTTPRoutes.</p> <p>Defaults provide cluster operators with the ability to protect the infrastructure against unplanned and malicious network traffic attempt, such as by setting safe default limits on hostnames and hostname wildcards.</p> <p>Inversely, a gateway policy that specify overrides declares a set of rules to be enforced on all routes attached to the gateway, thus atomically replacing any more specific policy occasionally attached to any of those routes.</p> <p>Target a Gateway HTTPRoute by setting the <code>spec.targetRef</code> field of the RateLimitPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: &lt;RateLimitPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n  defaults: # alternatively: `overrides`\n    limits: { \u2026 }\n</code></pre> <p></p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#overlapping-gateway-and-httproute-ratelimitpolicies","title":"Overlapping Gateway and HTTPRoute RateLimitPolicies","text":"<p>Two possible semantics are to be considered here \u2013 gateway policy defaults vs gateway policy overrides.</p> <p>Gateway RateLimitPolicies that declare defaults (or alternatively neither defaults nor overrides) protect all traffic routed through the gateway except where a more specific HTTPRoute RateLimitPolicy exists, in which case the HTTPRoute RateLimitPolicy prevails.</p> <p>Example with 4 RateLimitPolicies, 3 HTTPRoutes and 1 Gateway default (plus 2 HTTPRoute and 2 Gateways without RateLimitPolicies attached):</p> <ul> <li>RateLimitPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy G (defaults) \u2192 Gateway G (<code>*.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 RateLimitPolicy A will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 RateLimitPolicy B will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 RateLimitPolicy W will be enforced</li> <li>Request to <code>other.com</code> (suppose a route exists) \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>yet-another.net</code> (suppose a route and gateway exist) \u2192 No RateLimitPolicy will be enforced</li> </ul> <p>Gateway RateLimitPolicies that declare overrides protect all traffic routed through the gateway, regardless of existence of any more specific HTTPRoute RateLimitPolicy.</p> <p>Example with 4 RateLimitPolicies, 3 HTTPRoutes and 1 Gateway override (plus 2 HTTPRoute and 2 Gateways without RateLimitPolicies attached):</p> <ul> <li>RateLimitPolicy A \u2192 HTTPRoute A (<code>a.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy B \u2192 HTTPRoute B (<code>b.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy W \u2192 HTTPRoute W (<code>*.toystore.com</code>) \u2192 Gateway G (<code>*.com</code>)</li> <li>RateLimitPolicy G (overrides) \u2192 Gateway G (<code>*.com</code>)</li> </ul> <p>Expected behavior:</p> <ul> <li>Request to <code>a.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>b.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>other.toystore.com</code> \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>other.com</code> (suppose a route exists) \u2192 RateLimitPolicy G will be enforced</li> <li>Request to <code>yet-another.net</code> (suppose a route and gateway exist) \u2192 No RateLimitPolicy will be enforced</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#limit-definition","title":"Limit definition","text":"<p>A limit will be activated whenever a request comes in and the request matches:</p> <ul> <li>all of the <code>when</code> conditions specified in the limit.</li> </ul> <p>A limit can define:</p> <ul> <li>counters that are qualified based on dynamic values fetched from the request, or</li> <li>global counters (implicitly, when no qualified counter is specified)</li> </ul> <p>A limit is composed of one or more rate limits.</p> <p>E.g.</p> <pre><code>spec:\n  limits:\n    \"toystore-all\":\n      rates:\n\n        - limit: 5000\n          window: 1s\n\n    \"toystore-api-per-username\":\n      rates:\n\n        - limit: 100\n          window: 1s\n        - limit: 1000\n          window: 1m\n      counters:\n        - expression: auth.identity.username\n      when:\n        - predicate: request.host == 'api.toystore.com'\n\n    \"toystore-admin-unverified-users\":\n      rates:\n\n        - limit: 250\n          window: 1s\n      when:\n        - predicate: request.host == 'admin.toystore.com'\n        - predicate: !auth.identity.email_verified\n</code></pre> Request to Rate limits enforced <code>api.toystore.com</code> 100rps/username or 1000rpm/username (whatever happens first) <code>admin.toystore.com</code> 250rps <code>other.toystore.com</code> 5000rps"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#when-conditions","title":"<code>when</code> conditions","text":"<p><code>when</code> conditions can be used to scope a limit (i.e. to filter the traffic to which a limit definition applies) without any coupling to the underlying network topology, i.e. without making direct references to HTTPRouteRules.</p> <p>Use <code>when</code> conditions to conditionally activate limits based on attributes that cannot be expressed in the HTTPRoutes' <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or in general in RateLimitPolicies that target a Gateway.</p> <p>The selectors within the <code>when</code> conditions of a RateLimitPolicy are a subset of Kuadrant's Well-known Attributes (RFC 0002). Check out the reference for the full list of supported selectors.</p>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of rate limiting services with Kuadrant:</p> <ul> <li>Simple Rate Limiting for Applications</li> <li>Authenticated Rate Limiting for Application</li> <li>Gateway Rate Limiting for Cluster Operators</li> <li>Authenticated Rate Limiting with JWTs and Kubernetes RBAC</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#known-limitations","title":"Known limitations","text":"<ul> <li>RateLimitPolicies can only target HTTPRoutes/Gateways defined within the same namespace of the RateLimitPolicy.</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/rate-limiting/#implementation-details","title":"Implementation details","text":"<p>Driven by limitations related to how Istio injects configuration in the filter chains of the ingress gateways, Kuadrant relies on Envoy's Wasm Network filter in the data plane, to manage the integration with rate limiting service (\"Limitador\"), instead of the Rate Limit filter.</p> <p>Motivation: Multiple rate limit domains</p> <p>The first limitation comes from having only one filter chain per listener. This often leads to one single global rate limiting filter configuration per gateway, and therefore to a shared rate limit domain across applications and policies. Even though, in a rate limit filter, the triggering of rate limit calls, via actions to build so-called \"descriptors\", can be defined at the level of the virtual host and/or specific route rule, the overall rate limit configuration is only one, i.e., always the same rate limit domain for all calls to Limitador.</p> <p>On the other hand, the possibility to configure and invoke the rate limit service for multiple domains depending on the context allows to isolate groups of policy rules, as well as to optimize performance in the rate limit service, which can rely on the domain for indexation.</p> <p>Motivation: Fine-grained matching rules A second limitation of configuring the rate limit filter via Istio, particularly from Gateway API resources, is that rate limit descriptors at the level of a specific HTTP route rule require \"named routes\" \u2013 defined only in an Istio VirtualService resource and referred in an EnvoyFilter one. Because Gateway API HTTPRoute rules lack a \"name\" property<sup>1</sup>, as well as the Istio VirtualService resources are only ephemeral data structures handled by Istio in-memory in its implementation of gateway configuration for Gateway API, where the names of individual route rules are auto-generated and not referable by users in a policy<sup>2</sup><sup>3</sup>, rate limiting by attributes of the HTTP request (e.g., path, method, headers, etc) would be very limited while depending only on Envoy's Rate Limit filter.</p> <p>Motivated by the desire to support multiple rate limit domains per ingress gateway, as well as fine-grained HTTP route matching rules for rate limiting, Kuadrant implements a wasm-shim that handles the rules to invoke the rate limiting service, complying with Envoy's Rate Limit Service (RLS) protocol.</p> <p>The wasm module integrates with the gateway in the data plane via Wasm Network filter, and parses a configuration composed out of user-defined RateLimitPolicy resources by the Kuadrant control plane. Whereas the rate limiting service (\"Limitador\") remains an implementation of Envoy's RLS protocol, capable of being integrated directly via Rate Limit extension or by Kuadrant, via wasm module for the Istio Gateway API implementation.</p> <p>As a consequence of this design:</p> <ul> <li>Users can define fine-grained rate limit rules that match their Gateway and HTTPRoute definitions including for subsections of these.</li> <li>Rate limit definitions are insulated, not leaking across unrelated policies or applications.</li> <li>Conditions to activate limits are evaluated in the context of the gateway process, reducing the gRPC calls to the external rate limiting service only to the cases where rate limit counters are known in advance to have to be checked/incremented.</li> <li>The rate limiting service can rely on the indexation to look up for groups of limit definitions and counters.</li> <li>Components remain compliant with industry protocols and flexible for different integration options.</li> </ul> <p>A Kuadrant wasm-shim configuration for one RateLimitPolicy custom resources targeting a HTTPRoute looks like the following and it is generated automatically by the Kuadrant control plane:</p> <pre><code>apiVersion: extensions.istio.io/v1alpha1\nkind: WasmPlugin\nmetadata:\n  creationTimestamp: \"2024-10-01T16:59:40Z\"\n  generation: 1\n  name: kuadrant-kuadrant-ingressgateway\n  namespace: gateway-system\n  ownerReferences:\n\n    - apiVersion: gateway.networking.k8s.io/v1\n      blockOwnerDeletion: true\n      controller: true\n      kind: Gateway\n      name: kuadrant-ingressgateway\n      uid: 0298355b-fb30-4442-af2b-88d0c05bd2bd\n  resourceVersion: \"11253\"\n  uid: 36ef1fb7-9eca-46c7-af63-fe783f40148c\nspec:\n  phase: STATS\n  pluginConfig:\n    services:\n      ratelimit-service:\n        type: ratelimit\n        endpoint: ratelimit-cluster\n        failureMode: allow\n    actionSets:\n      - name: some_name_0\n        routeRuleConditions:\n          hostnames:\n            - \"*.toystore.website\"\n            - \"*.toystore.io\"\n          predicates:\n            - request.url_path.startsWith(\"/assets\")\n        actions:\n          - service: ratelimit-service\n            scope: gateway-system/app-rlp\n            predicates:\n              - request.host.endsWith('.toystore.website')\n            data:\n              - expression:\n                  key: limit.toystore_assets_all_domains__b61ee8e6\n                  value: \"1\"\n      - name: some_name_1\n        routeRuleConditions:\n          hostnames:\n            - \"*.toystore.website\"\n            - \"*.toystore.io\"\n          predicates:\n            - request.url_path.startsWith(\"/v1\")\n        actions:\n          - service: ratelimit-service\n            scope: gateway-system/app-rlp\n            predicates:\n              - request.host.endsWith('.toystore.website')\n              - auth.identity.username == \"\"\n            data:\n              - expression:\n                  key: limit.toystore_v1_website_unauthenticated__377837ee\n                  value: \"1\"\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: kuadrant-ingressgateway\n  url: oci://quay.io/kuadrant/wasm-shim:latest\n</code></pre> <ol> <li> <p>https://github.com/kubernetes-sigs/gateway-api/pull/996\u00a0\u21a9</p> </li> <li> <p>https://github.com/istio/istio/issues/36790\u00a0\u21a9</p> </li> <li> <p>https://github.com/istio/istio/issues/37346\u00a0\u21a9</p> </li> </ol>"},{"location":"kuadrant-operator/doc/overviews/tls/","title":"TLS","text":"<p>A Kuadrant TLSPolicy custom resource:</p> <p>Targets Gateway API networking resources Gateways to provide tls for gateway listeners by managing the lifecycle of tls certificates using <code>CertManager</code>.</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#how-it-works","title":"How it works","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#the-tlspolicy-custom-resource","title":"The TLSPolicy custom resource","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#overview","title":"Overview","text":"<p>The <code>TLSPolicy</code> spec includes the following parts:</p> <ul> <li>A reference to an existing Gateway API resource (<code>spec.targetRef</code>)</li> </ul>"},{"location":"kuadrant-operator/doc/overviews/tls/#high-level-example-and-field-definition","title":"High-level example and field definition","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: my-tls-policy\nspec:\n  # reference to an existing networking resource to attach the policy to\n  # it can only be a Gateway API Gateway resource\n  # it can only refer to objects in the same namespace as the TLSPolicy\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mygateway\n</code></pre> <p>Check out the API reference for a full specification of the TLSPolicy CRD.</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#using-the-tlspolicy","title":"Using the TLSPolicy","text":""},{"location":"kuadrant-operator/doc/overviews/tls/#targeting-a-gateway-networking-resource","title":"Targeting a Gateway networking resource","text":"<p>When a TLSPolicy targets a Gateway, the policy will be enforced on all gateway listeners that have a valid TLS section.</p> <p>Target a Gateway by setting the <code>spec.targetRef</code> field of the TLSPolicy as follows:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: &lt;TLSPolicy name&gt;\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: &lt;Gateway Name&gt;\n</code></pre>"},{"location":"kuadrant-operator/doc/overviews/tls/#examples","title":"Examples","text":"<p>Check out the following user guides for examples of using the Kuadrant TLSPolicy:</p>"},{"location":"kuadrant-operator/doc/overviews/tls/#known-limitations","title":"Known limitations","text":""},{"location":"kuadrant-operator/doc/reference/authpolicy/","title":"The AuthPolicy Custom Resource Definition (CRD)","text":"<ul> <li>AuthPolicy</li> <li>AuthPolicySpec</li> <li>AuthScheme<ul> <li>AuthRuleCommon</li> <li>AuthenticationRule</li> <li>MetadataRule</li> <li>AuthorizationRule</li> <li>ResponseSpec</li> <li>SuccessResponseSpec<ul> <li>SuccessResponseItem</li> </ul> </li> <li>CallbackRule</li> </ul> </li> <li>NamedPattern</li> <li>AuthPolicyCommonSpec</li> <li>AuthPolicyStatus</li> <li>ConditionSpec</li> </ul>"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicy","title":"AuthPolicy","text":"Field Type Required Description <code>spec</code> AuthPolicySpec Yes The specification for AuthPolicy custom resource <code>status</code> AuthPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicyspec","title":"AuthPolicySpec","text":"Field Type Required Description <code>targetRef</code> LocalPolicyTargetReference Yes Reference to a Kubernetes resource that the policy attaches to <code>rules</code> AuthScheme No Implicit default authentication/authorization rules <code>patterns</code> MapNamedPattern&gt; No Implicit default named patterns of lists of <code>selector</code>, <code>operator</code> and <code>value</code> tuples, to be reused in <code>when</code> conditions and pattern-matching authorization rules. <code>when</code> []PatternExpressionOrRef No List of implicit default additional dynamic conditions (expressions) to activate the policy. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway. <code>defaults</code> AuthPolicyCommonSpec No Explicit default definitions. This field is mutually exclusive with any of the implicit default definitions: <code>spec.rules</code>, <code>spec.patterns</code>, <code>spec.when</code> <code>overrides</code> AuthPolicyCommonSpec No Atomic overrides definitions. This field is mutually exclusive with any of the implicit or explicit default definitions: <code>spec.rules</code>, <code>spec.patterns</code>, <code>spec.when</code>, <code>spec.default</code>"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicycommonspec","title":"AuthPolicyCommonSpec","text":"Field Type Required Description <code>rules</code> AuthScheme No Authentication/authorization rules <code>patterns</code> MapNamedPattern&gt; No Named patterns of lists of <code>selector</code>, <code>operator</code> and <code>value</code> tuples, to be reused in <code>when</code> conditions and pattern-matching authorization rules. <code>when</code> []PatternExpressionOrRef No List of additional dynamic conditions (expressions) to activate the policy. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authscheme","title":"AuthScheme","text":"Field Type Required Description <code>authentication</code> MapAuthenticationRule&gt; No Authentication rules. At least one config MUST evaluate to a valid identity object for the auth request to be successful. If omitted or empty, anonymous access is assumed. <code>metadata</code> MapMetadataRule&gt; No Rules for fetching auth metadata from external sources. <code>authorization</code> MapAuthorizationRule&gt; No Authorization rules. All policies MUST allow access for the auth request be successful. <code>response</code> ResponseSpec No Customizations to the response to the authorization request. Use it to set custom values for unauthenticated, unauthorized, and/or success access request. <code>callbacks</code> MapCallbackRule&gt; No Rules for post-authorization callback requests to external services. Triggered regardless of the result of the authorization request."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authrulecommon","title":"AuthRuleCommon","text":"Field Type Required Description <code>when</code> []PatternExpressionOrRef No List of additional dynamic conditions (expressions) to activate the auth rule. Use it for filtering attributes that cannot be expressed in the targeted HTTPRoute's <code>spec.hostnames</code> and <code>spec.rules.matches</code> fields, or when targeting a Gateway. <code>cache</code> Caching spec No Caching options for the resolved object returned when applying this auth rule. (Default: disabled) <code>priority</code> Integer No Priority group of the auth rule. All rules in the same priority group are evaluated concurrently; consecutive priority groups are evaluated sequentially. (Default: <code>0</code>) <code>metrics</code> Boolean No Whether the auth rule emits individual observability metrics. (Default: <code>false</code>)"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authenticationrule","title":"AuthenticationRule","text":"Field Type Required Description <code>apiKey</code> API Key authentication spec No Authentication based on API keys stored in Kubernetes secrets. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>kubernetesTokenReview</code> KubernetesTokenReview spec No Authentication by Kubernetes token review. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>jwt</code> JWT verification spec No Authentication based on JSON Web Tokens (JWT). Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>oauth2Introspection</code> OAuth2 Token Introscpection spec No Authentication by OAuth2 token introspection. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>x509</code> X.509 authentication spec No Authentication based on client X.509 certificates. The certificates presented by the clients must be signed by a trusted CA whose certificates are stored in Kubernetes secrets. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>plain</code> Plain identity object spec No Identity object extracted from the context. Use this method when authentication is performed beforehand by a proxy and the resulting object passed to Authorino as JSON in the auth request. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>anonymous</code> Anonymous access No Anonymous access. Use one of: <code>apiKey</code>, <code>jwt</code>, <code>oauth2Introspection</code>, <code>kubernetesTokenReview</code>, <code>x509</code>, <code>plain</code>, <code>anonymous</code>. <code>credentials</code> Auth credentials spec No Customizations to where credentials are required to be passed in the request for authentication based on this auth rule. Defaults to HTTP Authorization header with prefix \"Bearer\". <code>overrides</code> Identity extension spec No JSON overrides to set to the resolved identity object. Do not use it with identity objects of other JSON types (array, string, etc). <code>defaults</code> Identity extension spec No JSON defaults to set to the resolved identity object. Do not use it with identity objects of other JSON types (array, string, etc). (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#metadatarule","title":"MetadataRule","text":"Field Type Required Description <code>http</code> HTTP GET/GET-by-POST external metadata spec No External source of auth metadata via HTTP request. Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. <code>userInfo</code> OIDC UserInfo spec No OpendID Connect UserInfo linked to an OIDC authentication rule declared in this same AuthPolicy. Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. <code>uma</code> UMA metadata spec No User-Managed Access (UMA) source of resource data.  Use one of: <code>http</code>, <code>userInfo</code>, <code>uma</code>. (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#authorizationrule","title":"AuthorizationRule","text":"Field Type Required Description <code>patternMatching</code> Pattern-matching authorization spec No Pattern-matching authorization rules. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>opa</code> OPA authorization spec No Open Policy Agent (OPA) Rego policy. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>kubernetesSubjectAccessReview</code> Kubernetes SubjectAccessReview spec No Authorization by Kubernetes SubjectAccessReview. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. <code>spicedb</code> SpiceDB authorization spec No Authorization decision delegated to external Authzed/SpiceDB server. Use one of: <code>patternMatching</code>, <code>opa</code>, <code>kubernetesSubjectAccessReview</code>, <code>spicedb</code>. (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#responsespec","title":"ResponseSpec","text":"Field Type Required Description <code>unauthenticated</code> Custom denial status spec No Customizations on the denial status and other HTTP attributes when the request is unauthenticated. (Default: <code>401 Unauthorized</code>) <code>unauthorized</code> Custom denial status spec No Customizations on the denial status and other HTTP attributes when the request is unauthorized. (Default: <code>403 Forbidden</code>) <code>success</code> SuccessResponseSpec No Response items to be included in the auth response when the request is authenticated and authorized."},{"location":"kuadrant-operator/doc/reference/authpolicy/#successresponsespec","title":"SuccessResponseSpec","text":"Field Type Required Description <code>headers</code> Map&lt;string:SuccessResponseItem&gt; No Custom success response items wrapped as HTTP headers to be injected in the request. <code>filters</code> Map&lt;string:SuccessResponseItem&gt; No Custom success response items made available to other filters managed by Kuadrant (i.e. Rate Limit)."},{"location":"kuadrant-operator/doc/reference/authpolicy/#successresponseitem","title":"SuccessResponseItem","text":"Field Type Required Description <code>plain</code> Plain text response item No Plain text content. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>json</code> JSON injection response item No Specification of a JSON object. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>wristband</code> Festival Wristband token response item No Specification of a JSON object. Use one of: <code>plain</code>, <code>json</code>, <code>wristband</code>. <code>key</code> String No The key used to add the custom response item (name of the HTTP header or root property of the Dynamic Metadata object). Defaults to the name of the response item if omitted."},{"location":"kuadrant-operator/doc/reference/authpolicy/#callbackrule","title":"CallbackRule","text":"Field Type Required Description <code>http</code> HTTP endpoints callback spec No HTTP endpoint settings to build the callback request (webhook). (inline) AuthRuleCommon No"},{"location":"kuadrant-operator/doc/reference/authpolicy/#namedpattern","title":"NamedPattern","text":"Field Type Required Description <code>selector</code> String Yes A valid Well-known attribute whose resolved value in the data plane will be compared to <code>value</code>, using the <code>operator</code>. <code>operator</code> String Yes The binary operator to be applied to the resolved value specified by the selector. One of: <code>eq</code> (equal to), <code>neq</code> (not equal to), <code>incl</code> (includes; for arrays), <code>excl</code> (excludes; for arrays), <code>matches</code> (regex). <code>value</code> String Yes The static value to be compared to the one resolved from the selector."},{"location":"kuadrant-operator/doc/reference/authpolicy/#authpolicystatus","title":"AuthPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/authpolicy/#conditionspec","title":"ConditionSpec","text":"<ul> <li>The lastTransitionTime field provides a timestamp for when the entity last transitioned from one status to another.</li> <li>The message field is a human-readable message indicating details about the transition.</li> <li>The reason field is a unique, one-word, CamelCase reason for the condition\u2019s last transition.</li> <li>The status field is a string, with possible values True, False, and Unknown.</li> <li>The type field is a string with the following possible values:</li> <li>Available: the resource has successfully configured;</li> </ul> Field Type Description <code>type</code> String Condition Type <code>status</code> String Status: True, False, Unknown <code>reason</code> String Condition state reason <code>message</code> String Condition state description <code>lastTransitionTime</code> Timestamp Last transition timestamp"},{"location":"kuadrant-operator/doc/reference/authpolicy/#high-level-example","title":"High-level example","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: my-auth-policy\nspec:\n  # Reference to an existing networking resource to attach the policy to. REQUIRED.\n  # It can be a Gateway API HTTPRoute or Gateway resource.\n  # It can only refer to objects in the same namespace as the AuthPolicy.\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute / Gateway\n    name: myroute / mygateway\n\n  # Additional dynamic conditions to trigger the AuthPolicy.\n  # Use it for filtering attributes not supported by HTTPRouteRule or with AuthPolicies that target a Gateway.\n  # Check out https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md to learn more\n  # about the Well-known Attributes that can be used in this field.\n  # Equivalent to if otherwise declared within `defaults`.\n  when: [\u2026]\n\n  # Sets of common patterns of selector-operator-value triples, to be referred by name in `when` conditions\n  # and pattern-matching rules. Often employed to avoid repetition in the policy.\n  # Equivalent to if otherwise declared within `defaults`.\n  patterns: { \u2026 }\n\n  # The auth rules to apply to the network traffic routed through the targeted resource.\n  # Equivalent to if otherwise declared within `defaults`.\n  rules:\n    # Authentication rules to enforce.\n    # At least one config must evaluate to a valid identity object for the auth request to be successful.\n    # If omitted or empty, anonymous access is assumed.\n    authentication:\n      \"my-authn-rule\":\n        # The authentication method of this rule.\n        # One-of: apiKey, jwt, oauth2Introspection, kubernetesTokenReview, x509, plain, anonymous.\n        apiKey: { \u2026 }\n\n        # Where credentials are required to be passed in the request for authentication based on this rule.\n        # One-of: authorizationHeader, customHeader, queryString, cookie.\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n\n        # Rule-level additional conditions.\n        when: [\u2026]\n\n        # Configs for caching the resolved object returned out of evaluating this auth rule.\n        cache: { \u2026 }\n\n    # Rules for fetching auth metadata from external sources.\n    metadata:\n      \"my-external-source\":\n        # The method for fetching metadata from the external source.\n        # One-of: http: userInfo, uma.\n        http: { \u2026 }\n\n    # Authorization rules to enforce.\n    # All policies must allow access for the auth request be successful.\n    authorization:\n      \"my-authz-rule\":\n        # The authorization method of this rule.\n        # One-of: patternMatching, opa, kubernetesSubjectAccessReview, spicedb.\n        opa: { \u2026 }\n\n    # Customizations to the authorization response.\n    response:\n      # Custom denial status and other HTTP attributes for unauthenticated requests.\n      unauthenticated: { \u2026 }\n\n      # Custom denial status and other HTTP attributes for unauhtorized requests.\n      unauthorized: { \u2026 }\n\n      # Custom response items when access is granted.\n      success:\n        # Custom response items wrapped as HTTP headers to be injected in the request\n        headers:\n          \"my-custom-header\":\n            # One-of: plain, json, wristband.\n            plain: { \u2026 }\n\n        # Custom response items wrapped as envoy dynamic metadata.\n        dynamicMetadata:\n          # One-of: plain, json, wristband.\n          \"my-custom-dyn-metadata\":\n            json: { \u2026 }\n\n    # Rules for post-authorization callback requests to external services.\n    # Triggered regardless of the result of the authorization request.\n    callbacks:\n      \"my-webhook\":\n        http: { \u2026 }\n\n    # Explicit defaults. Used in policies that target a Gateway object to express default rules to be enforced on\n    # routes that lack a more specific policy attached to.\n    # Mutually exclusive with `overrides` and with declaring the `rules`, `when` and `patterns` at the top-level of\n    # the spec.\n    defaults:\n      rules:\n        authentication: { \u2026 }\n        metadata: { \u2026 }\n        authorization: { \u2026 }\n        response: { \u2026 }\n        callbacks: { \u2026 }\n      when: [\u2026]\n      patterns: { \u2026 }\n\n    # Overrides. Used in policies that target a Gateway object to be enforced on all routes linked to the gateway,\n    # thus also overriding any more specific policy occasionally attached to any of those routes.\n    # Mutually exclusive with `defaults` and with declaring `rules`, `when` and `patterns` at the top-level of\n    # the spec.\n    overrides:\n      rules:\n        authentication: { \u2026 }\n        metadata: { \u2026 }\n        authorization: { \u2026 }\n        response: { \u2026 }\n        callbacks: { \u2026 }\n      when: [\u2026]\n      patterns: { \u2026 }\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/dnspolicy/","title":"The DNSPolicy Custom Resource Definition (CRD)","text":"<ul> <li>DNSPolicy</li> <li>DNSPolicySpec</li> <li>excludeAddresses</li> <li>ProviderRefs</li> <li>HealthCheckSpec</li> <li>LoadBalancingSpec<ul> <li>LoadBalancingWeighted</li> <li>CustomWeight</li> <li>LoadBalancingGeo</li> </ul> </li> <li>DNSPolicyStatus</li> <li>HealthCheckStatus</li> </ul>"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicy","title":"DNSPolicy","text":"Field Type Required Description <code>spec</code> DNSPolicySpec Yes The specification for DNSPolicy custom resource <code>status</code> DNSPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicyspec","title":"DNSPolicySpec","text":"Field Type Required Description <code>targetRef</code> Gateway API LocalPolicyTargetReferenceWithSectionName  Yes Reference to a Kubernetes resource that the policy attaches to <code>healthCheck</code> HealthCheckSpec No HealthCheck spec <code>loadBalancing</code> LoadBalancingSpec No LoadBalancing Spec <code>providerRefs</code> ProviderRefs Yes array of references to providers. (currently limited to max 1)"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#providerrefs","title":"ProviderRefs","text":"Field Type Required Description <code>providerRefs</code> []ProviderRef Yes max 1 reference. This is an array of providerRef that points to a local secret(s) that contains the required provider auth values"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#providerref","title":"ProviderRef","text":"Field Type Required Description <code>name</code> String Yes Name of the secret in the same namespace that contains the provider credentials"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#excludeaddresses","title":"ExcludeAddresses","text":"Field Type Required Description <code>excludeAddresses</code> []String No set of hostname, CIDR or IP Addresses to exclude from the DNS Provider"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#healthcheckspec","title":"HealthCheckSpec","text":"Field Type Required Description <code>name</code> String Yes Name of the secret in the same namespace that contains the provider credentials -------------------- ------------ :------------: ----------------------------------------------------------------------------------------------------------- <code>path</code> String Yes Path is the path to append to the host to reach the expected health check. Must start with \"?\" or \"/\", contain only valid URL characters and end with alphanumeric char or \"/\". For example \"/\" or \"/healthz\" are common <code>port</code> Number Yes Port to connect to the host on. Must be either 80, 443 or 1024-49151 <code>protocol</code> String Yes Protocol to use when connecting to the host, valid values are \"HTTP\" or \"HTTPS\" <code>failureThreshold</code> Number Yes FailureThreshold is a limit of consecutive failures that must occur for a host to be considered unhealthy <code>interval</code> Duration Yes Interval defines how frequently this probe should execute <code>additionalHeadersRef</code> String No AdditionalHeadersRef refers to a secret that contains extra headers to send in the probe request, this is primarily useful if an authentication token is required by the endpoint. <code>allowInsecureCertificate</code> Boolean No AllowInsecureCertificate will instruct the health check probe to not fail on a self-signed or otherwise invalid SSL certificate this is primarily used in development or testing environments"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#loadbalancingspec","title":"LoadBalancingSpec","text":"Field Type Required Description <code>defaultGeo</code> Boolean Yes Specifies if this is the default geo <code>geo</code> String Yes Geo value to apply to geo endpoints <code>weight</code> Number No Weight value to apply to weighted endpoints default: 120"},{"location":"kuadrant-operator/doc/reference/dnspolicy/#dnspolicystatus","title":"DNSPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource. <code>healthCheck</code> HealthCheckStatus HealthCheck status. <code>recordConditions</code> [String][]Kubernetes meta/v1.Condition Status of individual DNSRecords owned by this policy."},{"location":"kuadrant-operator/doc/reference/dnspolicy/#healthcheckstatus","title":"HealthCheckStatus","text":"Field Type Description <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/dnspolicy/#high-level-example","title":"High-level example","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-dns-policy\nspec:\n  # reference to an existing networking resource to attach the policy to\n  # it can only be a Gateway API Gateway resource\n  # it can only refer to objects in the same namespace as the DNSPolicy\n  # it can target a specific listener using sectionName\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: mygateway\n    sectionName: api # (optional) if not set policy applies to all listeners that do not have a policy attached directly\n\n  # reference to an existing secret resource containing provider credentials and configuration\n  # it can only refer to Secrets in the same namespace as the DNSPolicy that have the type kuadrant.io/(provider) e.g kuadrant.io/aws\n  providerRefs:\n\n    - name: my-aws-credentials\n\n  # (optional) loadbalancing specification\n  # use it for providing the specification of how dns will be configured in order to provide balancing of requests across multiple clusters. If not configured, a simple A or CNAME record will be created. If you have a policy with no loadbalancing defined and want to move to a loadbalanced configuration, you will need to delete and re-create the policy.\n  loadBalancing:\n    # is this the default geo to be applied to records. It is important that you set the default geo flag to true **Only** for the GEO value you wish to act as the catchall GEO, you should not set multiple GEO values as default for a given targeted listener. Example: policy 1 targets listener 1 with a geo of US and sets default to true. Policy 2 targets a listener on another cluster and set the geo to EU and default to false. It is fine for policies in the same default GEO to set the value to true. The main thing is to have only one unique GEO set as the default for any shared listener hostname.\n    defaultGeo: true\n    # weighted specification. This will apply the given weight to the records created based on the targeted gateway listeners. If you have multiple gateways that share a listener host, you can set different weight values to influence how much traffic will be brought to a given gateway.\n    weight: 100\n    # This is the actual GEO location to set for records created by this policy. This can and should be different if you have multiple gateways across multiple geographic areas.\n\n    # AWS: To see all regions supported by AWS Route 53, please see the official (documentation)[https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values-geo.html]. With Route 53 when setting a continent code use a \"GEO-\" prefix otherwise it will be considered a country code.\n\n    # GCP: To see all regions supported by GCP Cloud DNS, please see the official (documentation)[https://cloud.google.com/compute/docs/regions-zones]\n\n    #To see the different values you can use for the geo based DNS with Azure take a look at the following (documentation)[https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-geographic-regions]\n    geo: IE\n\n  # (optional) health check specification\n  # health check probes with the following specification will be created for each DNS target, these probes constantly check that the endpoint can be reached. They will flag an unhealthy endpoint in the status. If no DNSRecord has yet been published and the endpoint is unhealthy, the record will not be published until the health check passes.\n  healthCheck:\n    # the path on the listener host(s) that you want to check.\n    path: /health\n    # how many times does the health check need to fail before unhealthy.\n    failureThreshold: 3\n    # how often should it be checked.\n    interval: 5min\n    # additionalHeadersRef is reference to a local secret with a set of key value pairs to be used as headers when sending the health check request.\n    additionalHeadersRef:\n      name: headers\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/kuadrant/","title":"The Kuadrant Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrant","title":"kuadrant","text":"Field Type Required Description <code>spec</code> KuadrantSpec No Blank specification <code>status</code> KuadrantStatus No The status for the custom resources."},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrantspec","title":"KuadrantSpec","text":"<p>Currently blank specification.</p>"},{"location":"kuadrant-operator/doc/reference/kuadrant/#kuadrantstatus","title":"KuadrantStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/","title":"The RateLimitPolicy Custom Resource Definition (CRD)","text":""},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicy","title":"RateLimitPolicy","text":"Field Type Required Description <code>spec</code> RateLimitPolicySpec Yes The specification for RateLimitPolicy custom resource <code>status</code> RateLimitPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicyspec","title":"RateLimitPolicySpec","text":"Field Type Required Description <code>targetRef</code> LocalPolicyTargetReferenceWithSectionName Yes Reference to a Kubernetes resource that the policy attaches to. For more info <code>defaults</code> RateLimitPolicyCommonSpec No Default limit definitions. This field is mutually exclusive with the <code>limits</code> field <code>overrides</code> RateLimitPolicyCommonSpec No Overrides limit definitions. This field is mutually exclusive with the <code>limits</code> field and <code>defaults</code> field. This field is only allowed for policies targeting <code>Gateway</code> in <code>targetRef.kind</code> <code>limits</code> MapLimit&gt; No Limit definitions. This field is mutually exclusive with the <code>defaults</code> field"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#localpolicytargetreferencewithsectionname","title":"LocalPolicyTargetReferenceWithSectionName","text":"Field Type Required Description <code>LocalPolicyTargetReference</code> LocalPolicyTargetReference Yes Reference to a local policy target. <code>sectionName</code> SectionName No Section name for further specificity (if needed)."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#localpolicytargetreference","title":"LocalPolicyTargetReference","text":"Field Type Required Description <code>group</code> <code>Group</code> Yes Group of the target resource. <code>kind</code> <code>Kind</code> Yes Kind of the target resource. <code>name</code> <code>ObjectName</code> Yes Name of the target resource."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#sectionname","title":"SectionName","text":"Field Type Required Description SectionName v1.SectionName (String) Yes SectionName is the name of a section in a Kubernetes resource. In the following resources, SectionName is interpreted as the following:  Gateway: Listener name HTTPRoute: HTTPRouteRule name* Service: Port name ### RateLimitPolicyCommonSpec Field Type Required Description <code>when</code> []Predicate No List of dynamic predicates to activate the policy. All expression must evaluate to true for the policy to be applied <code>limits</code> MapLimit&gt; No Explicit Limit definitions. This field is mutually exclusive with RateLimitPolicySpec <code>limits</code> field"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#predicate","title":"Predicate","text":"Field Type Required Description <code>predicate</code> String Yes Defines one CEL expression that must be evaluated to bool"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#counter","title":"Counter","text":"Field Type Required Description <code>expression</code> String Yes Defines one CEL expression that will be used as rate limiting counter"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#limit","title":"Limit","text":"Field Type Required Description <code>rates</code> []RateLimit No List of rate limits associated with the limit definition <code>counters</code> []Counter No List of rate limit counter qualifiers. Items must be a valid Well-known attribute. Each distinct value resolved in the data plane starts a separate counter for each rate limit. <code>when</code> []Predicate No List of dynamic predicates to activate the limit. All expression must evaluate to true for the limit to be applied"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimit","title":"RateLimit","text":"Field Type Required Description <code>limit</code> Number Yes Maximum value allowed within the given period of time (duration) <code>window</code> String Yes The period of time that the limit applies. Follows Gateway API Duration format"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#ratelimitpolicystatus","title":"RateLimitPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []ConditionSpec List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#conditionspec","title":"ConditionSpec","text":"<ul> <li>The lastTransitionTime field provides a timestamp for when the entity last transitioned from one status to another.</li> <li>The message field is a human-readable message indicating details about the transition.</li> <li>The reason field is a unique, one-word, CamelCase reason for the condition\u2019s last transition.</li> <li>The status field is a string, with possible values True, False, and Unknown.</li> <li>The type field is a string with the following possible values:<ul> <li>Available: the resource has successfully configured;</li> </ul> </li> </ul> Field Type Description <code>type</code> String Condition Type <code>status</code> String Status: True, False, Unknown <code>reason</code> String Condition state reason <code>message</code> String Condition state description <code>lastTransitionTime</code> Timestamp Last transition timestamp"},{"location":"kuadrant-operator/doc/reference/ratelimitpolicy/#high-level-example","title":"High-level example","text":"<pre><code>apiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: my-rate-limit-policy\nspec:\n  # Reference to an existing networking resource to attach the policy to. REQUIRED.\n  # It can be a Gateway API HTTPRoute or Gateway resource.\n  # It can only refer to objects in the same namespace as the RateLimitPolicy.\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute / Gateway\n    name: myroute / mygateway\n\n  # The limits definitions to apply to the network traffic routed through the targeted resource.\n  # Equivalent to if otherwise declared within `defaults`.\n  limits:\n    \"my_limit\":\n      # The rate limits associated with this limit definition. REQUIRED.\n      # E.g., to specify a 50rps rate limit, add `{ limit: 50, duration: 1, unit: secod }`\n      rates: [\u2026]\n\n      # Counter qualifiers.\n      # Each dynamic value in the data plane starts a separate counter, combined with each rate limit.\n      # E.g., to define a separate rate limit for each user name detected by the auth layer, add `metadata.filter_metadata.envoy\\.filters\\.http\\.ext_authz.username`.\n      # Check out Kuadrant RFC 0002 (https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md) to learn more about the Well-known Attributes that can be used in this field.\n      counters: [\u2026]\n\n      # Additional dynamic conditions to trigger the limit.\n      # Use it for filtering attributes not supported by HTTPRouteRule or with RateLimitPolicies that target a Gateway.\n      # Check out Kuadrant RFC 0002 (https://github.com/Kuadrant/architecture/blob/main/rfcs/0002-well-known-attributes.md) to learn more about the Well-known Attributes that can be used in this field.\n      when: [\u2026]\n\n    # Explicit defaults. Used in policies that target a Gateway object to express default rules to be enforced on\n    # routes that lack a more specific policy attached to.\n    # Mutually exclusive with `overrides` and with declaring `limits` at the top-level of the spec.\n    defaults:\n      limits: { \u2026 }\n\n    # Overrides. Used in policies that target a Gateway object to be enforced on all routes linked to the gateway,\n    # thus also overriding any more specific policy occasionally attached to any of those routes.\n    # Mutually exclusive with `defaults` and with declaring `limits` at the top-level of the spec.\n    overrides:\n      limits: { \u2026 }\n</code></pre>"},{"location":"kuadrant-operator/doc/reference/tlspolicy/","title":"The TLSPolicy Custom Resource Definition (CRD)","text":"<ul> <li>TLSPolicy</li> <li>TLSPolicySpec</li> <li>TLSPolicyStatus</li> </ul>"},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicy","title":"TLSPolicy","text":"Field Type Required Description <code>spec</code> TLSPolicySpec Yes The specification for TLSPolicy custom resource <code>status</code> TLSPolicyStatus No The status for the custom resource"},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicyspec","title":"TLSPolicySpec","text":"Field Type Required Description <code>targetRef</code> Gateway API LocalPolicyTargetReference Yes Reference to a Kuberentes resource that the policy attaches to <code>issuerRef</code> CertManager meta/v1.ObjectReference Yes IssuerRef is a reference to the issuer for the created certificate <code>commonName</code> String No CommonName is a common name to be used on the created certificate <code>duration</code> Kubernetes meta/v1.Duration No The requested 'duration' (i.e. lifetime) of the created certificate. <code>renewBefore</code> Kubernetes meta/v1.Duration No How long before the currently issued certificate's expiry cert-manager should renew the certificate. <code>usages</code> []CertManager v1.KeyUsage No Usages is the set of x509 usages that are requested for the certificate. Defaults to <code>digital signature</code> and <code>key encipherment</code> if not specified <code>revisionHistoryLimit</code> Number No RevisionHistoryLimit is the maximum number of CertificateRequest revisions that are maintained in the Certificate's history <code>privateKey</code> CertManager meta/v1.CertificatePrivateKey No Options to control private keys used for the Certificate <p>IssuerRef certmanmetav1.ObjectReference</p>"},{"location":"kuadrant-operator/doc/reference/tlspolicy/#tlspolicystatus","title":"TLSPolicyStatus","text":"Field Type Description <code>observedGeneration</code> String Number of the last observed generation of the resource. Use it to check if the status info is up to date with latest resource spec. <code>conditions</code> []Kubernetes meta/v1.Condition List of conditions that define that status of the resource."},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/","title":"Enforcing authentication &amp; authorization with Kuadrant AuthPolicy","text":"<p>This tutorial walks you through the process of setting up a local Kubernetes cluster with Kuadrant where you will protect Gateway API endpoints by declaring Kuadrant AuthPolicy custom resources.</p> <p>Three AuthPolicies will be declared:</p> Use case AuthPolicies App developer 2 AuthPolicies targeting a HTTPRoute that routes traffic to a sample \"Toy Store\" application \u2192 enforce API key authentication to all requests in this route; require API key owners to be mapped to <code>groups:admins</code> metadata to access a specific HTTPRouteRule of the route. Platform engineer use-case 1 AuthPolicy targeting the <code>kuadrant-ingressgateway</code> Gateway \u2192 enforces a trivial \"deny-all\" policy that locks down any other HTTPRoute attached to the Gateway. <p>Topology:</p> <pre><code>                            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502        (Gateway)        \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                            \u2502         external        \u2502\u25c4\u2500\u2500\u2502 (AuthPolicy)  \u2502\n                            \u2502                         \u2502   \u2502    gw-auth    \u2502\n                            \u2502            *            \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u25b2                      \u25b2\n                     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502   (HTTPRoute)    \u2502   \u2502   (HTTPRoute)    \u2502\n\u2502  (AuthPolicy)  \u2502\u2500\u2500\u25ba\u2502    toystore      \u2502   \u2502      other       \u2502\n\u2502 toystore-authn \u2502   \u2502                  \u2502   \u2502                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502 api.toystore.com \u2502   \u2502 *.other-apps.com \u2502\n                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u25b2                \u25b2\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            | (HTTPRouteRule) | | (HTTPRouteRule) |   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            |     rule-1      | |     rule-2      |\u25c4\u2500\u2500\u2502   (AuthPolicy)  \u2502\n            |                 | |                 |   \u2502 toystore-admins \u2502\n            | - GET /cars*    | | - /admins*      |   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            | - GET /dolls*   | \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#deploy-the-toy-store-sample-application-persona-app-developer","title":"Deploy the Toy Store sample application (Persona: App developer)","text":"<p>Create the namespace for the toystore API:</p> <p><pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> Deploy the Toy store  <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/kuadrant-operator/refs/heads/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre></p> <p>Create the Toy Store HTTPRoute <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n     app: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches: # rule-1\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/dolls\"\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches: # rule-2\n    - path:\n        type: PathPrefix\n        value: \"/admin\"\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre></p> <p>Export the gateway hostname and port:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <p>Send requests to the application unprotected:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/cars -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/dolls -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/admin -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#protect-the-toy-store-application-persona-app-developer","title":"Protect the Toy Store application (Persona: App developer)","text":"<p>Create AuthPolicies to enforce the following auth rules:</p> <ul> <li>Authentication:</li> <li>All users must present a valid API key</li> <li>Authorization:</li> <li><code>/admin*</code> paths (2nd rule of the HTTPRoute) require user mapped to the <code>admins</code> group (<code>kuadrant.io/groups=admins</code> annotation added to the Kubernetes API key Secret)</li> </ul> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-authn\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  defaults:\n    strategy: merge\n    rules:\n      authentication:\n        \"api-key-authn\":\n          apiKey:\n            selector:\n              matchLabels:\n                app: toystore\n          credentials:\n            authorizationHeader:\n              prefix: APIKEY\n---\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-admins\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-2\n  rules:\n    authorization:\n      \"only-admins\":\n        opa:\n          rego: |\n            groups := split(object.get(input.auth.identity.metadata.annotations, \"kuadrant.io/groups\", \"\"), \",\")\n            allow { groups[_] == \"admins\" }\nEOF\n</code></pre> <p>Create the API keys (must be created in the same namespace as the Kuadrant CR):</p> <pre><code>kubectl apply -n kuadrant-system -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-regular-user\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\nstringData:\n  api_key: iamaregularuser\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-admin-user\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    kuadrant.io/groups: admins\nstringData:\n  api_key: iamanadmin\ntype: Opaque\nEOF\n</code></pre> <p>Send requests to the application protected by Kuadrant:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/cars -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-authn\"\n# x-ext-auth-reason: credential not found\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamaregularuser' http://$KUADRANT_GATEWAY_URL/cars -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamaregularuser' http://$KUADRANT_GATEWAY_URL/admin -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' -H 'Authorization: APIKEY iamanadmin' http://$KUADRANT_GATEWAY_URL/admin -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/auth/auth-for-app-devs-and-platform-engineers/#create-a-default-deny-all-policy-at-the-level-of-the-gateway-persona-platform-engineer","title":"Create a default \"deny-all\" policy at the level of the gateway (Persona: Platform engineer)","text":"<p>Create the policy:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: gw-auth\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  defaults:\n    strategy: atomic\n    rules:\n      authorization:\n        deny-all:\n          opa:\n            rego: \"allow = false\"\n      response:\n        unauthorized:\n          headers:\n            \"content-type\":\n              value: application/json\n          body:\n            value: |\n              {\n                \"error\": \"Forbidden\",\n                \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n              }\nEOF\n</code></pre> <p>The policy won't be effective until there is at least one accepted route not yet protected by another more specific policy attached to it.</p> <p>Create a route that will inherit the default policy attached to the gateway:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: other\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - \"*.other-apps.com\"\nEOF\n</code></pre> <p>Send requests to the route protected by the default policy set at the level of the gateway:</p> <pre><code>curl -H 'Host: foo.other-apps.com' http://$KUADRANT_GATEWAY_URL/ -i\n# HTTP/1.1 403 Forbidden\n# content-type: application/json\n# x-ext-auth-reason: Unauthorized\n# [\u2026]\n#\n# {\n#   \"error\": \"Forbidden\",\n#   \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n# }\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/","title":"Basic DNS","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#basic-dns-setup","title":"Basic DNS setup","text":"<p>The document will cover the most basic DNS setup using the Kuadrant DNSPolicy API. In order to follow this guide, it is expected that you have a cluster setup with the latest version of Kuadrant installed. Also as we are using DNS, it is also important that the Gateways are accessible either via your local network or via the public internet. DNSPolicy will work with any Gateway provider so it is not essential that you have Istio or Envoy Gateway installed, but you do need a Gateway API provider installed. We would recommend using Istio or Envoy Gateway as this will allow you to use some of the other policies provided by Kuadrant.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#gateway-and-httproute-configuration","title":"Gateway and HTTPRoute configuration","text":"<p>With a Gateway provider installed, in order to configure DNS via <code>DNSPolicy</code>, you must first configure a Gateway with a listener that uses a specified hostname. You must also have a HTTPRoute resource attached to this gateway listener. Below are some simple examples of these resources (note we are not using a HTTPS listener for simplicity but that will also work):</p> <p><pre><code>---\nkind: Gateway\napiVersion: gateway.networking.k8s.io/v1\nmetadata:\n  name: external\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      port: 8080\n      hostname: test.example.com\n      protocol: HTTP\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  labels:\n    app: toystore\nspec:\n  parentRefs:\n    - name: external\n  hostnames: [\"test.example.com\"]\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: \"/toy\"\n          method: GET\n        - path:\n            type: Exact\n            value: \"/admin/toy\"\n          method: POST\n        - path:\n            type: Exact\n            value: \"/admin/toy\"\n          method: DELETE\n      backendRefs:\n        - name: toystore\n          port: 80\n</code></pre> With these defined, we are ready to setup DNS via DNSPolicy.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#configure-a-dnsprovider","title":"Configure a DNSProvider","text":"<p>The first step is to configure a DNSProvider. This is a simple kubernetes secret with credentials to access the DNS provider. With Kuadrant we support using <code>AWS Route53, Azure and GCP</code> as DNS providers. It is important that this credential has access to write and read to your DNS zones.</p> <p>More info on the various DNS Providers</p> <p>In this example we will configure an AWS route53 DNS provider:</p> <pre><code>kubectl create secret generic aws-credentials \\\n  --namespace=my-gateway-namespace \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=XXXX \\\n  --from-literal=AWS_REGION=eu-west-1 \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=XXX\n</code></pre> <p>With this in place we can now define our DNSPolicy resource:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: basic-dnspolicy\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external\n  providerRefs:\n\n    - name: aws-credentials\n</code></pre> <p>This resource also needs to be created in the same namespace as your Gateway and the <code>targetRef</code> needs to reference your gateway. When this is done we can check the status of the DNSPolicy and the Gateway to check when it is ready.</p> <pre><code>kubectl wait dnspolicy/basic-dnspolicy -n my-gateway-namespace --for=\"condition=Ready=true\" --timeout=300s\n</code></pre> <p>If you look at the gateway status you should also see:</p> <pre><code>  - lastTransitionTime: \"2024-10-09T11:22:10Z\"\n    message: Object affected by DNSPolicy kuadrant-system/simple-dnspolicy\n    observedGeneration: 1\n    reason: Accepted\n    status: \"True\"\n    type: kuadrant.io/DNSPolicyAffected\n</code></pre> <p>DNS is now setup for your Gateway. After allowing a little time for the DNS propagate to the nameservers, you should be able to test the DNS using a dig command alternatively you can curl your endpoint.</p> <pre><code>dig test.example.com +short\n\ncurl -v test.example.com/toy\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/basic-dns-configuration/#important-considerations","title":"Important Considerations","text":"<p>With this guide, you have learned how to setup the most basic DNSPolicy. DNSPolicy is also capable of setting up advanced DNS record structure to help balance traffic across multiple gateways. With the most basic policy outlined here, you should not apply it to more than one gateway that shares a listener with the same host name. There is one exception to this rule, which is if all your gateways are using IP addresses rather than hostname addresses; in this case DNSPolicy will merge the IPs into a multi-value response. However, if your Gateways are using hostnames, DNSPolicy will set up a simple CNAME record and as there is only one record and CNAMEs cannot have multiple values by definition, one of the DNSPolicies (the last one to attempt to update the provider) will report an error. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/","title":"DNS Health Checks","text":"<p>The DNS health check feature allows you to define a HTTP based health check via the DNSPolicy API that will be executed against targeted gateway listener(s) that have specified none wildcard hostnames. These health checks will flag a published endpoint as healthy or unhealthy based on the defined configuration. When unhealthy an endpoint will not be published if it has not already been published to the DNS provider, will only be unpublished if it is part of a multi-value A record and in all cases can be observable via the DNSPolicy status.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#limitations","title":"Limitations","text":"<ul> <li>We do not currently support a health check being targeted to a <code>HTTPRoute</code> resource: DNSPolicy can only target Gateways. </li> <li>As mentioned above, when a record has been published using the load balancing options (GEO and Weighting) via DNSPolicy, a failing health check will not remove the endpoint record from the provider, this is to avoid an accidental NX-Domain response. If the policy is not using the load balancing options and results in a multiple value A record, then unhealthy IPs will be removed from this A record unless it would result in an empty value set. </li> <li>Health checks will not be added to listeners that define a wildcard hostname E.G (*.example.com) as we currently cannot know which host to use to for the health check.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#configuration-of-health-checks","title":"Configuration of Health Checks","text":"<p>To configure a DNS health check, you need to specify the <code>health check</code> section of the DNSPolicy.</p> <p>Below are some examples of DNSPolicy with health checks defined:</p> <p>1) DNSPolicy with a health check that will be applied to all listeners on a gateway that define a none wildcard hostname</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: gateway-dns\nspec:\n  healthCheck:\n    failureThreshold: 3\n    interval: 5m\n    path: /health\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n</code></pre> <p>2) DNSPolicy with health check  that will be applied for a specific listener with a none wildcard hostname</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-listener-dns\nspec:\n  healthCheck:\n    failureThreshold: 3\n    interval: 5m\n    path: /ok #different path for this listener\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n    sectionName: my-listener #notice the addition of section name here that must match the listener name\n</code></pre> <p>These policies can be combined on a single gateway. The policy with the section name defined will override the gateway policy including the health check.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#sending-additional-headers-with-the-health-check-request","title":"Sending additional headers with the health check request","text":"<p>Sometimes, it may be desirable to send some additional headers with the health check request. For example to send API key or service account token that can be defined in the request headers.</p> <p>To do this you will need to create a secret in the same namespace as the DNSPolicy with the keys and values you wish to send:</p> <pre><code>kubectl create secret generic healthheaders --from-literal=token=supersecret -n my-dns-policy-namespace\n</code></pre> <p>Next you will need to update the DNSPolicy to add a reference to this secret:</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: my-listener-dns\nspec:\n  healthCheck:\n    additionalHeadersRef: #add the following\n      name: healthheaders\n    failureThreshold: 3\n    interval: 5m\n    path: /ok\n  ...\n   targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external  \n    sectionName: my-listener\n</code></pre> <p>The health check requests will now send the key value pairs in the secret as headers when performing a health check request.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#health-check-status","title":"Health Check Status","text":"<p>When all health checks based on a DNSPolicy are passing you will see the following status:</p> <pre><code>    - lastTransitionTime: \"2024-11-14T12:33:13Z\"\n      message: All sub-resources are healthy\n      reason: SubResourcesHealthy\n      status: \"True\"\n      type: SubResourcesHealthy\n</code></pre> <p>If one or more of the health checks are failing you will see a status in the DNSPolicy simiar to the one shown below:</p> <pre><code>   - lastTransitionTime: \"2024-11-15T10:40:15Z\"\n      message: 'DNSPolicy has encountered some issues: not all sub-resources of policy\n        are passing the policy defined health check. Not healthy DNSRecords are: external-t1b '\n      reason: Unknown\n      status: \"False\"\n      type: SubResourcesHealthy\n    observedGeneration: 1\n    recordConditions:\n      t1b.cb.hcpapps.net:\n      - lastTransitionTime: \"2024-11-15T10:40:14Z\"\n        message: 'Not healthy addresses: [aeeba26642f1b47d9816297143e2d260-434484576.eu-west-1.elb.amazonaws.com]'\n        observedGeneration: 1\n        reason: health checksFailed\n        status: \"False\"\n        type: Healthy\n</code></pre> <p>Finally, you can also take a look at the underlying individual health check status by inspecting the <code>dnshealthcheckprobe</code> resource:</p> <p>Note: These resources are for view only interactions as they are controlled by the Kuadrant Operator based on the DNSPolicy API</p> <pre><code>kubectl get dnshealthcheckprobes n my-dns-policy-namespace -o=wide\n</code></pre> <p>If you look at the status of one of these you can see additional information:</p> <pre><code>status:\n  consecutiveFailures: 3\n  healthy: false\n  observedGeneration: 1\n  reason: 'Status code: 503'\n  status: 503\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/dnshealthchecks/#manually-removing-unhealthy-records","title":"Manually removing unhealthy records","text":"<p>If you have a failing health check for one of your gateway listeners and you would like to remove it from the DNS provider, you can do this by deleting the associated DNSRecord resource.</p> <p>Finding the correct record</p> <p>DNSRecord resources are kept in the same namespace as the DNSPolicy that configured and created them.</p> <pre><code>kubectl get dnsrecords.kuadrant.io -n &lt;dns-policy-namespace&gt;\n</code></pre> <p>As shown above, when a health check is failing, the DNSPolicy will show a status for that listener host to surface that failure:</p> <pre><code>recordConditions:\n    t1a.cb.hcpapps.net:\n\n    - lastTransitionTime: \"2024-11-27T14:00:52Z\"\n      message: 'Not healthy addresses: [ae4d131ee5d7b4fb098f4afabf4aba4c-513237325.us-east-1.elb.amazonaws.com]'\n      observedGeneration: 1\n      reason: HealthChecksFailed\n      status: \"False\"\n      type: Healthy\n</code></pre> <p>The DNSRecord resource is named after the gateway and the listener name. So if you have a gateway called <code>ingress</code> and a listener called <code>example</code> you will have a <code>DNSRecord</code> resource named <code>ingress-example</code> in the same namespace as your DNSPolicy. So from this status you can get the hostname and find the associated listener on your gateway. You can then delete the associated DNSRecord resource. </p> <pre><code>kubectl delete dnsrecord.kuadrant.io &lt;gateway-name&gt;-&lt;listener-name&gt; -n &lt;dns policy namespace&gt;\n</code></pre> <p>Removing this resource will remove all of the associated DNS records in the DNS provider and while the health check is failing, the dns operator will not re-publish these records. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/","title":"Gateway DNS configuration for routes attached to a ingress gateway","text":"<p>This tutorial walks you through an example of how to configure DNS for all routes attached to an ingress gateway. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> <li>AWS/Azure or GCP with DNS capabilities.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\nexport KUADRANT_AWS_ACCESS_KEY_ID=xxxx # AWS Key ID with access to manage the DNS Zone ID below\nexport KUADRANT_AWS_SECRET_ACCESS_KEY=xxxx # AWS Secret Access Key with access to manage the DNS Zone ID below\nexport KUADRANT_AWS_DNS_PUBLIC_ZONE_ID=xxxx # AWS Route 53 Zone ID for the Gateway\nexport KUADRANT_ZONE_ROOT_DOMAIN=example.com # Root domain associated with the Zone ID above\n</code></pre> <p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n\n\n### Create a DNS provider secret \nCreate AWS provider secret. You should limit the permissions of this credential to only the zones you want us to access.\n\n```bash\nkubectl -n ${KUADRANT_GATEWAY_NS} create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$KUADRANT_AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$KUADRANT_AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create a gateway using your KUADRANT_ZONE_ROOT_DOMAIN as part of a listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\n      hostname: \"api.${KUADRANT_ZONE_ROOT_DOMAIN}\"    \nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#enable-dns-on-the-gateway","title":"Enable DNS on the gateway","text":"<p>Create a Kuadrant <code>DNSPolicy</code> to configure DNS:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-dns\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    name: ${KUADRANT_GATEWAY_NAME}\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:  \n\n    - name: aws-credentials\nEOF\n</code></pre> <p>Check that the <code>DNSPolicy</code> has been Accepted and Enforced (This mat take a few minutes):</p> <pre><code>kubectl get dnspolicy ${KUADRANT_GATEWAY_NAME}-dns -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#deploy-the-toystore-app","title":"Deploy the Toystore app","text":"<p>Create the namespace for the Toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy the Toystore app to the developer namespace:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#setup-toystore-application-httproute","title":"Setup Toystore application HTTPRoute","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n    deployment: toystore\n    service: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - \"api.${KUADRANT_ZONE_ROOT_DOMAIN}\"\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    backendRefs:\n    - name: toystore\n      port: 80  \nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/gateway-dns/#verify-dns-works-by-sending-requests","title":"Verify DNS works by sending requests","text":"<p>Verify DNS using dig you should see your IP address:</p> <pre><code>dig api.${KUADRANT_ZONE_ROOT_DOMAIN} +short\n</code></pre> <p>Verify DNS using curl you should get a status 200:</p> <pre><code>curl http://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars -i\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/","title":"Load Balanced DNS","text":""},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#overview","title":"Overview","text":"<p>This document will show you how to setup a load balanced DNS configuration using the (DNSPolicy)[https://docs.kuadrant.io/latest/kuadrant-operator/doc/reference/dnspolicy/] API. When we say \"load balanced\", this means we configure the DNS provider (AWS, GCP etc) to return different gateway/loadbalancer addresses to queries from DNS clients based on specific weighting and geo location configuration.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#when-should-i-use-a-load-balanced-dns-policy","title":"When should I use a load balanced DNS policy?","text":"<p>It is most useful to use the load balancing options when targeting multiple gateways that share a listener host E.G (api.example.com). It is also perfectly valid to use it when you only have a single gateway; this provides the benefit of allowing you to easily expand beyond this single gateway for a given shared hostname. It is worth knowing that the load balanced DNSpolicy comes with a relatively small additional cost of some added records and lookups during DNS resolution vs a \"simple\" DNSPolicy with no load balancing specified as the latter only sets up a simple A or CNAME record. So in summary if you expect to need multiple gateways for a given listener host then you should take advantage of the load balanced option.</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#important-considerations","title":"Important Considerations","text":"<ul> <li>When using a DNSPolicy with a load balanced configuration, all DNSPolicies effecting a listener with the same hostname should have load balanced options set. Without the load balanced configuration, Kuadrant's dns controller will try to set up only a simple A or CNAME record.</li> <li>When setting geographic configuration, only ever set one unique GEO as the default GEO across all instances of DNSPolicy targeting a listener with the same hostname. If you set different defaults for a single listener hostname, the dns controllers will constantly attempt to bring the default into the state they each feel is correct. </li> <li>If you want different load balancing options for a particular listener in a gateway, you can target that listener directly with DNSPolicy via the targetRef sectionName property.</li> <li>If you do not use the load balanced configuration, a simple single A or CNAME record is set up. Later if you need to move to load balanced, you will need to delete and recreate your policy.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#dns-provider-setup","title":"DNS Provider Setup","text":"<p>A DNSPolicy acts against a target Gateway or a target listener within a gateway by processing the hostnames on the targeted listeners. Using these it can create dns records using the address exposed in the Gateway's status block. In order for Kuadrant's DNS component to do this, it must be able to access and know which DNS provider to use. This is done through the creation of a dns provider secret containing the needed credentials and the provider identifier.</p> <p>(Learn more about how to setup a DNS Provider)[https://docs.kuadrant.io/latest/dns-operator/docs/provider/]</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#loadbalanced-dnspolicy-creation-and-attachment","title":"LoadBalanced DNSPolicy creation and attachment","text":"<p>Once an appropriate provider credential is configured, we can now create and attach a DNSPolicy to start managing DNS for the listeners on our Gateway. Below is an example.</p> <pre><code>apiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: prod-web\n  namespace: ingress-gateway\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    sectionName: listenerName \n  providerRef:\n    name: my-aws-credentials \n  loadBalancing:\n    weight: 120 \n    geo: GEO-EU \n    defaultGeo: true\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#load-balancing-section","title":"Load Balancing section","text":"<p>This section must be filled out and indicates to the dns component that the targets of this policy should be setup to handle more than one gateway. It is required to define values for the weighted and geo options. These values are used for the records created by the policy controller based on the target gateway. To read more detail about each of the fields in the loadbalanced section take a look at DNS Overview</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#locations-supported-per-dns-provider","title":"Locations supported per DNS provider","text":"Supported AWS GCP Continents Country codes States Regions"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#continents-and-country-codes-supported-by-aws-route-53","title":"Continents and country codes supported by AWS Route 53","text":"<p>:Note:  For more information please the official AWS documentation </p> <p>To see all regions supported by AWS Route 53, please see the official (documentation)[https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/resource-record-sets-values-geo.html]. With Route 53 when setting a continent code use a \"GEO-\" prefix otherwise it will be considered a country code. </p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#regions-supported-by-gcp-cloud-dns","title":"Regions supported by GCP Cloud DNS","text":"<p>To see all regions supported by GCP Cloud DNS, please see the official (documentation)[https://cloud.google.com/compute/docs/regions-zones]</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#regions-and-countries-supported-by-azure-cloud-dns","title":"Regions and Countries supported by Azure Cloud DNS","text":"<p>To see the different values you can use for the geo based DNS with Azure take a look at the following (documentation)[https://learn.microsoft.com/en-us/azure/traffic-manager/traffic-manager-geographic-regions]</p>"},{"location":"kuadrant-operator/doc/user-guides/dns/load-balanced-dns/#moving-from-non-load-balanced-to-load-balanced-or-vice-versa","title":"Moving from non load balanced to load balanced or vice versa","text":"<p>It is possible to update a DNSPolicy that has no load balancing options set to one that has these options set and vice versa. Underneath, the DNS Operator will remove the existing records and replace them with the correct set of records based on your configuration. It is important however that when using DNSPolicy across multiple Gateways that share a hostname, the DNSPolicies targeting a listener with a shared hostname all use a load balancing configuration (or absence thereof). It is invalid to have two DNSPolcies targeting a listener with a shared hostname that use different dns <code>strategies</code>. Doing so will cause one of the DNSPolicies to fail to be enforced and report an error caused by an inability to bring the DNS records into a consistent state.</p> <p>Example:</p> <p>If you have <code>gateway1</code> with listener <code>example</code> with a hostname of <code>example.com</code> and you have a separate gateway <code>gateway2</code> with the same listener definition as <code>gateway1</code> (perhaps on a different cluster in a different region), you should ensure that the DNSPolcies targeting these listeners are both using a <code>loadbalanced</code> configuration. Below is an example of valid and invalid configuration. </p> <p>Valid Config</p> <p>Given a gateway deployed on two different cluster in two different locations:</p> <pre><code># example gateway\nkind: Gateway\napiVersion: gateway.networking.k8s.io/v1\nmetadata:\n  name: api-gateway\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: example\n      port: 80\n      hostname: 'api.example.com'\n      protocol: HTTP\n</code></pre> <pre><code># gateway 1\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway1\nspec:\n  loadBalancing:\n    weight: 130\n    geo: GEO-EU\n    defaultGeo: true\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n\n# gateway 2\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway2\nspec:\n  loadBalancing:\n    weight: 130\n    geo: US\n    defaultGeo: false\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n</code></pre> <p>Invalid Config</p> <pre><code># gateway 1\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway1\nspec:\n  loadBalancing:\n    weight: 130\n    geo: GEO-EU\n    defaultGeo: true\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n\n# gateway 2\n\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: dnspolicy-gateway2\nspec: #notice no loadbalancing defined\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: api-gateway\n    sectionName: example\n  providerRefs:\n\n    - name: aws-provider-credentials\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/","title":"Secure, protect, and connect APIs with Kuadrant","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#overview","title":"Overview","text":"<p>This tutorial walks you through using Kuadrant to secure, protect, and connect an API exposed by a Gateway (Kubernetes Gateway API) from the personas platform engineer and application developer. For more information on the different personas please see the Gateway API documentation </p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> <li>AWS/Azure or GCP with DNS capabilities.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#set-the-environment-variables","title":"Set the environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\nexport KUADRANT_AWS_ACCESS_KEY_ID=xxxx # AWS Key ID with access to manage the DNS Zone ID below\nexport KUADRANT_AWS_SECRET_ACCESS_KEY=xxxx # AWS Secret Access Key with access to manage the DNS Zone ID below\nexport KUADRANT_AWS_DNS_PUBLIC_ZONE_ID=xxxx # AWS Route 53 Zone ID for the Gateway\nexport KUADRANT_ZONE_ROOT_DOMAIN=example.com # Root domain associated with the Zone ID above\nexport KUADRANT_CLUSTER_ISSUER_NAME=self-signed # Name for the ClusterIssuer\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#set-up-a-dns-provider","title":"Set up a DNS Provider","text":"<p>The DNS provider declares credentials to access the zone(s) that Kuadrant can use to set up DNS configuration. Ensure that this credential only has access to the zones you want Kuadrant to manage via <code>DNSPolicy</code></p> <p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create the secret credentials in the same namespace as the Gateway - these will be used to configure DNS:</p> <pre><code>kubectl -n ${KUADRANT_GATEWAY_NS} create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$KUADRANT_AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$KUADRANT_AWS_SECRET_ACCESS_KEY\n</code></pre> <p>Before adding a TLS issuer, create the secret credentials in the cert-manager namespace:</p> <pre><code>kubectl -n cert-manager create secret generic aws-credentials \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=$KUADRANT_AWS_ACCESS_KEY_ID \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=$KUADRANT_AWS_SECRET_ACCESS_KEY\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#deploy-the-toystore-app","title":"Deploy the Toystore app","text":"<p>Create the namespace for the Toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy the Toystore app to the developer namespace:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#add-a-tls-issuer","title":"Add a TLS issuer","text":"<p>To secure communication to the Gateways, define a TLS issuer for TLS certificates.</p> <p>Note</p> <p>This example uses Let's Encrypt, but you can use any issuer supported by <code>cert-manager</code>.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: cert-manager.io/v1\nkind: ClusterIssuer\nmetadata:\n  name: ${KUADRANT_CLUSTER_ISSUER_NAME}\nspec:\n  selfSigned: {}\nEOF\n</code></pre> <p>Wait for the <code>ClusterIssuer</code> to become ready.</p> <pre><code>kubectl wait clusterissuer/${KUADRANT_CLUSTER_ISSUER_NAME} --for=condition=ready=true\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#deploy-a-gateway","title":"Deploy a Gateway","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n    gatewayClassName: istio\n    listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All \n      hostname: \"api.${KUADRANT_ZONE_ROOT_DOMAIN}\"\n      name: api\n      port: 443\n      protocol: HTTPS\n      tls:\n        certificateRefs:\n        - group: \"\"\n          kind: Secret\n          name: api-${KUADRANT_GATEWAY_NAME}-tls\n        mode: Terminate\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}'\n</code></pre> <p>Check the status of the listener, you will see that it is not yet programmed or ready to accept traffic due to bad TLS configuration. This will be fixed in the next step with the <code>TLSPolicy</code>:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.listeners[0].conditions[?(@.type==\"Programmed\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#secure-and-protect-the-gateway-with-auth-rate-limit-and-dns-policies","title":"Secure and protect the Gateway with Auth, Rate Limit, and DNS policies.","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#deploy-the-gateway-tls-policy","title":"Deploy the gateway TLS policy","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-tls\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    name: ${KUADRANT_GATEWAY_NAME}\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  issuerRef:\n    group: cert-manager.io\n    kind: ClusterIssuer\n    name: ${KUADRANT_CLUSTER_ISSUER_NAME}\nEOF\n</code></pre> <p>Check that the <code>TLSpolicy</code> has an Accepted and Enforced status (This may take a few minutes for certain provider e.g Lets Encrypt):</p> <pre><code>kubectl get tlspolicy ${KUADRANT_GATEWAY_NAME}-tls -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#setup-toystore-application-httproute","title":"Setup Toystore application HTTPRoute","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\n  labels:\n    deployment: toystore\n    service: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - \"api.${KUADRANT_ZONE_ROOT_DOMAIN}\"\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/cars\"\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/health\"    \n    backendRefs:\n    - name: toystore\n      port: 80  \nEOF\n</code></pre> <p>While the <code>Gateway</code> is now deployed, it currently has exposed endpoints. The next steps will be defining an <code>AuthPolicy</code> to set up a default <code>403</code> response for any unprotected endpoints, as well as a <code>RateLimitPolicy</code> to set up a default unrealistic low global limit to further protect any exposed endpoints.</p>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#set-the-deny-all-gateway-authpolicy","title":"Set the <code>Deny all</code> Gateway AuthPolicy","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-auth\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  defaults:\n   when:\n\n     - predicate: \"request.path != '/health'\"\n   rules:\n    authorization:\n      deny-all:\n        opa:\n          rego: \"allow = false\"\n    response:\n      unauthorized:\n        headers:\n          \"content-type\":\n            value: application/json\n        body:\n          value: |\n            {\n              \"error\": \"Forbidden\",\n              \"message\": \"Access denied by default by the gateway operator. If you are the administrator of the service, create a specific auth policy for the route.\"\n            }\nEOF\n</code></pre> <p>Check that the <code>AuthPolicy</code> has Accepted and Enforced status:</p> <pre><code>kubectl get authpolicy ${KUADRANT_GATEWAY_NAME}-auth -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#deploy-the-low-limit-gateway-ratelimitpolicy","title":"Deploy the <code>low-limit</code> Gateway RateLimitPolicy","text":"<pre><code>kubectl apply -f  - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-rlp\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: ${KUADRANT_GATEWAY_NAME}\n  defaults:\n    limits:\n      \"low-limit\":\n        rates:\n\n        - limit: 1\n          window: 10s\nEOF\n</code></pre> <p>Check that the <code>RateLimitPolicy</code> has Accepted and Enforced status:</p> <pre><code>kubectl get ratelimitpolicy ${KUADRANT_GATEWAY_NAME}-rlp -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#create-the-gateway-dnspolicy","title":"Create the Gateway DNSPolicy","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: DNSPolicy\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}-dnspolicy\n  namespace: ${KUADRANT_GATEWAY_NS}\nspec:\n  healthCheck:\n    failureThreshold: 3\n    interval: 1m\n    path: /health\n  loadBalancing:\n    defaultGeo: true\n    geo: GEO-NA\n    weight: 120\n  targetRef:\n    name: ${KUADRANT_GATEWAY_NAME}\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  providerRefs:\n\n  - name: aws-credentials # Secret created earlier\nEOF\n</code></pre> <p>Check that the <code>DNSPolicy</code> has been Accepted and Enforced (This mat take a few minutes):</p> <pre><code>kubectl get dnspolicy ${KUADRANT_GATEWAY_NAME}-dnspolicy -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#dns-health-checks","title":"DNS Health checks","text":"<p>DNS Health checks has been enabled on the DNSPolicy. These health checks will flag a published endpoint as healthy or unhealthy based on the defined configuration. When unhealthy an endpoint will not be published if it has not already been published to the DNS provider, will only be unpublished if it is part of a multi-value A record and in all cases can be observable via the DNSPolicy status. For more information see DNS Health checks documentation</p> <p>Check the status of the health checks as follow:</p> <pre><code>kubectl get dnspolicy ${KUADRANT_GATEWAY_NAME}-dnspolicy -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"SubResourcesHealthy\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#test-the-low-limit-and-deny-all-policies","title":"Test the <code>low-limit</code> and <code>deny all</code> policies","text":"<pre><code>while :; do curl -k --write-out '%{http_code}\\n' --silent --output /dev/null  \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#override-the-gateways-deny-all-authpolicy","title":"Override the Gateway's deny-all AuthPolicy","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#set-up-api-key-auth-flow","title":"Set up API key auth flow","text":"<p>Set up an example API key for the new users:</p> <pre><code>export KUADRANT_SYSTEM_NS=$(kubectl get kuadrant -A -o jsonpath=\"{.items[0].metadata.namespace}\")\n</code></pre> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  namespace: ${KUADRANT_SYSTEM_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  namespace: ${KUADRANT_SYSTEM_NS}\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre> <p>Create a new AuthPolicy in a different namespace that overrides the <code>Deny all</code> created earlier:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-auth\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  defaults:\n   when:\n\n     - predicate: \"request.path != '/health'\"  \n   rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#override-low-limit-ratelimitpolicy-for-specific-users","title":"Override <code>low-limit</code> RateLimitPolicy for specific users","text":"<p>Create a new <code>RateLimitPolicy</code> in a different namespace to override the default <code>RateLimitPolicy</code> created earlier:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-rlp\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"general-user\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      counters:\n      - expression: auth.identity.userid\n      when:\n      - predicate: \"auth.identity.userid != 'bob'\"\n    \"bob-limit\":\n      rates:\n      - limit: 2\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre> <p>The <code>RateLimitPolicy</code> should be Accepted and Enforced:</p> <pre><code>kubectl get ratelimitpolicy -n ${KUADRANT_DEVELOPER_NS} toystore-rlp -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Enforced\")].message}'\n</code></pre> <p>Check the status of the <code>HTTPRoute</code>, is now affected by the <code>RateLimitPolicy</code> in the same namespace:</p> <pre><code>kubectl get httproute toystore -n ${KUADRANT_DEVELOPER_NS} -o=jsonpath='{.status.parents[0].conditions[?(@.type==\"kuadrant.io/RateLimitPolicyAffected\")].message}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#test-the-new-rate-limit-and-auth-policy","title":"Test the new Rate limit and Auth policy","text":""},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#send-requests-as-alice","title":"Send requests as Alice:","text":"<p>You should see status <code>200</code> every second for 5 second followed by stats <code>429</code> every second for 5 seconds</p> <pre><code>while :; do curl -k --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#send-requests-as-bob","title":"Send requests as Bob:","text":"<p>You should see status <code>200</code> every second for 2 seconds followed by stats <code>429</code> every second for 8 seconds</p> <pre><code>while :; do curl -k --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' \"https://api.$KUADRANT_ZONE_ROOT_DOMAIN/cars\" | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/full-walkthrough/secure-protect-connect/#next-steps","title":"Next Steps","text":"<ul> <li>mTLS Configuration</li> <li>Configure Observability of Gateway and Kuadrant components</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/monitors/","title":"Configure Observability of Gateway and Kuadrant components","text":""},{"location":"kuadrant-operator/doc/user-guides/observability/monitors/#overview","title":"Overview","text":"<p>This guide includes steps to enable the Kuadrant observability feature. This feature provides an integration between the Kuadrant components (including any gateways) and the Prometheus Operator if you have it installed in your cluster. The feature works by creating a set of ServiceMonitors and PodMonitors, which instruct prometheus to scrape metrics from the Kuadrant and Gateway components. The scraped metrics are used in the Example Dashboards and Alerts.</p>"},{"location":"kuadrant-operator/doc/user-guides/observability/monitors/#prerequisites","title":"Prerequisites","text":"<ul> <li>You have installed Kuadrant in a Kubernetes cluster.</li> <li>You have installed the Prometheus Operator.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/observability/monitors/#enabling-observability","title":"Enabling Observability","text":"<p>To enable observability for Kuadrant and any gateways, set <code>enable: true</code> under the <code>observability</code> section in your Kuadrant CR:</p> <pre><code>apiVersion: kuadrant.io/v1beta1\nkind: Kuadrant\nmetadata:\n  name: kuadrant-sample\nspec:\n  observability:\n    enable: true\n</code></pre> <p>When enabled, Kuadrant creates ServiceMonitors and PodMonitors for its own components in the same namespae as the Kuadrant operator. A single set of monitors are also created in each gateway namespace (Envoy Gateway or Istio) to scrape metrics from all gateways in the gateway namespace, and in the corresponding gateway \"system\" namespace:</p> <ul> <li>Istio: <code>istio-system</code> namespace for the istiod pod</li> <li>Envoy Gateway:  <code>envoy-gateway-system</code> namespace for the envoy gateway pod</li> </ul> <p>You can check all created monitors using this command:</p> <pre><code>kubectl get servicemonitor,podmonitor -A -l kuadrant.io/observability=true\n</code></pre> <p>You can make changes to the monitors after they are created if you need to. Monitors will only ever be created or deleted, not updated or reverted. If you decide the default monitors aren\u2019t suitable, disable the feature by setting <code>enable: false</code> and create your own ServiceMonitor/PodMonitor definitions or configure Prometheus directly. For more details on specific metrics, check out the Metrics reference page.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/","title":"Authenticated Rate Limiting for Application developers","text":"<p>For more info on the different personas see Gateway API </p> <p>This tutorial walks you through an example of how to configure authenticated rate limiting for an application using Kuadrant.</p> <p>Authenticated rate limiting rate limits the traffic directed to an application based on attributes of the client user, who is authenticated by some authentication method. A few examples of authenticated rate limiting use cases are:</p> <ul> <li>User A can send up to 50rps (\"requests per second\"), while User B can send up to 100rps.</li> <li>Each user can send up to 20rpm (\"request per minute\").</li> <li>Admin users (members of the 'admin' group) can send up to 100rps, while regular users (non-admins) can send up to 20rpm and no more than 5rps.</li> </ul> <p>In this tutorial, we will rate limit a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request. The API exposes an endpoint at <code>GET http://api.toystore.com/toy</code>, to mimic an operation of reading toy records.</p> <p>We will define 2 users of the API, which can send requests to the API at different rates, based on their user IDs. The authentication method used is API key.</p> User ID Rate limit alice 5rp10s (\"5 requests every 10 seconds\") bob 2rp10s (\"2 requests every 10 seconds\")"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<p>Create the namespace for the Toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy the Toystore app to the developer namespace:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Export the gateway hostname and port:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <p>Verify the route works:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/kuadrant-${KUADRANT_GATEWAY_NAME}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#enforce-authentication-on-requests-to-the-toy-store-api","title":"Enforce authentication on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure the authentication:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre> <p>Verify the authentication works by sending a request to the Toy Store API without API key:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-users\"\n# x-ext-auth-reason: \"credential not found\"\n</code></pre> <p>Create API keys for users <code>alice</code> and <code>bob</code> to authenticate:</p> <p>Note: Kuadrant stores API keys as Kubernetes Secret resources. User metadata can be stored in the annotations of the resource.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-for-app-developers/#enforce-authenticated-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce authenticated rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"alice-limit\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'alice'\"\n    \"bob-limit\":\n      rates:\n      - limit: 2\n        window: 10s\n      when:\n      - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests as Alice and Bob.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds allowed for Alice, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Up to 2 successful (<code>200 OK</code>) requests every 10 seconds allowed for Bob, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/","title":"Authenticated Rate Limiting with JWTs and Kubernetes RBAC","text":"<p>This tutorial walks you through an example of how to use Kuadrant to protect an application with policies to enforce: </p> <ul> <li>authentication based OpenId Connect (OIDC) ID tokens (signed JWTs), issued by a Keycloak server;</li> <li>alternative authentication method by Kubernetes Service Account tokens;</li> <li>authorization delegated to Kubernetes RBAC system;</li> <li>rate limiting by user ID.</li> </ul> <p>In this example, we will protect a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request.</p> <p>The API listens to requests at the hostnames <code>*.toystore.com</code>, where it exposes the endpoints <code>GET /toy*</code>, <code>POST /admin/toy</code> and <code>DELETE /amind/toy</code>, respectively, to mimic operations of reading, creating, and deleting toy records.</p> <p>Any authenticated user/service account can send requests to the Toy Store API, by providing either a valid Keycloak-issued access token or Kubernetes token.</p> <p>Privileges to execute the requested operation (read, create or delete) will be granted according to the following RBAC rules, stored in the Kubernetes authorization system:</p> Operation Endpoint Required role Read <code>GET /toy*</code> <code>toystore-reader</code> Create <code>POST /admin/toy</code> <code>toystore-write</code> Delete <code>DELETE /admin/toy</code> <code>toystore-write</code> <p>Each user will be entitled to a maximum of 5rp10s (5 requests every 10 seconds).</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<p>Create the namespace for the Toystore application:</p> <pre><code>kubectl create ns ${KUADRANT_DEVELOPER_NS}\n</code></pre> <p>Deploy the Toystore app to the developer namespace:</p> <p><pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml -n ${KUADRANT_DEVELOPER_NS}\n</code></pre> Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#api-lifecycle","title":"API lifecycle","text":""},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-unprotected","title":"Try the API unprotected","text":"<p>Export the gateway hostname and port:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>It should return <code>200 OK</code>.</p> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/${KUADRANT_GATEWAY_NS}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#deploy-keycloak","title":"Deploy Keycloak","text":"<p>Create the namespace for Keycloak:</p> <pre><code>kubectl create namespace keycloak\n</code></pre> <p>Deploy Keycloak with a bootstrap realm, users, and clients:</p> <pre><code>kubectl apply -n keycloak -f https://raw.githubusercontent.com/Kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Note: The Keycloak server may take a couple of minutes to be ready.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#enforce-authentication-and-authorization-for-the-toy-store-api","title":"Enforce authentication and authorization for the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure authentication and authorization:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: AuthPolicy\nmetadata:\n  name: toystore-protection\n  namespace: ${KUADRANT_DEVELOPER_NS}\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"keycloak-users\":\n        jwt:\n          issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      \"k8s-service-accounts\":\n        kubernetesTokenReview:\n          audiences:\n\n          - https://kubernetes.default.svc.cluster.local\n        overrides:\n          \"sub\":\n            selector: auth.identity.user.username\n    authorization:\n      \"k8s-rbac\":\n        kubernetesSubjectAccessReview:\n          user:\n            selector: auth.identity.sub\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.sub\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-missing-authentication","title":"Try the API missing authentication","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak-users\"\n# www-authenticate: Bearer realm=\"k8s-service-accounts\"\n# x-ext-auth-reason: {\"k8s-service-accounts\":\"credential not found\",\"keycloak-users\":\"credential not found\"}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-without-permission","title":"Try the API without permission","text":"<p>Obtain an access token with the Keycloak server:</p> <pre><code>KUADRANT_ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .KUADRANT_ACCESS_TOKEN)\n</code></pre> <p>Send a request to the API as the Keycloak-authenticated user while still missing permissions:</p> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>Create a Kubernetes Service Account to represent a consumer of the API associated with the alternative source of identities <code>k8s-service-accounts</code>:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: client-app-1\nEOF\n</code></pre> <p>Obtain an access token for the <code>client-app-1</code> service account:</p> <pre><code>KUADRANT_SA_TOKEN=$(kubectl create token client-app-1)\n</code></pre> <p>Send a request to the API as the service account while still missing permissions:</p> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_SA_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#grant-access-to-the-toy-store-api-for-user-and-service-account","title":"Grant access to the Toy Store API for user and service account","text":"<p>Create the <code>toystore-reader</code> and <code>toystore-writer</code> roles:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: toystore-reader\nrules:\n\n- nonResourceURLs: [\"/toy*\"]\n  verbs: [\"get\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: toystore-writer\nrules:\n- nonResourceURLs: [\"/admin/toy\"]\n  verbs: [\"post\", \"delete\"]\nEOF\n</code></pre> <p>Add permissions to the user and service account:</p> User Kind Roles john User registered in Keycloak <code>toystore-reader</code>, <code>toystore-writer</code> client-app-1 Kuberentes Service Account <code>toystore-reader</code> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: toystore-readers\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: toystore-reader\nsubjects:\n\n- kind: User\n  name: $(jq -R -r 'split(\".\") | .[1] | @base64d | fromjson | .sub' &lt;&lt;&lt; \"$KUADRANT_ACCESS_TOKEN\")\n- kind: ServiceAccount\n  name: client-app-1\n  namespace: default\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: toystore-writers\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: toystore-writer\nsubjects:\n- kind: User\n  name: $(jq -R -r 'split(\".\") | .[1] | @base64d | fromjson | .sub' &lt;&lt;&lt; \"$KUADRANT_ACCESS_TOKEN\")\nEOF\n</code></pre> Q: Can I use <code>Roles</code> and <code>RoleBindings</code> instead of <code>ClusterRoles</code> and <code>ClusterRoleBindings</code>? <p>Yes, you can.</p> <p>The example above is for non-resource URL Kubernetes roles. For using <code>Roles</code> and <code>RoleBindings</code> instead of <code>ClusterRoles</code> and <code>ClusterRoleBindings</code>, thus more flexible resource-based permissions to protect the API, see the spec for Kubernetes SubjectAccessReview authorization in the Authorino docs.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-with-permission","title":"Try the API with permission","text":"<p>Send requests to the API as the Keycloak-authenticated user:</p> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_ACCESS_TOKEN\" -H 'Host: api.toystore.com' -X POST http://$KUADRANT_GATEWAY_URL/admin/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Send requests to the API as the Kubernetes service account:</p> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_SA_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $KUADRANT_SA_TOKEN\" -H 'Host: api.toystore.com' -X POST http://$KUADRANT_GATEWAY_URL/admin/toy -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#enforce-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  limits:\n    \"per-user\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      counters:\n      - expression: auth.identity.userid\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/authenticated-rl-with-jwt-and-k8s-authnz/#try-the-api-rate-limited","title":"Try the API rate limited","text":"<p>Each user should be entitled to a maximum of 5 requests every 10 seconds.</p> <p>Note: If the tokens have expired, you may need to refresh them first.</p> <p>Send requests as the Keycloak-authenticated user:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Authorization: Bearer $KUADRANT_ACCESS_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Send requests as the Kubernetes service account:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H \"Authorization: Bearer $KUADRANT_SA_TOKEN\" -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/","title":"Gateway Rate Limiting for Cluster Operators","text":"<p>For more info on the different personas see Gateway API </p> <p>This tutorial walks you through an example of how to configure rate limiting for all routes attached to a specific ingress gateway.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#deploy-the-toystore-example-api","title":"Deploy the Toystore example API:","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#create-the-ingress-gateways","title":"Create the ingress gateways","text":"<pre><code>kubectl -n gateway-system apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: external\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - name: external\n    port: 80\n    protocol: HTTP\n    hostname: '*.io'\n    allowedRoutes:\n      namespaces:\n        from: All\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: internal\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n  - name: local\n    port: 80\n    protocol: HTTP\n    hostname: '*.local'\n    allowedRoutes:\n      namespaces:\n        from: All\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#enforce-rate-limiting-on-requests-incoming-through-the-external-gateway","title":"Enforce rate limiting on requests incoming through the <code>external</code> gateway","text":"<pre><code>    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502 (Gateway) \u2502      \u2502 (Gateway) \u2502\n    \u2502  external \u2502      \u2502  internal \u2502\n    \u2502           \u2502      \u2502           \u2502\n    \u2502   *.io    \u2502      \u2502  *.local  \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n          \u25b2\n          \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 (RateLimitPolicy) \u2502\n\u2502       gw-rlp      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <pre><code>kubectl apply -n gateway-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: external\n  limits:\n    \"global\":\n      rates:\n\n      - limit: 5\n        window: 10s\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#deploy-a-sample-api-to-test-rate-limiting-enforced-at-the-level-of-the-gateway","title":"Deploy a sample API to test rate limiting enforced at the level of the gateway","text":"<pre><code>                           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502 (Gateway) \u2502      \u2502 (Gateway) \u2502\n\u2502 (RateLimitPolicy) \u2502      \u2502  external \u2502      \u2502  internal \u2502\n\u2502       gw-rlp      \u251c\u2500\u2500\u2500\u2500\u2500\u25ba\u2502           \u2502      \u2502           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502   *.io    \u2502      \u2502  *.local  \u2502\n                           \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2518\n                                 \u2502                  \u2502\n                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                           \u2502\n                                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                 \u2502   (HTTPRoute)    \u2502\n                                 \u2502     toystore     \u2502\n                                 \u2502                  \u2502\n                                 \u2502 *.toystore.io    \u2502\n                                 \u2502 *.toystore.local \u2502\n                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                          \u2502\n                                   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                                   \u2502   (Service)  \u2502\n                                   \u2502   toystore   \u2502\n                                   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#route-traffic-to-the-api-from-both-gateways","title":"Route traffic to the API from both gateways:","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: external\n    namespace: gateway-system\n  - name: internal\n    namespace: gateway-system\n  hostnames:\n  - \"*.toystore.io\"\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/gateway-rl-for-cluster-operators/#verify-the-rate-limiting-works-by-sending-requests-in-a-loop","title":"Verify the rate limiting works by sending requests in a loop","text":"<p>Expose the gateways, respectively at the port numbers <code>9081</code> and <code>9082</code> of the local host:</p> <pre><code>kubectl port-forward -n gateway-system service/external-istio 9081:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nkubectl port-forward -n gateway-system service/internal-istio 9082:80 &gt;/dev/null 2&gt;&amp;1 &amp;\n</code></pre> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds through the <code>external</code> ingress gateway (<code>*.io</code>), then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.io' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) through the <code>internal</code> ingress gateway (<code>*.local</code>):</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.local' http://localhost:9082 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/","title":"Gateway Rate Limiting","text":"<p>This tutorial walks you through an example of how to configure multiple rate limit polices for different listeners in an ingress gateway. </p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#deploy-the-sample-api","title":"Deploy the sample API:","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-the-ingress-gateways","title":"Create the ingress gateways","text":"<pre><code>kubectl -n kuadrant-system apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: environment\n  annotations:\n    kuadrant.io/namespace: kuadrant-system\n    networking.istio.io/service-type: ClusterIP\nspec:\n  gatewayClassName: istio\n  listeners:\n\n  - name: external\n    port: 80\n    protocol: HTTP\n    hostname: '*.io'\n    allowedRoutes:\n      namespaces:\n        from: All\n  - name: local\n    port: 80\n    protocol: HTTP\n    hostname: '*.local'\n    allowedRoutes:\n      namespaces:\n        from: All\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#route-traffic-to-the-api-from-both-gateways-listeners","title":"Route traffic to the API from both gateways listeners","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: environment\n    namespace: kuadrant-system\n  hostnames:\n  - \"*.toystore.io\"\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-a-kuadrant-ratelimitpolicy-to-configure-rate-limiting-for-the-external-listener","title":"Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting for the external listener:","text":"<pre><code>kubectl apply -n kuadrant-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp-external\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: environment\n    sectionName: external\n  defaults:\n    strategy: merge\n    limits:\n      \"external\":\n        rates:\n\n        - limit: 2\n          window: 10s\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#create-a-kuadrant-ratelimitpolicy-to-configure-rate-limiting-for-the-local-listener","title":"Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting for the local listener:","text":"<pre><code>kubectl apply -n kuadrant-system -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: RateLimitPolicy\nmetadata:\n  name: gw-rlp-local\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: environment\n    sectionName: local\n  defaults:\n    strategy: merge\n    limits:\n      \"local\":\n        rates:\n\n        - limit: 5\n          window: 10s\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-diff-section/#verify-the-rate-limiting-works-by-sending-requests-in-a-loop","title":"Verify the rate limiting works by sending requests in a loop","text":"<p>Expose the gateways, respectively at the port numbers <code>9081</code> and <code>9082</code> of the local host:</p> <pre><code>kubectl port-forward -n gateway-system service/environment-istio 9081:80 &gt;/dev/null 2&gt;&amp;1 &amp;\n</code></pre> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds through the <code>external</code> ingress gateway (<code>*.io</code>), then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.io' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) through the <code>internal</code> ingress gateway (<code>*.local</code>):</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.local' http://localhost:9081 | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/","title":"Multi authenticated Rate Limiting for an Application","text":"<p>This tutorial walks you through an example of how to configure multiple authenticated rate limiting for an application using Kuadrant. </p> <p>Authenticated rate limiting, rate limits the traffic directed to an application based on attributes of the client user, who is authenticated by some authentication method. A few examples of authenticated rate limiting use cases are:</p> <ul> <li>User A can send up to 50rps (\"requests per second\"), while User B can send up to 100rps.</li> <li>Each user can send up to 20rpm (\"request per minute\").</li> <li>Admin users (members of the 'admin' group) can send up to 100rps, while regular users (non-admins) can send up to 20rpm and no more than 5rps.</li> </ul> <p>In this tutorial, we will rate limit a sample REST API called Toy Store, an echo service that echoes back to the user whatever attributes it gets in the request. The API exposes an endpoint at <code>GET http://api.toystore.com/toy</code>, to mimic an operation of reading toy records.</p> <p>We will define 2 users of the API, which can send requests to the API at different rates, based on their user IDs. The authentication method used is API key.</p> User ID Rate limit alice 5rp10s (\"5 requests every 10 seconds\") bob 2rp10s (\"2 requests every 10 seconds\")"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#create-a-httproute-to-route-traffic-to-the-service-via-istio-ingress-gateway","title":"Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - path:\n        type: Exact\n        value: \"/toy\"\n      method: GET\n    - path:\n        type: Exact\n        value: \"/car\"\n      method: GET\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#export-the-gateway-hostname-and-port","title":"Export the gateway hostname and port:","text":"<pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#verify-the-route-works","title":"Verify the route works:","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/${KUADRANT_GATEWAY_NAME}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#enforce-authentication-on-requests-to-the-toy-store-api","title":"Enforce authentication on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>AuthPolicy</code> to configure the authentication:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: AuthPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n  rules:\n    authentication:\n      \"api-key-users\":\n        apiKey:\n          selector:\n            matchLabels:\n              app: toystore\n          allNamespaces: true\n        credentials:\n          authorizationHeader:\n            prefix: APIKEY\n    response:\n      success:\n        filters:\n          \"identity\":\n            json:\n              properties:\n                \"userid\":\n                  selector: auth.identity.metadata.annotations.secret\\.kuadrant\\.io/user-id\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#verify-the-authentication-works-by-sending-a-request-to-the-toy-store-api-without-api-key","title":"Verify the authentication works by sending a request to the Toy Store API without API key:","text":"<pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-key-users\"\n# x-ext-auth-reason: \"credential not found\"\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#create-api-keys-for-users-alice-and-bob-to-authenticate","title":"Create API keys for users <code>alice</code> and <code>bob</code> to authenticate:","text":"<p>Note: Kuadrant stores API keys as Kubernetes Secret resources. User metadata can be stored in the annotations of the resource.</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: bob-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: bob\nstringData:\n  api_key: IAMBOB\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: alice-key\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: toystore\n  annotations:\n    secret.kuadrant.io/user-id: alice\nstringData:\n  api_key: IAMALICE\ntype: Opaque\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#enforce-authenticated-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce authenticated rate limiting on requests to the Toy Store API","text":"<p>Create Kuadrant <code>RateLimitPolicy's</code> to configure rate limiting for Bob and Alice:</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#bob","title":"Bob","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-1\n  defaults:\n    strategy: merge\n    limits:\n      \"bob-limit\":\n        rates:\n\n        - limit: 2\n          window: 10s\n        when:\n        - predicate: \"auth.identity.userid == 'bob'\"\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/multi-auth-rlp-same-section/#alice","title":"Alice","text":"<pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1beta3\nkind: RateLimitPolicy\nmetadata:\n  name: toystore-alice\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-1\n  defaults:\n    strategy: merge\n    limits:\n      \"alice-limit\":\n        rates:\n\n        - limit: 5\n          window: 10s\n        when:\n        - predicate: \"auth.identity.userid == 'alice'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests as Alice and Bob.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds allowed for Alice, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMALICE' -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Up to 2 successful (<code>200 OK</code>) requests every 10 seconds allowed for Bob, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Authorization: APIKEY IAMBOB' -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/","title":"Simple Rate Limiting for Application developers","text":"<p>For more info on the different personas see Gateway API </p> <p>This tutorial walks you through an example of how to configure rate limiting for an endpoint of an application using Kuadrant.</p> <p>In this tutorial, we will rate limit a sample REST API called Toy Store. In reality, this API is just an echo service that echoes back to the user whatever attributes it gets in the request. The API listens to requests at the hostname <code>api.toystore.com</code>, where it exposes the endpoints <code>GET /toys*</code> and <code>POST /toys</code>, respectively, to mimic operations of reading and writing toy records.</p> <p>We will rate limit the <code>POST /toys</code> endpoint to a maximum of 5rp10s (\"5 requests every 10 seconds\").</p>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#setup-environment-variables","title":"Setup environment variables","text":"<p>Set the following environment variables used for convenience in this tutorial:</p> <pre><code>export KUADRANT_GATEWAY_NS=api-gateway # Namespace for the example Gateway\nexport KUADRANT_GATEWAY_NAME=external # Name for the example Gateway\nexport KUADRANT_DEVELOPER_NS=toystore # Namespace for an example toystore app\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#create-an-ingress-gateway","title":"Create an Ingress Gateway","text":"<p>Create the namespace the Gateway will be deployed in:</p> <pre><code>kubectl create ns ${KUADRANT_GATEWAY_NS}\n</code></pre> <p>Create a gateway using toystore as the listener hostname:</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: ${KUADRANT_GATEWAY_NAME}\n  namespace: ${KUADRANT_GATEWAY_NS}\n  labels:\n    kuadrant.io/gateway: \"true\"\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - name: http\n      protocol: HTTP\n      port: 80\n      allowedRoutes:\n        namespaces:\n          from: All\nEOF\n</code></pre> <p>Check the status of the <code>Gateway</code> ensuring the gateway is Accepted and Programmed:</p> <pre><code>kubectl get gateway ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o=jsonpath='{.status.conditions[?(@.type==\"Accepted\")].message}{\"\\n\"}{.status.conditions[?(@.type==\"Programmed\")].message}{\"\\n\"}'\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#deploy-the-toy-store-api","title":"Deploy the Toy Store API","text":"<p>Create the deployment:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\n</code></pre> <p>Create a HTTPRoute to route traffic to the service via Istio Ingress Gateway:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: ${KUADRANT_GATEWAY_NAME}\n    namespace: ${KUADRANT_GATEWAY_NS}\n  hostnames:\n  - api.toystore.com\n  rules:\n  - matches:\n    - method: GET\n      path:\n        type: PathPrefix\n        value: \"/toys\"\n    backendRefs:\n    - name: toystore\n      port: 80\n  - matches: # it has to be a separate HTTPRouteRule so we do not rate limit other endpoints\n    - method: POST\n      path:\n        type: Exact\n        value: \"/toys\"\n    backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre> <p>Export the gateway hostname and port:</p> <pre><code>export KUADRANT_INGRESS_HOST=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.status.addresses[0].value}')\nexport KUADRANT_INGRESS_PORT=$(kubectl get gtw ${KUADRANT_GATEWAY_NAME} -n ${KUADRANT_GATEWAY_NS} -o jsonpath='{.spec.listeners[?(@.name==\"http\")].port}')\nexport KUADRANT_GATEWAY_URL=${KUADRANT_INGRESS_HOST}:${KUADRANT_INGRESS_PORT}\n</code></pre> <p>Verify the route works:</p> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toys -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Note: If the command above fails to hit the Toy Store API on your environment, try forwarding requests to the service and accessing over localhost:</p> <pre><code>kubectl port-forward -n ${KUADRANT_GATEWAY_NS} service/${KUADRANT_GATEWAY_NAME}-istio 9080:80 &gt;/dev/null 2&gt;&amp;1 &amp;\nexport KUADRANT_GATEWAY_URL=localhost:9080\n</code></pre> <pre><code>curl -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toy -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/ratelimiting/simple-rl-for-app-developers/#enforce-rate-limiting-on-requests-to-the-toy-store-api","title":"Enforce rate limiting on requests to the Toy Store API","text":"<p>Create a Kuadrant <code>RateLimitPolicy</code> to configure rate limiting:</p> <p></p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: RateLimitPolicy\nmetadata:\n  name: toystore\nspec:\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: toystore\n    sectionName: rule-2\n  limits:\n    \"create-toy\":\n      rates:\n\n      - limit: 5\n        window: 10s\n      when:\n      - predicate: \"request.method == 'POST'\"\nEOF\n</code></pre> <p>Note: It may take a couple of minutes for the RateLimitPolicy to be applied depending on your cluster.</p> <p>Verify the rate limiting works by sending requests in a loop.</p> <p>Up to 5 successful (<code>200 OK</code>) requests every 10 seconds to <code>POST /toys</code>, then <code>429 Too Many Requests</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toys -X POST | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre> <p>Unlimited successful (<code>200 OK</code>) to <code>GET /toys</code>:</p> <pre><code>while :; do curl --write-out '%{http_code}\\n' --silent --output /dev/null -H 'Host: api.toystore.com' http://$KUADRANT_GATEWAY_URL/toys | grep -E --color \"\\b(429)\\b|$\"; sleep 1; done\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/","title":"Gateway TLS for Cluster Operators","text":"<p>This tutorial walks you through an example of how to configure TLS for all routes attached to an ingress gateway. </p>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster with Kuadrant operator installed. See our Getting Started guide for more information.</li> <li>kubectl command line tool.</li> </ul>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#setup","title":"Setup","text":"<pre><code>kubectl create namespace my-gateways\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#create-an-ingress-gateway","title":"Create an ingress gateway","text":"<p>Create a gateway:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: prod-web\nspec:\n  gatewayClassName: istio\n  listeners:\n\n    - allowedRoutes:\n        namespaces:\n          from: All\n      name: api\n      hostname: \"*.toystore.local\"\n      port: 443\n      protocol: HTTPS\n      tls:\n        mode: Terminate\n        certificateRefs:\n          - name: toystore-local-tls\n            kind: Secret\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#enable-tls-on-the-gateway","title":"Enable TLS on the gateway","text":"<p>The TLSPolicy requires a reference to an existing CertManager Issuer.</p> <p>Create a CertManager Issuer:</p> <pre><code>kubectl apply -n my-gateways -f - &lt;&lt;EOF\napiVersion: cert-manager.io/v1\nkind: Issuer\nmetadata:\n  name: selfsigned-issuer\nspec:\n  selfSigned: {}\nEOF\n</code></pre> <p>Note: We are using a self-signed issuer here but any supported CerManager issuer or cluster issuer can be used.</p> <pre><code>kubectl get issuer selfsigned-issuer -n my-gateways\n</code></pre> <p>Response:</p> <pre><code>NAME                        READY   AGE\nselfsigned-issuer   True    18s\n</code></pre> <p>Create a Kuadrant <code>TLSPolicy</code> to configure TLS:</p> <pre><code>kubectl apply -n my-gateways -f - &lt;&lt;EOF\napiVersion: kuadrant.io/v1\nkind: TLSPolicy\nmetadata:\n  name: prod-web\nspec:\n  targetRef:\n    name: prod-web\n    group: gateway.networking.k8s.io\n    kind: Gateway\n  issuerRef:\n    group: cert-manager.io\n    kind: Issuer\n    name: selfsigned-issuer\nEOF\n</code></pre> <p>Check policy status:</p> <pre><code>kubectl get tlspolicy -o wide -n my-gateways\n</code></pre> <p>Response:</p> <pre><code>NAME       STATUS     TARGETREFKIND   TARGETREFNAME   AGE\nprod-web   Accepted   Gateway         prod-web        13s\n</code></pre> <p>Check a Certificate resource was created:</p> <pre><code>kubectl get certificates -n my-gateways\n</code></pre> <p>Response</p> <pre><code>NAME                 READY   SECRET               AGE\ntoystore-local-tls   True    toystore-local-tls   7m30s\n</code></pre> <p>Check a TLS Secret resource was created:</p> <pre><code>kubectl get secrets -n my-gateways --field-selector=\"type=kubernetes.io/tls\"\n</code></pre> <p>Response:</p> <pre><code>NAME                 TYPE                DATA   AGE\ntoystore-local-tls   kubernetes.io/tls   3      7m42s\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#deploy-a-sample-api-to-test-tls","title":"Deploy a sample API to test TLS","text":"<p>Deploy the sample API:</p> <pre><code>kubectl -n my-gateways apply -f https://raw.githubusercontent.com/Kuadrant/Kuadrant-operator/main/examples/toystore/toystore.yaml\nkubectl -n my-gateways wait --for=condition=Available deployments toystore --timeout=60s\n</code></pre> <p>Route traffic to the API from our gateway:</p> <pre><code>kubectl -n my-gateways apply -f - &lt;&lt;EOF\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: toystore\nspec:\n  parentRefs:\n\n  - name: prod-web\n    namespace: my-gateways\n  hostnames:\n  - \"*.toystore.local\"\n  rules:\n  - backendRefs:\n    - name: toystore\n      port: 80\nEOF\n</code></pre>"},{"location":"kuadrant-operator/doc/user-guides/tls/gateway-tls/#verify-tls-works-by-sending-requests","title":"Verify TLS works by sending requests","text":"<p>Get the gateway address@</p> <pre><code>GWADDRESS=`kubectl get gateway/prod-web -n my-gateways -o=jsonpath='{.status.addresses[?(@.type==\"IPAddress\")].value}'`\necho $GWADDRESS\n</code></pre> <p>Response:</p> <pre><code>172.18.200.1\n</code></pre> <p>Verify we can access the service via TLS:</p> <pre><code>curl -vkI https://api.toystore.local --resolve \"api.toystore.local:443:$GWADDRESS\"\n</code></pre> <p>Response:</p> <pre><code>* Added api.toystore.local:443:172.18.200.1 to DNS cache\n* Hostname api.toystore.local was found in DNS cache\n*   Trying 172.18.200.1:443...\n* Connected to api.toystore.local (172.18.200.1) port 443 (#0)\n* ALPN: offers h2\n* ALPN: offers http/1.1\n* TLSv1.0 (OUT), TLS header, Certificate Status (22):\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\n* TLSv1.2 (IN), TLS header, Certificate Status (22):\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS header, Finished (20):\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):\n* TLSv1.3 (IN), TLS handshake, Certificate (11):\n* TLSv1.3 (IN), TLS handshake, CERT verify (15):\n* TLSv1.3 (IN), TLS handshake, Finished (20):\n* TLSv1.2 (OUT), TLS header, Finished (20):\n* TLSv1.3 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.3 (OUT), TLS handshake, Finished (20):\n* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384\n* ALPN: server accepted h2\n* Server certificate:\n*  subject: [NONE]\n*  start date: Feb 15 11:46:50 2024 GMT\n*  expire date: May 15 11:46:50 2024 GMT\n* Using HTTP2, server supports multiplexing\n* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* h2h3 [:method: HEAD]\n* h2h3 [:path: /]\n* h2h3 [:scheme: https]\n* h2h3 [:authority: api.toystore.local]\n* h2h3 [user-agent: curl/7.85.0]\n* h2h3 [accept: */*]\n* Using Stream ID: 1 (easy handle 0x5623e4fe5bf0)\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n&gt; HEAD / HTTP/2\n&gt; Host: api.toystore.local\n&gt; user-agent: curl/7.85.0\n&gt; accept: */*\n&gt;\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\n* TLSv1.3 (IN), TLS handshake, Newsession Ticket (4):\n* old SSL session ID is stale, removing\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n* Connection state changed (MAX_CONCURRENT_STREAMS == 2147483647)!\n* TLSv1.2 (OUT), TLS header, Supplemental data (23):\n* TLSv1.2 (IN), TLS header, Supplemental data (23):\n&lt; HTTP/2 200\nHTTP/2 200\n&lt; content-type: application/json\ncontent-type: application/json\n&lt; server: istio-envoy\nserver: istio-envoy\n&lt; date: Thu, 15 Feb 2024 12:13:27 GMT\ndate: Thu, 15 Feb 2024 12:13:27 GMT\n&lt; content-length: 1658\ncontent-length: 1658\n&lt; x-envoy-upstream-service-time: 1\nx-envoy-upstream-service-time: 1\n\n&lt;\n\n* Connection #0 to host api.toystore.local left intact\n</code></pre>"},{"location":"authorino/docs/","title":"Documentation","text":""},{"location":"authorino/docs/#getting-started","title":"Getting started","text":""},{"location":"authorino/docs/#terminology","title":"Terminology","text":""},{"location":"authorino/docs/#architecture","title":"Architecture","text":""},{"location":"authorino/docs/#feature-description","title":"Feature description","text":""},{"location":"authorino/docs/#user-guides","title":"User guides","text":""},{"location":"authorino/docs/#developers-guide","title":"Developer\u2019s guide","text":""},{"location":"authorino/docs/architecture/","title":"Architecture","text":""},{"location":"authorino/docs/architecture/#overview","title":"Overview","text":"<p>There are a few concepts to understand Authorino's architecture. The main components are: Authorino, Envoy and the Upstream service to be protected. Envoy proxies requests to the configured virtual host upstream service, first contacting with Authorino to decide on authN/authZ.</p> <p>The topology can vary from centralized proxy and centralized authorization service, to dedicated sidecars, with the nuances in between. Read more about the topologies in the Topologies section below.</p> <p>Authorino is deployed using the Authorino Operator, from an <code>Authorino</code> Kubernetes custom resource. Then, from another kind of custom resource, the <code>AuthConfig</code> CRs, each Authorino instance reads and adds to the index the exact rules of authN/authZ to enforce for each protected host (\"index reconciliation\").</p> <p>Everything that the AuthConfig reconciler can fetch in reconciliation-time is stored in the index. This is the case of static parameters such as signing keys, authentication secrets and authorization policies from external policy registries.</p> <p><code>AuthConfig</code>s can refer to identity providers (IdP) and trusted auth servers whose access tokens will be accepted to authenticate to the protected host. Consumers obtain an authentication token (short-lived access token or long-lived API key) and send those in the requests to the protected service.</p> <p>When Authorino is triggered by Envoy via the gRPC interface, it starts evaluating the Auth Pipeline, i.e. it applies to the request the parameters to verify the identity and to enforce authorization, as found in the index for the requested host (See host lookup for details).</p> <p>Apart from static rules, these parameters can include instructions to contact online with external identity verifiers, external sources of metadata and policy decision points (PDPs).</p> <p>On every request, Authorino's \"working memory\" is called Authorization JSON, a data structure that holds information about the context (the HTTP request) and objects from each phase of the auth pipeline: i.e., authentication verification (phase i), ad-hoc metadata fetching (phase ii), authorization policy enforcement (phase iii), dynamic response (phase iv), and callbacks (phase v). The evaluators in each of these phases can both read and write from the Authorization JSON for dynamic steps and decisions of authN/authZ.</p>"},{"location":"authorino/docs/architecture/#topologies","title":"Topologies","text":"<p>Typically, upstream APIs are deployed to the same Kubernetes cluster and namespace where the Envoy proxy and Authorino is running (although not necessarily). Whatever is the case, Envoy must be proxying to the upstream API (see Envoy's HTTP route components and virtual hosts) and pointing to Authorino in the external authorization filter.</p> <p>This can be achieved with different topologies:</p> <ul> <li>Envoy can be a centralized gateway with one dedicated instance of Authorino, proxying to one or more upstream services</li> <li>Envoy can be deployed as a sidecar of each protected service, but still contacting from a centralized Authorino authorization service</li> <li>Both Envoy and Authorino deployed as sidecars of the protected service, restricting all communication between them to localhost</li> </ul> <p>Each topology above induces different measures for security.</p>"},{"location":"authorino/docs/architecture/#centralized-gateway","title":"Centralized gateway","text":"<p>Recommended in the protected services to validate the origin of the traffic. It must have been proxied by Envoy. See Authorino JSON injection for an extra validation option using a shared secret passed in HTTP header.</p>"},{"location":"authorino/docs/architecture/#centralized-authorization-service","title":"Centralized authorization service","text":"<p>Protected service should only listen on <code>localhost</code> and all traffic can be considered safe.</p>"},{"location":"authorino/docs/architecture/#sidecars","title":"Sidecars","text":"<p>Recommended <code>namespaced</code> instances of Authorino with fine-grained label selectors to avoid unnecessary caching of <code>AuthConfig</code>s.</p> <p>Apart from that, protected service should only listen on <code>localhost</code> and all traffic can be considered safe.</p>"},{"location":"authorino/docs/architecture/#cluster-wide-vs-namespaced-instances","title":"Cluster-wide vs. Namespaced instances","text":"<p>Authorino instances can run in either cluster-wide or namespaced mode.</p> <p>Namespace-scoped instances only watch resources (<code>AuthConfig</code>s and <code>Secret</code>s) created in a given namespace. This deployment mode does not require admin privileges over the Kubernetes cluster to deploy the instance of the service (given Authorino's CRDs have been installed beforehand, such as when Authorino is installed using the Authorino Operator).</p> <p>Cluster-wide deployment mode, in contraposition, deploys instances of Authorino that watch resources across the entire cluster, consolidating all resources into a multi-namespace index of auth configs. Admin privileges over the Kubernetes cluster is required to deploy Authorino in cluster-wide mode.</p> <p>Be careful to avoid superposition when combining multiple Authorino instances and instance modes in the same Kubernetes cluster. Apart from caching unnecessary auth config data in the instances depending on your routing settings, the leaders of each instance (set of replicas) may compete for updating the status of the custom resources that are reconciled. See Resource reconciliation and status update for more information.</p> <p>If necessary, use label selectors to narrow down the space of resources watched and reconciled by each Authorino instance. Check out the Sharding section below for details.</p>"},{"location":"authorino/docs/architecture/#the-authorino-authconfig-custom-resource-definition-crd","title":"The Authorino <code>AuthConfig</code> Custom Resource Definition (CRD)","text":"<p>The desired protection for a service is declaratively stated by applying an <code>AuthConfig</code> Custom Resource to the Kubernetes cluster running Authorino.</p> <p>An <code>AuthConfig</code> resource typically looks like the following:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n    # The list of public host names of the services protected by this AuthConfig resource.\n    # Authorino uses the host name provided in the payload of external authorization request to lookup for the corresponding AuthConfig to enforce.\n  # Hostname collisions are prevented by rejecting to index a hostname already taken by another AuthConfig.\n  # Format: hostname[:port]\n  hosts:\n\n  - my-api.io:443 # north-south traffic\n  - my-api.ns.svc.cluster.local # east-west traffic\n\n  # Set of stored named patterns to be reused in conditions and pattern-matching authorization rules\n  patterns: {\"name\" \u2192 {selector, operator, value}, \u2026}\n\n  # Top-level conditions for the AuthConfig to be enforced.\n  # If omitted, the AuthConfig will be enforced at all requests.\n  # If present, all conditions must match for the AuthConfig to be enforced; otherwise, Authorino skips the AuthConfig and returns to the auth request with status OK.\n  when: [{selector, operator, value | named pattern ref}, \u2026]\n\n  # List of one or more trusted sources of identity:\n  # - Configurations to verify JSON Web Tokens (JWTs) issued by an OpenID Connect (OIDC) server\n  # - Endpoints for OAuth 2.0 token introspection\n  # - Attributes for the Kubernetes `TokenReview` API\n  # - Label selectors for API keys (stored in Kubernetes `Secret`s)\n  # - Label selectors trusted x509 issuer certificates (stored in Kubernetes `Secret`s)\n  # - Selectors for plain identity objects supplied in the payload of the authorization request\n  # - Anonymous access configs\n  authentication: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # List of sources of external metadata for the authorization (optional):\n  # - Endpoints for HTTP GET or GET-by-POST requests\n  # - OIDC UserInfo endpoints (associated with an OIDC token issuer specified in the authentication configs)\n  # - User-Managed Access (UMA) resource registries\n  metadata: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # List of authorization policies to be enforced (optional):\n  # - Pattern-matching rules (e.g. `context.request.http.path eq '/pets'`)\n  # - Open Policy Agent (OPA) inline or external Rego policies\n  # - Attributes for the Kubernetes `SubjectAccessReview` API\n  # \u2013 Attributes for authorization with an external SpiceDB server\n  authorization: {\"name\" \u2192 {\u2026}, \u2026}\n\n  # Customization to the response to the external authorization request (optional)\n  response:\n    # List of dynamic response elements into the request on success authoization (optional):\n    # - Plain text\n    # - JSON objects\n    # - Festival Wristbands (signed JWTs issued by Authorino)\n    success:\n      # List of HTTP headers to inject into the request post-authorization (optional):\n      headers: {\"name\" \u2192 {\u2026}, \u2026}\n\n      # List of Envoy Dynamic Metadata to inject into the request post-authorization (optional):\n      dynamicMetadata: {\"name\" \u2192 {\u2026}, \u2026}\n\n    # Custom HTTP status code, message and headers to replace the default `401 Unauthorized` response (optional)\n    unauthenticated:\n      code: 302\n      message: Redirecting to login\n      headers:\n        \"Location\":\n          value: https://my-app.io/login\n\n    # Custom HTTP status code, message and headers to replace the default `and `403 Forbidden` response (optional)\n    unauthorized: {code, message, headers, body}\n\n  # List of callback targets:\n  # - Endpoints for HTTP requests\n  callbacks: {\"name\" \u2192 {\u2026}, \u2026}\n</code></pre> <p>Check out the OAS of the <code>AuthConfig</code> CRD for a formal specification of the options for <code>authentication</code> verification, external <code>metadata</code> fetching, <code>authorization</code> policies, and dynamic <code>response</code>, as well as any other host protection capability implemented by Authorino.</p> <p>You can also read the specification from the CLI using the <code>kubectl explain</code> command. The Authorino CRD is required to have been installed in Kubernetes cluster. E.g. <code>kubectl explain authconfigs.spec.authentication.overrides</code>.</p> <p>A complete description of supported features and corresponding configuration options within an <code>AuthConfig</code> CR can be found in the Features page.</p> <p>More concrete examples of <code>AuthConfig</code>s for specific use-cases can be found in the User guides.</p>"},{"location":"authorino/docs/architecture/#resource-reconciliation-and-status-update","title":"Resource reconciliation and status update","text":"<p>The instances of the Authorino authorization service workload, following the Operator pattern, watch events related to the <code>AuthConfig</code> custom resources, to build and reconcile an in-memory index of configs. Whenever a replica receives traffic for authorization request, it looks up in the index of <code>AuthConfig</code>s and then triggers the \"Auth Pipeline\", i.e. enforces the associated auth spec onto the request.</p> <p>An instance can be a single authorization service workload or a set of replicas. All replicas watch and reconcile the same set of resources that match the <code>--auth-config-label-selector</code> and <code>--secret-label-selector</code> configuration options. (See both Cluster-wide vs. Namespaced instances and Sharding, for details about defining the reconciliation space of Authorino instances.)</p> <p>The above means that all replicas of an Authorino instance should be able to receive traffic for authorization requests.</p> <p>Among the multiple replicas of an instance, Authorino elects one replica to be leader. The leader is responsible for updating the status of reconciled <code>AuthConfig</code>s. If the leader eventually becomes unavailable, the instance will automatically elect another replica take its place as the new leader.</p> <p>The status of an <code>AuthConfig</code> tells whether the resource is \"ready\" (i.e. indexed). It also includes summary information regarding the numbers of authentication configs, metadata configs, authorization configs and response configs within the spec, as well as whether Festival Wristband tokens are being issued by the Authorino instance as by spec.</p> <p>Apart from watching events related to <code>AuthConfig</code> custom resources, Authorino also watches events related to Kubernetes <code>Secret</code>s, as part of Authorino's API key authentication feature. <code>Secret</code> resources that store API keys are linked to their corresponding <code>AuthConfig</code>s in the index. Whenever the Authorino instance detects a change in the set of API key <code>Secret</code>s linked to an <code>AuthConfig</code>s, the instance reconciles the index.</p> <p>Authorino only watches events related to <code>Secret</code>s whose <code>metadata.labels</code> match the label selector <code>--secret-label-selector</code> of the Authorino instance. The default values of the label selector for Kubernetes <code>Secret</code>s representing Authorino API keys is <code>authorino.kuadrant.io/managed-by=authorino</code>.</p>"},{"location":"authorino/docs/architecture/#the-auth-pipeline-aka-enforcing-protection-in-request-time","title":"The \"Auth Pipeline\" (aka: enforcing protection in request-time)","text":"<p>In each request to the protected API, Authorino triggers the so-called \"Auth Pipeline\", a set of configured evaluators that are organized in a 5-phase pipeline:</p> <ul> <li>(i) Authentication phase: at least one source of identity (i.e., one authentication config) must resolve the supplied credential in the request into a valid identity or Authorino will otherwise reject the request as unauthenticated (401 HTTP response status).</li> <li>(ii) Metadata phase: optional fetching of additional data from external sources, to add up to context and identity information, and used in authorization policies, dynamic responses and callback requests (phases iii to v).</li> <li>(iii) Authorization phase: all unskipped policies must evaluate to a positive result (\"authorized\"), or Authorino will otherwise reject the request as unauthorized (403 HTTP response code).</li> <li>(iv) Response phase \u2013 Authorino builds all user-defined response items (dynamic JSON objects and/or Festival Wristband OIDC tokens), which are supplied back to the external authorization client within added HTTP headers or as Envoy Dynamic Metadata</li> <li>(v) Callbacks phase \u2013 Authorino sends callbacks to specified HTTP endpoints.</li> </ul> <p>Each phase is sequential to the other, from (i) to (v), while the evaluators within each phase are triggered concurrently or as prioritized. The Authentication phase (i) is the only one required to list at least one evaluator (i.e. 1+ authentication configs); Metadata, Authorization and Response phases can have any number of evaluators (including zero, and even be omitted in this case).</p>"},{"location":"authorino/docs/architecture/#host-lookup","title":"Host lookup","text":"<p>Authorino reads the request host from <code>Attributes.Http.Host</code> of Envoy's <code>CheckRequest</code> type, and uses it as key to lookup in the index of <code>AuthConfig</code>s, matched against <code>spec.hosts</code>.</p> <p>Alternatively to <code>Attributes.Http.Host</code>, a <code>host</code> entry can be supplied in the <code>Attributes.ContextExtensions</code> map of the external authorino request. This will take precedence before the host attribute of the HTTP request.</p> <p>The <code>host</code> context extension is useful to support use cases such as of path prefix-based lookup and wildcard subdomains lookup with lookup strongly dictated by the external authorization client (e.g. Envoy), which often knows about routing and the expected <code>AuthConfig</code> to enforce beyond what Authorino can infer strictly based on the host name.</p> <p>Wildcards can also be used in the host names specified in the <code>AuthConfig</code>, resolved by Authorino. E.g. if <code>*.pets.com</code> is in <code>spec.hosts</code>, Authorino will match the concrete host names <code>dogs.pets.com</code>, <code>cats.pets.com</code>, etc. In case, of multiple possible matches, Authorino will try the longest match first (in terms of host name labels) and fall back to the closest wildcard upwards in the domain tree (if any).</p> <p>When more than one host name is specified in the <code>AuthConfig</code>, all of them can be used as key, i.e. all of them can be requested in the authorization request and will be mapped to the same config.</p> <p>Example. Host lookup with wildcards.</p> <p></p> <p>The domain tree above induces the following relation:</p> <ul> <li><code>foo.nip.io</code> \u2192 <code>authconfig-1</code> (matches <code>*.io</code>)</li> <li><code>talker-api.nip.io</code> \u2192 <code>authconfig-2</code> (matches <code>talker-api.nip.io</code>)</li> <li><code>dogs.pets.com</code> \u2192 <code>authconfig-2</code> (matches <code>*.pets.com</code>)</li> <li><code>api.acme.com</code> \u2192 <code>authconfig-3</code> (matches <code>api.acme.com</code>)</li> <li><code>www.acme.com</code> \u2192 <code>authconfig-4</code> (matches <code>*.acme.com</code>)</li> <li><code>foo.org</code> \u2192 <code>404 Not found</code></li> </ul> <p></p> <p>The host can include the port number (i.e. <code>hostname:port</code>) or it can be just the name of the host name. Authorino will first try finding in the index a config associated to <code>hostname:port</code>, as supplied in the authorization request; if the index misses an entry for <code>hostname:port</code>, Authorino will then remove the <code>:port</code> suffix and repeat the lookup using just <code>hostname</code> as key. This provides implicit support for multiple port numbers for a same host without having to list all combinations in the <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/architecture/#avoiding-host-name-collision","title":"Avoiding host name collision","text":"<p>Authorino tries to prevent host name collision between <code>AuthConfig</code>s by rejecting to link in the index any <code>AuthConfig</code> and host name if the host name is already linked to a different <code>AuthConfig</code> in the index. This was intentionally designed to prevent users from superseding each other's <code>AuthConfig</code>s, partially or fully, by just picking the same host names or overlapping host names as others.</p> <p>When wildcards are involved, a host name that matches a host wildcard already linked in the index to another <code>AuthConfig</code> will be considered taken, and therefore the newest <code>AuthConfig</code> will be rejected to be linked to that host.</p> <p>This behavior can be disabled to allow <code>AuthConfig</code>s to partially supersede each others' host names (limited to strict host subsets), by supplying the <code>--allow-superseding-host-subsets</code> command-line flag when running the Authorino instance.</p>"},{"location":"authorino/docs/architecture/#the-authorization-json","title":"The Authorization JSON","text":"<p>On every Auth Pipeline, Authorino builds the Authorization JSON, a \"working-memory\" data structure composed of <code>context</code> (information about the request, as supplied by the Envoy proxy to Authorino) and <code>auth</code> (objects resolved in phases (i) to (v) of the pipeline). The evaluators of each phase can read from the Authorization JSON and implement dynamic properties and decisions based on its values.</p> <p>At phase (iii), the authorization evaluators count on an Authorization JSON payload that looks like the following:</p> <pre><code>// The authorization JSON combined along Authorino's auth pipeline for each request\n{\n  \"context\": { // the input from the proxy\n    \"origin\": {\u2026},\n    \"request\": {\n      \"http\": {\n        \"method\": \"\u2026\",\n        \"headers\": {\u2026},\n        \"path\": \"/\u2026\",\n        \"host\": \"\u2026\",\n        \u2026\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      // the identity resolved, from the supplied credentials, by one of the evaluators of phase (i)\n    },\n    \"metadata\": {\n      // each metadata object/collection resolved by the evaluators of phase (ii), by name of the evaluator\n    }\n  }\n}\n</code></pre> <p>The policies evaluated can use any data from the authorization JSON to define authorization rules.</p> <p>After phase (iii), Authorino appends to the authorization JSON the results of this phase as well, and the payload available for phase (iv) becomes:</p> <pre><code>// The authorization JSON combined along Authorino's auth pipeline for each request\n{\n  \"context\": { // the input from the proxy\n    \"origin\": {\u2026},\n    \"request\": {\n      \"http\": {\n        \"method\": \"\u2026\",\n        \"headers\": {\u2026},\n        \"path\": \"/\u2026\",\n        \"host\": \"\u2026\",\n        \u2026\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      // the identity resolved, from the supplied credentials, by one of the evaluators of phase (i)\n    },\n    \"metadata\": {\n      // each metadata object/collection resolved by the evaluators of phase (ii), by name of the evaluator\n    },\n    \"authorization\": {\n      // each authorization policy result resolved by the evaluators of phase (iii), by name of the evaluator\n    }\n  }\n}\n</code></pre> <p>Festival Wristbands and Dynamic JSON responses can include dynamic values (custom claims/properties) fetched from the authorization JSON. These can be returned to the external authorization client in added HTTP headers or as Envoy Well Known Dynamic Metadata. Check out Custom response features for details.</p> <p>For information about reading and fetching data from the Authorization JSON (syntax, functions, etc), check out Common Expression Language (CEL).</p>"},{"location":"authorino/docs/architecture/#raw-http-authorization-interface","title":"Raw HTTP Authorization interface","text":"<p>Besides providing the gRPC authorization interface \u2013 that implements the Envoy gRPC authorization server \u2013, Authorino also provides another interface for raw HTTP authorization. This second interface responds to <code>GET</code> and <code>POST</code> HTTP requests sent to <code>:5001/check</code>, and is suitable for other forms of integration, such as:</p> <ul> <li>using Authorino as Kubernetes ValidatingWebhook service (example);</li> <li>other HTTP proxies and API gateways;</li> <li>old versions of Envoy incompatible with the latest version of gRPC external authorization protocol (Authorino is based on v3.19.1 of Envoy external authorization API)</li> </ul> <p>In the raw HTTP interface, the host used to lookup for an <code>AuthConfig</code> must be supplied in the <code>Host</code> HTTP header of the request. Other attributes of the HTTP request are also passed in the context to evaluate the <code>AuthConfig</code>, including the body of the request.</p>"},{"location":"authorino/docs/architecture/#caching","title":"Caching","text":""},{"location":"authorino/docs/architecture/#openid-connect-and-user-managed-access-configs","title":"OpenID Connect and User-Managed Access configs","text":"<p>OpenID Connect and User-Managed Access configurations, discovered usually at reconciliation-time from well-known discovery endpoints.</p> <p>Cached individual OpenID Connect configurations discovered by Authorino can be configured to be auto-refreshed, by setting the corresponding <code>spec.authentication.jwt.ttl</code> field in the AuthConfig (given in seconds, default: <code>0</code> \u2013 i.e. no cache update).</p>"},{"location":"authorino/docs/architecture/#json-web-keys-jwks-and-json-web-key-sets-jwks","title":"JSON Web Keys (JWKs) and JSON Web Key Sets (JWKS)","text":"<p>JSON signature verification certificates linked by discovered OpenID Connect configurations, fetched usually at reconciliation-time.</p>"},{"location":"authorino/docs/architecture/#revoked-access-tokens","title":"Revoked access tokens","text":"Not implemented - In analysis (#19) <p>Caching of access tokens identified and or notified as revoked prior to expiration.</p>"},{"location":"authorino/docs/architecture/#external-metadata","title":"External metadata","text":"Not implemented - Planned (#21) <p>Caching of resource data obtained in previous requests.</p>"},{"location":"authorino/docs/architecture/#compiled-rego-policies","title":"Compiled Rego policies","text":"<p>Performed automatically by Authorino at reconciliation-time for the authorization policies based on the built-in OPA module.</p> <p>Precompiled and cached individual Rego policies originally pulled by Authorino from external registries can be configured to be auto-refreshed, by setting the corresponding <code>spec.authorization.opa.externalRegistry.ttl</code> field in the AuthConfig (given in seconds, default: <code>0</code> \u2013 i.e. no cache update).</p>"},{"location":"authorino/docs/architecture/#repeated-requests","title":"Repeated requests","text":"Not implemented - In analysis (#20) <p>For consecutive requests performed, within a given period of time, by a same user that request for a same resource, such that the result of the auth pipeline can be proven that would not change.</p>"},{"location":"authorino/docs/architecture/#sharding","title":"Sharding","text":"<p>By default, Authorino instances will watch <code>AuthConfig</code> CRs in the entire space (namespace or entire cluster; see Cluster-wide vs. Namespaced instances for details). To support combining multiple Authorino instances and instance modes in the same Kubernetes cluster, and yet avoiding superposition between the instances (i.e. multiple instances reconciling the same <code>AuthConfig</code>s), Authorino offers support for data sharding, i.e. to horizontally narrow down the space of reconciliation of an Authorino instance to a subset of that space.</p> <p>The benefits of limiting the space of reconciliation of an Authorino instance include avoiding unnecessary caching and workload in instances that do not receive corresponding traffic (according to your routing settings) and preventing leaders of multiple instances (sets of replicas) to compete on resource status updates (see Resource reconciliation and status update for details).</p> <p>Use-cases for sharding of <code>AuthConfig</code>s:</p> <ul> <li>Horizontal load balancing of traffic of authorization requests</li> <li>Supporting for managed centralized instances of Authorino to API owners who create and maintain their own <code>AuthConfig</code>s within their own user namespaces.</li> </ul> <p>Authorino's custom controllers filter the <code>AuthConfig</code>-related events to be reconciled using Kubernetes label selectors, defined for the Authorino instance via <code>--auth-config-label-selector</code> command-line flag. By default, <code>--auth-config-label-selector</code> is empty, meaning all <code>AuthConfig</code>s in the space are watched; this variable can be set to any value parseable as a valid label selector, causing Authorino to then watch only events of <code>AuthConfig</code>s whose <code>metadata.labels</code> match the selector.</p> <p>The following are all valid examples of <code>AuthConfig</code> label selector filters:</p> <pre><code>--auth-config-label-selector=\"authorino.kuadrant.io/managed-by=authorino\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by=authorino,other-label=other-value\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by in (authorino,kuadrant)\"\n--auth-config-label-selector=\"authorino.kuadrant.io/managed-by!=authorino-v0.4\"\n--auth-config-label-selector=\"!disabled\"\n</code></pre>"},{"location":"authorino/docs/architecture/#rbac","title":"RBAC","text":"<p>The table below describes the roles and role bindings defined by the Authorino service:</p> Role Kind Scope(*) Description Permissions <code>authorino-manager-role</code> <code>ClusterRole</code> C/N Role of the Authorino manager service Watch and reconcile <code>AuthConfig</code>s and <code>Secret</code>s <code>authorino-manager-k8s-auth-role</code> <code>ClusterRole</code> C/N Role for the Kubernetes auth features Create <code>TokenReview</code>s and <code>SubjectAccessReview</code>s (Kubernetes auth) <code>authorino-leader-election-role</code> <code>Role</code> N Leader election role Create/update the <code>ConfigMap</code> used to coordinate which replica of Authorino is the leader <code>authorino-authconfig-editor-role</code> <code>ClusterRole</code> - <code>AuthConfig</code> editor R/W <code>AuthConfig</code>s; Read <code>AuthConfig/status</code> <code>authorino-authconfig-viewer-role</code> <code>ClusterRole</code> - <code>AuthConfig</code> viewer Read <code>AuthConfig</code>s and <code>AuthConfig/status</code> <code>authorino-proxy-role</code> <code>ClusterRole</code> C/N Kube-rbac-proxy-role (sidecar)'s role Create <code>TokenReview</code>s and <code>SubjectAccessReview</code>s to check permissions to the <code>/metrics</code> endpoint <code>authorino-metrics-reader</code> <code>ClusterRole</code> - Metrics reader <code>GET /metrics</code> <p>(*) C - Cluster-wide | N - Authorino namespace | C/N - Cluster-wide or Authorino namespace (depending on the deployment mode).</p>"},{"location":"authorino/docs/architecture/#observability","title":"Observability","text":"<p>Please refer to the Observability user guide for info on Prometheus metrics exported by Authorino, readiness probe, logging, tracing, etc.</p>"},{"location":"authorino/docs/contributing/","title":"Developer's Guide","text":""},{"location":"authorino/docs/contributing/#technology-stack-for-developers","title":"Technology stack for developers","text":"<p>Minimum requirements to contribute to Authorino are:</p> <ul> <li>Golang v1.22+</li> <li>Docker</li> </ul> <p>Authorino's code was originally bundled using the Operator SDK (v1.9.0).</p> <p>The following tools can be installed as part of the development workflow:</p> <ul> <li> <p>Installed with <code>go install</code> to the <code>$PROJECT_DIR/bin</code> directory:</p> <ul> <li>controller-gen: for building custom types and manifests</li> <li>Kustomize: for assembling flavoured manifests and installing/deploying</li> <li>setup-envtest: for running the tests \u2013 extra tools installed to <code>./testbin</code></li> <li>benchstat: for human-friendly test benchmark reports</li> <li>mockgen: to generate mocks for tests \u2013 e.g. <code>./bin/mockgen -source=pkg/auth/auth.go -destination=pkg/auth/mocks/mock_auth.go</code></li> <li>Kind: for deploying a containerized Kubernetes cluster for integration testing purposes</li> </ul> </li> <li> <p>Other recommended tools to have installed:</p> <ul> <li>jq</li> <li>yq</li> <li>gnu-sed</li> </ul> </li> </ul>"},{"location":"authorino/docs/contributing/#workflow","title":"Workflow","text":""},{"location":"authorino/docs/contributing/#check-the-issues","title":"Check the issues","text":"<p>Start by checking the list of issues in GitHub.</p> <p>In case you want to contribute with an idea for enhancement, a bug fix, or question, please make sure to describe the issue so we can start a conversation together and help you find the best way to get your contribution merged.</p>"},{"location":"authorino/docs/contributing/#clone-the-repo-and-setup-the-local-environment","title":"Clone the repo and setup the local environment","text":"<p>Fork/clone the repo:</p> <pre><code>git clone git@github.com:kuadrant/authorino.git &amp;&amp; cd authorino\n</code></pre> <p>Download the Golang dependencies: <pre><code>make vendor\n</code></pre></p> <p>For additional automation provided, check:</p> <pre><code>make help\n</code></pre>"},{"location":"authorino/docs/contributing/#make-your-changes","title":"Make your changes","text":"<p>Good changes...</p> <ul> <li>follow the Golang conventions</li> <li>have proper test coverage</li> <li>address corresponding updates to the docs</li> <li>help us fix wherever we failed to do the above \ud83d\ude1c</li> </ul>"},{"location":"authorino/docs/contributing/#run-the-tests","title":"Run the tests","text":"<p>To run the tests:</p> <pre><code>make test\n</code></pre>"},{"location":"authorino/docs/contributing/#try-locally","title":"Try locally","text":""},{"location":"authorino/docs/contributing/#build-deploy-and-try-authorino-in-a-local-cluster","title":"Build, deploy and try Authorino in a local cluster","text":"<p>The following command will:</p> <ul> <li>Start a local Kubernetes cluster (using Kind)</li> <li>Install cert-manager in the cluster</li> <li>Install the Authorino Operator and Authorino CRDs</li> <li>Build an image of Authorino based on the current branch</li> <li>Push the freshly built image to the cluster's registry</li> <li>Generate TLS certificates for the Authorino service</li> <li>Deploy an instance of Authorino</li> <li>Deploy the example application Talker API, a simple HTTP API that echoes back whatever it gets in the request</li> <li>Setup Envoy for proxying to the Talker API and using Authorino for external authorization</li> </ul> <pre><code>make local-setup\n</code></pre> <p>You will be prompted to edit the <code>Authorino</code> custom resource.</p> <p>The main workload composed of Authorino instance and user apps (Envoy, Talker API) will be deployed to the <code>default</code> Kubernetes namespace.</p> <p>Once the deployment is ready, you can forward the requests on port 8000 to the Envoy service</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 &amp;\n</code></pre> Pro tips <ol> <li>Change the default workload namespace by supplying the <code>NAMESPACE</code> argument to your <code>make local-setup</code> and other deployment, apps and local cluster related targets. If the namespace does not exist, it will be created.</li> <li>Switch to TLS disabled by default when deploying locally by supplying <code>TLS_ENABLED=0</code> to your <code>make local-setup</code> and <code>make deploy</code> commands. E.g. <code>make local-setup TLS_ENABLED=0</code>.</li> <li>Skip being prompted to edit the <code>Authorino</code> CR and default to an Authorino deployment with TLS enabled, debug/development log level/mode, and standard name 'authorino', by supplying <code>FF=1</code> to your <code>make local-setup</code> and <code>make deploy</code> commands. E.g. <code>make local-setup FF=1</code></li> <li>Supply <code>DEPLOY_IDPS=1</code> to <code>make local-setup</code> and <code>make user-apps</code> to deploy Keycloak and Dex to the cluster. <code>DEPLOY_KEYCLOAK</code> and <code>DEPLOY_DEX</code> are also available. Read more about additional tools for specific use cases in the section below.</li> <li>Saving the ID of the process (PID) of the port-forward command spawned in the background can be useful to later kill and restart the process. E.g. <code>kubectl port-forward deployment/envoy 8000:8000 &amp;;PID=$!</code>; then <code>kill $PID</code>.</li> </ol>"},{"location":"authorino/docs/contributing/#additional-tools-for-specific-use-cases","title":"Additional tools (for specific use-cases)","text":"Limitador <p>To deploy Limitador \u2013 pre-configured in Envoy for rate-limiting the Talker API to 5 hits per minute per <code>user_id</code> when available in the cluster workload \u2013, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre> Keycloak <p>Authorino examples include a bundle of Keycloak preloaded with the following realm setup:</p> <ul> <li>Admin console: http://localhost:8080/admin  (admin/p)</li> <li>Preloaded realm: kuadrant</li> <li>Preloaded clients:<ul> <li>demo: to which API consumers delegate access and therefore the one which access tokens are issued to</li> <li>authorino: used by Authorino to fetch additional user info with <code>client_credentials</code> grant type</li> <li>talker-api: used by Authorino to fetch UMA-protected resource data associated with the Talker API</li> </ul> </li> <li>Preloaded resources:<ul> <li><code>/hello</code></li> <li><code>/greetings/1</code> (owned by user john)</li> <li><code>/greetings/2</code> (owned by user jane)</li> <li><code>/goodbye</code></li> </ul> </li> <li>Realm roles:<ul> <li>member (default to all users)</li> <li>admin</li> </ul> </li> <li>Preloaded users:<ul> <li>john/p (member)</li> <li>jane/p (admin)</li> <li>peter/p (member, email not verified)</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl port-forward deployment/keycloak 8080:8080 &amp;\n</code></pre> Dex <p>Authorino examples include a bundle of Dex preloaded with the following setup:</p> <ul> <li>Preloaded clients:<ul> <li>demo: to which API consumers delegate access and therefore the one which access tokens are issued to (Client secret: aaf88e0e-d41d-4325-a068-57c4b0d61d8e)</li> </ul> </li> <li>Preloaded users:<ul> <li>marta@localhost/password</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/dex/dex-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of Dex running in the cluster:</p> <pre><code>kubectl port-forward deployment/dex 5556:5556 &amp;\n</code></pre> a12n-server <p>Authorino examples include a bundle of a12n-server and corresponding MySQL database, preloaded with the following setup:</p> <ul> <li>Admin console: http://a12n-server:8531 (admin/123456)</li> <li>Preloaded clients:<ul> <li>service-account-1: to obtain access tokens via <code>client_credentials</code> OAuth2 grant type, to consume the Talker API (Client secret: DbgXROi3uhWYCxNUq_U1ZXjGfLHOIM8X3C2bJLpeEdE); includes metadata privilege: <code>{ \"talker-api\": [\"read\"] }</code> that can be used to write authorization policies</li> <li>talker-api: to authenticate to the token introspect endpoint (Client secret: V6g-2Eq2ALB1_WHAswzoeZofJ_e86RI4tdjClDDDb4g)</li> </ul> </li> </ul> <p>To deploy, run:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/a12n-server/a12n-server-deploy.yaml\n</code></pre> <p>Forward local requests to the instance of a12n-server running in the cluster:</p> <pre><code>kubectl port-forward deployment/a12n-server 8531:8531 &amp;\n</code></pre>"},{"location":"authorino/docs/contributing/#re-build-and-rollout-latest","title":"Re-build and rollout latest","text":"<p>Re-build and rollout latest Authorino image:</p> <pre><code>make local-rollout\n</code></pre> <p>If you made changes to the CRD between iterations, re-install by running:</p> <pre><code>make install\n</code></pre>"},{"location":"authorino/docs/contributing/#clean-up","title":"Clean-up","text":"<p>The following command deletes the entire Kubernetes cluster started with Kind:</p> <pre><code>make local-cleanup\n</code></pre>"},{"location":"authorino/docs/contributing/#sign-your-commits","title":"Sign your commits","text":"<p>All commits to be accepted to Authorino's code are required to be signed. Refer to this page about signing your commits.</p>"},{"location":"authorino/docs/contributing/#logging-policy","title":"Logging policy","text":"<p>A few guidelines for adding logging messages in your code:</p> <ol> <li>Make sure you understand Authorino's Logging architecture and policy regarding log levels, log modes, tracing IDs, etc.</li> <li>Respect controller-runtime's Logging Guidelines.</li> <li>Do not add sensitive data to your <code>info</code> log messages; instead, redact all sensitive data in your log messages or use <code>debug</code> log level by mutating the logger with <code>V(1)</code> before outputting the message.</li> </ol>"},{"location":"authorino/docs/contributing/#additional-resources","title":"Additional resources","text":"<p>Here in the repo:</p> <ul> <li>Getting started</li> <li>Terminology</li> <li>Architecture</li> <li>Feature description</li> </ul> <p>Other repos:</p> <ul> <li>Authorino Operator</li> <li>Authorino examples</li> </ul>"},{"location":"authorino/docs/contributing/#reach-out","title":"Reach out","text":"<p>#kuadrant channel on kubernetes.slack.com.</p>"},{"location":"authorino/docs/features/","title":"Features","text":""},{"location":"authorino/docs/features/#overview","title":"Overview","text":"<p>We call features of Authorino the different things one can do to enforce identity verification &amp; authentication and authorization on requests to protected services. These can be a specific identity verification method based on a supported authentication protocol, or a method to fetch additional auth metadata in request-time, etc.</p> <p>Most features of Authorino relate to the different phases of the Auth Pipeline and therefore are configured in the Authorino <code>AuthConfig</code>. An identity verification/authentication feature usually refers to a functionality of Authorino such as the API key-based authentication, the validation of JWTs/OIDC ID tokens, and authentication based on Kubernetes TokenReviews. Analogously, OPA, pattern-matching and Kubernetes SubjectAccessReview are examples of authorization features of Authorino.</p> <p>At a deeper level, a feature can also be an additional functionality within a bigger feature, usually applicable to the whole class the bigger feature belongs to. For instance, the configuration of how auth credentials expected to be carried in the request, which is broadly available for any identity verification method. Other examples are: Identity extension and Priorities.</p> <p>A full specification of all features of Authorino that can be configured in an <code>AuthConfig</code> can be found in the official spec of the custom resource definition.</p> <p>You can also learn about Authorino features by using the <code>kubectl explain</code> command in a Kubernetes cluster where the Authorino CRD has been installed. E.g. <code>kubectl explain authconfigs.spec.authentication.credentials</code>.</p>"},{"location":"authorino/docs/features/#common-feature-json-paths-selector","title":"Common feature: JSON paths (<code>selector</code>)","text":"<p>Deprecated: Prefer <code>predicate</code> and <code>expression</code>, based on Common Expression Language (CEL), instead.</p> <p>The first feature of Authorino to learn about is a common functionality used in the specification of many other features. JSON paths are selectors of data from the Authorization JSON used in parts of an AuthConfig for referring to dynamic values of each authorization request.</p> <p>Usage examples of JSON paths are: dynamic URLs and request parameters when fetching metadata from external sources, dynamic authorization policy rules, and dynamic authorization response attributes (e.g. injected HTTP headers, Festival Wristband token claims, etc).</p>"},{"location":"authorino/docs/features/#syntax","title":"Syntax","text":"<p>The syntax to fetch data from the Authorization JSON with JSON paths is based on GJSON. Refer to GJSON Path Syntax page for more information.</p>"},{"location":"authorino/docs/features/#string-modifiers","title":"String modifiers","text":"<p>On top of GJSON, Authorino defines a few string modifiers.</p> <p>Examples below provided for the following Authorization JSON:</p> <pre><code>{\n  \"context\": {\n    \"request\": {\n      \"http\": {\n        \"path\": \"/pets/123\",\n        \"headers\": {\n          \"authorization\": \"Basic amFuZTpzZWNyZXQK\" // jane:secret\n          \"baggage\": \"eyJrZXkxIjoidmFsdWUxIn0=\" // {\"key1\":\"value1\"}\n        }\n      }\n    }\n  },\n  \"auth\": {\n    \"identity\": {\n      \"username\": \"jane\",\n      \"fullname\": \"Jane Smith\",\n      \"email\": \"\\u0006jane\\u0012@petcorp.com\\n\"\n    },\n  },\n}\n</code></pre> <p><code>@strip</code> Strips out any non-printable characters such as carriage return. E.g. <code>auth.identity.email.@strip</code> \u2192 <code>\"jane@petcorp.com\"</code>.</p> <p><code>@case:upper|lower</code> Changes the case of a string. E.g. <code>auth.identity.username.@case:upper</code> \u2192 <code>\"JANE\"</code>.</p> <p><code>@replace:{\"old\":string,\"new\":string}</code> Replaces a substring within a string. E.g. <code>auth.identity.username.@replace:{\"old\":\"Smith\",\"new\":\"Doe\"}</code> \u2192 <code>\"Jane Doe\"</code>.</p> <p><code>@extract:{\"sep\":string,\"pos\":int}</code> Splits a string at occurrences of a separator (default: <code>\" \"</code>) and selects the substring at the <code>pos</code>-th position (default: <code>0</code>). E.g. <code>context.request.path.@extract:{\"sep\":\"/\",\"pos\":2}</code> \u2192 <code>123</code>.</p> <p><code>@base64:encode|decode</code> base64-encodes or decodes a string value. E.g. <code>auth.identity.username.decoded.@base64:encode</code> \u2192 <code>\"amFuZQo=\"</code>.</p> <p>In combination with <code>@extract</code>, <code>@base64</code> can be used to extract the username in an HTTP Basic Authentication request. E.g. <code>context.request.headers.authorization.@extract:{\"pos\":1}|@base64:decode|@extract:{\"sep\":\":\",\"pos\":1}</code> \u2192 <code>\"jane\"</code>.</p>"},{"location":"authorino/docs/features/#interpolation","title":"Interpolation","text":"<p>JSON paths can be interpolated into strings to build template-like dynamic values. E.g. <code>\"Hello, {auth.identity.name}!\"</code>.</p>"},{"location":"authorino/docs/features/#common-feature-common-expression-language-cel","title":"Common feature: Common Expression Language (CEL)","text":"<p>Similar to JSON Paths, Authorino supports Common Expression Language (CEL) for selecting data from the Authorization JSON and representing predicates. This is a more powerful, properly typed alternative to JSON Paths, with a well-documented syntax.</p> <p>String extension functions, such as <code>split</code>, <code>substring</code>, <code>indexOf</code>, etc, are also supported.</p> <p>Use the <code>expression</code> field for selecting values from the Authorization JSON. The type of the selected value will be converted to a JSON-compatible equivalent. Complex types without a direct JSON equivalent may be converted to objects (e.g. <code>google.golang.org/protobuf/types/known/timestamppb.Timestamp</code> gets converted to <code>{ \"seconds\": Number, \"nanos\": Number }</code>)</p> <p>The most common applications of <code>expression</code> are for building dynamic URLs and request parameters when fetching metadata from external sources, extending properties of identity objects, and dynamic authorization response attributes (e.g. injected HTTP headers, etc).</p> <p>Use <code>predicate</code> for expressions that return a boolean value, such as in <code>when</code> conditions and pattern-matching authorization rules.</p>"},{"location":"authorino/docs/features/#identity-verification-authentication-features-authentication","title":"Identity verification &amp; authentication features (<code>authentication</code>)","text":""},{"location":"authorino/docs/features/#api-key-authenticationapikey","title":"API key (<code>authentication.apiKey</code>)","text":"<p>Authorino relies on Kubernetes <code>Secret</code> resources to represent API keys.</p> <p>To define an API key, create a <code>Secret</code> in the cluster containing an <code>api_key</code> entry that holds the value of the API key.</p> <p>API key secrets must be created in the same namespace of the <code>AuthConfig</code> (default) or <code>spec.authentication.apiKey.allNamespaces</code> must be set to <code>true</code> (only works with cluster-wide Authorino instances).</p> <p>API key secrets must be labeled with the labels that match the selectors specified in <code>spec.authentication.apiKey.selector</code> in the <code>AuthConfig</code>.</p> <p>Whenever an <code>AuthConfig</code> is indexed, Authorino will also index all matching API key secrets. In order for Authorino to also watch events related to API key secrets individually (e.g. new <code>Secret</code> created, updates, deletion/revocation), <code>Secret</code>s must also include a label that matches Authorino's bootstrap configuration <code>--secret-label-selector</code> (default: <code>authorino.kuadrant.io/managed-by=authorino</code>). This label may or may not be present to <code>spec.authentication.apiKey.selector</code> in the <code>AuthConfig</code> without implications for the caching of the API keys when triggered by the reconciliation of the <code>AuthConfig</code>; however, if not present, individual changes related to the API key secret (i.e. without touching the <code>AuthConfig</code>) will be ignored by the reconciler.</p> <p>Example. For the following <code>AuthConfig</code>:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\n  namespace: authorino-system\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"api-key-users\":\n      apiKey:\n        selector:\n          matchLabels: # the key-value set used to select the matching `Secret`s; resources including these labels will be accepted as valid API keys to authenticate to this service\n            group: friends # some custom label\n        allNamespaces: true # only works with cluster-wide Authorino instances; otherwise, create the API key secrets in the same namespace of the AuthConfig\n</code></pre> <p>The following Kubernetes <code>Secret</code> represents a valid API key:</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: user-1-api-key-1\n  namespace: default\n  labels:\n    authorino.kuadrant.io/managed-by: authorino # so the Authorino controller reconciles events related to this secret\n    group: friends\nstringData:\n  api_key: &lt;some-randomly-generated-api-key-value&gt;\ntype: Opaque\n</code></pre> <p>The resolved identity object, added to the authorization JSON following an API key identity source evaluation, is the Kubernetes <code>Secret</code> resource (as JSON).</p>"},{"location":"authorino/docs/features/#kubernetes-tokenreview-authenticationkubernetestokenreview","title":"Kubernetes TokenReview (<code>authentication.kubernetesTokenReview</code>)","text":"<p>Authorino can verify Kubernetes-valid access tokens (using Kubernetes TokenReview API).</p> <p>These tokens can be either <code>ServiceAccount</code> tokens such as the ones issued by kubelet as part of Kubernetes Service Account Token Volume Projection, or any valid user access tokens issued to users of the Kubernetes server API.</p> <p>The list of <code>audiences</code> of the token must include the requested host and port of the protected API (default), or all audiences specified in the Authorino <code>AuthConfig</code> custom resource. For example:</p> <p>For the following <code>AuthConfig</code> CR, the Kubernetes token must include the audience <code>my-api.io</code>:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"cluster-users\":\n      kubernetesTokenReview: {}\n</code></pre> <p>Whereas for the following <code>AuthConfig</code> CR, the Kubernetes token audiences must include foo and bar:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"cluster-users\":\n      kubernetesTokenReview:\n        audiences:\n        - foo\n        - bar\n</code></pre> <p>The resolved identity object added to the authorization JSON following a successful Kubernetes authentication identity evaluation is the <code>status</code> field of TokenReview response (see TokenReviewStatus for reference).</p>"},{"location":"authorino/docs/features/#jwt-verification-authenticationjwt","title":"JWT verification (<code>authentication.jwt</code>)","text":"<p>In reconciliation-time, using OpenID Connect Discovery well-known endpoint, Authorino automatically discovers and caches OpenID Connect configurations and associated JSON Web Key Sets (JWKS) for all OpenID Connect issuers declared in an <code>AuthConfig</code>. Then, in request-time, Authorino verifies the JSON Web Signature (JWS) and check the time validity of signed JSON Web Tokens (JWT) supplied on each request.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p></p> <p>The <code>kid</code> claim stated in the JWT header must match one of the keys cached by Authorino during OpenID Connect Discovery, therefore supporting JWK rotation.</p> <p>The decoded payload of the validated JWT is appended to the authorization JSON as the resolved identity.</p> <p>OpenID Connect configurations and linked JSON Web Key Sets can be configured to be automatically refreshed (pull again from the OpenID Connect Discovery well-known endpoints), by setting the <code>authentication.jwt.ttl</code> field (given in seconds, default: <code>0</code> \u2013 i.e. auto-refresh disabled).</p> <p>For an excellent summary of the underlying concepts and standards that relate OpenID Connect and JSON Object Signing and Encryption (JOSE), see this article by Jan Rusnacko. For official specification and RFCs, see OpenID Connect Core, OpenID Connect Discovery, JSON Web Token (JWT) (RFC7519), and JSON Object Signing and Encryption (JOSE).</p>"},{"location":"authorino/docs/features/#oauth-20-introspection-authenticationoauth2introspection","title":"OAuth 2.0 introspection (<code>authentication.oauth2Introspection</code>)","text":"<p>For bare OAuth 2.0 implementations, Authorino can perform token introspection on the access tokens supplied in the requests to protected APIs.</p> <p>Authorino does not implement any of OAuth 2.0 grants for the applications to obtain the token. However, it can verify supplied tokens with the OAuth server, including opaque tokens, as long as the server exposes the <code>token_introspect</code> endpoint (RFC 7662).</p> <p>Developers must set the token introspection endpoint in the <code>AuthConfig</code>, as well as a reference to the Kubernetes secret storing the credentials of the OAuth client to be used by Authorino when requesting the introspect.</p> <p></p> <p>The response returned by the OAuth2 server to the token introspection request is the resolved identity appended to the authorization JSON.</p>"},{"location":"authorino/docs/features/#x509-client-certificate-authentication-authenticationx509","title":"X.509 client certificate authentication (<code>authentication.x509</code>)","text":"<p>Authorino can verify X.509 certificates presented by clients for authentication on the request to the protected APIs, at application level.</p> <p>Trusted root Certificate Authorities (CA) are stored in Kubernetes Secrets labeled according to selectors specified in the AuthConfig, watched and indexed by Authorino. Make sure to create proper <code>kubernetes.io/tls</code>-typed Kubernetes Secrets, containing the public certificates of the CA stored in either a <code>tls.crt</code> or <code>ca.crt</code> entry inside the secret.</p> <p>Trusted root CA secrets must be created in the same namespace of the <code>AuthConfig</code> (default) or <code>spec.authentication.x509.allNamespaces</code> must be set to <code>true</code> (only works with cluster-wide Authorino instances).</p> <p>Client certificates must include x509 v3 extension specifying 'Client Authentication' extended key usage.</p> <p>The identity object resolved out of a client x509 certificate is equal to the subject field of the certificate, and it serializes as JSON within the Authorization JSON usually as follows:</p> <pre><code>{\n    \"auth\": {\n        \"identity\": {\n            \"CommonName\": \"aisha\",\n            \"Country\": [\"PK\"],\n            \"ExtraNames\": null,\n            \"Locality\": [\"Islamabad\"],\n            \"Names\": [\n                { \"Type\": [2, 5, 4, 3], \"Value\": \"aisha\" },\n                { \"Type\": [2, 5, 4, 6], \"Value\": \"PK\" },\n                { \"Type\": [2, 5, 4, 7], \"Value\": \"Islamabad\" },\n                { \"Type\": [2, 5, 4,10], \"Value\": \"ACME Inc.\" },\n                { \"Type\": [2, 5, 4,11], \"Value\": \"Engineering\" }\n            ],\n            \"Organization\": [\"ACME Inc.\"],\n            \"OrganizationalUnit\": [\"Engineering\"],\n            \"PostalCode\": null,\n            \"Province\": null,\n            \"SerialNumber\": \"\",\n            \"StreetAddress\": null\n        }\n  }\n}\n</code></pre>"},{"location":"authorino/docs/features/#plain-authenticationplain","title":"Plain (<code>authentication.plain</code>)","text":"<p>Authorino can read plain identity objects, based on authentication tokens provided and verified beforehand using other means (e.g. Envoy JWT Authentication filter, Kubernetes API server authentication), and injected into the payload to the external authorization service.</p> <p>The plain identity object is retrieved from the Authorization JSON. See Common Expression Language (CEL).</p> <p>This feature is particularly useful in cases where authentication/identity verification is handled before invoking the authorization service and its resolved value injected in the payload can be trusted. Examples of applications for this feature include:</p> <ul> <li>Authentication handled in Envoy leveraging the Envoy JWT Authentication filter (decoded JWT injected as 'metadata_context')</li> <li>Use of Authorino as Kubernetes ValidatingWebhook service (Kubernetes 'userInfo' injected in the body of the <code>AdmissionReview</code> request)</li> </ul> <p>Example of <code>AuthConfig</code> to retrieve plain identity object from the Authorization JSON.</p> <pre><code>spec:\n  authentication:\n    \"pre-validated-jwt\":\n      plain:\n        expression: metadata.filter_metadata['envoy.filters.http.jwt_authn'].verified_jwt\n</code></pre> <p>If the specified JSON path does not exist in the Authorization JSON or the value is <code>null</code>, the identity verification will fail and, unless other identity config succeeds, Authorino will halt the Auth Pipeline with the usual <code>401 Unauthorized</code>.</p>"},{"location":"authorino/docs/features/#anonymous-access-authenticationanonymous","title":"Anonymous access (<code>authentication.anonymous</code>)","text":"<p>Literally a no-op evaluator for the identity verification phase that returns a static identity object <code>{\"anonymous\":true}</code>.</p> <p>It allows to implement <code>AuthConfigs</code> that bypasses the identity verification phase of Authorino, to such as:</p> <ul> <li>enable anonymous access to protected services (always or combined with Priorities)</li> <li>postpone authentication in the Auth Pipeline to be resolved as part of an OPA policy</li> </ul> <p>Example of <code>AuthConfig</code> spec that falls back to anonymous access when OIDC authentication fails, enforcing read-only access to the protected service in such cases:</p> <pre><code>spec:\n  authentication:\n    \"jwt\":\n      jwt:\n        issuerUrl: \"\u2026\"\n    \"anonymous\":\n      priority: 1 # expired oidc token, missing creds, etc. default to anonymous access\n      anonymous: {}\n  authorization:\n    \"read-only-access-if-authn-fails\":\n      when:\n\n      - predicate: has(auth.identity.anonymous) &amp;&amp; auth.identity.anonymous\n      patternMatching:\n        patterns:\n        - predicate: request.method == 'GET'\n</code></pre>"},{"location":"authorino/docs/features/#festival-wristband-authentication","title":"Festival Wristband authentication","text":"<p>Authorino-issued Festival Wristband tokens can be validated as any other signed JWT using Authorino's JWT verification.</p> <p>The value of the issuer must be the same issuer specified in the custom resource for the protected API originally issuing wristband. Eventually, this can be the same custom resource where the wristband is configured as a valid source of identity, but not necessarily.</p>"},{"location":"authorino/docs/features/#extra-auth-credentials-authenticationcredentials","title":"Extra: Auth credentials (<code>authentication.credentials</code>)","text":"<p>All the identity verification methods supported by Authorino can be configured regarding the location where access tokens and credentials (i.e. authentication secrets) fly within the request.</p> <p>By default, authentication secrets are expected to be supplied in the <code>Authorization</code> HTTP header, with the default <code>Bearer</code> prefix and the plain authentication secret separated by space.</p> <p>The full list of supported options is exemplified below:</p> <pre><code>spec:\n  authentication:\n    \"creds-in-the-authz-header\":\n      credentials:\n        authorizationHeader:\n          prefix: JWT\n\n    \"creds-in-a-custom-header\":\n      credentials:\n        customHeader:\n          name: X-MY-CUSTOM-HEADER\n          prefix: \"\"\n\n    \"creds-in-a-query-param\":\n      queryString:\n        name: my_param\n\n    \"creds-in-a-cookie-entry\":\n      cookie:\n        name: cookie-key\n</code></pre>"},{"location":"authorino/docs/features/#extra-identity-extension-authenticationdefaults-and-authenticationoverrides","title":"Extra: Identity extension (<code>authentication.defaults</code> and <code>authentication.overrides</code>)","text":"<p>Resolved identity objects can be extended with user-defined JSON properties. Values can be static or fetched from the Authorization JSON.</p> <p>A typical use-case for this feature is token normalization. Say you have more than one identity source listed in your <code>AuthConfig</code> but each source issues an access token with a different JSON structure \u2013 e.g. two OIDC issuers that use different names for custom JWT claims of similar meaning; when two different identity verification/authentication methods are combined, such as API keys (whose identity objects are the corresponding Kubernetes <code>Secret</code>s) and Kubernetes tokens (whose identity objects are Kubernetes UserInfo data).</p> <p>In such cases, identity extension can be used to normalize the token to always include the same set of JSON properties of interest, regardless of the source of identity that issued the original token verified by Authorino. This simplifies the writing of authorization policies and configuration of dynamic responses.</p> <p>In case of extending an existing property of the identity object (replacing), the API allows to control whether to overwrite the value or not. This is particularly useful for normalizing tokens of a same identity source that nonetheless may occasionally differ in structure, such as in the case of JWT claims that sometimes may not be present but can be safely replaced with another (e.g. <code>username</code> or <code>sub</code>).</p>"},{"location":"authorino/docs/features/#external-auth-metadata-features-metadata","title":"External auth metadata features (<code>metadata</code>)","text":""},{"location":"authorino/docs/features/#http-getget-by-post-metadatahttp","title":"HTTP GET/GET-by-POST (<code>metadata.http</code>)","text":"<p>Generic HTTP adapter that sends a request to an external service. It can be used to fetch external metadata for the authorization policies (phase ii of the Authorino Auth Pipeline), or as a web hook.</p> <p>The adapter allows issuing requests either by GET or POST methods; in both cases with URL and parameters defined by the user in the spec. Dynamic values fetched from the Authorization JSON can be used.</p> <p>POST request parameters as well as the encoding of the content can be controlled using the <code>bodyParameters</code> and <code>contentType</code> fields of the config, respectively. The Content-Type of POST requests can be either <code>application/x-www-form-urlencoded</code> (default) or <code>application/json</code>.</p> <p>Authentication of Authorino with the external metadata server can be set either via long-lived shared secret stored in a Kubernetes Secret or via OAuth2 client credentials grant. For long-lived shared secret, set the <code>sharedSecretRef</code> field. For OAuth2 client credentials grant, use the <code>oauth2</code> option.</p> <p>In both cases, the location where the secret (long-lived or OAuth2 access token) travels in the request performed to the external HTTP service can be specified in the <code>credentials</code> field. By default, the authentication secret is supplied in the <code>Authorization</code> header with the <code>Bearer</code> prefix.</p> <p>Custom headers can be set with the <code>headers</code> field. Nevertheless, headers such as <code>Content-Type</code> and <code>Authorization</code> (or eventual custom header used for carrying the authentication secret, set instead via the <code>credentials</code> option) will be superseded by the respective values defined for the fields <code>contentType</code> and <code>sharedSecretRef</code>.</p>"},{"location":"authorino/docs/features/#oidc-userinfo-metadatauserinfo","title":"OIDC UserInfo (<code>metadata.userInfo</code>)","text":"<p>Online fetching of OpenID Connect (OIDC) UserInfo data (phase ii of the Authorino Auth Pipeline), associated with an OIDC identity source configured and resolved in phase (i).</p> <p>Apart from possibly complementing information of the JWT, fetching OpenID Connect UserInfo in request-time can be particularly useful for remote checking the state of the session, as opposed to only verifying the JWT/JWS offline.</p> <p>Implementation requires a JWT verification authentication config (<code>spec.authentication.jwt</code>) in the same <code>AuthConfig</code>, so the well-known configuration of the OpenId Connect (OIDC) issuer can be reused.</p> <p>The response returned by the OIDC server to the UserInfo request is appended (as JSON) to <code>auth.metadata</code> in the authorization JSON.</p>"},{"location":"authorino/docs/features/#user-managed-access-uma-resource-registry-metadatauma","title":"User-Managed Access (UMA) resource registry (<code>metadata.uma</code>)","text":"<p>User-Managed Access (UMA) is an OAuth-based protocol for resource owners to allow other users to access their resources. Since the UMA-compliant server is expected to know about the resources, Authorino includes a client that fetches resource data from the server and adds that as metadata of the authorization payload.</p> <p>This enables the implementation of resource-level Attribute-Based Access Control (ABAC) policies. Attributes of the resource fetched in a UMA flow can be, e.g., the owner of the resource, or any business-level attributes stored in the UMA-compliant server.</p> <p>A UMA-compliant server is an external authorization server (e.g., Keycloak) where the protected resources are registered. It can be as well the upstream API itself, as long as it implements the UMA protocol, with initial authentication by <code>client_credentials</code> grant to exchange for a Protected API Token (PAT).</p> <p></p> <p>It's important to notice that Authorino does NOT manage resources in the UMA-compliant server. As shown in the flow above, Authorino's UMA client is only to fetch data about the requested resources. Authorino exchanges client credentials for a Protected API Token (PAT), then queries for resources whose URI match the path of the HTTP request (as passed to Authorino by the Envoy proxy) and fetches data of each matching resource.</p> <p>The resources data is added as metadata of the authorization payload and passed as input for the configured authorization policies. All resources returned by the UMA-compliant server in the query by URI are passed along. They are available in the PDPs (authorization payload) as <code>input.auth.metadata.custom-name =&gt; Array</code>. (See The \"Auth Pipeline\" for details.)</p>"},{"location":"authorino/docs/features/#authorization-features-authorization","title":"Authorization features (<code>authorization</code>)","text":""},{"location":"authorino/docs/features/#pattern-matching-authorization-authorizationpatternmatching","title":"Pattern-matching authorization (<code>authorization.patternMatching</code>)","text":"<p>Grant/deny access based on simple pattern-matching expressions (\"patterns\") compared against values selected from the Authorization JSON.</p> <p>Each expression is composed of exactly one of the following options:</p> <ol> <li>a <code>predicate</code> field - Common Expression Language (CEL) expression that evaluates to a boolean value;</li> <li>a tuple composed of:</li> <li><code>selector</code>: a JSON path to fetch a value from the Authorization JSON</li> <li><code>operator</code>: one of: <code>eq</code> (equals), <code>neq</code> (not equal); <code>incl</code> (includes) and <code>excl</code> (excludes), for arrays; and <code>matches</code>, for regular expressions</li> <li><code>value</code>: a static string value to compare the value selected from the Authorization JSON with;</li> <li>a <code>patternRef</code> field \u2013 value that maps to a predefined set of <code>{ selector, operator, value }</code> tuples stored at the top-level of the AuthConfig spec (<code>patterns</code>).</li> </ol> <p>Rules can mix and combine literal expressions and references to expression sets (\"named patterns\") defined at the upper level of the <code>AuthConfig</code> spec. (See Common feature: Conditions)</p> <pre><code>spec:\n  authorization:\n    \"my-simple-json-pattern-matching-policy\":\n      patternMatching:\n        patterns: # All patterns must match for access to be granted\n\n        - predicate: auth.identity.email_verified\n        - patternRef: admin\n\n  patterns:\n    admin: # a named pattern that can be reused in other sets of rules or conditions\n\n    - selector: auth.identity.roles\n      operator: incl\n      value: admin\n</code></pre>"},{"location":"authorino/docs/features/#open-policy-agent-opa-rego-policies-authorizationopa","title":"Open Policy Agent (OPA) Rego policies (<code>authorization.opa</code>)","text":"<p>You can model authorization policies in Rego language and add them as part of the protection of your APIs.</p> <p>Policies can be either declared in-line in Rego language (<code>rego</code>) or as an HTTP endpoint where Authorino will fetch the source code of the policy in reconciliation-time (<code>externalPolicy</code>).</p> <p>Policies pulled from external registries can be configured to be automatically refreshed (pulled again from the external registry), by setting the <code>authorization.opa.externalPolicy.ttl</code> field (given in seconds, default: <code>0</code> \u2013 i.e. auto-refresh disabled).</p> <p>Authorino's built-in OPA module precompiles the policies during reconciliation of the AuthConfig and caches the precompiled policies for fast evaluation in runtime, where they receive the Authorization JSON as input.</p> <p></p> <p>An optional field <code>allValues: boolean</code> makes the values of all rules declared in the Rego document to be returned in the OPA output after policy evaluation. When disabled (default), only the boolean value <code>allow</code> is returned. Values of internal rules of the Rego document can be referenced in subsequent policies/phases of the Auth Pipeline.</p>"},{"location":"authorino/docs/features/#kubernetes-subjectaccessreview-authorizationkubernetessubjectaccessreview","title":"Kubernetes SubjectAccessReview (<code>authorization.kubernetesSubjectAccessReview</code>)","text":"<p>Access control enforcement based on rules defined in the Kubernetes authorization system, i.e. <code>Role</code>, <code>ClusterRole</code>, <code>RoleBinding</code> and <code>ClusterRoleBinding</code> resources of Kubernetes RBAC.</p> <p>Authorino issues a SubjectAccessReview (SAR) inquiry that checks with the underlying Kubernetes server whether the user can access a particular resource, resource kind or generic URL.</p> <p>It supports resource attributes authorization check (parameters defined in the <code>AuthConfig</code>) and non-resource attributes authorization check (HTTP endpoint inferred from the original request).</p> <ul> <li>Resource attributes: adequate for permissions set at namespace level, defined in terms of common attributes of operations on Kubernetes resources (namespace, API group, kind, name, subresource, verb)</li> <li>Non-resource attributes: adequate for permissions set at cluster scope, defined for protected endpoints of a generic HTTP API (URL path + verb)</li> </ul> <p>Example of Kubernetes role for resource attributes authorization:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  name: pet-reader\nrules:\n\n- apiGroups: [\"pets.io\"]\n  resources: [\"pets\"]\n  verbs: [\"get\"]\n</code></pre> <p>Example of Kubernetes cluster role for non-resource attributes authorization:</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: pet-editor\nrules:\n\n- nonResourceURLs: [\"/pets/*\"]\n  verbs: [\"put\", \"delete\"]\n</code></pre> <p>Kubernetes' authorization policy configs look like the following in an Authorino <code>AuthConfig</code>:</p> <pre><code>authorization:\n  \"kubernetes-rbac\":\n    kubernetesSubjectAccessReview:\n      user: # values of the parameter can be fixed (`value`) or fetched from the Authorization JSON (`selector`)\n        expression: auth.identity.metadata.annotations.userid\n\n      groups: [] # user groups to test for.\n\n      # for resource attributes permission checks; omit it to perform a non-resource attributes SubjectAccessReview with path and method/verb assumed from the original request\n      # if included, use the resource attributes, where the values for each parameter can be fixed (`value`) or fetched from the Authorization JSON (`selector`)\n      resourceAttributes:\n        namespace:\n          value: default\n        group:\n          value: pets.io # the api group of the protected resource to be checked for permissions for the user\n        resource:\n          value: pets # the resource kind\n        name:\n          expression: request.path.split('/')[2] # resource name \u2013 e.g., the {id} in `/pets/{id}`\n        verb:\n          expression: request.method.lowerAscii() # api operation \u2013 e.g., copying from the context to use the same http method of the request\n</code></pre> <p><code>user</code> and properties of <code>resourceAttributes</code> can be defined from fixed values or patterns of the Authorization JSON.</p> <p>An array of <code>groups</code> (optional) can as well be set. When defined, it will be used in the <code>SubjectAccessReview</code> request.</p>"},{"location":"authorino/docs/features/#spicedb-authorizationspicedb","title":"SpiceDB (<code>authorization.spicedb</code>)","text":"<p>Check permission requests via gRPC with an external Google Zanzibar-inspired SpiceDB server, by Authzed.</p> <p>Subject, resource and permission parameters can be set to static values or read from the Authorization JSON.</p> <pre><code>spec:\n  authorization:\n    \"spicedb\":\n      spicedb:\n        endpoint: spicedb:50051\n        insecure: true # disables TLS\n        sharedSecretRef:\n          name: spicedb\n          key: token\n        subject:\n          kind:\n            value: blog/user\n          name:\n            expression: auth.identity.sub\n        resource:\n          kind:\n            value: blog/post\n          name:\n            expression: request.path.split('/')[2] # /posts/{id}\n        permission:\n          expression: request.method\n</code></pre>"},{"location":"authorino/docs/features/#custom-response-features-response","title":"Custom response features (<code>response</code>)","text":""},{"location":"authorino/docs/features/#custom-response-forms-successful-authorization-vs-custom-denial-status","title":"Custom response forms: successful authorization vs custom denial status","text":"<p>The response to the external authorization request can be customized in the following fashion:</p> <ul> <li>Successful authorization (<code>response.success</code>)</li> <li>Added HTTP headers (<code>response.success.headers</code>)</li> <li>Envoy Dynamic Metadata (<code>response.success.dynamicMetadata</code>)</li> <li>Custom denial status</li> <li>Unauthenticated (<code>response.unauthenticated</code>)</li> <li>Unauthorized (<code>response.unauthorized</code>)</li> </ul> <p>Successful authorization custom responses can be set based on any of the supported custom authorization methods:</p> <ul> <li>Plain text value</li> <li>JSON injection</li> <li>Festival Wristband Tokens</li> </ul>"},{"location":"authorino/docs/features/#added-http-headers","title":"Added HTTP headers","text":"<p>Set custom responses as HTTP headers injected in the request post-successful authorization by specifying one of the supported methods under <code>response.success.headers</code>.</p> <p>The name of the response config (default) or the value of the <code>key</code> option (if provided) will used as the name of the header.</p>"},{"location":"authorino/docs/features/#envoy-dynamic-metadata","title":"Envoy Dynamic Metadata","text":"<p>Authorino custom response methods can also be used to propagate Envoy Dynamic Metadata. To do so, set one of the supported methods under <code>response.success.dynamicMetadata</code>.</p> <p>The name of the response config (default) or the value of the <code>key</code> option (if provided) will used as the name of the root property of the dynamic metadata content.</p> <p>A custom response exported as Envoy Dynamic Metadata can be set in the Envoy route or virtual host configuration as input to a consecutive filter in the filter chain.</p> <p>E.g., to read metadata emitted by the authorization service with scheme <code>{ \"auth-data\": { \"api-key-ns\": string, \"api-key-name\": string } }</code>, as input in a rate limit configuration placed in the filter chain after the external authorization, the Envoy config may look like the following:</p> <pre><code># Envoy config snippet to inject `user_namespace` and `username` rate limit descriptors from metadata emitted by Authorino\nrate_limits:\n\n- actions:\n  - metadata:\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - key: auth-data # root of the dynamic metadata object, as declared in a custom response config of the AuthConfig (name or key)\n        - key: api-key-ns\n      descriptor_key: user_namespace\n  - metadata:\n      metadata_key:\n        key: \"envoy.filters.http.ext_authz\"\n        path:\n        - key: auth-data # root of the dynamic metadata object, as declared in a custom response config of the AuthConfig (name or key)\n        - key: api-key-name\n      descriptor_key: username\n</code></pre>"},{"location":"authorino/docs/features/#custom-denial-status-responseunauthenticated-and-responseunauthorized","title":"Custom denial status (<code>response.unauthenticated</code> and <code>response.unauthorized</code>)","text":"<p>By default, Authorino will inform Envoy to respond with <code>401 Unauthorized</code> or <code>403 Forbidden</code> respectively when the identity verification (phase i of the Auth Pipeline) or authorization (phase ii) fail. These can be customized respectively by specifying <code>spec.response.unauthanticated</code> and <code>spec.response.unauthorized</code> in the <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/features/#custom-response-methods","title":"Custom response methods","text":""},{"location":"authorino/docs/features/#plain-text-responsesuccessheadersdynamicmetadataplain","title":"Plain text (<code>response.success.&lt;headers|dynamicMetadata&gt;.plain</code>)","text":"<p>Simpler, yet more generalized form, for extending the authorization response for header mutation and Envoy Dynamic Metadata, based on plain text values.</p> <p>The value can be static:</p> <pre><code>response:\n  success:\n    headers:\n      \"x-auth-service\"\n        plain:\n          value: Authorino\n</code></pre> <p>or fetched dynamically from the Authorization JSON (which includes support for interpolation):</p> <pre><code>response:\n  success:\n    headers:\n      \"x-username\":\n        plain:\n          expression: auth.identity.username\n</code></pre>"},{"location":"authorino/docs/features/#json-injection-responsesuccessheadersdynamicmetadatajson","title":"JSON injection (<code>response.success.&lt;headers|dynamicMetadata&gt;.json</code>)","text":"<p>User-defined dynamic JSON objects generated by Authorino in the response phase, from static or dynamic data of the auth pipeline, and passed back to the external authorization client within added HTTP headers or Dynamic Metadata.</p> <p>The following Authorino <code>AuthConfig</code> custom resource is an example that defines 3 dynamic JSON response items, where two items are returned to the client, stringified, in added HTTP headers, and the third as Envoy Dynamic Metadata. Envoy proxy can be configured to propagate the dynamic metadata emitted by Authorino into another filter \u2013 e.g. the rate limit filter.</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  namespace: my-namespace\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"edge\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-my-custom-header\":\n          json:\n            properties:\n              \"prop1\":\n                value: value1\n              \"prop2\":\n                expression: some.path.within.auth.json\n        \"x-ext-auth-other-json\":\n          json:\n            properties:\n              \"propX\":\n                value: valueX\n\n      dynamicMetadata:\n        \"auth-data\":\n          json:\n            properties:\n              \"api-key-ns\":\n                expression: auth.identity.metadata.namespace\n              \"api-key-name\":\n                expression: auth.identity.metadata.name\n</code></pre>"},{"location":"authorino/docs/features/#festival-wristband-tokens-responsesuccessheadersdynamicmetadatawristband","title":"Festival Wristband tokens (<code>response.success.&lt;headers|dynamicMetadata&gt;.wristband</code>)","text":"<p>Festival Wristbands are signed OpenID Connect JSON Web Tokens (JWTs) issued by Authorino at the end of the auth pipeline and passed back to the client, typically in added HTTP response header. It is an opt-in feature that can be used to implement Edge Authentication Architecture (EAA) and enable token normalization. Authorino wristbands include minimal standard JWT claims such as <code>iss</code>, <code>iat</code>, and <code>exp</code>, and optional user-defined custom claims, whose values can be static or dynamically fetched from the authorization JSON.</p> <p>The Authorino <code>AuthConfig</code> custom resource below sets an API protection that issues a wristband after a successful authentication via API key. Apart from standard JWT claims, the wristband contains 2 custom claims: a static value <code>aud=internal</code> and a dynamic value <code>born</code> that fetches from the authorization JSON the date/time of creation of the secret that represents the API key used to authenticate.</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  namespace: my-namespace\n  name: my-api-protection\nspec:\n  hosts:\n\n  - my-api.io\n  authentication:\n    \"edge\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-wristband\":\n          wristband:\n            issuer: https://authorino-oidc.default.svc:8083/my-namespace/my-api-protection/x-wristband\n            customClaims:\n              \"aud\":\n                value: internal\n              \"age\":\n                expression: int(request.time.seconds) - (timestamp(auth.identity.metadata.creationTimestamp) - timestamp(\"1970-01-01T00:00:00Z\")).getSeconds()\n            tokenDuration: 300\n            signingKeyRefs:\n            - name: my-signing-key\n              algorithm: ES256\n            - name: my-old-signing-key\n              algorithm: RS256\n</code></pre> <p>The signing key names listed in <code>signingKeyRefs</code> must match the names of Kubernetes <code>Secret</code> resources created in the same namespace, where each secret contains a <code>key.pem</code> entry that holds the value of the private key that will be used to sign the wristbands issued, formatted as PEM. The first key in this list will be used to sign the wristbands, while the others are kept to support key rotation.</p> <p>For each protected API configured for the Festival Wristband issuing, Authorino exposes the following OpenID Connect Discovery well-known endpoints (available for requests within the cluster):</p> <ul> <li>OpenID Connect configuration:   https://authorino-oidc.default.svc:8083/{namespace}/{api-protection-name}/{response-config-name}/.well-known/openid-configuration</li> <li>JSON Web Key Set (JWKS) well-known endpoint:   https://authorino-oidc.default.svc:8083/{namespace}/{api-protection-name}/{response-config-name}/.well-known/openid-connect/certs</li> </ul>"},{"location":"authorino/docs/features/#callbacks-callbacks","title":"Callbacks (<code>callbacks</code>)","text":""},{"location":"authorino/docs/features/#http-endpoints-callbackshttp","title":"HTTP endpoints (<code>callbacks.http</code>)","text":"<p>Sends requests to specified HTTP endpoints at the end of the auth pipeline.</p> <p>The scheme of the <code>http</code> field is the same as of <code>metadata.http</code>.</p> <p>Example:</p> <pre><code>spec:\n  authentication: [\u2026]\n  authorization: [\u2026]\n\n  callbacks:\n    \"log\":\n      http:\n        url: http://logsys\n        method: POST\n        body:\n          expression: |\n            { \"requestId\": request.id, \"username\": auth.identity.username, \"authorizationResult\": auth.authorization }\n    \"important-forbidden\":\n      when:\n\n      - predicate: \"!auth.authorization.important-policy\"\n      http:\n        urlExpression: |\n          \"http://monitoring/important?forbidden-user=\" + auth.identity.username\n</code></pre>"},{"location":"authorino/docs/features/#common-feature-priorities","title":"Common feature: Priorities","text":"<p>Priorities allow to set sequence of execution for blocks of concurrent evaluators within phases of the Auth Pipeline.</p> <p>Evaluators of same priority execute concurrently to each other \"in a block\". After syncing that block (i.e. after all evaluators of the block have returned), the next block of evaluator configs of consecutive priority is triggered.</p> <p>Use cases for priorities are:</p> <ol> <li>Saving expensive tasks to be triggered when there's a high chance of returning immediately after finishing executing a less expensive one \u2013 e.g.<ul> <li>an identity config that calls an external IdP to verify a token that is rarely used, compared to verifying JWTs preferred by most users of the service;</li> <li>an authorization policy that performs some quick checks first, such as verifying allowed paths, and only if it passes, moves to the evaluation of a more expensive policy.</li> </ul> </li> <li>Establishing dependencies between evaluators - e.g.<ul> <li>an external metadata request that needs to wait until a previous metadata responds first (in order to use data from the response)</li> </ul> </li> </ol> <p>Priorities can be set using the <code>priority</code> property available in all evaluator configs of all phases of the Auth Pipeline (identity, metadata, authorization and response). The lower the number, the highest the priority. By default, all evaluators have priority 0 (i.e. highest priority).</p> <p>Consider the following example to understand how priorities work:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api\n  authentication:\n    \"tier-1\":\n      priority: 0\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"1\"\n    \"tier-2\":\n      priority: 1\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"2\"\n    \"tier-3\":\n      priority: 1\n      apiKey:\n        selector:\n          matchLabels:\n            tier: \"3\"\n  metadata:\n    \"first\":\n      http:\n        url: http://talker-api:3000\n    \"second\":\n      priority: 1\n      http:\n        url: http://talker-api:3000/first_uuid={auth.metadata.first.uuid}\n  authorization:\n    \"allowed-endpoints\":\n      when:\n      - predicate: |\n          !(request.path in ['/hi', '/hello', '/aloha', '/ciao'])\n      patternMatching:\n        patterns:\n        - pattern: \"true\"\n    \"more-expensive-policy\": # no point in evaluating this one if it's not an allowed endpoint\n      priority: 1\n      opa:\n        rego: |\n          allow { true }\n  response:\n    success:\n      headers:\n        \"x-auth-data\":\n          json:\n            properties:\n              \"tier\":\n                expression: auth.identity.metadata.labels.tier\n              \"first-uuid\":\n                expression: auth.metadata.first.uuid\n              \"second-uuid\":\n                expression: auth.metadata.second.uuid\n              \"second-path\":\n                expression: auth.metadata.second.path\n</code></pre> <p>For the <code>AuthConfig</code> above,</p> <ul> <li> <p>Identity configs <code>tier-2</code> and <code>tier-3</code> (priority 1) will only trigger (concurrently) in case <code>tier-1</code> (priority 0) fails to validate the authentication token first. (This behavior happens without prejudice of context canceling between concurrent evaluators \u2013 i.e. evaluators that are triggered concurrently to another, such as <code>tier-2</code> and <code>tier-3</code>, continue to cancel the context of each other if any of them succeeds validating the token first.)</p> </li> <li> <p>Metadata source <code>second</code> (priority 1) uses the response of the request issued by metadata source <code>first</code> (priority 0), so it will wait for <code>first</code> to finish by triggering only in the second block.</p> </li> <li> <p>Authorization policy <code>allowed-endpoints</code> (priority 0) is considered to be a lot less expensive than <code>more-expensive-policy</code> (priority 1) and has a high chance of denying access to the protected service (if the path is not one of the allowed endpoints). By setting different priorities to these policies we ensure the more expensive policy if triggered in sequence of the less expensive one, instead of concurrently.</p> </li> </ul>"},{"location":"authorino/docs/features/#common-feature-conditions-when","title":"Common feature: Conditions (<code>when</code>)","text":"<p>Conditions, identified by the <code>when</code> field in the AuthConfig API, are logical expressions (\"predicates\") that can be used to condition the evaluation of a particular auth rule, as well as of the AuthConfig altogether (\"top-level conditions\").</p> <p>The predicates are evaluated against the Authorization JSON, where each predicate is composed of exactly one of the following options:</p> <ol> <li>a <code>predicate</code> field \u2013 CEL expression that evaluates to a boolean value;</li> <li>a tuple composed of:</li> <li><code>selector</code>: a JSON path to fetch a value from the Authorization JSON</li> <li><code>operator</code>: one of: <code>eq</code> (equals); <code>neq</code> (not equal); <code>incl</code> (includes) and <code>excl</code> (excludes), for when the value fetched from the Authorization JSON is expected to be an array; <code>matches</code>, for regular expressions</li> <li><code>value</code>: a static string value to compare the value selected from the Authorization JSON with;</li> <li>a <code>patternRef</code> field \u2013 value that maps to a predefined set of <code>{ selector, operator, value }</code> tuples stored at the top-level of the AuthConfig spec (<code>patterns</code>).</li> </ol> <p>An expression contains one or more patterns and they must either all evaluate to true (\"AND\" operator, declared by grouping the patterns within an <code>all</code> block) or at least one of the patterns must be true (\"OR\" operator, when grouped within an <code>any</code> block.) Patterns not explicitly grouped are AND'ed by default.</p> <p>Examples of <code>when</code> conditions</p> <p>i) to skip an entire <code>AuthConfig</code> based on the context (AND operator assumed by default):</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/*\n\n  - predicate: request.method == 'POST' &amp;&amp; request.path.matches(\"^/resources/.*\")\n</code></pre> <p>ii) equivalent to the above using <code>{ selector, operator, value }</code> tuples and an explicit AND operator (<code>all</code>):</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/*\n\n  - all:\n    - selector: request.method\n      operator: eq\n      value: POST\n    - selector: request.path\n      operator: matches\n      value: ^/resources/.*\n</code></pre> <p>iii) OR condition (<code>any</code>) using <code>{ selector, operator, value }</code> tuples:</p> <pre><code>spec:\n  when: # auth enforced only on requests with HTTP method equals to POST or PUT\n\n  - any:\n    - selector: request.method\n      operator: eq\n      value: POST\n    - selector: request.method\n      operator: eq\n      value: PUT\n</code></pre> <p>iv) complex expression with nested operations using <code>{ selector, operator, value }</code> tuples:</p> <pre><code>spec:\n  when: # auth enforced only on requests to POST /resources/* or PUT /resources/*\n\n  - any:\n    - all:\n      - selector: request.method\n        operator: eq\n        value: POST\n      - selector: request.path\n        operator: matches\n        value: ^/resources/.*\n    - all:\n      - selector: request.method\n        operator: eq\n        value: PUT\n      - selector: request.path\n        operator: matches\n        value: ^/resources/.*\n</code></pre> <p>v) more concise equivalent of the above using CEL:</p> <pre><code>spec:\n  when: # auth enforced only on requests to /resources/* path with method equals to POST or PUT\n\n  - predicate: request.path .matches(\"^/resources/.*\") &amp;&amp; request.method in ['POST', 'PUT']\n</code></pre> <p>vi) to skip part of an AuthConfig (i.e., a specific auth rule):</p> <pre><code>spec:\n  metadata:\n    \"metadata-source\":\n      http:\n        url: https://my-metadata-source.io\n      when: # only fetch the external metadata if the context is HTTP method other than OPTIONS\n\n      - predicate: request.method != 'OPTIONS'\n</code></pre> <p>vii) skipping part of an AuthConfig will not affect other auth rules:</p> <pre><code>spec:\n  authentication:\n    \"authn-meth-1\":\n      apiKey: {\u2026} # this auth rule only triggers for POST requests to /foo[/*]\n      when:\n\n      - predicate: request.method == 'POST' &amp;&amp; request.path.matches(\"^/foo(/.*)?$\")\n\n    \"authn-meth-2\": # this auth rule triggerred regardless\n      jwt: {\u2026}\n</code></pre> <p>viii) concrete use-case: evaluating only the necessary identity checks based on the user's indication of the preferred authentication method (prefix of the value supplied in the HTTP <code>Authorization</code> request header):</p> <pre><code>spec:\n  authentication:\n    \"jwt\":\n      when:\n\n      - predicate: request.headers['authorization'].startsWith('JWT')\n      jwt: {\u2026}\n\n    \"api-key\":\n      when:\n\n      - predicate: request.headers['authorization'].startsWith('APIKEY')\n      apiKey: {\u2026}\n</code></pre> <p>ix) to avoid repetition while defining patterns for conditions:</p> <pre><code>spec:\n  patterns:\n    a-pet: # a named pattern that can be reused in sets of conditions\n\n    - selector: context.request.http.path\n      operator: matches\n      value: ^/pets/\\d+(/.*)$\n\n  metadata:\n    \"pets-info\":\n      when:\n\n      - patternRef: a-pet\n      http:\n        urlExpression: |\n          \"https://pets-info.io?petId=\" + request.path.split('/')[2]\n\n  authorization:\n    \"pets-owners-only\":\n      when:\n\n      - patternRef: a-pet\n      opa:\n        rego: |\n          allow { input.metadata[\"pets-info\"].ownerid == input.auth.identity.userid }\n</code></pre> <p>x) combining literals and refs \u2013 concrete case: authentication required for selected operations:</p> <pre><code>spec:\n  patterns:\n    api-base-path:\n\n    - selector: request.path\n      operator: matches\n      value: ^/api/.*\n\n    authenticated-user:\n\n    - selector: auth.identity.anonymous\n      operator: neq\n      value: \"true\"\n\n  authentication:\n    api-users: # tries to authenticate all requests to path /api/*\n      when:\n\n      - patternRef: api-base-path\n      jwt: {\u2026}\n\n    others: # defaults to anonymous access when authentication fails or not /api/* path\n      anonymous: {}\n      priority: 1\n\n  authorization:\n    api-write-access-requires-authentication: # POST/PUT/DELETE requests to /api/* path cannot be anonymous\n      when:\n\n      - patternRef: api-base-path\n      - predicate: request.method in ['POST', 'PUT', 'DELETE']\n      opa:\n        patternMatching:\n          rules:\n          - patternRef: authenticated-user\n\n  response: # bonus: export user data if available\n    success:\n      dynamicMetadata:\n        \"user-data\":\n          when:\n\n          - patternRef: authenticated-user\n          json:\n            properties:\n              jwt-claims:\n                expression: auth.identity\n</code></pre>"},{"location":"authorino/docs/features/#common-feature-caching-cache","title":"Common feature: Caching (<code>cache</code>)","text":"<p>Objects resolved at runtime in an Auth Pipeline can be cached \"in-memory\", and avoided being evaluated again at a subsequent request, until it expires. A lookup cache key and a TTL can be set individually for any evaluator config in an AuthConfig.</p> <p>Each cache config induces a completely independent cache table (or \"cache namespace\"). Consequently, different evaluator configs can use the same cache key and there will be no collision between entries from different evaluators.</p> <p>E.g.:</p> <pre><code>spec:\n  hosts:\n\n  - my-api.io\n\n  authentication: [\u2026]\n\n  metadata:\n    \"external-metadata\":\n      http:\n        urlExpression: |\n          \"http://my-external-source?search=\" + request.path\n      cache:\n        key:\n          expression: request.path\n        ttl: 300\n\n  authorization:\n    \"complex-policy\":\n      opa:\n        externalPolicy:\n          url: http://my-policy-registry\n      cache:\n        key:\n          expression: auth.identity.group + '-' + request.method + '-' + request.path\n        ttl: 60\n</code></pre> <p>The example above sets caching for the 'external-metadata' metadata config and for the 'complex-policy' authorization policy. In the case of 'external-metadata', the cache key is the path of the original HTTP request being authorized by Authorino (fetched dynamically from the Authorization JSON); i.e., after obtaining a metadata object from the external source for a given contextual HTTP path one first time, whenever that same HTTP path repeats in a subsequent request, Authorino will use the cached object instead of sending a request again to the external source of metadata. After 5 minutes (300 seconds), the cache entry will expire and Authorino will fetch again from the source if requested.</p> <p>As for the 'complex-policy' authorization policy, the cache key is a string composed the 'group' the identity belongs to, the method of the HTTP request and the path of the HTTP request. Whenever these repeat, Authorino will use the result of the policy that was evaluated and cached priorly. Cache entries in this namespace expire after 60 seconds.</p> <p>Notes on evaluator caching</p> <p>Capacity - By default, each cache namespace is limited to 1 mb. Entries will be evicted following First-In-First-Out (FIFO) policy to release space. The individual capacity of cache namespaces is set at the level of the Authorino instance (via <code>--evaluator-cache-size</code> command-line flag or <code>spec.evaluatorCacheSize</code> field of the <code>Authorino</code> CR).</p> <p>Usage - Avoid caching objects whose evaluation is considered to be relatively cheap. Examples of operations associated to Authorino auth features that are usually NOT worth caching: validation of JSON Web Tokens (JWT), Kubernetes TokenReviews and SubjectAccessReviews, API key validation, simple JSON pattern-matching authorization rules, simple OPA policies. Examples of operations where caching may be desired: OAuth2 token introspection, fetching of metadata from external sources (via HTTP request), complex OPA policies.</p>"},{"location":"authorino/docs/features/#common-feature-metrics-metrics","title":"Common feature: Metrics (<code>metrics</code>)","text":"<p>By default, Authorino will only export metrics down to the level of the AuthConfig. Deeper metrics at the level of each evaluator within an AuthConfig can be activated by setting the common field <code>metrics: true</code> of the evaluator config.</p> <p>E.g.:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-authconfig\n  namespace: my-ns\nspec:\n  metadata:\n    \"my-external-metadata\":\n      http:\n        url: http://my-external-source?search={request.path}\n      metrics: true\n</code></pre> <p>The above will enable the metrics <code>auth_server_evaluator_duration_seconds</code> (histogram) and <code>auth_server_evaluator_total</code> (counter) with labels <code>namespace=\"my-ns\"</code>, <code>authconfig=\"my-authconfig\"</code>, <code>evaluator_type=\"METADATA_GENERIC_HTTP\"</code> and <code>evaluator_name=\"my-external-metadata\"</code>.</p> <p>The same pattern works for other types of evaluators. Find below the list of all types and corresponding label constant used in the metric:</p> Evaluator type Metric's <code>evaluator_type</code> label <code>authentication.apiKey</code> IDENTITY_APIKEY <code>authentication.kubernetesTokenReview</code> IDENTITY_KUBERNETES <code>authentication.jwt</code> IDENTITY_OIDC <code>authentication.oauth2Introspection</code> IDENTITY_OAUTH2 <code>authentication.x509</code> IDENTITY_MTLS <code>authentication.plain</code> IDENTITY_PLAIN <code>authentication.anonymous</code> IDENTITY_NOOP <code>metadata.http</code> METADATA_GENERIC_HTTP <code>metadata.userInfo</code> METADATA_USERINFO <code>metadata.uma</code> METADATA_UMA <code>authorization.patternMatching</code> AUTHORIZATION_JSON <code>authorization.opa</code> AUTHORIZATION_OPA <code>authorization.kubernetesSubjectAccessReview</code> AUTHORIZATION_KUBERNETES <code>authorization.spicedb</code> AUTHORIZATION_AUTHZED <code>response.success..plain</code> RESPONSE_PLAIN <code>response.success..json</code> RESPONSE_JSON <code>response.success..wristband</code> RESPONSE_WRISTBAND <p>Metrics at the level of the evaluators can also be enforced to an entire Authorino instance, by setting the <code>--deep-metrics-enabled</code> command-line flag. In this case, regardless of the value of the field <code>spec.(authentication|metadata|authorization|response).metrics</code> in the AuthConfigs, individual metrics for all evaluators of all AuthConfigs will be exported.</p> <p>For more information about metrics exported by Authorino, see Observability.</p>"},{"location":"authorino/docs/getting-started/","title":"Getting started","text":"<p>This page covers requirements and instructions to deploy Authorino on a Kubernetes cluster, as well as the steps to declare, apply and try out a protection layer of authentication and authorization over your service, clean-up and complete uninstallation.</p> <p>If you prefer learning with an example, check out our Hello World.</p>"},{"location":"authorino/docs/getting-started/#requirements","title":"Requirements","text":""},{"location":"authorino/docs/getting-started/#platform-requirements","title":"Platform requirements","text":"<p>These are the platform requirements to use Authorino:</p> <ul> <li> <p>Kubernetes server (recommended v1.21 or later), with permission to create Kubernetes Custom Resource Definitions (CRDs) (for bootstrapping Authorino and Authorino Operator)</p> <p> Alternative: K8s distros and platforms <p>Alternatively to upstream Kubernetes, you should be able to use any other Kubernetes distribution or Kubernetes Management Platform (KMP) with support for Kubernetes Custom Resources Definitions (CRD) and custom controllers, such as Red Hat OpenShift, IBM Cloud Kubernetes Service (IKS), Google Kubernetes Engine (GKE), Amazon Elastic Kubernetes Service (EKS) and Azure Kubernetes Service (AKS). </p> <li> <p>Envoy proxy (recommended v1.19 or later), to wire up Upstream services (i.e. the services to be protected with Authorino) and external authorization filter (Authorino) for integrations based on the reverse-proxy architecture - example</p> <p> Alternative: Non-reverse-proxy integration <p>Technically, any client that implements Envoy's external authorization gRPC protocol should be compatible with Authorino. For integrations based on the reverse-proxy architecture nevertheless, we strongly recommended that you leverage Envoy alongside Authorino. </p>"},{"location":"authorino/docs/getting-started/#feature-specific-requirements","title":"Feature-specific requirements","text":"<p>A few examples are:</p> <ul> <li> <p>For OpenID Connect, make sure you have access to an identity provider (IdP) and an authority that can issue ID tokens (JWTs). Check out Keycloak which can solve both and connect to external identity sources and user federation like LDAP.</p> </li> <li> <p>For Kubernetes authentication tokens, platform support for the TokenReview and SubjectAccessReview APIs of Kubernetes shall be required. In case you want to be able to requests access tokens for clients running outside the custer, you may also want to check out the requisites for using Kubernetes TokenRequest API (GA in v1.20).</p> </li> <li> <p>For User-Managed Access (UMA) resource data, you will need a UMA-compliant server running as well. This can be an implementation of the UMA protocol by each upstream API itself or (more typically) an external server that knows about the resources. Again, Keycloak can be a good fit here as well. Just keep in mind that, whatever resource server you choose, changing-state actions commanded in the upstream APIs or other parties will have to be reflected in the resource server. Authorino will not do that for you.</p> </li> </ul> <p>Check out the Feature specification page for more feature-specific requirements.</p>"},{"location":"authorino/docs/getting-started/#installation","title":"Installation","text":""},{"location":"authorino/docs/getting-started/#step-install-the-authorino-operator","title":"Step: Install the Authorino Operator","text":"<p>The simplest way to install the Authorino Operator is by applying the manifest bundle:</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre> <p>The above will install the latest build of the Authorino Operator and latest version of the manifests (CRDs and RBAC), which by default points as well to the latest build of Authorino, both based on the <code>main</code> branches of each component. To install a stable released version of the Operator and therefore also defaults to its latest compatible stable release of Authorino, replace <code>main</code> with another tag of a proper release of the Operator, e.g. 'v0.2.0'.</p> <p>This step will also install cert-manager in the cluster (required).</p> <p>Alternatively, you can deploy the Authorino Operator using the Operator Lifecycle Manager bundles. For instructions, check out Installing via OLM.</p>"},{"location":"authorino/docs/getting-started/#step-request-an-authorino-instance","title":"Step: Request an Authorino instance","text":"<p>Choose either cluster-wide or namespaced deployment mode and whether you want TLS termination enabled for the Authorino endpoints (gRPC authorization, raw HTTP authorization, and OIDC Festival Wristband Discovery listeners), and follow the corresponding instructions below.</p> <p>The instructions here are for centralized gateway or centralized authorization service architecture. Check out the Topologies section of the docs for alternatively running Authorino in a sidecar container.</p> Cluster-wide (with TLS) <p>Create the namespace:   <pre><code>kubectl create namespace authorino\n</code></pre></p> <p>Create the TLS certificates (requires cert-manager; skip if you already have certificates and certificate keys created and stored in Kubernetes <code>Secret</code>s in the namespace):   <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/authorino/g\" | kubectl -n authorino apply -f -\n</code></pre></p> <p>Deploy Authorino:   <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  replicas: 1\n  clusterWide: true\n  listener:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre></p> Cluster-wide (without TLS) <pre><code>kubectl create namespace authorino\nkubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: true\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> Namespaced (with TLS) <p>Create the namespace:   <pre><code>kubectl create namespace myapp\n</code></pre></p> <p>Create the TLS certificates (requires cert-manager; skip if you already have certificates and certificate keys created and stored in Kubernetes <code>Secret</code>s in the namespace):   <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/myapp/g\" | kubectl -n myapp apply -f -\n</code></pre></p> <p>Deploy Authorino:   <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: false\n  listener:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      enabled: true\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre></p> Namespaced (without TLS) <pre><code>kubectl create namespace myapp\nkubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  image: quay.io/kuadrant/authorino:latest\n  replicas: 1\n  clusterWide: false\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/getting-started/#protect-a-service","title":"Protect a service","text":"<p>The most typical integration to protect services with Authorino is by putting the service (upstream) behind a reverse-proxy or API gateway, enabled with an authorization filter that ensures all requests to the service are first checked with the authorization server (Authorino).</p> <p>To do that, make sure you have your upstream service deployed and running, usually in the same Kubernetes server where you installed Authorino. Then, setup an Envoy proxy and create an Authorino <code>AuthConfig</code> for your service.</p> <p>Authorino exposes 2 interfaces to serve the authorization requests:</p> <ul> <li>a gRPC interface that implements Envoy's External Authorization protocol;</li> <li>a raw HTTP authorization interface, suitable for using Authorino with Kubernetes ValidatingWebhook, for Envoy external authorization via HTTP, and other integrations (e.g. other proxies).</li> </ul> <p>To use Authorino as a simple satellite (sidecar) Policy Decision Point (PDP), applications can integrate directly via any of these interfaces. By integrating via a proxy or API gateway, the combination makes Authorino to perform as an external Policy Enforcement Point (PEP) completely decoupled from the application.</p>"},{"location":"authorino/docs/getting-started/#life-cycle","title":"Life cycle","text":""},{"location":"authorino/docs/getting-started/#step-setup-envoy","title":"Step: Setup Envoy","text":"<p>To configure Envoy for proxying requests targeting the upstream service and authorizing with Authorino, setup an Envoy configuration that enables Envoy's external authorization HTTP filter. Store the configuration in a <code>ConfigMap</code>.</p> <p>These are the important bits in the Envoy configuration to activate Authorino:</p> <pre><code>static_resources:\n  listeners:\n\n  - address: {\u2026} # TCP socket address and port of the proxy\n    filter_chains:\n    - filters:\n      - name: envoy.http_connection_manager\n        typed_config:\n          \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n          route_config: {\u2026} # routing configs - virtual host domain and endpoint matching patterns and corresponding upstream services to redirect the traffic\n          http_filters:\n          - name: envoy.filters.http.ext_authz # the external authorization filter\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n              transport_api_version: V3\n              failure_mode_allow: false # ensures only authenticated and authorized traffic goes through\n              grpc_service:\n                envoy_grpc:\n                  cluster_name: authorino\n                timeout: 1s\n  clusters:\n  - name: authorino\n    connect_timeout: 0.25s\n    type: strict_dns\n    lb_policy: round_robin\n    http2_protocol_options: {}\n    load_assignment:\n      cluster_name: authorino\n      endpoints:\n      - lb_endpoints:\n        - endpoint:\n            address:\n              socket_address:\n                address: authorino-authorino-authorization # name of the Authorino service deployed \u2013 it can be the fully qualified name with `.&lt;namespace&gt;.svc.cluster.local` suffix (e.g. `authorino-authorino-authorization.myapp.svc.cluster.local`)\n                port_value: 50051\n    transport_socket: # in case TLS termination is enabled in Authorino; omit it otherwise\n      name: envoy.transport_sockets.tls\n      typed_config:\n        \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n        common_tls_context:\n          validation_context:\n            trusted_ca:\n              filename: /etc/ssl/certs/authorino-ca-cert.crt\n</code></pre> <p>For a complete Envoy <code>ConfigMap</code> containing an upstream API protected with Authorino, with TLS enabled and option for rate limiting with Limitador, plus a webapp served with under the same domain of the protected API, check out this example.</p> <p>After creating the <code>ConfigMap</code> with the Envoy configuration, create an Envoy <code>Deployment</code> and <code>Service</code>. E.g.:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: envoy\n  labels:\n    app: envoy\nspec:\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n\n        - name: envoy\n          image: envoyproxy/envoy:v1.19-latest\n          command: [\"/usr/local/bin/envoy\"]\n          args:\n            - --config-path /usr/local/etc/envoy/envoy.yaml\n            - --service-cluster front-proxy\n            - --log-level info\n            - --component-log-level filter:trace,http:debug,router:debug\n          ports:\n            - name: web\n              containerPort: 8000 # matches the address of the listener in the envoy config\n          volumeMounts:\n            - name: config\n              mountPath: /usr/local/etc/envoy\n              readOnly: true\n            - name: authorino-ca-cert # in case TLS termination is enabled in Authorino; omit it otherwise\n              subPath: ca.crt\n              mountPath: /etc/ssl/certs/authorino-ca-cert.crt\n              readOnly: true\n      volumes:\n        - name: config\n          configMap:\n            name: envoy\n            items:\n              - key: envoy.yaml\n                path: envoy.yaml\n        - name: authorino-ca-cert # in case TLS termination is enabled in Authorino; omit it otherwise\n          secret:\n            defaultMode: 420\n            secretName: authorino-ca-cert\n  replicas: 1\nEOF\n</code></pre> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\nspec:\n  selector:\n    app: envoy\n  ports:\n\n    - name: web\n      port: 8000\n      protocol: TCP\nEOF\n</code></pre>"},{"location":"authorino/docs/getting-started/#step-apply-an-authconfig","title":"Step: Apply an <code>AuthConfig</code>","text":"<p>Check out the docs for a full description of Authorino's <code>AuthConfig</code> Custom Resource Definition (CRD) and its features.</p> <p>For examples based on specific use-cases, check out the User guides.</p> <p>For authentication based on OpenID Connect (OIDC) JSON Web Tokens (JWT), plus one simple JWT claim authorization check, a typical <code>AuthConfig</code> custom resource looks like the following:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: my-api-protection\nspec:\n  hosts: # any hosts that resolve to the envoy service and envoy routing config where the external authorization filter is enabled\n\n  - my-api.io # north-south traffic through a Kubernetes `Ingress` or OpenShift `Route`\n  - my-api.myapp.svc.cluster.local # east-west traffic (between applications within the cluster)\n  authentication:\n    \"idp-users\":\n      jwt:\n        issuerUrl: https://my-idp.com/auth/realm\n  authorization:\n    \"check-claim\":\n      patternMatching:\n        patterns:\n        - selector: auth.identity.group\n          operator: eq\n          value: allowed-users\nEOF\n</code></pre> <p>After applying the <code>AuthConfig</code>, consumers of the protected service should be able to start sending requests.</p>"},{"location":"authorino/docs/getting-started/#clean-up","title":"Clean-up","text":""},{"location":"authorino/docs/getting-started/#remove-protection","title":"Remove protection","text":"<p>Delete the <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp delete authconfig/my-api-protection\n</code></pre> <p>Decommission the Authorino instance:</p> <pre><code>kubectl -n myapp delete authorino/authorino\n</code></pre>"},{"location":"authorino/docs/getting-started/#uninstall","title":"Uninstall","text":"<p>To completely remove Authorino CRDs, run from the Authorino Operator directory:</p> <pre><code>make uninstall\n</code></pre>"},{"location":"authorino/docs/getting-started/#next-steps","title":"Next steps","text":"<ol> <li>Read the docs. The Architecture page and the Features page are good starting points to learn more about how Authorino works and its functionalities.</li> <li>Check out the User guides for several examples of <code>AuthConfig</code>s based on specific use-cases</li> </ol>"},{"location":"authorino/docs/terminology/","title":"Terminology","text":"<p>Here we define some terms that are used in the project, with the goal of avoiding confusion and facilitating more accurate conversations related to <code>Authorino</code>.</p> <p>If you see terms used that are not here (or are used in place of terms here) please consider contributing a definition to this doc with a PR, or modifying the use elsewhere to align with these terms.</p>"},{"location":"authorino/docs/terminology/#terms","title":"Terms","text":"<p>Access token Type of temporary password (security token), tied to an authenticated identity, issued by an auth server as of request from either the identity subject itself or a registered auth client known by the auth server, and that delegates to a party powers to operate on behalf of that identity before a resource server; it can be formatted  as an opaque data string or as an encoded JSON Web Token (JWT).</p> <p>Application Programming Interface (API) Interface that defines interactions between multiple software applications; (in HTTP communication) set of endpoints and specification to expose resources hosted by a resource server, to be consumed by client applications; the access facade of a resource server.</p> <p>Attribute-based Access Control (ABAC) Authorization model that grants/denies access to resources based on evaluation of authorization policies which combine attributes together (from claims, from the request, from the resource, etc).</p> <p>Auth Usually employed as a short for authentication and authorization together (AuthN/AuthZ).</p> <p>Auth client Application client (software) that uses an auth server, either in the process of authenticating and/or authorizing identity subjects (including self) who want to consume resources from a resources server or auth server.</p> <p>Auth server Server where auth clients, users, roles, scopes, resources, policies and permissions can be stored and managed.</p> <p>Authentication (AuthN) Process of verifying that a given credential belongs to a claimed-to-be identity; usually resulting in the issuing of an access token.</p> <p>Authorization (AuthZ) Process of granting (or denying) access over a resource to a party based on the set of authorization rules, policies and/or permissions enforced.</p> <p>Authorization header HTTP request header frequently used to carry credentials to authenticate a user in an HTTP communication, like in requests sent to an API; alternatives usually include credentials carried in another (custom) HTTP header, query string parameter or HTTP cookie.</p> <p>Capability Usually employed to refer to a management feature of a Kubernetes-native system, based on the definition and use of Kubernetes Custom Resources (CRDs and CRs), that enables that system to one of the following \u201ccapability levels\u201d: Basic Install, Seamless Upgrades, Full Lifecycle, Deep Insights, Auto Pilot.</p> <p>Claim Attribute packed in a security token which represents a claim that one who bears the token is making about an entity, usually an identity subject.</p> <p>Client ID Unique identifier of an auth client within an auth server domain (or auth server realm).</p> <p>Client secret Password presented by auth clients together with their Client IDs while authenticating with an auth server, either when requesting access tokens to be issued or when consuming services from the auth servers in general.</p> <p>Delegation Process of granting a party (usually an auth client) with powers to act, often with limited scope, on behalf of an identity, to access resources from a resource server. See also OAuth2.</p> <p>Hash-based Message Authentication Code (HMAC) Specific type of message authentication code (MAC) that involves a cryptographic hash function and a shared secret cryptographic key; it can be used to verify the authenticity of a message and therefore as an authentication method.</p> <p>Identity Set of properties that qualifies a subject as a strong identifiable entity (usually a user), who can be authenticated by an auth server. See also Claims.</p> <p>Identity and Access Management (IAM) system Auth system that implements and/or connects with sources of identity (IdP) and offers interfaces for managing access (authorization policies and permissions). See also Auth server.</p> <p>Identity Provider (IdP) Source of identity; it can be a feature of an auth server or external source connected to an auth server.</p> <p>ID token Special type of access token; an encoded JSON Web Token (JWT) that packs claims about an identity.</p> <p>JSON Web Token (JWT) JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.</p> <p>JSON Web Signature (JWS) Standard for signing arbitrary data, especially JSON Web Tokens (JWT).</p> <p>JSON Web Key Set (JWKS) Set of keys containing the public keys used to verify any JSON Web Token (JWT).</p> <p>Keycloak Open source auth server to allow single sign-on with identity and access management.</p> <p>Lightweight Directory Access Protocol (LDAP) Open standard for distributed directory information services for sharing of information about users, systems, networks, services and applications.</p> <p>Mutual Transport Layer Security (mTLS) Protocol for the mutual authentication of client-server communication, i.e., the client authenticates the server and the server authenticates the client, based on the acceptance of the X.509 certificates of each party.</p> <p>OAuth 2.0 (OAuth2) Industry-standard protocol for delegation.</p> <p>OpenID Connect (OIDC) Simple identity verification (authentication) layer built on top of the OAuth2 protocol.</p> <p>Open Policy Agent (OPA) Authorization policy agent that enables the usage of declarative authorization policies written in Rego language.</p> <p>Opaque token Security token devoid of explicit meaning (e.g. random string); it requires the usage of lookup mechanism to be translated into a meaningful set claims representing an identity.</p> <p>Permission Association between a protected resource the authorization policies that must be evaluated whether access should be granted; e.g. <code>&lt;user|group|role&gt;</code> CAN DO <code>&lt;action&gt;</code> ON RESOURCE <code>&lt;X&gt;</code>.</p> <p>Policy Rule or condition (authorization policy) that must be satisfied to grant access to a resource; strongly related to the different access control mechanisms (ACMs) and strategies one can use to protect resources, e.g. attribute-based access control (ABAC), role-based access control (RBAC), context-based access control, user-based access control (UBAC).</p> <p>Policy Administration Point (PAP) Set of UIs and APIs to manage resources servers, resources, scopes, policies and permissions; it is where the auth system is configured.</p> <p>Policy Decision Point (PDP) Where the authorization requests are sent, with permissions being requested, and authorization policies are evaluated accordingly.</p> <p>Policy Enforcement Point (PEP) Where the authorization is effectively enforced, usually at the resource server or at a proxy, based on a response provided by the Policy Decision Point (PDP).</p> <p>Policy storage Where policies are stored and from where they can be fetched, perhaps to be cached.</p> <p>Red Hat SSO Auth server; downstream product created from the Keycloak Open Source project.</p> <p>Refresh token Special type of security token, often provided together with an access token in an OAuth2 flow, used to renew the duration of an access token before it expires; it requires client authentication.</p> <p>Request Party Token (RPT) JSON Web Token (JWT) digitally signed using JSON Web Signature (JWS), issued by the Keycloak auth server.</p> <p>Resource One or more endpoints of a system, API or server, that can be protected.</p> <p>Resource-level Access Control (RLAC) Authorization model that takes into consideration attributes of each specific request resource to grant/deny access to those resources (e.g. the resource's owner).</p> <p>Resource server Server that hosts protected resources.</p> <p>Role Aspect of a user\u2019s identity assigned to the user to indicate the level of access they should have to the system; essentially, roles represent collections of permissions</p> <p>Role-based Access Control (RBAC) Authorization model that grants/denies access to resources based on the roles of authenticated users (rather than on complex attributes/policy rules).</p> <p>Scope Mechanism that defines the specific operations that applications can be allowed to do or information that they can request on an identity\u2019s behalf; often presented as a parameter when access is requested as a way to communicate what access is needed, and used by auth server to respond what actual access is granted.</p> <p>Single Page Application (SPA) Web application or website that interacts with the user by dynamically rewriting the current web page with new data from the web server.</p> <p>Single Sign-on (SSO) Authentication scheme that allows a user to log in with a single ID and password to any of several related, yet independent, software systems.</p> <p>Upstream (In the context of authentication/authorization) API whose endpoints must be protected by the auth system; the unprotected service in front of which a protection layer is added (by connecting with a Policy Decision Point).</p> <p>User-based Access Control (UBAC) Authorization model that grants/denies access to resources based on claims of the identity (attributes of the user).</p> <p>User-Managed Access (UMA) OAuth2-based access management protocol, used for users of an auth server to control the authorization process, i.e. directly granting/denying access to user-owned resources to other requesting parties.</p>"},{"location":"authorino/docs/user-guides/","title":"User guides","text":"<ul> <li> <p>Hello World The basics of protecting an API with Authorino.</p> </li> <li> <p>Authentication with Kubernetes tokens (TokenReview API) Validate Kubernetes Service Account tokens to authenticate requests to your protected hosts.</p> </li> <li> <p>Authentication with API keys Issue API keys stored in Kubernetes <code>Secret</code>s for clients to authenticate with your protected hosts.</p> </li> <li> <p>Authentication with X.509 certificates and mTLS Verify client X.509 certificates against trusted root CAs.</p> </li> <li> <p>OpenID Connect Discovery and authentication with JWTs Validate JSON Web Tokens (JWT) issued and signed by an OpenID Connect server; leverage OpenID Connect Discovery to automatically fetch JSON Web Key Sets (JWKS).</p> </li> <li> <p>OAuth 2.0 token introspection (RFC 7662) Introspect OAuth 2.0 access tokens (e.g. opaque tokens) for online user data and token validation in request-time.</p> </li> <li> <p>Passing credentials (<code>Authorization</code> header, cookie headers and others) Customize where credentials are supplied in the request by each trusted source of identity.</p> </li> <li> <p>HTTP \"Basic\" Authentication (RFC 7235) Turn Authorino API key <code>Secret</code>s settings into HTTP basic auth.</p> </li> <li> <p>Anonymous access Bypass identity verification or fall back to anonymous access when credentials fail to validate</p> </li> <li> <p>Token normalization Normalize identity claims from trusted sources and reduce complexity in your policies.</p> </li> <li> <p>Edge Authentication Architecture (EAA) Exchange satellite (outer-layer) authentication tokens for \"Festival Wristbands\" accepted ubiquitously at the inside of your network. Normalize from multiple and varied sources of identity and authentication methods in the edge of your architecture; filter privacy data, limit the scope of permissions, and simplify authorization rules to your internal microservices.</p> </li> <li> <p>Fetching auth metadata from external sources Get online data from remote HTTP services to enhance authorization rules.</p> </li> <li> <p>OpenID Connect UserInfo Fetch user info for OpenID Connect ID tokens in request-time for extra metadata for your policies and online verification of token validity.</p> </li> <li> <p>Resource-level authorization with User-Managed Access (UMA) resource registry Fetch resource attributes relevant for authorization from a User-Managed Access (UMA) resource registry such as Keycloak resource server clients.</p> </li> <li> <p>Simple pattern-matching authorization policies Write simple authorization rules based on JSON patterns matched against Authorino's Authorization JSON; check contextual information of the request, validate JWT claims, cross metadata fetched from external sources, etc.</p> </li> <li> <p>OpenID Connect (OIDC) and Role-Based Access Control (RBAC) with Authorino and Keycloak Combine OpenID Connect (OIDC) authentication and Role-Based Access Control (RBAC) authorization rules leveraging Keycloak and Authorino working together.</p> </li> <li> <p>Open Policy Agent (OPA) Rego policies Leverage the power of Open Policy Agent (OPA) policies, evaluated against Authorino's Authorization JSON in a built-in runtime compiled together with Authorino; pre-cache policies defined in Rego language inline or fetched from an external policy registry.</p> </li> <li> <p>Kubernetes RBAC for service authorization (SubjectAccessReview API) Manage permissions in the Kubernetes RBAC and let Authorino to check them in request-time with the authorization system of the cluster.</p> </li> <li> <p>Authorization with Keycloak Authorization Services Use Authorino as an adapter for Keycloak Authorization Services without importing any library or rebuilding your application code.</p> </li> <li> <p>Integration with Authzed/SpiceDB Permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> </li> <li> <p>Injecting data in the request Inject HTTP headers with serialized JSON content.</p> </li> <li> <p>Authenticated rate limiting (with Envoy Dynamic Metadata) Provide Envoy with dynamic metadata from the external authorization process to be injected and used by consecutive filters, such as by a rate limiting service.</p> </li> <li> <p>Redirecting to a login page Customize response status code and headers on failed requests. E.g. redirect users of a web application protected with Authorino to a login page instead of a <code>401 Unauthorized</code>; mask resources on access denied behind a <code>404 Not Found</code> response instead of <code>403 Forbidden</code>.</p> </li> <li> <p>Mixing Envoy built-in filter for auth and Authorino Have JWT validation handled by Envoy beforehand and the JWT payload injected into the request to Authorino, to be used in custom authorization policies defined in a AuthConfig.</p> </li> <li> <p>Host override via context extension Induce the lookup of an AuthConfig by supplying extended host context, for use cases such as of path prefix-based lookup and wildcard subdomains lookup.</p> </li> <li> <p>Using Authorino as ValidatingWebhook service Use Authorino as a generic Kubernetes ValidatingWebhook service where the rules to validate a request to the Kubernetes API are written in an AuthConfig.</p> </li> <li> <p>Reducing the operational space: sharding, noise and multi-tenancy Have multiple instances of Authorino running in the same space (Kubernetes namespace or cluster-scoped), yet watching particular sets of resources.</p> </li> <li> <p>Caching Cache auth objects resolved at runtime for any configuration bit of an AuthConfig, for easy access in subsequent requests whenever an arbitrary cache key repeats, until the cache entry expires.</p> </li> <li> <p>Observability Prometheus metrics exported by Authorino, readiness probe, logging, tracing, etc.</p> </li> </ul>"},{"location":"authorino/docs/user-guides/anonymous-access/","title":"User guide: Anonymous access","text":"<p>Bypass identity verification or fall back to anonymous access when credentials fail to validate</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Anonymous access</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/anonymous-access/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/anonymous-access/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"public\":\n      anonymous: {}\nEOF\n</code></pre> <p>The example above enables anonymous access (i.e. removes authentication), without adding any extra layer of protection to the API. This is virtually equivalent to setting a top-level condition to the <code>AuthConfig</code> that always skips the configuration, or to switching authentication/authorization off completely in the route to the API.</p> <p>For more sophisticated use cases of anonymous access with Authorino, consider combining this feature with other identity sources in the <code>AuthConfig</code> while playing with the priorities of each source, as well as combination with <code>when</code> conditions, and/or adding authorization policies that either cover authentication or address anonymous access with proper rules (e.g. enforcing read-only access).</p> <p>Check out the docs for the Anonymous access feature for an example of an <code>AuthConfig</code> that falls back to anonymous access when a priority OIDC/JWT-based authentication fails, and enforces a read-only policy in such cases.</p>"},{"location":"authorino/docs/user-guides/anonymous-access/#consume-the-api","title":"\u277b Consume the API","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/anonymous-access/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/api-key-authentication/","title":"User guide: Authentication with API keys","text":"<p>Issue API keys stored in Kubernetes <code>Secret</code>s for clients to authenticate with your protected hosts.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>In Authorino, API keys are stored as Kubernetes <code>Secret</code>s. Each resource must contain an <code>api_key</code> entry with the value of the API key, and labeled to match the selectors specified in <code>spec.identity.apiKey.selector</code> of the <code>AuthConfig</code>.</p> <p>API key <code>Secret</code>s must also include labels that match the <code>secretLabelSelector</code> field of the Authorino instance. See Resource reconciliation and status update for details.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/api-key-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/api-key-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid API key:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>With missing or invalid API key:</p> <pre><code>curl -H 'Authorization: APIKEY invalid' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"friends\"\n# x-ext-auth-reason: the API Key provided is invalid\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#delete-an-api-key-revoke-access-to-the-api","title":"\u277d Delete an API key (revoke access to the API)","text":"<pre><code>kubectl delete secret/api-key-1\n</code></pre>"},{"location":"authorino/docs/user-guides/api-key-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/","title":"User guide: Authenticated rate limiting (with Envoy Dynamic Metadata)","text":"<p>Provide Envoy with dynamic metadata about the external authorization process to be injected into the rate limiting filter.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Response wrappers \u2192 Envoy Dynamic Metadata</li> <li>Dynamic response \u2192 JSON injection</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Dynamic JSON objects built out of static values and values fetched from the Authorization JSON can be wrapped to be returned to the reverse-proxy as Envoy Well Known Dynamic Metadata content. Envoy can use those to inject data returned by the external authorization service into the other filters, such as the rate limiting filter.</p> <p>Check out as well the user guides about Injecting data in the request and Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-limitador","title":"\u2778 Deploy Limitador","text":"<p>Limitador is a lightweight rate limiting service that can be used with Envoy.</p> <p>On this bundle, we will deploy Limitador pre-configured to limit requests to the <code>talker-api</code> domain up to 5 requests per interval of 60 seconds per <code>user_id</code>. Envoy will be configured to recognize the presence of Limitador and activate it on requests to the Talker API.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#deploy-the-talker-api","title":"\u2779 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#setup-envoy","title":"\u277a Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#create-an-authconfig","title":"\u277b Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>An annotation <code>auth-data/username</code> will be read from the Kubernetes API Key secret and passed as dynamic metadata <code>{ \"ext_auth_data\": { \"username\": \u00abannotations.auth-data/username\u00bb } }</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      dynamicMetadata:\n        \"rate-limit\":\n          json:\n            properties:\n              \"username\":\n                expression: auth.identity.metadata.annotations['auth-data/username']\n          key: ext_auth_data # how this bit of dynamic metadata from the ext authz service is named in the Envoy config\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#create-the-api-keys","title":"\u277c Create the API keys","text":"<p>For user John:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/username: john\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>For user Jane:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/username: jane\nstringData:\n  api_key: 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#consume-the-api","title":"\u277d Consume the API","text":"<p>As John:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Repeat the request a few more times within the 60-second time window, until the response status is <code>429 Too Many Requests</code>.</p> <p>While the API is still limited to John, send requests as Jane:</p> <pre><code>curl -H 'Authorization: APIKEY 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY' http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/authenticated-rate-limiting-envoy-dynamic-metadata/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete secret/api-key-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/limitador/limitador-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/authzed/","title":"User guide: Integration with Authzed/SpiceDB","text":"<p>Permission requests sent to a Google Zanzibar-based Authzed/SpiceDB instance, via gRPC.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 SpiceDB</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p></p>"},{"location":"authorino/docs/user-guides/authzed/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/authzed/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-the-permission-database","title":"\u277a Create the permission database","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace spicedb\n</code></pre> <p>Create the SpiceDB instance:</p> <pre><code>kubectl -n spicedb apply -f -&lt;&lt;EOF\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: spicedb\n  labels:\n    app: spicedb\nspec:\n  selector:\n    matchLabels:\n      app: spicedb\n  template:\n    metadata:\n      labels:\n        app: spicedb\n    spec:\n      containers:\n\n      - name: spicedb\n        image: authzed/spicedb\n        args:\n        - serve\n        - \"--grpc-preshared-key\"\n        - secret\n        - \"--http-enabled\"\n        ports:\n        - containerPort: 50051\n        - containerPort: 8443\n  replicas: 1\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: spicedb\nspec:\n  selector:\n    app: spicedb\n  ports:\n    - name: grpc\n      port: 50051\n      protocol: TCP\n    - name: http\n      port: 8443\n      protocol: TCP\nEOF\n</code></pre> <p>Forward local request to the SpiceDB service inside the cluster:</p> <pre><code>kubectl -n spicedb port-forward service/spicedb 8443:8443 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Create the permission schema:</p> <pre><code>curl -X POST http://localhost:8443/v1/schema/write \\\n  -H 'Authorization: Bearer secret' \\\n  -H 'Content-Type: application/json' \\\n  -d @- &lt;&lt; EOF\n{\n  \"schema\": \"definition blog/user {}\\ndefinition blog/post {\\n\\trelation reader: blog/user\\n\\trelation writer: blog/user\\n\\n\\tpermission read = reader + writer\\n\\tpermission write = writer\\n}\"\n}\nEOF\n</code></pre> <p>Create the relationships:</p> <ul> <li><code>blog/user:emilia</code> \u2192 <code>writer</code> of <code>blog/post:1</code></li> <li><code>blog/user:beatrice</code> \u2192 <code>reader</code> of <code>blog/post:1</code></li> </ul> <pre><code>curl -X POST http://localhost:8443/v1/relationships/write \\\n  -H 'Authorization: Bearer secret' \\\n  -H 'Content-Type: application/json' \\\n  -d @- &lt;&lt; EOF\n{\n  \"updates\": [\n    {\n      \"operation\": \"OPERATION_CREATE\",\n      \"relationship\": {\n        \"resource\": {\n          \"objectType\": \"blog/post\",\n          \"objectId\": \"1\"\n        },\n        \"relation\": \"writer\",\n        \"subject\": {\n          \"object\": {\n            \"objectType\": \"blog/user\",\n            \"objectId\": \"emilia\"\n          }\n        }\n      }\n    },\n    {\n      \"operation\": \"OPERATION_CREATE\",\n      \"relationship\": {\n        \"resource\": {\n          \"objectType\": \"blog/post\",\n          \"objectId\": \"1\"\n        },\n        \"relation\": \"reader\",\n        \"subject\": {\n          \"object\": {\n            \"objectType\": \"blog/user\",\n            \"objectId\": \"beatrice\"\n          }\n        }\n      }\n    }\n  ]\n}\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Store the shared token for Authorino to authenticate with the SpiceDB instance in a Service:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: spicedb\n  labels:\n    app: spicedb\nstringData:\n  grpc-preshared-key: secret\nEOF\n</code></pre> <p>Create the AuthConfig:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"blog-users\":\n      apiKey:\n        selector:\n          matchLabels:\n            app: talker-api\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  authorization:\n    \"authzed-spicedb\":\n      spicedb:\n        endpoint: spicedb.spicedb.svc.cluster.local:50051\n        insecure: true\n        sharedSecretRef:\n          name: spicedb\n          key: grpc-preshared-key\n        subject:\n          kind:\n            value: blog/user\n          name:\n            selector: auth.identity.metadata.annotations.username\n        resource:\n          kind:\n            value: blog/post\n          name:\n            selector: context.request.http.path.@extract:{\"sep\":\"/\",\"pos\":2}\n        permission:\n          selector: context.request.http.method.@replace:{\"old\":\"GET\",\"new\":\"read\"}.@replace:{\"old\":\"POST\",\"new\":\"write\"}\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#create-the-api-keys","title":"\u277c Create the API keys","text":"<p>For Emilia (writer):</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-writer\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: talker-api\n  annotations:\n    username: emilia\nstringData:\n  api_key: IAMEMILIA\nEOF\n</code></pre> <p>For Beatrice (reader):</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-reader\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    app: talker-api\n  annotations:\n    username: beatrice\nstringData:\n  api_key: IAMBEATRICE\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#consume-the-api","title":"\u277d Consume the API","text":"<p>As Emilia, send a GET request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMEMILIA' \\\n     -X GET \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Emilia, send a POST request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMEMILIA' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Beatrice, send a GET request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMBEATRICE' \\\n     -X GET \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Beatrice, send a POST request:</p> <pre><code>curl -H 'Authorization: APIKEY IAMBEATRICE' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/posts/1 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: PERMISSIONSHIP_NO_PERMISSION;token=GhUKEzE2NzU3MDE3MjAwMDAwMDAwMDA=\n</code></pre>"},{"location":"authorino/docs/user-guides/authzed/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace spicedb\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/caching/","title":"User guide: Caching","text":"<p>Cache auth objects resolved at runtime for any configuration bit of an AuthConfig (i.e. any evaluator), of any phase (identity, metadata, authorization and dynamic response), for easy access in subsequent requests, whenever an arbitrary (user-defined) cache key repeats, until the cache entry expires.</p> <p>This is particularly useful for configuration bits whose evaluation is significantly more expensive than accessing the cache. E.g.:</p> <ul> <li>Caching of metadata fetched from external sources in general</li> <li>Caching of previously validated identity access tokens (e.g. for OAuth2 opaque tokens that involve consuming the token introspection endpoint of an external auth server)</li> <li>Caching of complex Rego policies that involve sending requests to external services</li> </ul> <p>Cases where one will NOT want to enable caching, due to relatively cheap compared to accessing and managing the cache:</p> <ul> <li>Validation of OIDC/JWT access tokens</li> <li>OPA/Rego policies that do not involve external requests</li> <li>JSON pattern-matching authorization</li> <li>Dynamic JSON responses</li> <li>Anonymous access</li> </ul> Authorino capabilities featured in this guide: <ul> <li>Common feature \u2192 Caching</li> <li>Identity verification &amp; authentication \u2192 Anonymous access</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Dynamic response \u2192 JSON injection</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/caching/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/caching/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The example below enables caching for the external source of metadata, which in this case, for convenience, is the same upstream API protected by Authorino (i.e. the Talker API), though consumed directly by Authorino, without passing through the proxy. This API generates a <code>uuid</code> random hash that it injects in the JSON response. This value is different in every request processed by the API.</p> <p>The example also enables caching of returned OPA virtual documents. <code>cached-authz</code> is a trivial Rego policy that always grants access, but generates a timestamp, which Authorino will cache.</p> <p>In both cases, the path of the HTTP request is used as cache key. I.e., whenever the path repeats, Authorino reuse the values stored previously in each cache table (<code>cached-metadata</code> and <code>cached-authz</code>), respectively saving a request to the external source of metadata and the evaluation of the OPA policy. Cache entries will expire in both cases after 60 seconds they were stored in the cache.</p> <p>The cached values will be visible in the response returned by the Talker API in <code>x-authz-data</code> header injected by Authorino. This way, we can tell when an existing value in the cache was used and when a new one was generated and stored.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"anonymous\":\n      anonymous: {}\n  metadata:\n    \"cached-metadata\":\n      http:\n        url: \"http://talker-api.default.svc.cluster.local:3000/metadata/{context.request.http.path}\"\n      cache:\n        key:\n          selector: context.request.http.path\n        ttl: 60\n  authorization:\n    \"cached-authz\":\n      opa:\n        rego: |\n          now = time.now_ns()\n          allow = true\n        allValues: true\n      cache:\n        key:\n          selector: context.request.http.path\n        ttl: 60\n  response:\n    success:\n      headers:\n        \"x-authz-data\":\n          json:\n            properties:\n              \"cached-metadata\":\n                selector: auth.metadata.cached-metadata.uuid\n              \"cached-authz\":\n                selector: auth.authorization.cached-authz.now\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#consume-the-api","title":"\u277b Consume the API","text":"<ol> <li>To <code>/hello</code></li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343067462380300\\\",\\\"cached-metadata\\\":\\\"92c111cd-a10f-4e86-8bf0-e0cd646c6f79\\\"}\",\n# [\u2026]\n</code></pre> <ol> <li>To a different path</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/goodbye\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343097860450300\\\",\\\"cached-metadata\\\":\\\"37fce386-1ee8-40a7-aed1-bf8a208f283c\\\"}\",\n# [\u2026]\n</code></pre> <ol> <li>To <code>/hello</code> again before the cache entry expires (60 seconds from the first request sent to this path)</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343067462380300\\\",\\\"cached-metadata\\\":\\\"92c111cd-a10f-4e86-8bf0-e0cd646c6f79\\\"}\",  &lt;=== same cache-id as before\n# [\u2026]\n</code></pre> <ol> <li>To <code>/hello</code> again after the cache entry expires (60 seconds from the first request sent to this path)</li> </ol> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello\n# [\u2026]\n#  \"X-Authz-Data\": \"{\\\"cached-authz\\\":\\\"1649343135702743800\\\",\\\"cached-metadata\\\":\\\"e708a3a6-5caf-4028-ab5c-573ad9be7188\\\"}\",  &lt;=== different cache-id\n# [\u2026]\n</code></pre>"},{"location":"authorino/docs/user-guides/caching/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/","title":"User guide: Redirecting to a login page","text":"<p>Customize response status code and headers on failed requests to redirect users of a web application protected with Authorino to a login page instead of a <code>401 Unauthorized</code>.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Custom denial status</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino's default response status codes, messages and headers for unauthenticated (<code>401</code>) and unauthorized (<code>403</code>) requests can be customized with static values and values fetched from the Authorization JSON.</p> <p>Check out as well the user guides about HTTP \"Basic\" Authentication (RFC 7235) and OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample web application called Matrix Quotes to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#deploy-the-matrix-quotes-web-application","title":"\u2778 Deploy the Matrix Quotes web application","text":"<p>The Matrix Quotes is a static web application that contains quotes from the film The Matrix.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/matrix-quotes-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Matrix Quotes webapp behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/envoy-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>matrix-quotes.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: matrix-quotes-protection\nspec:\n  hosts:\n\n  - matrix-quotes.127.0.0.1.nip.io\n  authentication:\n    \"browser-users\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        cookie:\n          name: TOKEN\n    \"http-basic-auth\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        authorizationHeader:\n          prefix: Basic\n  response:\n    unauthenticated:\n      code: 302\n      headers:\n        \"Location\":\n          expression: |\n            'http://matrix-quotes.127.0.0.1.nip.io:8000/login.html?redirect_to=' + request.path\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: user-credential-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: am9objpw # john:p\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#consume-the-application","title":"\u277c Consume the application","text":"<p>On a web browser, navigate to http://matrix-quotes.127.0.0.1.nip.io:8000.</p> <p>Click on the cards to read quotes from characters of the movie. You should be redirected to login page.</p> <p>Log in using John's credentials:</p> <ul> <li>Username: john</li> <li>Password: p</li> </ul> <p>Click again on the cards and check that now you are able to access the inner pages.</p> <p>You can also consume a protected endpoint of the application using HTTP Basic Authentication:</p> <pre><code>curl -u john:p http://matrix-quotes.127.0.0.1.nip.io:8000/neo.html\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#optional-modify-the-authconfig-to-authenticate-with-oidc","title":"\u277d (Optional) Modify the <code>AuthConfig</code> to authenticate with OIDC","text":""},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#setup-a-keycloak-server","title":"Setup a Keycloak server","text":"<p>Deploy a Keycloak server preloaded with a realm named <code>kuadrant</code>:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Resolve local Keycloak domain so it can be accessed from the local host and inside the cluster with the name: (This will be needed to redirect to Keycloak's login page and at the same time validate issued tokens.)</p> <pre><code>echo '127.0.0.1 keycloak' &gt;&gt; /etc/hosts\n</code></pre> <p>Forward local requests to the instance of Keycloak running in the cluster:</p> <pre><code>kubectl port-forward deployment/keycloak 8080:8080 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Create a client:</p> <pre><code>curl -H \"Authorization: Bearer $(curl http://keycloak:8080/realms/master/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=admin-cli' -d 'username=admin' -d 'password=p' | jq -r .access_token)\" \\\n     -H 'Content-type: application/json' \\\n     -d '{ \"name\": \"matrix-quotes\", \"clientId\": \"matrix-quotes\", \"publicClient\": true, \"redirectUris\": [\"http://matrix-quotes.127.0.0.1.nip.io:8000/auth*\"], \"enabled\": true }' \\\n     http://keycloak:8080/admin/realms/kuadrant/clients\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#reconfigure-the-matrix-quotes-app-to-use-keycloaks-login-page","title":"Reconfigure the Matrix Quotes app to use Keycloak's login page","text":"<pre><code>kubectl set env deployment/matrix-quotes KEYCLOAK_REALM=http://keycloak:8080/realms/kuadrant CLIENT_ID=matrix-quotes\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#apply-the-changes-to-the-authconfig","title":"Apply the changes to the <code>AuthConfig</code>","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: matrix-quotes-protection\nspec:\n  hosts:\n\n  - matrix-quotes.127.0.0.1.nip.io\n  authentication:\n    \"idp-users\":\n      jwt:\n        issuerUrl: http://keycloak:8080/realms/kuadrant\n      credentials:\n        cookie:\n          name: TOKEN\n  response:\n    unauthenticated:\n      code: 302\n      headers:\n        \"Location\":\n          expression: |\n            'http://keycloak:8080/realms/kuadrant/protocol/openid-connect/auth?client_id=matrix-quotes&amp;redirect_uri=http://matrix-quotes.127.0.0.1.nip.io:8000/auth?redirect_to=' + request.path + '&amp;scope=openid&amp;response_type=code'\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#consume-the-application-again","title":"Consume the application again","text":"<p>Refresh the browser window or navigate again to http://matrix-quotes.127.0.0.1.nip.io:8000.</p> <p>Click on the cards to read quotes from characters of the movie. You should be redirected to login page this time served by the Keycloak server.</p> <p>Log in as Jane (a user of the Keycloak realm):</p> <ul> <li>Username: jane</li> <li>Password: p</li> </ul> <p>Click again on the cards and check that now you are able to access the inner pages.</p>"},{"location":"authorino/docs/user-guides/deny-with-redirect-to-login/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/user-credential-1\nkubectl delete authconfig/matrix-quotes-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/matrix-quotes/matrix-quotes-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/","title":"User guide: Edge Authentication Architecture (EAA)","text":"<p>Edge Authentication Architecture (EAA) is a pattern where more than extracting authentication logics and specifics from the application codebase to a proper authN/authZ layer, this is pushed to the edge of your cloud network, without violating the Zero Trust principle nevertheless.</p> <p>The very definition of \"edge\" is subject to discussion, but the underlying idea is that clients (e.g. API clients, IoT devices, etc.) authenticate with a layer that, before moving traffic to inside the network:</p> <ul> <li>understands the complexity of all the different methods of authentication supported;</li> <li>sometimes some token normalization is involved;</li> <li>eventually enforces some preliminary authorization policies; and</li> <li>possibly filters data bits that are sensitive to privacy concerns (e.g. to comply with local legislation such as GRPD, CCPA, etc)</li> </ul> <p>As a minimum, EAA allows to simplify authentication between applications and microservices inside the network, as well as to reduce authorization to domain-specific rules and policies, rather than having to deal all the complexity to support all types of clients in every node.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 Festival Wristband tokens</li> <li>Identity verification &amp; authentication \u2192 Identity extension</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Festival Wristbands are OpenID Connect ID tokens (signed JWTs) issued by Authorino by the end of the Auth Pipeline, for authorized requests. It can be configured to include claims based on static values and values fetched from the Authorization JSON.</p> <p>Check out as well the user guides about Token normalization, Authentication with API keys and OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> <li>jwt, to inspect JWTs (optional)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino and configuring 2 environments of an architecture, <code>edge</code> and <code>internal</code>.</p> <p>The first environment is a facade for handling the first layer of authentication and exchanging any valid presented authentication token for a Festival Wristband token. In the second, we will deploy a sample service called Talker API that the authorization service will ensure to receive only authenticated traffic presented with a valid Festival Wristband.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u2779.</p> <p>At steps \u2779 and \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-namespaces","title":"\u2777 Create the namespaces","text":"<p>For simplicity, this examples will set up edge and internal nodes in different namespaces of the same Kubernetes cluster. Those will share a same single cluster-wide Authorino instance. In real-life scenarios, it does not have to be like that.</p> <pre><code>kubectl create namespace authorino\nkubectl create namespace edge\nkubectl create namespace internal\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#deploy-authorino","title":"\u2778 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources cluster-wide<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-the-edge","title":"\u2779 Setup the Edge","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-envoy","title":"Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up external authorization with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl -n edge apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/eaa/envoy-edge-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>edge.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 9000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n edge port-forward deployment/envoy 9000:9000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-authconfig","title":"Create the <code>AuthConfig</code>","text":"<p>Create a required secret that will be used by Authorino to sign the Festival Wristband tokens:</p> <pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: wristband-signing-key\nstringData:\n  key.pem: |\n    -----BEGIN EC PRIVATE KEY-----\n    MHcCAQEEIDHvuf81gVlWGo0hmXGTAnA/HVxGuH8vOc7/8jewcVvqoAoGCCqGSM49\n    AwEHoUQDQgAETJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZxJKDysoGwn\n    cnUvHIu23SgW+Ee9lxSmZGhO4eTdQeKxMA==\n    -----END EC PRIVATE KEY-----\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: edge-auth\nspec:\n  hosts:\n\n  - edge.127.0.0.1.nip.io\n  authentication:\n    \"api-clients\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino.kuadrant.io/managed-by: authorino\n        allNamespaces: true\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n      overrides:\n        \"username\":\n          selector: auth.identity.metadata.annotations.authorino\\.kuadrant\\.io/username\n    \"idp-users\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      defaults:\n        \"username\":\n          selector: auth.identity.preferred_username\n  response:\n    success:\n      dynamicMetadata:\n        \"wristband\":\n          wristband:\n            issuer: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\n            customClaims:\n              \"username\":\n                selector: auth.identity.username\n            tokenDuration: 300\n            signingKeyRefs:\n            - name: wristband-signing-key\n              algorithm: ES256\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-the-internal-workload","title":"\u277a Setup the internal workload","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#deploy-the-talker-api","title":"Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl -n internal apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#setup-envoy_1","title":"Setup Envoy","text":"<p>This other bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.</p> <pre><code>kubectl -n internal apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/eaa/envoy-node-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n internal port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-the-authconfig_1","title":"Create the <code>AuthConfig</code>","text":"Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n internal apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"edge-authenticated\":\n      jwt:\n        issuerUrl: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl -n edge apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n  annotations:\n    authorino.kuadrant.io/username: alice\n    authorino.kuadrant.io/email: alice@host\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#consume-the-api","title":"\u277c Consume the API","text":""},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#using-the-api-key-to-authenticate","title":"Using the API key to authenticate","text":"<p>Authenticate at the edge:</p> <pre><code>WRISTBAND_TOKEN=$(curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://edge.127.0.0.1.nip.io:9000/auth -is | tr -d '\\r' | sed -En 's/^x-wristband-token: (.*)/\\1/p')\n</code></pre> <p>Consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $WRISTBAND_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Try to consume the API with authentication token that is only accepted in the edge:</p> <pre><code>curl -H \"Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"edge-authenticated\"\n# x-ext-auth-reason: credential not found\n</code></pre> <p>(Optional) Inspect the wristband token and verify that it only contains restricted info to authenticate and authorize with internal apps.</p> <pre><code>jwt decode $WRISTBAND_TOKEN\n# [...]\n#\n# Token claims\n# ------------\n# {\n#   \"exp\": 1638452051,\n#   \"iat\": 1638451751,\n#   \"iss\": \"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/edge/edge-auth/wristband\",\n#   \"sub\": \"02cb51ea0e1c9f3c0960197a2518c8eb4f47e1b9222a968ffc8d4c8e783e4d19\",\n#   \"username\": \"alice\"\n# }\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#authenticating-with-the-keycloak-server","title":"Authenticating with the Keycloak server","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl -n edge run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>(Optional) Inspect the access token issue by Keycloak and verify and how it contains more details about the identity than required to authenticate and authorize with internal apps.</p> <pre><code>jwt decode $ACCESS_TOKEN\n# [...]\n#\n# Token claims\n# ------------\n# { [...]\n#   \"email\": \"jane@kuadrant.io\",\n#   \"email_verified\": true,\n#   \"exp\": 1638452220,\n#   \"family_name\": \"Smith\",\n#   \"given_name\": \"Jane\",\n#   \"iat\": 1638451920,\n#   \"iss\": \"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\",\n#   \"jti\": \"699f6e49-dea4-4f29-ae2a-929a3a18c94b\",\n#   \"name\": \"Jane Smith\",\n#   \"preferred_username\": \"jane\",\n#   \"realm_access\": {\n#     \"roles\": [\n#       \"offline_access\",\n#       \"member\",\n#       \"admin\",\n#       \"uma_authorization\"\n#     ]\n#   },\n# [...]\n</code></pre> <p>As Jane, obtain a limited wristband token at the edge:</p> <pre><code>WRISTBAND_TOKEN=$(curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://edge.127.0.0.1.nip.io:9000/auth -is | tr -d '\\r' | sed -En 's/^x-wristband-token: (.*)/\\1/p')\n</code></pre> <p>Consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $WRISTBAND_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/edge-authentication-architecture-festival-wristbands/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete namespace edge\nkubectl delete namespace internal\nkubectl delete namespace authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino and Authorino Operator manifests, run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/","title":"User guide: Mixing Envoy built-in filter for auth and Authorino","text":"<p>Have JWT validation handled by Envoy beforehand and the JWT payload injected into the request to Authorino, to be used in custom authorization policies defined in a AuthConfig.</p> <p>In this user guide, we will set up Envoy and Authorino to protect a service called the Talker API service, with JWT authentication handled in Envoy and a more complex authorization policy enforced in Authorino.</p> <p>The policy defines a geo-fence by which only requests originated in Great Britain (country code: GB) will be accepted, unless the user is bound to a role called 'admin' in the auth server, in which case no geofence is enforced.</p> <p>All requests to the Talker API will be authenticated in Envoy. However, requests to <code>/global</code> will not trigger the external authorization.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Plain</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Pattern-matching authorization</li> <li>Dynamic response \u2192 Custom denial status</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following command deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app: authorino\n  name: envoy\ndata:\n  envoy.yaml: |\n    static_resources:\n      clusters:\n\n      - name: talker-api\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: talker-api\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: talker-api\n                    port_value: 3000\n      - name: keycloak\n        connect_timeout: 0.25s\n        type: logical_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: keycloak\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: keycloak.keycloak.svc.cluster.local\n                    port_value: 8080\n      - name: authorino\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        http2_protocol_options: {}\n        load_assignment:\n          cluster_name: authorino\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: authorino-authorino-authorization\n                    port_value: 50051\n      listeners:\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 8000\n        filter_chains:\n        - filters:\n          - name: envoy.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              stat_prefix: local\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: local_service\n                  domains: ['*']\n                  routes:\n                  - match: { path_separated_prefix: /global }\n                    route: { cluster: talker-api }\n                    typed_per_filter_config:\n                      envoy.filters.http.ext_authz:\n                        \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n                        disabled: true\n                  - match: { prefix: / }\n                    route: { cluster: talker-api }\n              http_filters:\n              - name: envoy.filters.http.jwt_authn\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.jwt_authn.v3.JwtAuthentication\n                  providers:\n                    keycloak:\n                      issuer: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n                      remote_jwks:\n                        http_uri:\n                          uri: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/certs\n                          cluster: keycloak\n                          timeout: 5s\n                        cache_duration:\n                          seconds: 300\n                      payload_in_metadata: verified_jwt\n                  rules:\n                  - match: { prefix: / }\n                    requires: { provider_name: keycloak }\n              - name: envoy.filters.http.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  failure_mode_allow: false\n                  metadata_context_namespaces:\n                  - envoy.filters.http.jwt_authn\n                  grpc_service:\n                    envoy_grpc:\n                      cluster_name: authorino\n                    timeout: 1s\n              - name: envoy.filters.http.router\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router\n              use_remote_address: true\n    admin:\n      access_log_path: \"/tmp/admin_access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: authorino\n    svc: envoy\n  name: envoy\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: authorino\n      svc: envoy\n  template:\n    metadata:\n      labels:\n        app: authorino\n        svc: envoy\n    spec:\n      containers:\n      - args:\n        - --config-path /usr/local/etc/envoy/envoy.yaml\n        - --service-cluster front-proxy\n        - --log-level info\n        - --component-log-level filter:trace,http:debug,router:debug\n        command:\n        - /usr/local/bin/envoy\n        image: envoyproxy/envoy:v1.22-latest\n        name: envoy\n        ports:\n        - containerPort: 8000\n          name: web\n        - containerPort: 8001\n          name: admin\n        volumeMounts:\n        - mountPath: /usr/local/etc/envoy\n          name: config\n          readOnly: true\n      volumes:\n      - configMap:\n          items:\n          - key: envoy.yaml\n            path: envoy.yaml\n          name: envoy\n        name: config\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    app: authorino\n  name: envoy\nspec:\n  ports:\n  - name: web\n    port: 8000\n    protocol: TCP\n  selector:\n    app: authorino\n    svc: envoy\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-wildcard-host\nspec:\n  rules:\n  - host: talker-api.127.0.0.1.nip.io\n    http:\n      paths:\n      - backend:\n          service:\n            name: envoy\n            port:\n              number: 8000\n        path: /\n        pathType: Prefix\nEOF\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#deploy-the-ip-location-service","title":"\u277a Deploy the IP Location service","text":"<p>The IP Location service is a simple service that resolves an IPv4 address into geo location info.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/Kuadrant/authorino-examples/main/ip-location/ip-location-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#create-an-authconfig","title":"\u277b Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"jwt\":\n      plain:\n        selector: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\n  metadata:\n    \"geoinfo\":\n      http:\n        url: 'http://ip-location.default.svc.cluster.local:3000/{context.request.http.headers.x-forwarded-for.@extract:{\"sep\":\",\"}}'\n        headers:\n          \"Accept\":\n            value: application/json\n      cache:\n        key:\n          selector: \"context.request.http.headers.x-forwarded-for.@extract:{\\\"sep\\\":\\\",\\\"}\"\n  authorization:\n    \"geofence\":\n      when:\n      - selector: auth.identity.realm_access.roles\n        operator: excl\n        value: admin\n      patternMatching:\n        patterns:\n        - selector: auth.metadata.geoinfo.country_iso_code\n          operator: eq\n          value: \"GB\"\n  response:\n    unauthorized:\n      message:\n        selector: \"The requested resource is not available in {auth.metadata.geoinfo.country_name}\"\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-a-token-and-consume-the-api","title":"\u277c Obtain a token and consume the API","text":""},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user John, a non-admin (member) user:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As John, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: The requested resource is not available in Italy\n</code></pre> <p>As John, consume a path of the API that will cause Envoy to skip external authorization:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/global -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#obtain-an-access-token-and-consume-the-api-as-jane-admin","title":"Obtain an access token and consume the API as Jane (admin)","text":"<p>Obtain an access token with the Keycloak server for Jane, an admin user:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume a path of the API that will cause Envoy to skip external authorization:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 109.69.200.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/global -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/envoy-jwt-authn-and-authorino/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete ingress/ingress-wildcard-host\nkubectl delete service/envoy\nkubectl delete deployment/envoy\nkubectl delete configmap/envoy\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/external-metadata/","title":"User guide: Fetching auth metadata from external sources","text":"<p>Get online data from remote HTTP services to enhance authorization rules.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>You can configure Authorino to fetch additional metadata from external sources in request-time, by sending either GET or POST request to an HTTP service. The service is expected to return a JSON content which is appended to the Authorization JSON, thus becoming available for usage in other configs of the Auth Pipeline, such as in authorization policies or custom responses.</p> <p>URL, parameters and headers of the request to the external source of metadata can be configured, including with dynamic values. Authentication between Authorino and the service can be set as part of these configuration options, or based on shared authentication token stored in a Kubernetes <code>Secret</code>.</p> <p>Check out as well the user guides about Authentication with API keys and Open Policy Agent (OPA) Rego policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/external-metadata/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/external-metadata/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, we will implement a geofence policy for the API, using OPA and metadata fetching from an external service that returns geolocalization JSON data for a given IP address. The policy establishes that only <code>GET</code> requests are allowed and the path of the request should be in the form <code>/{country-code}/*</code>, where <code>{country-code}</code> is the 2-character code of the country where the client is identified as being physically present.</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  metadata:\n    \"geo\":\n      http:\n        urlExpression: |\n          'http://ip-api.com/json/' + request.headers['x-forwarded-for'].split(',')[0] + '?fields=countryCode'\n        headers:\n          \"Accept\":\n            expression: '\"application/json\"'\n  authorization:\n    \"geofence\":\n      opa:\n        rego: |\n          import input.context.request.http\n\n          allow {\n            http.method = \"GET\"\n            split(http.path, \"/\") = [_, requested_country, _]\n            lower(requested_country) == lower(object.get(input.auth.metadata.geo, \"countryCode\", \"\"))\n          }\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/external-metadata/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#consume-the-api","title":"\u277c Consume the API","text":"<p>From an IP address assigned to the United Kingdom of Great Britain and Northern Ireland (country code GB):</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000/gb/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 79.123.45.67' \\\n     http://talker-api.127.0.0.1.nip.io:8000/it/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>From an IP address assigned to Italy (country code IT):</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 109.112.34.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/gb/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 109.112.34.56' \\\n     http://talker-api.127.0.0.1.nip.io:8000/it/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/external-metadata/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/hello-world/","title":"User guide: Hello World","text":""},{"location":"authorino/docs/user-guides/hello-world/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant, you can skip step \u2778. You may already have Authorino installed and running as well. In this case, skip also step \u277a. If you even have your workload cluster configured, with sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, go straight to step \u277c.</p> <p>At step \u277c, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p>"},{"location":"authorino/docs/user-guides/hello-world/#create-the-namespace","title":"\u2776 Create the namespace","text":"<pre><code>kubectl create namespace hello-world\n# namespace/hello-world created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#deploy-the-talker-api","title":"\u2777 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n# deployment.apps/talker-api created\n# service/talker-api created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#setup-envoy","title":"\u2778 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>1</sup></p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/envoy-deploy.yaml\n# configmap/envoy created\n# deployment.apps/envoy created\n# service/envoy created\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl -n hello-world port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-unprotected","title":"\u2779 Consume the API (unprotected)","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#protect-the-api","title":"\u277a Protect the API","text":""},{"location":"authorino/docs/user-guides/hello-world/#install-the-authorino-operator","title":"Install the Authorino Operator","text":"<pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#deploy-authorino","title":"Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>2</sup> that watches for <code>AuthConfig</code> resources in the <code>hello-world</code> namespace<sup>3</sup>, with TLS disabled<sup>4</sup>.</p> <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/authorino.yaml\n# authorino.operator.authorino.kuadrant.io/authorino created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-behind-envoy-and-authorino","title":"\u277b Consume the API behind Envoy and Authorino","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 404 Not Found\n# x-ext-auth-reason: Service not found\n</code></pre> <p>Authorino does not know about the <code>talker-api.127.0.0.1.nip.io</code> host, hence the <code>404 Not Found</code>. Let's teach Authorino about this host by applying an <code>AuthConfig</code>.</p>"},{"location":"authorino/docs/user-guides/hello-world/#apply-the-authconfig","title":"\u277c Apply the <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl -n hello-world apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/hello-world/authconfig.yaml\n# authconfig.authorino.kuadrant.io/talker-api-protection created\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#consume-the-api-without-credentials","title":"\u277d Consume the API without credentials","text":"<pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"api-clients\"\n# x-ext-auth-reason: credential not found\n</code></pre>"},{"location":"authorino/docs/user-guides/hello-world/#grant-access-to-the-api-with-a-tailor-made-security-scheme","title":"Grant access to the API with a tailor-made security scheme","text":"<p>Check out other user guides for several use-cases of authentication and authorization, and the instructions to implement them using Authorino.</p> <p>A few examples of available ser guides:</p> <ul> <li>Authentication with API keys</li> <li>Authentication with JWTs and OpenID Connect Discovery</li> <li>Authentication with Kubernetes tokens (TokenReview API)</li> <li>Authorization with Open Policy Agent (OPA) Rego policies</li> <li>Authorization with simple JSON pattern-matching rules (e.g. JWT claims)</li> <li>Authorization with Kubernetes RBAC (SubjectAccessReview API)</li> <li>Fetching auth metadata from external sources</li> <li>Token normalization</li> </ul>"},{"location":"authorino/docs/user-guides/hello-world/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the namespaces created in step 1 and 5:</p> <pre><code>kubectl delete namespace hello-world\nkubectl delete namespace authorino-operator\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/host-override/","title":"Host override via context extension","text":"<p>By default, Authorino uses the host information of the HTTP request (<code>Attributes.Http.Host</code>) to lookup for an indexed AuthConfig to be enforced<sup>1</sup>. The host info be overridden by supplying a <code>host</code> entry as a (per-route) context extension (<code>Attributes.ContextExtensions</code>), which takes precedence whenever present.</p> <p>Overriding the host attribute of the HTTP request can be useful to support use cases such as of path prefix-based lookup and wildcard subdomains lookup.</p> \u26a0\ufe0f Important:         This feature may not be available to users of Authorino via Kuadrant.        <p></p> <p>In this guide:</p> <ul> <li>Example of host override for path prefix-based lookup</li> <li>Example of host override for wildcard subdomain lookup</li> </ul>"},{"location":"authorino/docs/user-guides/host-override/#example-of-host-override-for-path-prefix-based-lookup","title":"Example of host override for path prefix-based lookup","text":"<p>In this use case, 2 different APIs (i.e. Dogs API and Cats API) are served under the same base domain, and differentiated by the path prefix:</p> <ul> <li><code>pets.com/dogs</code> \u2192  Dogs API</li> <li><code>pets.com/cats</code> \u2192  Cats API</li> </ul> <p>Edit the Envoy config to extend the external authorization settings at the level of the routes, with the <code>host</code> value that will be favored by Authorino before the actual host attribute of the HTTP request:</p> <pre><code>virtual_hosts:\n\n- name: pets-api\n  domains: ['pets.com']\n  routes:\n  - match:\n      prefix: /dogs\n    route:\n      cluster: dogs-api\n    typed_per_filter_config:\n      envoy.filters.http.ext_authz:\n        \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n        check_settings:\n          context_extensions:\n            host: dogs.pets.com\n  - match:\n      prefix: /cats\n    route:\n      cluster: cats-api\n    typed_per_filter_config:\n      envoy.filters.http.ext_authz:\n        \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n        check_settings:\n          context_extensions:\n            host: cats.pets.com\n</code></pre> <p>Create the AuthConfig for the Pets API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: dogs-api-protection\nspec:\n  hosts:\n\n  - dogs.pets.com\n\n  authentication: [...]\n</code></pre> <p>Create the AuthConfig for the Cats API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: cats-api-protection\nspec:\n  hosts:\n\n  - cats.pets.com\n\n  authentication: [...]\n</code></pre> <p>Notice that the host subdomains <code>dogs.pets.com</code> and <code>cats.pets.com</code> are not really requested by the API consumers. Rather, users send requests to <code>pets.com/dogs</code> and <code>pets.com/cats</code>. When routing those requests, Envoy makes sure to inject the corresponding context extensions that will induce the right lookup in Authorino.</p>"},{"location":"authorino/docs/user-guides/host-override/#example-of-host-override-for-wildcard-subdomain-lookup","title":"Example of host override for wildcard subdomain lookup","text":"<p>In this use case, a single Pets API serves requests for any subdomain that matches <code>*.pets.com</code>, e.g.:</p> <ul> <li><code>dogs.pets.com</code> \u2192  Pets API</li> <li><code>cats.pets.com</code> \u2192  Pets API</li> </ul> <p>Edit the Envoy config to extend the external authorization settings at the level of the virtual host, with the <code>host</code> value that will be favored by Authorino before the actual host attribute of the HTTP request:</p> <pre><code>virtual_hosts:\n\n- name: pets-api\n  domains: ['*.pets.com']\n  typed_per_filter_config:\n    envoy.filters.http.ext_authz:\n      \\\"@type\\\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthzPerRoute\n      check_settings:\n        context_extensions:\n          host: pets.com\n  routes:\n  - match:\n      prefix: /\n    route:\n      cluster: pets-api\n</code></pre> <p>The <code>host</code> context extension used above is any key that matches one of the hosts listed in the targeted AuthConfig.</p> <p>Create the AuthConfig for the Pets API:</p> <pre><code>apiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: pets-api-protection\nspec:\n  hosts:\n\n  - pets.com\n\n  authentication: [...]\n</code></pre> <p>Notice that requests to <code>dogs.pets.com</code> and to <code>cats.pets.com</code> are all routed by Envoy to the same API, with same external authorization configuration. in all the cases, Authorino will lookup for the indexed AuthConfig associated with <code>pets.com</code>. The same is valid for a request sent, e.g., to <code>birds.pets.com</code>.</p> <ol> <li> <p>For further details about Authorino lookup of AuthConfig, check out Host lookup.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/http-basic-authentication/","title":"User guide: HTTP \"Basic\" Authentication (RFC 7235)","text":"<p>Turn Authorino API key <code>Secret</code>s settings into HTTP basic auth.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>HTTP \"Basic\" Authentication (RFC 7235) is not recommended if you can afford other more secure methods such as OpenID Connect. To support legacy nonetheless it is sometimes necessary to implement it.</p> <p>In Authorino, HTTP \"Basic\" Authentication can be modeled leveraging the API key authentication feature (stored as Kubernetes <code>Secret</code>s with an <code>api_key</code> entry and labeled to match selectors specified in <code>spec.identity.apiKey.selector</code> of the <code>AuthConfig</code>).</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The config uses API Key secrets to store base64-encoded <code>username:password</code> HTTP \"Basic\" authentication credentials. The config also specifies an Access Control List (ACL) by which only user <code>john</code> is authorized to consume the <code>/bye</code> endpoint of the API.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"http-basic-auth\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: users\n      credentials:\n        authorizationHeader:\n          prefix: Basic\n  authorization:\n    \"acl\":\n      when:\n      - predicate: request.path == '/bye'\n      patternMatching:\n        patterns:\n        - selector: context.request.http.headers.authorization.@extract:{\"pos\":1}|@base64:decode|@extract:{\"sep\":\":\"}\n          operator: eq\n          value: john\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON. Check out as well the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#create-user-credentials","title":"\u277b Create user credentials","text":"<p>To create credentials for HTTP \"Basic\" Authentication, store each <code>username:password</code>, base64-encoded, in the <code>api_key</code> value of the Kubernetes <code>Secret</code> resources. E.g.:</p> <pre><code>printf \"john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" | base64\n# am9objpuZHlCenJlVXpGNHpxRFFzcVNQTUhrUmhyaUVPdGNSeA==\n</code></pre> <p>Create credentials for user John:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: basic-auth-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: am9objpuZHlCenJlVXpGNHpxRFFzcVNQTUhrUmhyaUVPdGNSeA== # john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>Create credentials for user Jane:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: basic-auth-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: users\nstringData:\n  api_key: amFuZTpkTnNScnNhcHkwbk5Dd210NTM3ZkhGcHl4MGNCc0xFcA== # jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>As John (authorized in the ACL):</p> <pre><code>curl -u john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -u john:ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx http://talker-api.127.0.0.1.nip.io:8000/bye\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane (NOT authorized in the ACL):</p> <pre><code>curl -u jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -u jane:dNsRrsapy0nNCwmt537fHFpyx0cBsLEp http://talker-api.127.0.0.1.nip.io:8000/bye -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>With an invalid user/password:</p> <pre><code>curl -u unknown:invalid http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Basic realm=\"http-basic-auth\"\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#revoke-access-to-the-api","title":"\u277d Revoke access to the API","text":"<pre><code>kubectl delete secret/basic-auth-1\n</code></pre>"},{"location":"authorino/docs/user-guides/http-basic-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/basic-auth-1\nkubectl delete secret/basic-auth-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/injecting-data/","title":"User guide: Injecting data in the request","text":"<p>Inject HTTP headers with serialized JSON content.</p> Authorino capabilities featured in this guide: <ul> <li>Dynamic response \u2192 JSON injection</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Inject serialized custom JSON objects as HTTP request headers. Values can be static or fetched from the Authorization JSON.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/injecting-data/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/injecting-data/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The following defines a JSON object to be injected as an added HTTP header into the request, named after the response config <code>x-ext-auth-data</code>. The object includes 3 properties:</p> <ol> <li>a static value <code>authorized: true</code>;</li> <li>a dynamic value <code>request-time</code>, from Envoy-supplied contextual data present in the Authorization JSON; and</li> <li>a greeting message <code>geeting-message</code> that interpolates a dynamic value read from an annotation of the Kubernetes <code>Secret</code> resource that represents the API key used to authenticate into a static string.</li> </ol> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  response:\n    success:\n      headers:\n        \"x-ext-auth-data\":\n          json:\n            properties:\n              \"authorized\":\n                expression: \"true\"\n              \"request-time\":\n                expression: request.time.seconds\n              \"greeting-message\":\n                expression: |\n                  'Hello, ' + auth.identity.metadata.annotations['auth-data/name']\nEOF\n</code></pre> <p>Check out the docs about using Common Expression Language (CEL) for reading from the Authorization JSON.</p>"},{"location":"authorino/docs/user-guides/injecting-data/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\n  annotations:\n    auth-data/name: Rita\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#consume-the-api","title":"\u277c Consume the API","text":"<pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# {\n#   \"method\": \"GET\",\n#   \"path\": \"/hello\",\n#   \"query_string\": null,\n#   \"body\": \"\",\n#   \"headers\": {\n#     \u2026\n#     \"X-Ext-Auth-Data\": \"{\\\"authorized\\\":true,\\\"greeting-message\\\":\\\"Hello, Rita!\\\",\\\"request-time\\\":1637954644}\",\n#   },\n#   \u2026\n# }\n</code></pre>"},{"location":"authorino/docs/user-guides/injecting-data/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/","title":"User guide: Simple pattern-matching authorization policies","text":"<p>Write simple authorization rules based on JSON patterns matched against Authorino's Authorization JSON; check contextual information of the request, validate JWT claims, cross metadata fetched from external sources, etc.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Pattern-matching authorization</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino provides a built-in authorization module to check simple pattern-matching rules against the Authorization JSON. This is an alternative to OPA when all you want is to check for some simple rules, without complex logics, such as match the value of a JWT claim.</p> <p>Check out as well the user guide about OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The <code>email-verified-only</code> authorization policy ensures that users consuming the API from a given network (IP range 192.168.1/24) must have their emails verified.</p> <p>The <code>email_verified</code> claim is a property of the identity added to the JWT by the OpenID Connect issuer.</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"email-verified-only\":\n      when:\n      - predicate: |\n          request.headers['x-forwarded-for'].split(',')[0].matches(\"^192\\\\\\.168\\\\\\.1\\\\\\.\\\\\\d+$\")\n      patternMatching:\n        patterns:\n        - predicate: auth.identity.email_verified\nEOF\n</code></pre> <p>Check out the doc about using Common Expression Language (CEL) for reading from the Authorization JSON. Check out as well the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api-as-jane-email-verified","title":"Obtain an access token and consume the API as Jane (email verified)","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As Jane, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#obtain-an-access-token-and-consume-the-api-as-peter-email-not-verified","title":"Obtain an access token and consume the API as Peter (email NOT verified)","text":"<p>Obtain an access token with the Keycloak server for Peter:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=peter' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Peter, consume the API outside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As Peter, consume the API inside the area where the policy applies:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/json-pattern-matching-authorization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete namespace keycloak\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/","title":"User guide: Authorization with Keycloak Authorization Services","text":"<p>Keycloak provides a powerful set of tools (REST endpoints and administrative UIs), also known as Keycloak Authorization Services, to manage and enforce authorization, workflows for multiple access control mechanisms, including discretionary user access control and user-managed permissions.</p> <p>This user guide is an example of how to use Authorino as an adapter to Keycloak Authorization Services while still relying on the reverse-proxy integration pattern, thus not involving importing an authorization library nor rebuilding the application's code.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Keycloak server</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Forward local requests to Keycloak running inside the cluster (if using Kind):</p> <pre><code>kubectl -n keycloak port-forward deployment/keycloak 8080:8080 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, Authorino will accept access tokens (JWTs) issued by the Keycloak server. These JWTs can be either normal Keycloak ID tokens or Requesting Party Tokens (RPT).</p> <p>RPTs include claims about the permissions of the user regarding protected resources and scopes associated with a Keycloak authorization client that the user can access.</p> <p>When the supplied access token is an RPT, Authorino will just validate whether the user's granted permissions present in the token include the requested resource ID (translated from the path) and scope (inferred from the HTTP method). If the token does not contain a <code>permissions</code> claim (i.e. it is not an RPT), Authorino will negotiate a User-Managed Access (UMA) ticket on behalf of the user and try to obtain an RPT on that UMA ticket.</p> <p>In cases of asynchronous user-managed permission control, the first request to the API using a normal Keycloak ID token is denied by Authorino. The user that owns the resource acknowledges the access request in the Keycloak UI. If access is granted, the new permissions will be reflected in subsequent RPTs obtained by Authorino on behalf of the requesting party.</p> <p>Whenever an RPT with proper permissions is obtained by Authorino, the RPT is supplied back to the API consumer, so it can be used in subsequent requests thus skipping new negotiations of UMA tickets.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"uma\":\n      opa:\n        rego: |\n          pat := http.send({\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token\",\"method\": \"post\",\"headers\":{\"Content-Type\":\"application/x-www-form-urlencoded\"},\"raw_body\":\"grant_type=client_credentials\"}).body.access_token\n          resource_id := http.send({\"url\":concat(\"\",[\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/authz/protection/resource_set?uri=\",input.context.request.http.path]),\"method\":\"get\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",pat])}}).body[0]\n          scope := lower(input.context.request.http.method)\n          access_token := trim_prefix(input.context.request.http.headers.authorization, \"Bearer \")\n\n          default rpt = \"\"\n          rpt = access_token { object.get(input.auth.identity, \"authorization\", {}).permissions }\n          else = rpt_str {\n            ticket := http.send({\"url\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/authz/protection/permission\",\"method\":\"post\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",pat]),\"Content-Type\":\"application/json\"},\"raw_body\":concat(\"\",[\"[{\\\"resource_id\\\":\\\"\",resource_id,\"\\\",\\\"resource_scopes\\\":[\\\"\",scope,\"\\\"]}]\"])}).body.ticket\n            rpt_str := object.get(http.send({\"url\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token\",\"method\":\"post\",\"headers\":{\"Authorization\":concat(\" \",[\"Bearer \",access_token]),\"Content-Type\":\"application/x-www-form-urlencoded\"},\"raw_body\":concat(\"\",[\"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket&amp;ticket=\",ticket,\"&amp;submit_request=true\"])}).body, \"access_token\", \"\")\n          }\n\n          allow {\n            permissions := object.get(io.jwt.decode(rpt)[1], \"authorization\", { \"permissions\": [] }).permissions\n            permissions[i]\n            permissions[i].rsid = resource_id\n            permissions[i].scopes[_] = scope\n          }\n        allValues: true\n  response:\n    success:\n      headers:\n        \"x-keycloak\":\n          when:\n\n          - selector: auth.identity.authorization.permissions\n            operator: eq\n            value: \"\"\n          json:\n            properties:\n              \"rpt\":\n                selector: auth.authorization.uma.rpt\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for user Jane:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#consume-the-api","title":"\u277c Consume the API","text":"<p>As Jane, try to send a <code>GET</code> request to the protected resource <code>/greetings/1</code>, owned by user John.</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>As John, log in to http://localhost:8080/realms/kuadrant/account in the web browser (username: <code>john</code> / password: <code>p</code>), and grant access to the resource <code>greeting-1</code> for Jane. A pending permission request by Jane shall exist in the list of John's Resources.</p> <p> </p> <p>As Jane, try to consume the protected resource <code>/greetings/1</code> again:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 200 OK\n#\n# {\u2026\n#   \"headers\": {\u2026\n#     \"X-Keycloak\": \"{\\\"rpt\\\":\\\"&lt;RPT&gt;\", \u2026\n</code></pre> <p>Copy the RPT from the response and repeat the request now using the RPT to authenticate:</p> <pre><code>curl -H \"Authorization: Bearer &lt;RPT&gt;\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/keycloak-authorization-services/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/","title":"User guide: Kubernetes RBAC for service authorization (SubjectAccessReview API)","text":"<p>Manage permissions in the Kubernetes RBAC and let Authorino to check them in request-time with the authorization system of the cluster.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Kubernetes SubjectAccessReview</li> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> </ul> <p>Authorino can delegate authorization decision to the Kubernetes authorization system, allowing permissions to be stored and managed using the Kubernetes Role-Based Access Control (RBAC) for example. The feature is based on the <code>SubjectAccessReview</code> API and can be used for <code>resourceAttributes</code> (parameters defined in the <code>AuthConfig</code>) or <code>nonResourceAttributes</code> (inferring HTTP path and verb from the original request).</p> <p>Check out as well the user guide about Authentication with Kubernetes tokens (TokenReview API).</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC) and to create <code>TokenRequest</code>s (to consume the protected service from outside the cluster)</li> <li>jq</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>The <code>AuthConfig</code> below sets all Kubernetes service accounts as trusted users of the API, and relies on the Kubernetes RBAC to enforce authorization using Kubernetes SubjectAccessReview API for non-resource endpoints:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  - envoy.default.svc.cluster.local\n  authentication:\n    \"service-accounts\":\n      kubernetesTokenReview:\n        audiences: [\"https://kubernetes.default.svc.cluster.local\"]\n  authorization:\n    \"k8s-rbac\":\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.user.username\nEOF\n</code></pre> <p>Check out the spec for the Authorino Kubernetes SubjectAccessReview authorization feature, for resource attributes permission checks where SubjectAccessReviews issued by Authorino are modeled in terms of common attributes of operations on Kubernetes resources (namespace, API group, kind, name, subresource, verb).</p>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-roles-associated-with-endpoints-of-the-api","title":"\u277b Create roles associated with endpoints of the API","text":"<p>Because the <code>k8s-rbac</code> policy defined in the <code>AuthConfig</code> in the previous step is for non-resource access review requests, the corresponding roles and role bindings have to be defined at cluster scope.</p> <p>Create a <code>talker-api-greeter</code> role whose users and service accounts bound to this role can consume the non-resource endpoints <code>POST /hello</code> and <code>POST /hi</code> of the API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: talker-api-greeter\nrules:\n\n- nonResourceURLs: [\"/hello\"]\n  verbs: [\"post\"]\n- nonResourceURLs: [\"/hi\"]\n  verbs: [\"post\"]\nEOF\n</code></pre> <p>Create a <code>talker-api-speaker</code> role whose users and service accounts bound to this role can consume the non-resource endpoints <code>POST /say/*</code> of the API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: talker-api-speaker\nrules:\n\n- nonResourceURLs: [\"/say/*\"]\n  verbs: [\"post\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#create-the-serviceaccounts-and-permissions-to-consume-the-api","title":"\u277c Create the <code>ServiceAccount</code>s and permissions to consume the API","text":"<p>Create service accounts <code>api-consumer-1</code> and <code>api-consumer-2</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-1\nEOF\n</code></pre> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-2\nEOF\n</code></pre> <p>Bind both service accounts to the <code>talker-api-greeter</code> role:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: talker-api-greeter-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: talker-api-greeter\nsubjects:\n\n- kind: ServiceAccount\n  name: api-consumer-1\n  namespace: default\n- kind: ServiceAccount\n  name: api-consumer-2\n  namespace: default\nEOF\n</code></pre> <p>Bind service account <code>api-consumer-1</code> to the <code>talker-api-speaker</code> role:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: talker-api-speaker-rolebinding\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: talker-api-speaker\nsubjects:\n\n- kind: ServiceAccount\n  name: api-consumer-1\n  namespace: default\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#consume-the-api","title":"\u277d Consume the API","text":"<p>Run a pod that consumes one of the greeting endpoints of the API from inside the cluster, as service account <code>api-consumer-1</code>, bound to the <code>talker-api-greeter</code> and <code>talker-api-speaker</code> cluster roles in the Kubernetes RBAC:</p> <pre><code>kubectl run greeter --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/hi\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-1\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 200\n</code></pre> <p>Run a pod that sends a <code>POST</code> request to <code>/say/blah</code> from within the cluster, as service account <code>api-consumer-1</code>:</p> <pre><code>kubectl run speaker --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/say/blah\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-1\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 200\n</code></pre> <p>Run a pod that sends a <code>POST</code> request to <code>/say/blah</code> from within the cluster, as service account <code>api-consumer-2</code>, bound only to the <code>talker-api-greeter</code> cluster role in the Kubernetes RBAC:</p> <pre><code>kubectl run speaker --attach --rm --restart=Never -q --image=quay.io/kuadrant/authorino-examples:api-consumer --overrides='{\n  \"apiVersion\": \"v1\",\n  \"spec\": {\n    \"containers\": [{\n      \"name\": \"api-consumer\", \"image\": \"quay.io/kuadrant/authorino-examples:api-consumer\", \"command\": [\"./run\"],\n      \"args\":[\"--endpoint=http://envoy.default.svc.cluster.local:8000/say/blah\",\"--method=POST\",\"--interval=0\",\"--token-path=/var/run/secrets/tokens/api-token\"],\n      \"volumeMounts\": [{\"mountPath\": \"/var/run/secrets/tokens\",\"name\": \"access-token\"}]\n    }],\n    \"serviceAccountName\": \"api-consumer-2\",\n    \"volumes\": [{\"name\": \"access-token\",\"projected\": {\"sources\": [{\"serviceAccountToken\": {\"path\": \"api-token\",\"expirationSeconds\": 7200}}]}}]\n  }\n}' -- sh\n# Sending...\n# 403\n</code></pre> Extra: consume the API as service account <code>api-consumer-2</code> from outside the cluster <p></p> <p>Obtain a short-lived access token for service account <code>api-consumer-2</code>, bound to the <code>talker-api-greeter</code> cluster role in the Kubernetes RBAC, using the Kubernetes TokenRequest API:</p> <pre><code>export ACCESS_TOKEN=$(echo '{ \"apiVersion\": \"authentication.k8s.io/v1\", \"kind\": \"TokenRequest\", \"spec\": { \"expirationSeconds\": 600 } }' | kubectl create --raw /api/v1/namespaces/default/serviceaccounts/api-consumer-2/token -f - | jq -r .status.token)\n</code></pre> <p>Consume the API as <code>api-consumer-2</code> from outside the cluster:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X POST http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X POST http://talker-api.127.0.0.1.nip.io:8000/say/something -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-subjectaccessreview/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete serviceaccount/api-consumer-1\nkubectl delete serviceaccount/api-consumer-2\nkubectl delete clusterrolebinding/talker-api-greeter-rolebinding\nkubectl delete clusterrolebinding/talker-api-speaker-rolebinding\nkubectl delete clusterrole/talker-api-greeter\nkubectl delete clusterrole/talker-api-speaker\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/","title":"User guide: Authentication with Kubernetes tokens (TokenReview API)","text":"<p>Validate Kubernetes Service Account tokens to authenticate requests to your protected hosts.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> </ul> <p>Authorino can verify Kubernetes-valid access tokens (using Kubernetes TokenReview API).</p> <p>These tokens can be either <code>ServiceAccount</code> tokens or any valid user access tokens issued to users of the Kubernetes server API.</p> <p>The <code>audiences</code> claim of the token must include the requested host and port of the protected API (default), or all audiences specified in <code>spec.identity.kubernetes.audiences</code> of the <code>AuthConfig</code>.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC) and to create <code>TokenRequest</code>s (to consume the protected service from outside the cluster)</li> <li>jq</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  - envoy.default.svc.cluster.local\n  authentication:\n    \"authorized-service-accounts\":\n      kubernetesTokenReview:\n        audiences:\n        - talker-api\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-protected-by-authorino","title":"\u277b Consume the API protected by Authorino","text":""},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#create-a-serviceaccount","title":"Create a <code>ServiceAccount</code>","text":"<p>Create a Kubernetes <code>ServiceAccount</code> to identify the consumer application that will send requests to the protected API:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: api-consumer-1\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-from-outside-the-cluster","title":"Consume the API from outside the cluster","text":"<p>Obtain a short-lived access token for the <code>api-consumer-1</code> service account:</p> <pre><code>export ACCESS_TOKEN=$(echo '{ \"apiVersion\": \"authentication.k8s.io/v1\", \"kind\": \"TokenRequest\", \"spec\": { \"audiences\": [\"talker-api\"], \"expirationSeconds\": 600 } }' | kubectl create --raw /api/v1/namespaces/default/serviceaccounts/api-consumer-1/token -f - | jq -r .status.token)\n</code></pre> <p>Consume the API with a valid Kubernetes token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre> <p>Consume the API with the Kubernetes token expired (10 minutes):</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"authorized-service-accounts\"\n# x-ext-auth-reason: Not authenticated\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#consume-the-api-from-inside-the-cluster","title":"Consume the API from inside the cluster","text":"<p>Deploy an application that consumes an endpoint of the Talker API, in a loop, every 10 seconds. The application uses a short-lived service account token mounted inside the container using Kubernetes Service Account Token Volume Projection to authenticate.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: api-consumer\nspec:\n  containers:\n\n  - name: api-consumer\n    image: quay.io/kuadrant/authorino-examples:api-consumer\n    command: [\"./run\"]\n    args:\n      - --endpoint=http://envoy.default.svc.cluster.local:8000/hello\n      - --token-path=/var/run/secrets/tokens/api-token\n      - --interval=10\n    volumeMounts:\n    - mountPath: /var/run/secrets/tokens\n      name: talker-api-access-token\n  serviceAccountName: api-consumer-1\n  volumes:\n  - name: talker-api-access-token\n    projected:\n      sources:\n      - serviceAccountToken:\n          path: api-token\n          expirationSeconds: 7200\n          audience: talker-api\nEOF\n</code></pre> <p>Check the logs of <code>api-consumer</code>:</p> <pre><code>kubectl logs -f api-consumer\n# Sending...\n# 200\n# 200\n# 200\n# 200\n# ...\n</code></pre>"},{"location":"authorino/docs/user-guides/kubernetes-tokenreview/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete pod/api-consumer\nkubectl delete serviceaccount/api-consumer-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/mtls-authentication/","title":"User guide: Authentication with X.509 certificates and Mutual Transport Layer Security (mTLS)","text":"<p>Verify client X.509 certificates against trusted root CAs stored in Kubernetes <code>Secret</code>s to authenticate access to APIs protected with Authorino.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 X.509 client certificate authentication</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Authorino can verify x509 certificates presented by clients for authentication on the request to the protected APIs, at application level.</p> <p>Trusted root Certificate Authorities (CA) are stored as Kubernetes <code>kubernetes.io/tls</code> Secrets labeled according to selectors specified in the AuthConfig, watched and cached by Authorino.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/mtls-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277b.</p> <p>At step \u277b, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/mtls-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following commands will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS enabled<sup>3</sup>.</p> <p>Create the TLS certificates for the Authorino service:</p> <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/default/g\" | kubectl apply -f -\n</code></pre> <p>Request the Authorino instance:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#create-a-ca","title":"\u2779 Create a CA","text":"<p>Create a CA (Certificate Authority) certificate to issue the client certificates that will be used to authenticate clients that send requests to the Talker API:</p> <pre><code>openssl req -x509 -sha512 -nodes \\\n  -days 365 \\\n  -newkey rsa:4096 \\\n  -subj \"/CN=talker-api-ca\" \\\n  -addext basicConstraints=CA:TRUE \\\n  -addext keyUsage=digitalSignature,keyCertSign \\\n  -keyout /tmp/ca.key \\\n  -out /tmp/ca.crt\n</code></pre> <p>Store the CA cert in a Kubernetes <code>Secret</code>, labeled to be discovered by Authorino and to be mounted in the file system of the Envoy container:</p> <pre><code>kubectl create secret tls talker-api-ca --cert=/tmp/ca.crt --key=/tmp/ca.key\nkubectl label secret talker-api-ca authorino.kuadrant.io/managed-by=authorino app=talker-api\n</code></pre> <p>Prepare an extension file for the client certificate signing requests:</p> <pre><code>cat &gt; /tmp/x509v3.ext &lt;&lt; EOF\nauthorityKeyIdentifier=keyid,issuer\nbasicConstraints=CA:FALSE\nkeyUsage=digitalSignature,nonRepudiation,keyEncipherment,dataEncipherment\nextendedKeyUsage=clientAuth\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#setup-envoy","title":"\u277a Setup Envoy","text":"<p>The following command deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\ndata:\n  envoy.yaml: |\n    static_resources:\n      listeners:\n\n      - address:\n          socket_address:\n            address: 0.0.0.0\n            port_value: 8443\n        filter_chains:\n        - transport_socket:\n            name: envoy.transport_sockets.tls\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.DownstreamTlsContext\n              common_tls_context:\n                tls_certificates:\n                - certificate_chain: {filename: \"/etc/ssl/certs/talker-api/tls.crt\"}\n                  private_key: {filename: \"/etc/ssl/certs/talker-api/tls.key\"}\n                validation_context:\n                  trusted_ca:\n                    filename: /etc/ssl/certs/talker-api/tls.crt\n          filters:\n          - name: envoy.http_connection_manager\n            typed_config:\n              \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n              stat_prefix: local\n              route_config:\n                name: local_route\n                virtual_hosts:\n                - name: local_service\n                  domains: ['*']\n                  routes:\n                  - match: { prefix: / }\n                    route: { cluster: talker-api }\n              http_filters:\n              - name: envoy.filters.http.ext_authz\n                typed_config:\n                  \"@type\": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz\n                  transport_api_version: V3\n                  failure_mode_allow: false\n                  include_peer_certificate: true\n                  grpc_service:\n                    envoy_grpc: { cluster_name: authorino }\n                    timeout: 1s\n              - name: envoy.filters.http.router\n                typed_config: {}\n              use_remote_address: true\n      clusters:\n      - name: authorino\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        http2_protocol_options: {}\n        load_assignment:\n          cluster_name: authorino\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: authorino-authorino-authorization\n                    port_value: 50051\n        transport_socket:\n          name: envoy.transport_sockets.tls\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext\n            common_tls_context:\n              validation_context:\n                trusted_ca:\n                  filename: /etc/ssl/certs/authorino-ca-cert.crt\n      - name: talker-api\n        connect_timeout: 0.25s\n        type: strict_dns\n        lb_policy: round_robin\n        load_assignment:\n          cluster_name: talker-api\n          endpoints:\n          - lb_endpoints:\n            - endpoint:\n                address:\n                  socket_address:\n                    address: talker-api\n                    port_value: 3000\n    admin:\n      access_log_path: \"/tmp/admin_access.log\"\n      address:\n        socket_address:\n          address: 0.0.0.0\n          port_value: 8001\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  labels:\n    app: envoy\n  name: envoy\nspec:\n  selector:\n    matchLabels:\n      app: envoy\n  template:\n    metadata:\n      labels:\n        app: envoy\n    spec:\n      containers:\n      - args:\n        - --config-path /usr/local/etc/envoy/envoy.yaml\n        - --service-cluster front-proxy\n        - --log-level info\n        - --component-log-level filter:trace,http:debug,router:debug\n        command:\n        - /usr/local/bin/envoy\n        image: envoyproxy/envoy:v1.19-latest\n        name: envoy\n        ports:\n        - containerPort: 8443\n          name: web\n        - containerPort: 8001\n          name: admin\n        volumeMounts:\n        - mountPath: /usr/local/etc/envoy\n          name: config\n          readOnly: true\n        - mountPath: /etc/ssl/certs/authorino-ca-cert.crt\n          name: authorino-ca-cert\n          readOnly: true\n          subPath: ca.crt\n        - mountPath: /etc/ssl/certs/talker-api\n          name: talker-api-ca\n          readOnly: true\n      volumes:\n      - configMap:\n          items:\n          - key: envoy.yaml\n            path: envoy.yaml\n          name: envoy\n        name: config\n      - name: authorino-ca-cert\n        secret:\n          defaultMode: 420\n          secretName: authorino-ca-cert\n      - name: talker-api-ca\n        secret:\n          defaultMode: 420\n          secretName: talker-api-ca\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: envoy\nspec:\n  selector:\n    app: envoy\n  ports:\n  - name: web\n    port: 8443\n    protocol: TCP\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: ingress-wildcard-host\nspec:\n  rules:\n  - host: talker-api.127.0.0.1.nip.io\n    http:\n      paths:\n      - backend:\n          service:\n            name: envoy\n            port: { number: 8443 }\n        path: /\n        pathType: Prefix\nEOF\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8443 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8443:8443 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#create-the-authconfig","title":"\u277b Create the <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"mtls\":\n      x509:\n        selector:\n          matchLabels:\n            app: talker-api\n  authorization:\n    \"acme\":\n      patternMatching:\n        patterns:\n        - selector: auth.identity.Organization\n          operator: incl\n          value: ACME Inc.\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a TLS certificate signed by the trusted CA:</p> <pre><code>openssl genrsa -out /tmp/aisha.key 4096\nopenssl req -new -subj \"/CN=aisha/C=PK/L=Islamabad/O=ACME Inc./OU=Engineering\" -key /tmp/aisha.key -out /tmp/aisha.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/ca.crt -CAkey /tmp/ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/aisha.csr -out /tmp/aisha.crt\n\ncurl -k --cert /tmp/aisha.crt --key /tmp/aisha.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>With a TLS certificate signed by the trusted CA, though missing an authorized Organization:</p> <pre><code>openssl genrsa -out /tmp/john.key 4096\nopenssl req -new -subj \"/CN=john/C=UK/L=London\" -key /tmp/john.key -out /tmp/john.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/ca.crt -CAkey /tmp/ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/john.csr -out /tmp/john.crt\n\ncurl -k --cert /tmp/john.crt --key /tmp/john.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#try-the-authconfig-via-raw-http-authorization-interface","title":"\u277d Try the AuthConfig via raw HTTP authorization interface","text":"<p>Expose Authorino's raw HTTP authorization to the local host:</p> <pre><code>kubectl port-forward service/authorino-authorino-authorization 5001:5001 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>With a TLS certificate signed by the trusted CA:</p> <pre><code>curl -k --cert /tmp/aisha.crt --key /tmp/aisha.key -H 'Content-Type: application/json' -d '{}' https://talker-api.127.0.0.1.nip.io:5001/check -i\n# HTTP/2 200\n</code></pre> <p>With a TLS certificate signed by an unknown authority:</p> <pre><code>openssl req -x509 -sha512 -nodes \\\n  -days 365 \\\n  -newkey rsa:4096 \\\n  -subj \"/CN=untrusted\" \\\n  -addext basicConstraints=CA:TRUE \\\n  -addext keyUsage=digitalSignature,keyCertSign \\\n  -keyout /tmp/untrusted-ca.key \\\n  -out /tmp/untrusted-ca.crt\n\nopenssl genrsa -out /tmp/niko.key 4096\nopenssl req -new -subj \"/CN=niko/C=JP/L=Osaka\" -key /tmp/niko.key -out /tmp/niko.csr\nopenssl x509 -req -sha512 -days 1 -CA /tmp/untrusted-ca.crt -CAkey /tmp/untrusted-ca.key -CAcreateserial -extfile /tmp/x509v3.ext -in /tmp/niko.csr -out /tmp/niko.crt\n\ncurl -k --cert /tmp/niko.crt --key /tmp/niko.key -H 'Content-Type: application/json' -d '{}' https://talker-api.127.0.0.1.nip.io:5001/check -i\n# HTTP/2 401\n# www-authenticate: Basic realm=\"mtls\"\n# x-ext-auth-reason: x509: certificate signed by unknown authority\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#revoke-an-entire-chain-of-certificates","title":"\u277e Revoke an entire chain of certificates","text":"<pre><code>kubectl delete secret/talker-api-ca\n</code></pre> <p>Even if the deleted root certificate is still cached and accepted at the gateway, Authorino will revoke access at application level immediately.</p> <p>Try with a previously accepted certificate:</p> <pre><code>curl -k --cert /tmp/aisha.crt --key /tmp/aisha.key https://talker-api.127.0.0.1.nip.io:8443 -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Basic realm=\"mtls\"\n# x-ext-auth-reason: x509: certificate signed by unknown authority\n</code></pre>"},{"location":"authorino/docs/user-guides/mtls-authentication/#cleanup","title":"Cleanup","text":"<pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/","title":"User guide: OAuth 2.0 token introspection (RFC 7662)","text":"<p>Introspect OAuth 2.0 access tokens (e.g. opaque tokens) for online user data and token validation in request-time.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 OAuth 2.0 introspection</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Authorino can perform OAuth 2.0 token introspection (RFC 7662) on the access tokens supplied in the requests to protected APIs. This is particularly useful when using opaque tokens, for remote checking the token validity and resolving the identity object.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>OAuth 2.0 server that implements the token introspection endpoint (RFC 7662) (e.g. Keycloak or a12n-server)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy a Keycloak server preloaded with the realm settings required for this guide:</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p>Deploy an a12n-server server preloaded with all settings required for this guide:</p> <pre><code>kubectl create namespace a12n-server\nkubectl -n a12n-server apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/a12n-server/a12n-server-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create the required secrets that will be used by Authorino to authenticate with Keycloak and a12n-server during the introspection request:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: oauth2-token-introspection-credentials-keycloak\nstringData:\n  clientID: talker-api\n  clientSecret: 523b92b6-625d-4e1e-a313-77e7a8ae4e88\ntype: Opaque\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: oauth2-token-introspection-credentials-a12n-server\nstringData:\n  clientID: talker-api\n  clientSecret: V6g-2Eq2ALB1_WHAswzoeZofJ_e86RI4tdjClDDDb4g\ntype: Opaque\nEOF\n</code></pre> <p>Create the Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak\":\n      oauth2Introspection:\n        endpoint: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token/introspect\n        tokenTypeHint: requesting_party_token\n        credentialsRef:\n          name: oauth2-token-introspection-credentials-keycloak\n    \"a12n-server\":\n      oauth2Introspection:\n        endpoint: http://a12n-server.a12n-server.svc.cluster.local:8531/introspect\n        credentialsRef:\n          name: oauth2-token-introspection-credentials-a12n-server\n  authorization:\n    \"can-read\":\n      when:\n      - selector: auth.identity.privileges\n        operator: neq\n        value: \"\"\n      patternMatching:\n        patterns:\n        - selector: auth.identity.privileges.talker-api\n          operator: incl\n          value: read\nEOF\n</code></pre> <p>On every request, Authorino will try to verify the token remotely with the Keycloak server and the a12n-server server.</p> <p>For authorization, whenever the introspected token data includes a <code>privileges</code> property (returned by a12n-server), Authorino will enforce only consumers whose <code>privileges.talker-api</code> includes the <code>\"read\"</code> permission are granted access.</p> <p>Check out the docs for information about the common feature Conditions about skipping parts of an <code>AuthConfig</code> in the auth pipeline based on context.</p>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-with-keycloak-and-consume-the-api","title":"Obtain an access token with Keycloak and consume the API","text":"<p>Obtain an access token with the Keycloak server for user Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>export $(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r '\"ACCESS_TOKEN=\"+.access_token,\"REFRESH_TOKEN=\"+.refresh_token')\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As user Jane, consume the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/logout -H \"Content-Type: application/x-www-form-urlencoded\" -d \"refresh_token=$REFRESH_TOKEN\" -d 'token_type_hint=requesting_party_token' -u demo:\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#obtain-an-access-token-with-a12n-server-and-consume-the-api","title":"Obtain an access token with a12n-server and consume the API","text":"<p>Forward local requests to a12n-server instance running in the cluster:</p> <pre><code>kubectl -n a12n-server port-forward deployment/a12n-server 8531:8531 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre> <p>Obtain an access token with the a12n-server server for service account <code>service-account-1</code>:</p> <pre><code>ACCESS_TOKEN=$(curl -d 'grant_type=client_credentials' -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s \"http://localhost:8531/token\" | jq -r .access_token)\n</code></pre> <p>You can as well obtain an access token from within the cluster, in case your a12n-server is not reachable from the outside:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://a12n-server.a12n-server.svc.cluster.local:8531/token -s -d 'grant_type=client_credentials' -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s | jq -r .access_token)\n</code></pre> <p>Verify the issued token is an opaque access token in this case:</p> <pre><code>echo $ACCESS_TOKEN\n</code></pre> <p>As <code>service-account-1</code>, consumer the API with a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>curl -d \"token=$ACCESS_TOKEN\" -u service-account-1:FO6LgoMKA8TBDDHgSXZ5-iq1wKNwqdDkyeEGIl6gp0s \"http://localhost:8531/revoke\" -i\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#consume-the-api-with-a-missing-or-invalid-access-token","title":"Consume the API with a missing or invalid access token","text":"<pre><code>curl -H \"Authorization: Bearer invalid\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak\"\n# www-authenticate: Bearer realm=\"a12n-server\"\n# x-ext-auth-reason: {\"a12n-server\":\"token is not active\",\"keycloak\":\"token is not active\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/oauth2-token-introspection/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete secret/oauth2-token-introspection-credentials-keycloak\nkubectl delete secret/oauth2-token-introspection-credentials-a12n-server\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\nkubectl delete namespace a12n-server\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/observability/","title":"Observability","text":""},{"location":"authorino/docs/user-guides/observability/#metrics","title":"Metrics","text":"<p>Authorino exports metrics at 2 endpoints:</p> /metrics Metrics of the controller-runtime about reconciliation (caching) of AuthConfigs and API key Secrets /server-metrics Metrics of the external authorization gRPC and OIDC/Festival Wristband validation built-in HTTP servers <p>The Authorino Operator creates a Kubernetes <code>Service</code> named <code>&lt;authorino-cr-name&gt;-controller-metrics</code> that exposes the endpoints on port 8080. The Authorino instance allows to modify the port number of the metrics endpoints, by setting the <code>--metrics-addr</code> command-line flag (default: <code>:8080</code>).</p> <p>Main metrics exported by endpoint<sup>1</sup>:</p> Endpoint: <code>/metrics</code> Metric name Description\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Labels Type controller_runtime_reconcile_total Total number of reconciliations per controller <code>controller=authconfig|secret</code>, <code>result=success|error|requeue</code> counter controller_runtime_reconcile_errors_total Total number of reconciliation errors per controller <code>controller=authconfig|secret</code> counter controller_runtime_reconcile_time_seconds Length of time per reconciliation per controller <code>controller=authconfig|secret</code> histogram controller_runtime_max_concurrent_reconciles Maximum number of concurrent reconciles per controller <code>controller=authconfig|secret</code> gauge workqueue_adds_total Total number of adds handled by workqueue <code>name=authconfig|secret</code> counter workqueue_depth Current depth of workqueue <code>name=authconfig|secret</code> gauge workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested <code>name=authconfig|secret</code> histogram workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running. <code>name=authconfig|secret</code> gauge workqueue_retries_total Total number of retries handled by workqueue <code>name=authconfig|secret</code> counter workqueue_unfinished_work_seconds How many seconds of work has been done that is in progress and hasn't been observed by work_duration. <code>name=authconfig|secret</code> gauge workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes. <code>name=authconfig|secret</code> histogram rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host. <code>code=200|404</code>, <code>method=GET|PUT|POST</code> counter Endpoint: <code>/server-metrics</code> Metric name Description Labels Type auth_server_evaluator_total<sup>2</sup> Total number of evaluations of individual authconfig rule performed by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_cancelled<sup>2</sup> Number of evaluations of individual authconfig rule cancelled by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_ignored<sup>2</sup> Number of evaluations of individual authconfig rule ignored by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_denied<sup>2</sup> Number of denials from individual authconfig rule evaluated by the auth server. <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> counter auth_server_evaluator_duration_seconds<sup>2</sup> Response latency of individual authconfig rule evaluated by the auth server (in seconds). <code>namespace</code>, <code>authconfig</code>, <code>evaluator_type</code>, <code>evaluator_name</code> histogram auth_server_authconfig_total Total number of authconfigs enforced by the auth server, partitioned by authconfig. <code>namespace</code>, <code>authconfig</code> counter auth_server_authconfig_response_status Response status of authconfigs sent by the auth server, partitioned by authconfig. <code>namespace</code>, <code>authconfig</code>, <code>status=OK|UNAUTHENTICATED,PERMISSION_DENIED</code> counter auth_server_authconfig_duration_seconds Response latency of authconfig enforced by the auth server (in seconds). <code>namespace</code>, <code>authconfig</code> histogram auth_server_response_status Response status of authconfigs sent by the auth server. <code>status=OK|UNAUTHENTICATED,PERMISSION_DENIED|NOT_FOUND</code> counter grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure. <code>grpc_code=OK|Aborted|Canceled|DeadlineExceeded|Internal|ResourceExhausted|Unknown</code>, <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_handling_seconds Response latency (seconds) of gRPC that had been application-level handled by the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> histogram grpc_server_msg_received_total Total number of RPC stream messages received on the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter grpc_server_started_total Total number of RPCs started on the server. <code>grpc_method=Check</code>, <code>grpc_service=envoy.service.auth.v3.Authorization</code> counter http_server_handled_total Total number of calls completed on the raw HTTP authorization server, regardless of success or failure. <code>http_code</code> counter http_server_handling_seconds Response latency (seconds) of raw HTTP authorization request that had been application-level handled by the server. histogram oidc_server_requests_total Number of get requests received on the OIDC (Festival Wristband) server. <code>namespace</code>, <code>authconfig</code>, <code>wristband</code>, <code>path=oidc-config|jwks</code> counter oidc_server_response_status Status of HTTP response sent by the OIDC (Festival Wristband) server. <code>status=200|404</code> counter <p><sup>1</sup> Both endpoints export metrics about the Go runtime, such as number of goroutines (go_goroutines) and threads (go_threads), usage of CPU, memory and GC stats.</p> <p><sup>2</sup> Opt-in metrics: <code>auth_server_evaluator_*</code> metrics require <code>authconfig.spec.(identity|metadata|authorization|response).metrics: true</code> (default: <code>false</code>). This can be enforced for the entire instance (all AuthConfigs and evaluators), by setting the <code>--deep-metrics-enabled</code> command-line flag in the Authorino deployment.</p> Example of metrics exported at the <code>/metrics</code> endpoint <pre><code># HELP controller_runtime_active_workers Number of currently used workers per controller\n# TYPE controller_runtime_active_workers gauge\ncontroller_runtime_active_workers{controller=\"authconfig\"} 0\ncontroller_runtime_active_workers{controller=\"secret\"} 0\n# HELP controller_runtime_max_concurrent_reconciles Maximum number of concurrent reconciles per controller\n# TYPE controller_runtime_max_concurrent_reconciles gauge\ncontroller_runtime_max_concurrent_reconciles{controller=\"authconfig\"} 1\ncontroller_runtime_max_concurrent_reconciles{controller=\"secret\"} 1\n# HELP controller_runtime_reconcile_errors_total Total number of reconciliation errors per controller\n# TYPE controller_runtime_reconcile_errors_total counter\ncontroller_runtime_reconcile_errors_total{controller=\"authconfig\"} 12\ncontroller_runtime_reconcile_errors_total{controller=\"secret\"} 0\n# HELP controller_runtime_reconcile_time_seconds Length of time per reconciliation per controller\n# TYPE controller_runtime_reconcile_time_seconds histogram\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.005\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.01\"} 11\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.025\"} 17\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.05\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.1\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.15\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.2\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.25\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.3\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.35\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.4\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.45\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.6\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.7\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.8\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"0.9\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.25\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"1.75\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"2\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"2.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"3\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"3.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"4\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"4.5\"} 18\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"5\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"6\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"7\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"8\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"9\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"10\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"15\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"20\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"25\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"30\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"40\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"50\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"60\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"authconfig\",le=\"+Inf\"} 19\ncontroller_runtime_reconcile_time_seconds_sum{controller=\"authconfig\"} 5.171108321999999\ncontroller_runtime_reconcile_time_seconds_count{controller=\"authconfig\"} 19\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.005\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.01\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.025\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.05\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.1\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.15\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.2\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.3\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.35\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.4\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.45\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.6\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.7\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.8\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"0.9\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"1.75\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"2\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"2.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"3\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"3.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"4\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"4.5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"5\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"6\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"7\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"8\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"9\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"10\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"15\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"20\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"25\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"30\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"40\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"50\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"60\"} 1\ncontroller_runtime_reconcile_time_seconds_bucket{controller=\"secret\",le=\"+Inf\"} 1\ncontroller_runtime_reconcile_time_seconds_sum{controller=\"secret\"} 0.000138025\ncontroller_runtime_reconcile_time_seconds_count{controller=\"secret\"} 1\n# HELP controller_runtime_reconcile_total Total number of reconciliations per controller\n# TYPE controller_runtime_reconcile_total counter\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"error\"} 12\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"requeue\"} 0\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"requeue_after\"} 0\ncontroller_runtime_reconcile_total{controller=\"authconfig\",result=\"success\"} 7\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"error\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"requeue\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"requeue_after\"} 0\ncontroller_runtime_reconcile_total{controller=\"secret\",result=\"success\"} 1\n# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.\n# TYPE go_gc_cycles_automatic_gc_cycles_total counter\ngo_gc_cycles_automatic_gc_cycles_total 13\n# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.\n# TYPE go_gc_cycles_forced_gc_cycles_total counter\ngo_gc_cycles_forced_gc_cycles_total 0\n# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.\n# TYPE go_gc_cycles_total_gc_cycles_total counter\ngo_gc_cycles_total_gc_cycles_total 13\n# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.5971e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.69e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 0.000140699\ngo_gc_duration_seconds{quantile=\"0.75\"} 0.000313162\ngo_gc_duration_seconds{quantile=\"1\"} 0.001692423\ngo_gc_duration_seconds_sum 0.003671076\ngo_gc_duration_seconds_count 13\n# HELP go_gc_heap_allocs_by_size_bytes_total Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_by_size_bytes_total histogram\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 6357\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 45065\n[...]\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 128306\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"+Inf\"} 128327\ngo_gc_heap_allocs_by_size_bytes_total_sum 1.5021512e+07\ngo_gc_heap_allocs_by_size_bytes_total_count 128327\n# HELP go_gc_heap_allocs_bytes_total Cumulative sum of memory allocated to the heap by the application.\n# TYPE go_gc_heap_allocs_bytes_total counter\ngo_gc_heap_allocs_bytes_total 1.5021512e+07\n# HELP go_gc_heap_allocs_objects_total Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_objects_total counter\ngo_gc_heap_allocs_objects_total 128327\n# HELP go_gc_heap_frees_by_size_bytes_total Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_by_size_bytes_total histogram\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 3885\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 33418\n[...]\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 96417\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"+Inf\"} 96425\ngo_gc_heap_frees_by_size_bytes_total_sum 9.880944e+06\ngo_gc_heap_frees_by_size_bytes_total_count 96425\n# HELP go_gc_heap_frees_bytes_total Cumulative sum of heap memory freed by the garbage collector.\n# TYPE go_gc_heap_frees_bytes_total counter\ngo_gc_heap_frees_bytes_total 9.880944e+06\n# HELP go_gc_heap_frees_objects_total Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_objects_total counter\ngo_gc_heap_frees_objects_total 96425\n# HELP go_gc_heap_goal_bytes Heap size target for the end of the GC cycle.\n# TYPE go_gc_heap_goal_bytes gauge\ngo_gc_heap_goal_bytes 9.356624e+06\n# HELP go_gc_heap_objects_objects Number of objects, live or unswept, occupying heap memory.\n# TYPE go_gc_heap_objects_objects gauge\ngo_gc_heap_objects_objects 31902\n# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size.\n# TYPE go_gc_heap_tiny_allocs_objects_total counter\ngo_gc_heap_tiny_allocs_objects_total 11750\n# HELP go_gc_pauses_seconds_total Distribution individual GC-related stop-the-world pause latencies.\n# TYPE go_gc_pauses_seconds_total histogram\ngo_gc_pauses_seconds_total_bucket{le=\"9.999999999999999e-10\"} 0\ngo_gc_pauses_seconds_total_bucket{le=\"1.9999999999999997e-09\"} 0\n[...]\ngo_gc_pauses_seconds_total_bucket{le=\"206708.18602188796\"} 26\ngo_gc_pauses_seconds_total_bucket{le=\"+Inf\"} 26\ngo_gc_pauses_seconds_total_sum 0.003151488\ngo_gc_pauses_seconds_total_count 26\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 80\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.18.7\"} 1\n# HELP go_memory_classes_heap_free_bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory.\n# TYPE go_memory_classes_heap_free_bytes gauge\ngo_memory_classes_heap_free_bytes 589824\n# HELP go_memory_classes_heap_objects_bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.\n# TYPE go_memory_classes_heap_objects_bytes gauge\ngo_memory_classes_heap_objects_bytes 5.140568e+06\n# HELP go_memory_classes_heap_released_bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory.\n# TYPE go_memory_classes_heap_released_bytes gauge\ngo_memory_classes_heap_released_bytes 4.005888e+06\n# HELP go_memory_classes_heap_stacks_bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.\n# TYPE go_memory_classes_heap_stacks_bytes gauge\ngo_memory_classes_heap_stacks_bytes 786432\n# HELP go_memory_classes_heap_unused_bytes Memory that is reserved for heap objects but is not currently used to hold heap objects.\n# TYPE go_memory_classes_heap_unused_bytes gauge\ngo_memory_classes_heap_unused_bytes 2.0602e+06\n# HELP go_memory_classes_metadata_mcache_free_bytes Memory that is reserved for runtime mcache structures, but not in-use.\n# TYPE go_memory_classes_metadata_mcache_free_bytes gauge\ngo_memory_classes_metadata_mcache_free_bytes 13984\n# HELP go_memory_classes_metadata_mcache_inuse_bytes Memory that is occupied by runtime mcache structures that are currently being used.\n# TYPE go_memory_classes_metadata_mcache_inuse_bytes gauge\ngo_memory_classes_metadata_mcache_inuse_bytes 2400\n# HELP go_memory_classes_metadata_mspan_free_bytes Memory that is reserved for runtime mspan structures, but not in-use.\n# TYPE go_memory_classes_metadata_mspan_free_bytes gauge\ngo_memory_classes_metadata_mspan_free_bytes 17104\n# HELP go_memory_classes_metadata_mspan_inuse_bytes Memory that is occupied by runtime mspan structures that are currently being used.\n# TYPE go_memory_classes_metadata_mspan_inuse_bytes gauge\ngo_memory_classes_metadata_mspan_inuse_bytes 113968\n# HELP go_memory_classes_metadata_other_bytes Memory that is reserved for or used to hold runtime metadata.\n# TYPE go_memory_classes_metadata_other_bytes gauge\ngo_memory_classes_metadata_other_bytes 5.544408e+06\n# HELP go_memory_classes_os_stacks_bytes Stack memory allocated by the underlying operating system.\n# TYPE go_memory_classes_os_stacks_bytes gauge\ngo_memory_classes_os_stacks_bytes 0\n# HELP go_memory_classes_other_bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.\n# TYPE go_memory_classes_other_bytes gauge\ngo_memory_classes_other_bytes 537777\n# HELP go_memory_classes_profiling_buckets_bytes Memory that is used by the stack trace hash map used for profiling.\n# TYPE go_memory_classes_profiling_buckets_bytes gauge\ngo_memory_classes_profiling_buckets_bytes 1.455487e+06\n# HELP go_memory_classes_total_bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.\n# TYPE go_memory_classes_total_bytes gauge\ngo_memory_classes_total_bytes 2.026804e+07\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 5.140568e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 1.5021512e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.455487e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 108175\n# HELP go_memstats_gc_cpu_fraction The fraction of this program's available CPU time used by the GC since the program started.\n# TYPE go_memstats_gc_cpu_fraction gauge\ngo_memstats_gc_cpu_fraction 0\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 5.544408e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 5.140568e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 4.595712e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 7.200768e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 31902\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 4.005888e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.179648e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6461572121033354e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 140077\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 2400\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 16384\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 113968\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 131072\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 9.356624e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 537777\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 786432\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 786432\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.026804e+07\n# HELP go_sched_goroutines_goroutines Count of live goroutines.\n# TYPE go_sched_goroutines_goroutines gauge\ngo_sched_goroutines_goroutines 80\n# HELP go_sched_latencies_seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.\n# TYPE go_sched_latencies_seconds histogram\ngo_sched_latencies_seconds_bucket{le=\"9.999999999999999e-10\"} 244\ngo_sched_latencies_seconds_bucket{le=\"1.9999999999999997e-09\"} 244\n[...]\ngo_sched_latencies_seconds_bucket{le=\"206708.18602188796\"} 2336\ngo_sched_latencies_seconds_bucket{le=\"+Inf\"} 2336\ngo_sched_latencies_seconds_sum 0.18509832400000004\ngo_sched_latencies_seconds_count 2336\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 8\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 1.84\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 1.048576e+06\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 14\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.3728896e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.64615612779e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 7.65362176e+08\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n# HELP rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host.\n# TYPE rest_client_requests_total counter\nrest_client_requests_total{code=\"200\",host=\"10.96.0.1:443\",method=\"GET\"} 114\nrest_client_requests_total{code=\"200\",host=\"10.96.0.1:443\",method=\"PUT\"} 4\n# HELP workqueue_adds_total Total number of adds handled by workqueue\n# TYPE workqueue_adds_total counter\nworkqueue_adds_total{name=\"authconfig\"} 19\nworkqueue_adds_total{name=\"secret\"} 1\n# HELP workqueue_depth Current depth of workqueue\n# TYPE workqueue_depth gauge\nworkqueue_depth{name=\"authconfig\"} 0\nworkqueue_depth{name=\"secret\"} 0\n# HELP workqueue_longest_running_processor_seconds How many seconds has the longest running processor for workqueue been running.\n# TYPE workqueue_longest_running_processor_seconds gauge\nworkqueue_longest_running_processor_seconds{name=\"authconfig\"} 0\nworkqueue_longest_running_processor_seconds{name=\"secret\"} 0\n# HELP workqueue_queue_duration_seconds How long in seconds an item stays in workqueue before being requested\n# TYPE workqueue_queue_duration_seconds histogram\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-08\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-07\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1e-06\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-06\"} 8\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-05\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.001\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.01\"} 17\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"0.1\"} 18\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"1\"} 18\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"10\"} 19\nworkqueue_queue_duration_seconds_bucket{name=\"authconfig\",le=\"+Inf\"} 19\nworkqueue_queue_duration_seconds_sum{name=\"authconfig\"} 4.969016371\nworkqueue_queue_duration_seconds_count{name=\"authconfig\"} 19\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-08\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-07\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1e-06\"} 0\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-06\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-05\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.001\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.01\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"0.1\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"1\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"10\"} 1\nworkqueue_queue_duration_seconds_bucket{name=\"secret\",le=\"+Inf\"} 1\nworkqueue_queue_duration_seconds_sum{name=\"secret\"} 4.67e-06\nworkqueue_queue_duration_seconds_count{name=\"secret\"} 1\n# HELP workqueue_retries_total Total number of retries handled by workqueue\n# TYPE workqueue_retries_total counter\nworkqueue_retries_total{name=\"authconfig\"} 12\nworkqueue_retries_total{name=\"secret\"} 0\n# HELP workqueue_unfinished_work_seconds How many seconds of work has been done that is in progress and hasn't been observed by work_duration. Large values indicate stuck threads. One can deduce the number of stuck threads by observing the rate at which this increases.\n# TYPE workqueue_unfinished_work_seconds gauge\nworkqueue_unfinished_work_seconds{name=\"authconfig\"} 0\nworkqueue_unfinished_work_seconds{name=\"secret\"} 0\n# HELP workqueue_work_duration_seconds How long in seconds processing an item from workqueue takes.\n# TYPE workqueue_work_duration_seconds histogram\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-08\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-07\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"9.999999999999999e-05\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.001\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.01\"} 11\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"0.1\"} 18\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"1\"} 18\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"10\"} 19\nworkqueue_work_duration_seconds_bucket{name=\"authconfig\",le=\"+Inf\"} 19\nworkqueue_work_duration_seconds_sum{name=\"authconfig\"} 5.171738079000001\nworkqueue_work_duration_seconds_count{name=\"authconfig\"} 19\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-08\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-07\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-06\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"9.999999999999999e-05\"} 0\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.001\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.01\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"0.1\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"1\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"10\"} 1\nworkqueue_work_duration_seconds_bucket{name=\"secret\",le=\"+Inf\"} 1\nworkqueue_work_duration_seconds_sum{name=\"secret\"} 0.000150956\nworkqueue_work_duration_seconds_count{name=\"secret\"} 1\n</code></pre> Example of metrics exported at the <code>/server-metrics</code> endpoint <pre><code># HELP auth_server_authconfig_duration_seconds Response latency of authconfig enforced by the auth server (in seconds).\n# TYPE auth_server_authconfig_duration_seconds histogram\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.001\"} 0\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.051000000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.101\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.15100000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.201\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.251\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.301\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.351\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.40099999999999997\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.45099999999999996\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.501\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.551\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.6010000000000001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.6510000000000001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.7010000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.7510000000000002\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.8010000000000003\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.8510000000000003\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.9010000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"0.9510000000000004\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"edge-auth\",namespace=\"authorino\",le=\"+Inf\"} 1\nauth_server_authconfig_duration_seconds_sum{authconfig=\"edge-auth\",namespace=\"authorino\"} 0.001701795\nauth_server_authconfig_duration_seconds_count{authconfig=\"edge-auth\",namespace=\"authorino\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.001\"} 1\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.051000000000000004\"} 4\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.101\"} 4\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.15100000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.201\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.251\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.301\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.351\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.40099999999999997\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.45099999999999996\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.501\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.551\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.6010000000000001\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.6510000000000001\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.7010000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.7510000000000002\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.8010000000000003\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.8510000000000003\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.9010000000000004\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"0.9510000000000004\"} 5\nauth_server_authconfig_duration_seconds_bucket{authconfig=\"talker-api-protection\",namespace=\"authorino\",le=\"+Inf\"} 5\nauth_server_authconfig_duration_seconds_sum{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 0.26967658299999997\nauth_server_authconfig_duration_seconds_count{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 5\n# HELP auth_server_authconfig_response_status Response status of authconfigs sent by the auth server, partitioned by authconfig.\n# TYPE auth_server_authconfig_response_status counter\nauth_server_authconfig_response_status{authconfig=\"edge-auth\",namespace=\"authorino\",status=\"OK\"} 1\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"OK\"} 2\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"PERMISSION_DENIED\"} 2\nauth_server_authconfig_response_status{authconfig=\"talker-api-protection\",namespace=\"authorino\",status=\"UNAUTHENTICATED\"} 1\n# HELP auth_server_authconfig_total Total number of authconfigs enforced by the auth server, partitioned by authconfig.\n# TYPE auth_server_authconfig_total counter\nauth_server_authconfig_total{authconfig=\"edge-auth\",namespace=\"authorino\"} 1\nauth_server_authconfig_total{authconfig=\"talker-api-protection\",namespace=\"authorino\"} 5\n# HELP auth_server_evaluator_duration_seconds Response latency of individual authconfig rule evaluated by the auth server (in seconds).\n# TYPE auth_server_evaluator_duration_seconds histogram\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.001\"} 0\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.051000000000000004\"} 3\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.101\"} 3\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.15100000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.201\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.251\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.301\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.351\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.40099999999999997\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.45099999999999996\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.501\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.551\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.6010000000000001\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.6510000000000001\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.7010000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.7510000000000002\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.8010000000000003\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.8510000000000003\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.9010000000000004\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"0.9510000000000004\"} 4\nauth_server_evaluator_duration_seconds_bucket{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\",le=\"+Inf\"} 4\nauth_server_evaluator_duration_seconds_sum{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 0.25800055\nauth_server_evaluator_duration_seconds_count{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 4\n# HELP auth_server_evaluator_total Total number of evaluations of individual authconfig rule performed by the auth server.\n# TYPE auth_server_evaluator_total counter\nauth_server_evaluator_total{authconfig=\"talker-api-protection\",evaluator_name=\"geo\",evaluator_type=\"METADATA_GENERIC_HTTP\",namespace=\"authorino\"} 4\n# HELP auth_server_response_status Response status of authconfigs sent by the auth server.\n# TYPE auth_server_response_status counter\nauth_server_response_status{status=\"NOT_FOUND\"} 1\nauth_server_response_status{status=\"OK\"} 3\nauth_server_response_status{status=\"PERMISSION_DENIED\"} 2\nauth_server_response_status{status=\"UNAUTHENTICATED\"} 1\n# HELP go_gc_cycles_automatic_gc_cycles_total Count of completed GC cycles generated by the Go runtime.\n# TYPE go_gc_cycles_automatic_gc_cycles_total counter\ngo_gc_cycles_automatic_gc_cycles_total 11\n# HELP go_gc_cycles_forced_gc_cycles_total Count of completed GC cycles forced by the application.\n# TYPE go_gc_cycles_forced_gc_cycles_total counter\ngo_gc_cycles_forced_gc_cycles_total 0\n# HELP go_gc_cycles_total_gc_cycles_total Count of all completed GC cycles.\n# TYPE go_gc_cycles_total_gc_cycles_total counter\ngo_gc_cycles_total_gc_cycles_total 11\n# HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.\n# TYPE go_gc_duration_seconds summary\ngo_gc_duration_seconds{quantile=\"0\"} 4.5971e-05\ngo_gc_duration_seconds{quantile=\"0.25\"} 5.69e-05\ngo_gc_duration_seconds{quantile=\"0.5\"} 0.000158594\ngo_gc_duration_seconds{quantile=\"0.75\"} 0.000324091\ngo_gc_duration_seconds{quantile=\"1\"} 0.001692423\ngo_gc_duration_seconds_sum 0.003546711\ngo_gc_duration_seconds_count 11\n# HELP go_gc_heap_allocs_by_size_bytes_total Distribution of heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_by_size_bytes_total histogram\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 6261\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 42477\n[...]\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 122133\ngo_gc_heap_allocs_by_size_bytes_total_bucket{le=\"+Inf\"} 122154\ngo_gc_heap_allocs_by_size_bytes_total_sum 1.455944e+07\ngo_gc_heap_allocs_by_size_bytes_total_count 122154\n# HELP go_gc_heap_allocs_bytes_total Cumulative sum of memory allocated to the heap by the application.\n# TYPE go_gc_heap_allocs_bytes_total counter\ngo_gc_heap_allocs_bytes_total 1.455944e+07\n# HELP go_gc_heap_allocs_objects_total Cumulative count of heap allocations triggered by the application. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_allocs_objects_total counter\ngo_gc_heap_allocs_objects_total 122154\n# HELP go_gc_heap_frees_by_size_bytes_total Distribution of freed heap allocations by approximate size. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_by_size_bytes_total histogram\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"8.999999999999998\"} 3789\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"16.999999999999996\"} 31067\n[...]\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"32768.99999999999\"} 91013\ngo_gc_heap_frees_by_size_bytes_total_bucket{le=\"+Inf\"} 91021\ngo_gc_heap_frees_by_size_bytes_total_sum 9.399936e+06\ngo_gc_heap_frees_by_size_bytes_total_count 91021\n# HELP go_gc_heap_frees_bytes_total Cumulative sum of heap memory freed by the garbage collector.\n# TYPE go_gc_heap_frees_bytes_total counter\ngo_gc_heap_frees_bytes_total 9.399936e+06\n# HELP go_gc_heap_frees_objects_total Cumulative count of heap allocations whose storage was freed by the garbage collector. Note that this does not include tiny objects as defined by /gc/heap/tiny/allocs:objects, only tiny blocks.\n# TYPE go_gc_heap_frees_objects_total counter\ngo_gc_heap_frees_objects_total 91021\n# HELP go_gc_heap_goal_bytes Heap size target for the end of the GC cycle.\n# TYPE go_gc_heap_goal_bytes gauge\ngo_gc_heap_goal_bytes 9.601744e+06\n# HELP go_gc_heap_objects_objects Number of objects, live or unswept, occupying heap memory.\n# TYPE go_gc_heap_objects_objects gauge\ngo_gc_heap_objects_objects 31133\n# HELP go_gc_heap_tiny_allocs_objects_total Count of small allocations that are packed together into blocks. These allocations are counted separately from other allocations because each individual allocation is not tracked by the runtime, only their block. Each block is already accounted for in allocs-by-size and frees-by-size.\n# TYPE go_gc_heap_tiny_allocs_objects_total counter\ngo_gc_heap_tiny_allocs_objects_total 9866\n# HELP go_gc_pauses_seconds_total Distribution individual GC-related stop-the-world pause latencies.\n# TYPE go_gc_pauses_seconds_total histogram\ngo_gc_pauses_seconds_total_bucket{le=\"9.999999999999999e-10\"} 0\ngo_gc_pauses_seconds_total_bucket{le=\"1.9999999999999997e-09\"} 0\n[...]\ngo_gc_pauses_seconds_total_bucket{le=\"206708.18602188796\"} 22\ngo_gc_pauses_seconds_total_bucket{le=\"+Inf\"} 22\ngo_gc_pauses_seconds_total_sum 0.0030393599999999996\ngo_gc_pauses_seconds_total_count 22\n# HELP go_goroutines Number of goroutines that currently exist.\n# TYPE go_goroutines gauge\ngo_goroutines 79\n# HELP go_info Information about the Go environment.\n# TYPE go_info gauge\ngo_info{version=\"go1.18.7\"} 1\n# HELP go_memory_classes_heap_free_bytes Memory that is completely free and eligible to be returned to the underlying system, but has not been. This metric is the runtime's estimate of free address space that is backed by physical memory.\n# TYPE go_memory_classes_heap_free_bytes gauge\ngo_memory_classes_heap_free_bytes 630784\n# HELP go_memory_classes_heap_objects_bytes Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.\n# TYPE go_memory_classes_heap_objects_bytes gauge\ngo_memory_classes_heap_objects_bytes 5.159504e+06\n# HELP go_memory_classes_heap_released_bytes Memory that is completely free and has been returned to the underlying system. This metric is the runtime's estimate of free address space that is still mapped into the process, but is not backed by physical memory.\n# TYPE go_memory_classes_heap_released_bytes gauge\ngo_memory_classes_heap_released_bytes 3.858432e+06\n# HELP go_memory_classes_heap_stacks_bytes Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.\n# TYPE go_memory_classes_heap_stacks_bytes gauge\ngo_memory_classes_heap_stacks_bytes 786432\n# HELP go_memory_classes_heap_unused_bytes Memory that is reserved for heap objects but is not currently used to hold heap objects.\n# TYPE go_memory_classes_heap_unused_bytes gauge\ngo_memory_classes_heap_unused_bytes 2.14776e+06\n# HELP go_memory_classes_metadata_mcache_free_bytes Memory that is reserved for runtime mcache structures, but not in-use.\n# TYPE go_memory_classes_metadata_mcache_free_bytes gauge\ngo_memory_classes_metadata_mcache_free_bytes 13984\n# HELP go_memory_classes_metadata_mcache_inuse_bytes Memory that is occupied by runtime mcache structures that are currently being used.\n# TYPE go_memory_classes_metadata_mcache_inuse_bytes gauge\ngo_memory_classes_metadata_mcache_inuse_bytes 2400\n# HELP go_memory_classes_metadata_mspan_free_bytes Memory that is reserved for runtime mspan structures, but not in-use.\n# TYPE go_memory_classes_metadata_mspan_free_bytes gauge\ngo_memory_classes_metadata_mspan_free_bytes 16696\n# HELP go_memory_classes_metadata_mspan_inuse_bytes Memory that is occupied by runtime mspan structures that are currently being used.\n# TYPE go_memory_classes_metadata_mspan_inuse_bytes gauge\ngo_memory_classes_metadata_mspan_inuse_bytes 114376\n# HELP go_memory_classes_metadata_other_bytes Memory that is reserved for or used to hold runtime metadata.\n# TYPE go_memory_classes_metadata_other_bytes gauge\ngo_memory_classes_metadata_other_bytes 5.544408e+06\n# HELP go_memory_classes_os_stacks_bytes Stack memory allocated by the underlying operating system.\n# TYPE go_memory_classes_os_stacks_bytes gauge\ngo_memory_classes_os_stacks_bytes 0\n# HELP go_memory_classes_other_bytes Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.\n# TYPE go_memory_classes_other_bytes gauge\ngo_memory_classes_other_bytes 537777\n# HELP go_memory_classes_profiling_buckets_bytes Memory that is used by the stack trace hash map used for profiling.\n# TYPE go_memory_classes_profiling_buckets_bytes gauge\ngo_memory_classes_profiling_buckets_bytes 1.455487e+06\n# HELP go_memory_classes_total_bytes All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.\n# TYPE go_memory_classes_total_bytes gauge\ngo_memory_classes_total_bytes 2.026804e+07\n# HELP go_memstats_alloc_bytes Number of bytes allocated and still in use.\n# TYPE go_memstats_alloc_bytes gauge\ngo_memstats_alloc_bytes 5.159504e+06\n# HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even if freed.\n# TYPE go_memstats_alloc_bytes_total counter\ngo_memstats_alloc_bytes_total 1.455944e+07\n# HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket hash table.\n# TYPE go_memstats_buck_hash_sys_bytes gauge\ngo_memstats_buck_hash_sys_bytes 1.455487e+06\n# HELP go_memstats_frees_total Total number of frees.\n# TYPE go_memstats_frees_total counter\ngo_memstats_frees_total 100887\n# HELP go_memstats_gc_cpu_fraction The fraction of this program's available CPU time used by the GC since the program started.\n# TYPE go_memstats_gc_cpu_fraction gauge\ngo_memstats_gc_cpu_fraction 0\n# HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.\n# TYPE go_memstats_gc_sys_bytes gauge\ngo_memstats_gc_sys_bytes 5.544408e+06\n# HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.\n# TYPE go_memstats_heap_alloc_bytes gauge\ngo_memstats_heap_alloc_bytes 5.159504e+06\n# HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.\n# TYPE go_memstats_heap_idle_bytes gauge\ngo_memstats_heap_idle_bytes 4.489216e+06\n# HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.\n# TYPE go_memstats_heap_inuse_bytes gauge\ngo_memstats_heap_inuse_bytes 7.307264e+06\n# HELP go_memstats_heap_objects Number of allocated objects.\n# TYPE go_memstats_heap_objects gauge\ngo_memstats_heap_objects 31133\n# HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.\n# TYPE go_memstats_heap_released_bytes gauge\ngo_memstats_heap_released_bytes 3.858432e+06\n# HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.\n# TYPE go_memstats_heap_sys_bytes gauge\ngo_memstats_heap_sys_bytes 1.179648e+07\n# HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.\n# TYPE go_memstats_last_gc_time_seconds gauge\ngo_memstats_last_gc_time_seconds 1.6461569717723043e+09\n# HELP go_memstats_lookups_total Total number of pointer lookups.\n# TYPE go_memstats_lookups_total counter\ngo_memstats_lookups_total 0\n# HELP go_memstats_mallocs_total Total number of mallocs.\n# TYPE go_memstats_mallocs_total counter\ngo_memstats_mallocs_total 132020\n# HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.\n# TYPE go_memstats_mcache_inuse_bytes gauge\ngo_memstats_mcache_inuse_bytes 2400\n# HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.\n# TYPE go_memstats_mcache_sys_bytes gauge\ngo_memstats_mcache_sys_bytes 16384\n# HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.\n# TYPE go_memstats_mspan_inuse_bytes gauge\ngo_memstats_mspan_inuse_bytes 114376\n# HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.\n# TYPE go_memstats_mspan_sys_bytes gauge\ngo_memstats_mspan_sys_bytes 131072\n# HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.\n# TYPE go_memstats_next_gc_bytes gauge\ngo_memstats_next_gc_bytes 9.601744e+06\n# HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.\n# TYPE go_memstats_other_sys_bytes gauge\ngo_memstats_other_sys_bytes 537777\n# HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.\n# TYPE go_memstats_stack_inuse_bytes gauge\ngo_memstats_stack_inuse_bytes 786432\n# HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.\n# TYPE go_memstats_stack_sys_bytes gauge\ngo_memstats_stack_sys_bytes 786432\n# HELP go_memstats_sys_bytes Number of bytes obtained from system.\n# TYPE go_memstats_sys_bytes gauge\ngo_memstats_sys_bytes 2.026804e+07\n# HELP go_sched_goroutines_goroutines Count of live goroutines.\n# TYPE go_sched_goroutines_goroutines gauge\ngo_sched_goroutines_goroutines 79\n# HELP go_sched_latencies_seconds Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.\n# TYPE go_sched_latencies_seconds histogram\ngo_sched_latencies_seconds_bucket{le=\"9.999999999999999e-10\"} 225\ngo_sched_latencies_seconds_bucket{le=\"1.9999999999999997e-09\"} 225\n[...]\ngo_sched_latencies_seconds_bucket{le=\"206708.18602188796\"} 1916\ngo_sched_latencies_seconds_bucket{le=\"+Inf\"} 1916\ngo_sched_latencies_seconds_sum 0.18081453600000003\ngo_sched_latencies_seconds_count 1916\n# HELP go_threads Number of OS threads created.\n# TYPE go_threads gauge\ngo_threads 8\n# HELP grpc_server_handled_total Total number of RPCs completed on the server, regardless of success or failure.\n# TYPE grpc_server_handled_total counter\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Aborted\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"AlreadyExists\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Canceled\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DataLoss\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"DeadlineExceeded\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"FailedPrecondition\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Internal\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"InvalidArgument\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"NotFound\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OK\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"OutOfRange\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"PermissionDenied\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"ResourceExhausted\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unauthenticated\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unavailable\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unimplemented\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_handled_total{grpc_code=\"Unknown\",grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_handling_seconds Histogram of response latency (seconds) of gRPC that had been application-level handled by the server.\n# TYPE grpc_server_handling_seconds histogram\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.005\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.01\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.025\"} 3\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.05\"} 6\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.1\"} 6\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.25\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"0.5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"1\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"2.5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"5\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"10\"} 7\ngrpc_server_handling_seconds_bucket{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\",le=\"+Inf\"} 7\ngrpc_server_handling_seconds_sum{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 0.277605516\ngrpc_server_handling_seconds_count{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\n# HELP grpc_server_msg_received_total Total number of RPC stream messages received on the server.\n# TYPE grpc_server_msg_received_total counter\ngrpc_server_msg_received_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_msg_received_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_msg_received_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_msg_sent_total Total number of gRPC stream messages sent by the server.\n# TYPE grpc_server_msg_sent_total counter\ngrpc_server_msg_sent_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_msg_sent_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_msg_sent_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP grpc_server_started_total Total number of RPCs started on the server.\n# TYPE grpc_server_started_total counter\ngrpc_server_started_total{grpc_method=\"Check\",grpc_service=\"envoy.service.auth.v3.Authorization\",grpc_type=\"unary\"} 7\ngrpc_server_started_total{grpc_method=\"Check\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"unary\"} 0\ngrpc_server_started_total{grpc_method=\"Watch\",grpc_service=\"grpc.health.v1.Health\",grpc_type=\"server_stream\"} 0\n# HELP oidc_server_requests_total Number of get requests received on the OIDC (Festival Wristband) server.\n# TYPE oidc_server_requests_total counter\noidc_server_requests_total{authconfig=\"edge-auth\",namespace=\"authorino\",path=\"/.well-known/openid-configuration\",wristband=\"wristband\"} 1\noidc_server_requests_total{authconfig=\"edge-auth\",namespace=\"authorino\",path=\"/.well-known/openid-connect/certs\",wristband=\"wristband\"} 1\n# HELP oidc_server_response_status Status of HTTP response sent by the OIDC (Festival Wristband) server.\n# TYPE oidc_server_response_status counter\noidc_server_response_status{status=\"200\"} 2\n# HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.\n# TYPE process_cpu_seconds_total counter\nprocess_cpu_seconds_total 1.42\n# HELP process_max_fds Maximum number of open file descriptors.\n# TYPE process_max_fds gauge\nprocess_max_fds 1.048576e+06\n# HELP process_open_fds Number of open file descriptors.\n# TYPE process_open_fds gauge\nprocess_open_fds 14\n# HELP process_resident_memory_bytes Resident memory size in bytes.\n# TYPE process_resident_memory_bytes gauge\nprocess_resident_memory_bytes 4.370432e+07\n# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n# TYPE process_start_time_seconds gauge\nprocess_start_time_seconds 1.64615612779e+09\n# HELP process_virtual_memory_bytes Virtual memory size in bytes.\n# TYPE process_virtual_memory_bytes gauge\nprocess_virtual_memory_bytes 7.65362176e+08\n# HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.\n# TYPE process_virtual_memory_max_bytes gauge\nprocess_virtual_memory_max_bytes 1.8446744073709552e+19\n# HELP promhttp_metric_handler_requests_in_flight Current number of scrapes being served.\n# TYPE promhttp_metric_handler_requests_in_flight gauge\npromhttp_metric_handler_requests_in_flight 1\n# HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.\n# TYPE promhttp_metric_handler_requests_total counter\npromhttp_metric_handler_requests_total{code=\"200\"} 1\npromhttp_metric_handler_requests_total{code=\"500\"} 0\npromhttp_metric_handler_requests_total{code=\"503\"} 0\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#readiness-check","title":"Readiness check","text":"<p>Authorino exposes two main endpoints for health and readiness check of the AuthConfig controller:</p> <ul> <li><code>/healthz</code>: Health probe (ping) \u2013 reports \"ok\" if the controller is healthy.</li> <li><code>/readyz</code>: Readiness probe \u2013 reports \"ok\" if the controller is ready to reconcile AuthConfig-related events.</li> </ul> <p>In general, the endpoints return either <code>200</code> (\"ok\", i.e. all checks have passed) or <code>500</code> (when one or more checks failed).</p> <p>The default binding network address is <code>:8081</code>, which can be changed by setting the command-line flag <code>--health-probe-addr</code>.</p> <p>The following additional subpath is available and its corresponding check can be aggregated into the response from the main readiness probe:</p> <ul> <li><code>/readyz/authconfigs</code>: Aggregated readiness status of the AuthConfigs \u2013 reports \"ok\" if all AuthConfigs watched by the reconciler have been marked as ready.</li> </ul> Important!The AuthConfig readiness check within the scope of the aggregated readiness probe endpoint is deactivated by default \u2013 i.e. this check is an opt-in check. Sending a request to the <code>/readyz</code> endpoint without explicitly opting-in for the AuthConfigs check, by using the <code>include</code> parameter, will result in a response message that disregards the actual status of the watched AuthConfigs, possibly an \"ok\" message. To read the aggregated status of the watched AuthConfigs, either use the specific endpoint <code>/readyz/authconfigs</code> or opt-in for the check in the aggregated endpoint by sending a request to <code>/readyz?include=authconfigs</code> <p>Apart from <code>include</code> to add the aggregated status of the AuthConfigs, the following additional query string parameters are available:</p> <ul> <li><code>verbose=true|false</code> - provides more verbose response messages;</li> <li><code>exclude=(check name)</code> \u2013 to exclude a particular readiness check (for future usage).</li> </ul>"},{"location":"authorino/docs/user-guides/observability/#logging","title":"Logging","text":"<p>Authorino provides structured log messages (\"production\") or more log messages output to stdout in a more user-friendly format (\"development\" mode) and different level of logging.</p>"},{"location":"authorino/docs/user-guides/observability/#log-levels-and-log-modes","title":"Log levels and log modes","text":"<p>Authorino outputs 3 levels of log messages: (from lowest to highest level)</p> <ol> <li><code>debug</code></li> <li><code>info</code> (default)</li> <li><code>error</code></li> </ol> <p><code>info</code> logging is restricted to high-level information of the gRPC and HTTP authorization services, limiting messages to incoming request and respective outgoing response logs, with reduced details about the corresponding objects (request payload and authorization result), and without any further detailed logs of the steps in between, except for errors.</p> <p>Only <code>debug</code> logging will include processing details of each Auth Pipeline, such as intermediary requests to validate identities with external auth servers, requests to external sources of auth metadata or authorization policies.</p> <p>To configure the desired log level, set the <code>spec.logLevel</code> field of the <code>Authorino</code> custom resource (or <code>--log-level</code> command-line flag in the Authorino deployment), to one of the supported values listed above. Default log level is <code>info</code>.</p> <p>Apart from log level, Authorino can output messages to the logs in 2 different formats:</p> <ul> <li><code>production</code> (default): each line is a parseable JSON object with properties <code>{\"level\":string, \"ts\":int, \"msg\":string, \"logger\":string, extra values...}</code></li> <li><code>development</code>: more human-readable outputs, extra stack traces and logging info, plus extra values output as JSON, in the format: <code>&lt;timestamp-iso-8601&gt;\\t&lt;log-level&gt;\\t&lt;logger&gt;\\t&lt;message&gt;\\t{extra-values-as-json}</code></li> </ul> <p>To configure the desired log mode, set the <code>spec.logMode</code> field of the <code>Authorino</code> custom resource (or <code>--log-mode</code> command-line flag in the Authorino deployment), to one of the supported values listed above. Default log level is <code>production</code>.</p> <p>Example of <code>Authorino</code> custom resource with log level <code>debug</code> and log mode <code>production</code>:</p> <pre><code>apiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  logLevel: debug\n  logMode: production\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#sensitive-data-output-to-the-logs","title":"Sensitive data output to the logs","text":"<p>Authorino will never output HTTP headers and query string parameters to <code>info</code> log messages, as such values usually include sensitive data (e.g. access tokens, API keys and Authorino Festival Wristbands). However, <code>debug</code> log messages may include such sensitive information and those are not redacted.</p> <p>Therefore, DO NOT USE <code>debug</code> LOG LEVEL IN PRODUCTION! Instead, use either <code>info</code> or <code>error</code>.</p>"},{"location":"authorino/docs/user-guides/observability/#log-messages-printed-by-authorino","title":"Log messages printed by Authorino","text":"<p>Some log messages printed by Authorino and corresponding extra values included:</p> logger level message extra values <code>authorino</code> <code>info</code> \"setting instance base logger\" <code>min level=info\\|debug</code>, <code>mode=production\\|development</code> <code>authorino</code> <code>info</code> \"booting up authorino\" <code>version</code> <code>authorino</code> <code>debug</code> \"setting up with options\" <code>auth-config-label-selector</code>, <code>deep-metrics-enabled</code>, <code>enable-leader-election</code>, <code>evaluator-cache-size</code>, <code>ext-auth-grpc-port</code>, <code>ext-auth-http-port</code>, <code>health-probe-addr</code>, <code>log-level</code>, <code>log-mode</code>, <code>max-http-request-body-size</code>, <code>metrics-addr</code>, <code>oidc-http-port</code>, <code>oidc-tls-cert</code>, <code>oidc-tls-cert-key</code>, <code>secret-label-selector</code>, <code>timeout</code>, <code>tls-cert</code>, <code>tls-cert-key</code>, <code>watch-namespace</code> <code>authorino</code> <code>info</code> \"attempting to acquire leader lease &lt;namespace&gt;/cb88a58a.authorino.kuadrant.io...\\n\" <code>authorino</code> <code>info</code> \"successfully acquired lease &lt;namespace&gt;/cb88a58a.authorino.kuadrant.io\\n\" <code>authorino</code> <code>info</code> \"disabling grpc auth service\" <code>authorino</code> <code>info</code> \"starting grpc auth service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the grpc auth service\" <code>authorino</code> <code>error</code> \"failed to load tls cert for the grpc auth\" <code>authorino</code> <code>error</code> \"failed to start grpc auth service\" <code>authorino</code> <code>info</code> \"disabling http auth service\" <code>authorino</code> <code>info</code> \"starting http auth service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the http auth service\" <code>authorino</code> <code>error</code> \"failed to start http auth service\" <code>authorino</code> <code>info</code> \"disabling http oidc service\" <code>authorino</code> <code>info</code> \"starting http oidc service\" <code>port</code>, <code>tls</code> <code>authorino</code> <code>error</code> \"failed to obtain port for the http oidc service\" <code>authorino</code> <code>error</code> \"failed to start http oidc service\" <code>authorino</code> <code>info</code> \"starting manager\" <code>authorino</code> <code>error</code> \"unable to start manager\" <code>authorino</code> <code>error</code> \"unable to create controller\" <code>controller=authconfig\\|secret\\|authconfigstatusupdate</code> <code>authorino</code> <code>error</code> \"problem running manager\" <code>authorino</code> <code>info</code> \"starting status update manager\" <code>authorino</code> <code>error</code> \"unable to start status update manager\" <code>authorino</code> <code>error</code> \"problem running status update manager\" <code>authorino.controller-runtime.metrics</code> <code>info</code> \"metrics server is starting to listen\" <code>addr</code> <code>authorino.controller-runtime.manager</code> <code>info</code> \"starting metrics server\" <code>path</code> <code>authorino.controller-runtime.manager.events</code> <code>debug</code> \"Normal\" <code>object={kind=ConfigMap, apiVersion=v1}</code>, <code>reauthorino.ason=LeaderElection</code>, <code>message=\"authorino-controller-manager-* became leader\"</code> <code>authorino.controller-runtime.manager.events</code> <code>debug</code> \"Normal\" <code>object={kind=Lease, apiVersion=coordination.k8s.io/v1}</code>, <code>reauthorino.ason=LeaderElection</code>, <code>message=\"authorino-controller-manager-* became leader\"</code> <code>authorino.controller-runtime.manager.controller.authconfig</code> <code>info</code> \"resource reconciled\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig</code> <code>info</code> \"host already taken\" <code>authconfig</code>, <code>host</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>debug</code> \"resource status did not change\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>debug</code> \"resource status changed\" <code>authconfig</code>, <code>authconfig/status</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>error</code> \"failed to update the resource\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.authconfig.statusupdater</code> <code>info</code> \"resource status updated\" <code>authconfig</code> <code>authorino.controller-runtime.manager.controller.secret</code> <code>info</code> \"resource reconciled\" <code>authorino.controller-runtime.manager.controller.secret</code> <code>info</code> \"could not reconcile authconfigs using api key authorino.authentication\" <code>authorino.service.oidc</code> <code>info</code> \"request received\" <code>request id</code>, <code>url</code>, <code>realm</code>, <code>config</code>, <code>path</code> <code>authorino.service.oidc</code> <code>info</code> \"response sent\" <code>request id</code> <code>authorino.service.oidc</code> <code>error</code> \"failed to serve oidc request\" <code>authorino.service.auth</code> <code>info</code> \"incoming authorization request\" <code>request id</code>, <code>object</code> <code>authorino.service.auth</code> <code>debug</code> \"incoming authorization request\" <code>request id</code>, <code>object</code> <code>authorino.service.auth</code> <code>info</code> \"outgoing authorization response\" <code>request id</code>, <code>authorized</code>, <code>response</code>, <code>object</code> <code>authorino.service.auth</code> <code>debug</code> \"outgoing authorization response\" <code>request id</code>, <code>authorized</code>, <code>response</code>, <code>object</code> <code>authorino.service.auth</code> <code>error</code> \"failed to create dynamic metadata\" <code>request id</code>, <code>object</code> <code>authorino.service.auth.authpipeline</code> <code>debug</code> \"skipping config\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity</code> <code>debug</code> \"identity validated\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.identity</code> <code>debug</code> \"cannot validate identity\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity</code> <code>error</code> \"failed to extend identity object\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>error</code> \"failed to discovery openid connect configuration\" <code>endpoint</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>debug</code> \"auto-refresh of openid connect configuration disabled\" <code>endpoint</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.identity.oidc</code> <code>debug</code> \"openid connect configuration updated\" <code>endpoint</code> <code>authorino.service.auth.authpipeline.identity.oauth2</code> <code>debug</code> \"sending token introspection request\" <code>request id</code>, <code>url</code>, <code>data</code> <code>authorino.service.auth.authpipeline.identity.kubernetesauth</code> <code>debug</code> \"calling kubernetes token review api\" <code>request id</code>, <code>tokenreview</code> <code>authorino.service.auth.authpipeline.identity.apikey</code> <code>error</code> \"Something went wrong fetching the authorized credentials\" <code>authorino.service.auth.authpipeline.metadata</code> <code>debug</code> \"fetched auth metadata\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.metadata</code> <code>debug</code> \"cannot fetch metadata\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.metadata.http</code> <code>debug</code> \"sending request\" <code>request id</code>, <code>method</code>, <code>url</code>, <code>headers</code> <code>authorino.service.auth.authpipeline.metadata.userinfo</code> <code>debug</code> \"fetching user info\" <code>request id</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"requesting pat\" <code>request id</code>, <code>url</code>, <code>data</code>, <code>headers</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"querying resources by uri\" <code>request id</code>, <code>url</code> <code>authorino.service.auth.authpipeline.metadata.uma</code> <code>debug</code> \"getting resource data\" <code>request id</code>, <code>url</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"evaluating for input\" <code>request id</code>, <code>input</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"access granted\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.authorization</code> <code>debug</code> \"access denied\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"invalid response from policy evaluation\" <code>policy</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to precompile policy\" <code>policy</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to download policy from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>error</code> \"failed to refresh policy from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>debug</code> \"external policy unchanged\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>debug</code> \"auto-refresh  of external policy disabled\" <code>policy</code>, <code>endpoint</code>, <code>reason</code> <code>authorino.service.auth.authpipeline.authorization.opa</code> <code>info</code> \"policy updated from external registry\" <code>policy</code>, <code>endpoint</code> <code>authorino.service.auth.authpipeline.authorization.kubernetesauthz</code> <code>debug</code> \"calling kubernetes subject access review api\" <code>request id</code>, <code>subjectaccessreview</code> <code>authorino.service.auth.authpipeline.response</code> <code>debug</code> \"dynamic response built\" <code>request id</code>, <code>config</code>, <code>object</code> <code>authorino.service.auth.authpipeline.response</code> <code>debug</code> \"cannot build dynamic response\" <code>request id</code>, <code>config</code>, <code>reason</code> <code>authorino.service.auth.http</code> <code>debug</code> \"bad request\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"not found\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"request body too large\" <code>request id</code> <code>authorino.service.auth.http</code> <code>debug</code> \"service unavailable\" <code>request id</code>"},{"location":"authorino/docs/user-guides/observability/#examples","title":"Examples","text":"<p>The examples below are all with <code>--log-level=debug</code> and <code>--log-mode=production</code>.</p> Booting up the service <pre><code>{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"setting instance base logger\",\"min level\":\"info\",\"mode\":\"production\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"build information\",\"version\":\"v1beta3\",\"commit\":\"ae2dc8150af2e6cdb35957ba7305c4c2a76d6149\",\"dirty\":\"false\",\"cmd\":\"server\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting http auth service\",\"port\":5001,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting grpc auth service\",\"port\":50051,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting http oidc service\",\"port\":8083,\"tls\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting reconciliation manager\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting server\",\"kind\":\"health probe\",\"addr\":\"[::]:8081\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino.controller-runtime.metrics\",\"msg\":\"Starting metrics server\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino.controller-runtime.metrics\",\"msg\":\"Serving metrics server\",\"bindAddress\":\":8080\",\"secure\":false}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"source\":\"kind source: *v1beta3.AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\",\"source\":\"kind source: *v1.Secret\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"starting status update manager\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting EventSource\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"source\":\"kind source: *v1beta3.AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting Controller\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting workers\",\"controller\":\"secret\",\"controllerGroup\":\"\",\"controllerKind\":\"Secret\",\"worker count\":1}\n{\"level\":\"info\",\"ts\":\"2024-10-07T10:31:02+01:00\",\"logger\":\"authorino\",\"msg\":\"Starting workers\",\"controller\":\"authconfig\",\"controllerGroup\":\"authorino.kuadrant.io\",\"controllerKind\":\"AuthConfig\",\"worker count\":1}\n</code></pre> Reconciling an AuthConfig and 2 related API key secrets <pre><code>{\"level\":\"debug\",\"ts\":1669221208.7473805,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status changed\",\"authconfig\":\"default/talker-api-protection\",\"authconfig/status\":{\"conditions\":[{\"type\":\"Available\",\"status\":\"False\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"HostsNotLinked\",\"message\":\"No hosts linked to the resource\"},{\"type\":\"Ready\",\"status\":\"False\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"Unknown\"}],\"summary\":{\"ready\":false,\"hostsReady\":[],\"numHostsReady\":\"0/1\",\"numIdentitySources\":1,\"numMetadataSources\":0,\"numAuthorizationPolicies\":0,\"numResponseItems\":0,\"festivalWristbandEnabled\":false}}}\n{\"level\":\"info\",\"ts\":1669221208.7496614,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"info\",\"ts\":1669221208.7532616,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.7535005,\"logger\":\"authorino.controller.secret\",\"msg\":\"adding k8s secret to the index\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-1\",\"namespace\":\"default\",\"authconfig\":\"default/talker-api-protection\",\"config\":\"friends\"}\n{\"level\":\"debug\",\"ts\":1669221208.7535596,\"logger\":\"authorino.controller.secret.apikey\",\"msg\":\"api key added\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-1\",\"namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669221208.7536132,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-1\"}\n{\"level\":\"info\",\"ts\":1669221208.753772,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.753835,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status changed\",\"authconfig\":\"default/talker-api-protection\",\"authconfig/status\":{\"conditions\":[{\"type\":\"Available\",\"status\":\"True\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"HostsLinked\"},{\"type\":\"Ready\",\"status\":\"True\",\"lastTransitionTime\":\"2022-11-23T16:33:28Z\",\"reason\":\"Reconciled\"}],\"summary\":{\"ready\":true,\"hostsReady\":[\"talker-api.127.0.0.1.nip.io\"],\"numHostsReady\":\"1/1\",\"numIdentitySources\":1,\"numMetadataSources\":0,\"numAuthorizationPolicies\":0,\"numResponseItems\":0,\"festivalWristbandEnabled\":false}}}\n{\"level\":\"info\",\"ts\":1669221208.7571108,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"info\",\"ts\":1669221208.7573664,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.757429,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status did not change\",\"authconfig\":\"default/talker-api-protection\"}\n{\"level\":\"debug\",\"ts\":1669221208.7586699,\"logger\":\"authorino.controller.secret\",\"msg\":\"adding k8s secret to the index\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-2\",\"namespace\":\"default\",\"authconfig\":\"default/talker-api-protection\",\"config\":\"friends\"}\n{\"level\":\"debug\",\"ts\":1669221208.7586884,\"logger\":\"authorino.controller.secret.apikey\",\"msg\":\"api key added\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\",\"name\":\"api-key-2\",\"namespace\":\"default\"}\n{\"level\":\"info\",\"ts\":1669221208.7586913,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-2\"}\n{\"level\":\"debug\",\"ts\":1669221208.7597604,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status did not change\",\"authconfig\":\"default/talker-api-protection\"}\n</code></pre> Enforcing an AuthConfig with authentication based on Kubernetes tokens: <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830460.1486168,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"8157480586935853928\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830460.1491194,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"8157480586935853928\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830460,\"nanos\":147259000},\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"4c5d5c97-e15b-46a3-877a-d8188e09e08f\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830460.150506,\"logger\":\"authorino.service.auth.authpipeline.identity.kubernetesauth\",\"msg\":\"calling kubernetes token review api\",\"request id\":\"8157480586935853928\",\"tokenreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"token\":\"eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"audiences\":[\"talker-api\"]},\"status\":{\"user\":{}}}}\n{\"level\":\"debug\",\"ts\":1634830460.1509938,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830460.1517606,\"logger\":\"authorino.service.auth.authpipeline.identity.oauth2\",\"msg\":\"sending token introspection request\",\"request id\":\"8157480586935853928\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token/introspect\",\"data\":\"token=eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA&amp;token_type_hint=requesting_party_token\"}\n{\"level\":\"debug\",\"ts\":1634830460.1620777,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"identity validated\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"aud\":[\"talker-api\"],\"exp\":1634831051,\"iat\":1634830451,\"iss\":\"https://kubernetes.default.svc.cluster.local\",\"kubernetes.io\":{\"namespace\":\"authorino\",\"serviceaccount\":{\"name\":\"api-consumer-1\",\"uid\":\"b40f531c-ecab-4f31-a496-2ebc72add121\"}},\"nbf\":1634830451,\"sub\":\"system:serviceaccount:authorino:api-consumer-1\"}}\n{\"level\":\"debug\",\"ts\":1634830460.1622565,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"requesting pat\",\"request id\":\"8157480586935853928\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token\",\"data\":\"grant_type=client_credentials\",\"headers\":{\"Content-Type\":[\"application/x-www-form-urlencoded\"]}}\n{\"level\":\"debug\",\"ts\":1634830460.1670353,\"logger\":\"authorino.service.auth.authpipeline.metadata.http\",\"msg\":\"sending request\",\"request id\":\"8157480586935853928\",\"method\":\"GET\",\"url\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path=/hello\",\"headers\":{\"Content-Type\":[\"text/plain\"]}}\n{\"level\":\"debug\",\"ts\":1634830460.169326,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"cannot fetch metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"oidc-userinfo\",\"UserInfo\":{\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"}},\"UMA\":null,\"GenericHTTP\":null},\"reason\":\"Missing identity for OIDC issuer http://keycloak:8080/realms/kuadrant. Skipping related UserInfo metadata.\"}\n{\"level\":\"debug\",\"ts\":1634830460.1753876,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"http-metadata\",\"UserInfo\":null,\"UMA\":null,\"GenericHTTP\":{\"Endpoint\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path={context.request.http.path}\",\"Method\":\"GET\",\"Parameters\":[],\"ContentType\":\"application/x-www-form-urlencoded\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"1aa6ac66-3179-4351-b1a7-7f6a761d5b61\"}}\n{\"level\":\"debug\",\"ts\":1634830460.2331996,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"querying resources by uri\",\"request id\":\"8157480586935853928\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set?uri=/hello\"}\n{\"level\":\"debug\",\"ts\":1634830460.2495668,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"getting resource data\",\"request id\":\"8157480586935853928\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set/e20d194c-274c-4845-8c02-0ca413c9bf18\"}\n{\"level\":\"debug\",\"ts\":1634830460.2927864,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"uma-resource-registry\",\"UserInfo\":null,\"UMA\":{\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"GenericHTTP\":null},\"object\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}\n{\"level\":\"debug\",\"ts\":1634830460.2930083,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"evaluating for input\",\"request id\":\"8157480586935853928\",\"input\":{\"context\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":53144}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830460,\"nanos\":147259000},\"http\":{\"id\":\"8157480586935853928\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6IkRsVWJZMENyVy1sZ0tFMVRMd19pcTFUWGtTYUl6T0hyWks0VHhKYnpEZUUifQ.eyJhdWQiOlsidGFsa2VyLWFwaSJdLCJleHAiOjE2MzQ4MzEwNTEsImlhdCI6MTYzNDgzMDQ1MSwiaXNzIjoiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiLCJrdWJlcm5ldGVzLmlvIjp7Im5hbWVzcGFjZSI6ImF1dGhvcmlubyIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhcGktY29uc3VtZXItMSIsInVpZCI6ImI0MGY1MzFjLWVjYWItNGYzMS1hNDk2LTJlYmM3MmFkZDEyMSJ9fSwibmJmIjoxNjM0ODMwNDUxLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6YXV0aG9yaW5vOmFwaS1jb25zdW1lci0xIn0.PaP0vqdl5DPfErr84KfVhPdlsGAPgsw0NkDaA9rne1zXjzcO7KPPbXhFwZC-oIjSGG1HfRMSoQeCXbQz24PSATmX8l1T52a9IFeXgP7sQmXZIDbiPfTm3X09kIIlfPKHhK_f-jQwRIpMRqNgLntlZ-xXX3P1fOBBUYR8obTPAQ6NDDaLHxw2SAmHFTQWjM_DInPDemXX0mEm7nCPKifsNxHaQH4wx4CD3LCLGbCI9FHNf2Crid8mmGJXf4wzcH1VuKkpUlsmnlUgTG2bfT2lbhSF2lBmrrhTJyYk6_aA09DwL4Bf4kvG-JtCq0Bkd_XynViIsOtOnAhgmdSPkfr-oA\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"4c5d5c97-e15b-46a3-877a-d8188e09e08f\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}},\"auth\":{\"identity\":{\"aud\":[\"talker-api\"],\"exp\":1634831051,\"iat\":1634830451,\"iss\":\"https://kubernetes.default.svc.cluster.local\",\"kubernetes.io\":{\"namespace\":\"authorino\",\"serviceaccount\":{\"name\":\"api-consumer-1\",\"uid\":\"b40f531c-ecab-4f31-a496-2ebc72add121\"}},\"nbf\":1634830451,\"sub\":\"system:serviceaccount:authorino:api-consumer-1\"},\"metadata\":{\"http-metadata\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"1aa6ac66-3179-4351-b1a7-7f6a761d5b61\"},\"uma-resource-registry\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}}}}\n{\"level\":\"debug\",\"ts\":1634830460.2955465,\"logger\":\"authorino.service.auth.authpipeline.authorization.kubernetesauthz\",\"msg\":\"calling kubernetes subject access review api\",\"request id\":\"8157480586935853928\",\"subjectaccessreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"nonResourceAttributes\":{\"path\":\"/hello\",\"verb\":\"get\"},\"user\":\"system:serviceaccount:authorino:api-consumer-1\"},\"status\":{\"allowed\":false}}}\n{\"level\":\"debug\",\"ts\":1634830460.2986183,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"my-policy\",\"OPA\":{\"Rego\":\"fail := input.context.request.http.headers[\\\"x-ext-auth-mock\\\"] == \\\"FAIL\\\"\\nallow { not fail }\\n\",\"OPAExternalSource\":{\"Endpoint\":\"\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"JSON\":null,\"KubernetesAuthz\":null},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830460.3044975,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"kubernetes-rbac\",\"OPA\":null,\"JSON\":null,\"KubernetesAuthz\":{\"Conditions\":[],\"User\":{\"Static\":\"\",\"Pattern\":\"auth.identity.user.username\"},\"Groups\":null,\"ResourceAttributes\":null}},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830460.3052874,\"logger\":\"authorino.service.auth.authpipeline.response\",\"msg\":\"dynamic response built\",\"request id\":\"8157480586935853928\",\"config\":{\"Name\":\"wristband\",\"Wrapper\":\"httpHeader\",\"WrapperKey\":\"x-ext-auth-wristband\",\"Wristband\":{\"Issuer\":\"https://authorino-oidc.default.svc:8083/default/talker-api-protection/wristband\",\"CustomClaims\":[],\"TokenDuration\":300,\"SigningKeys\":[{\"use\":\"sig\",\"kty\":\"EC\",\"kid\":\"wristband-signing-key\",\"crv\":\"P-256\",\"alg\":\"ES256\",\"x\":\"TJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZw\",\"y\":\"SSg8rKBsJ3J1LxyLtt0oFvhHvZcUpmRoTuHk3UHisTA\",\"d\":\"Me-5_zWBWVYajSGZcZMCcD8dXEa4fy85zv_yN7BxW-o\"}]},\"DynamicJSON\":null},\"object\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IndyaXN0YmFuZC1zaWduaW5nLWtleSIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQ4MzA3NjAsImlhdCI6MTYzNDgzMDQ2MCwiaXNzIjoiaHR0cHM6Ly9hdXRob3Jpbm8tb2lkYy5hdXRob3Jpbm8uc3ZjOjgwODMvYXV0aG9yaW5vL3RhbGtlci1hcGktcHJvdGVjdGlvbi93cmlzdGJhbmQiLCJzdWIiOiI4NDliMDk0ZDA4MzU0ZjM0MjA4ZGI3MjBmYWZmODlmNmM3NmYyOGY3MTcxOWI4NTQ3ZDk5NWNlNzAwMjU2ZGY4In0.Jn-VB5Q_0EX1ed1ji4KvhO4DlMqZeIl5H0qlukbTyYkp-Pgb4SnPGSbYWp5_uvG8xllsFAA5nuyBIXeba-dbkw\"}\n{\"level\":\"info\",\"ts\":1634830460.3054585,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"8157480586935853928\",\"authorized\":true,\"response\":\"OK\"}\n{\"level\":\"debug\",\"ts\":1634830460.305476,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"8157480586935853928\",\"authorized\":true,\"response\":\"OK\"}\n</code></pre> Enforcing an AuthConfig with authentication based on API keys <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830413.2425854,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"7199257136822741594\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830413.2426975,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"7199257136822741594\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830413,\"nanos\":240094000},\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"d38f5e66-bd72-4733-95d1-3179315cdd60\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830413.2428744,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830413.2434332,\"logger\":\"authorino.service.auth.authpipeline\",\"msg\":\"skipping config\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"keycloak-jwts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"},\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"context canceled\"}\n{\"level\":\"debug\",\"ts\":1634830413.2479305,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"identity validated\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"object\":{\"apiVersion\":\"v1\",\"data\":{\"api_key\":\"bmR5QnpyZVV6RjR6cURRc3FTUE1Ia1JocmlFT3RjUng=\"},\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Secret\\\",\\\"metadata\\\":{\\\"annotations\\\":{\\\"userid\\\":\\\"john\\\"},\\\"labels\\\":{\\\"audience\\\":\\\"talker-api\\\",\\\"authorino.kuadrant.io/managed-by\\\":\\\"authorino\\\"},\\\"name\\\":\\\"api-key-1\\\",\\\"namespace\\\":\\\"authorino\\\"},\\\"stringData\\\":{\\\"api_key\\\":\\\"ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\\\"},\\\"type\\\":\\\"Opaque\\\"}\\n\",\"userid\":\"john\"},\"creationTimestamp\":\"2021-10-21T14:45:54Z\",\"labels\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"},\"managedFields\":[{\"apiVersion\":\"v1\",\"fieldsType\":\"FieldsV1\",\"fieldsV1\":{\"f:data\":{\".\":{},\"f:api_key\":{}},\"f:metadata\":{\"f:annotations\":{\".\":{},\"f:kubectl.kubernetes.io/last-applied-configuration\":{},\"f:userid\":{}},\"f:labels\":{\".\":{},\"f:audience\":{},\"f:authorino.kuadrant.io/managed-by\":{}}},\"f:type\":{}},\"manager\":\"kubectl-client-side-apply\",\"operation\":\"Update\",\"time\":\"2021-10-21T14:45:54Z\"}],\"name\":\"api-key-1\",\"namespace\":\"authorino\",\"resourceVersion\":\"8979\",\"uid\":\"c369852a-7e1a-43bd-94ca-e2b3f617052e\"},\"sub\":\"john\",\"type\":\"Opaque\"}}\n{\"level\":\"debug\",\"ts\":1634830413.248768,\"logger\":\"authorino.service.auth.authpipeline.metadata.http\",\"msg\":\"sending request\",\"request id\":\"7199257136822741594\",\"method\":\"GET\",\"url\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path=/hello\",\"headers\":{\"Content-Type\":[\"text/plain\"]}}\n{\"level\":\"debug\",\"ts\":1634830413.2496722,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"cannot fetch metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"oidc-userinfo\",\"UserInfo\":{\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"}},\"UMA\":null,\"GenericHTTP\":null},\"reason\":\"Missing identity for OIDC issuer http://keycloak:8080/realms/kuadrant. Skipping related UserInfo metadata.\"}\n{\"level\":\"debug\",\"ts\":1634830413.2497928,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"requesting pat\",\"request id\":\"7199257136822741594\",\"url\":\"http://talker-api:523b92b6-625d-4e1e-a313-77e7a8ae4e88@keycloak:8080/realms/kuadrant/protocol/openid-connect/token\",\"data\":\"grant_type=client_credentials\",\"headers\":{\"Content-Type\":[\"application/x-www-form-urlencoded\"]}}\n{\"level\":\"debug\",\"ts\":1634830413.258932,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"http-metadata\",\"UserInfo\":null,\"UMA\":null,\"GenericHTTP\":{\"Endpoint\":\"http://talker-api.default.svc.cluster.local:3000/metadata?encoding=text/plain&amp;original_path={context.request.http.path}\",\"Method\":\"GET\",\"Parameters\":[],\"ContentType\":\"application/x-www-form-urlencoded\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"object\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"97529f8c-587b-4121-a4db-cd90c63871fd\"}}\n{\"level\":\"debug\",\"ts\":1634830413.2945344,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"querying resources by uri\",\"request id\":\"7199257136822741594\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set?uri=/hello\"}\n{\"level\":\"debug\",\"ts\":1634830413.3123596,\"logger\":\"authorino.service.auth.authpipeline.metadata.uma\",\"msg\":\"getting resource data\",\"request id\":\"7199257136822741594\",\"url\":\"http://keycloak:8080/realms/kuadrant/authz/protection/resource_set/e20d194c-274c-4845-8c02-0ca413c9bf18\"}\n{\"level\":\"debug\",\"ts\":1634830413.3340268,\"logger\":\"authorino.service.auth.authpipeline.metadata\",\"msg\":\"fetched auth metadata\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"uma-resource-registry\",\"UserInfo\":null,\"UMA\":{\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"GenericHTTP\":null},\"object\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}\n{\"level\":\"debug\",\"ts\":1634830413.3367748,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"evaluating for input\",\"request id\":\"7199257136822741594\",\"input\":{\"context\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52702}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830413,\"nanos\":240094000},\"http\":{\"id\":\"7199257136822741594\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"d38f5e66-bd72-4733-95d1-3179315cdd60\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}},\"auth\":{\"identity\":{\"apiVersion\":\"v1\",\"data\":{\"api_key\":\"bmR5QnpyZVV6RjR6cURRc3FTUE1Ia1JocmlFT3RjUng=\"},\"kind\":\"Secret\",\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"v1\\\",\\\"kind\\\":\\\"Secret\\\",\\\"metadata\\\":{\\\"annotations\\\":{\\\"userid\\\":\\\"john\\\"},\\\"labels\\\":{\\\"audience\\\":\\\"talker-api\\\",\\\"authorino.kuadrant.io/managed-by\\\":\\\"authorino\\\"},\\\"name\\\":\\\"api-key-1\\\",\\\"namespace\\\":\\\"authorino\\\"},\\\"stringData\\\":{\\\"api_key\\\":\\\"ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\\\"},\\\"type\\\":\\\"Opaque\\\"}\\n\",\"userid\":\"john\"},\"creationTimestamp\":\"2021-10-21T14:45:54Z\",\"labels\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"},\"managedFields\":[{\"apiVersion\":\"v1\",\"fieldsType\":\"FieldsV1\",\"fieldsV1\":{\"f:data\":{\".\":{},\"f:api_key\":{}},\"f:metadata\":{\"f:annotations\":{\".\":{},\"f:kubectl.kubernetes.io/last-applied-configuration\":{},\"f:userid\":{}},\"f:labels\":{\".\":{},\"f:audience\":{},\"f:authorino.kuadrant.io/managed-by\":{}}},\"f:type\":{}},\"manager\":\"kubectl-client-side-apply\",\"operation\":\"Update\",\"time\":\"2021-10-21T14:45:54Z\"}],\"name\":\"api-key-1\",\"namespace\":\"authorino\",\"resourceVersion\":\"8979\",\"uid\":\"c369852a-7e1a-43bd-94ca-e2b3f617052e\"},\"sub\":\"john\",\"type\":\"Opaque\"},\"metadata\":{\"http-metadata\":{\"body\":\"\",\"headers\":{\"Accept-Encoding\":\"gzip\",\"Content-Type\":\"text/plain\",\"Host\":\"talker-api.default.svc.cluster.local:3000\",\"User-Agent\":\"Go-http-client/1.1\",\"Version\":\"HTTP/1.1\"},\"method\":\"GET\",\"path\":\"/metadata\",\"query_string\":\"encoding=text/plain&amp;original_path=/hello\",\"uuid\":\"97529f8c-587b-4121-a4db-cd90c63871fd\"},\"uma-resource-registry\":[{\"_id\":\"e20d194c-274c-4845-8c02-0ca413c9bf18\",\"attributes\":{},\"displayName\":\"hello\",\"name\":\"hello\",\"owner\":{\"id\":\"57a645a5-fb67-438b-8be5-dfb971666dbc\"},\"ownerManagedAccess\":false,\"resource_scopes\":[],\"uris\":[\"/hi\",\"/hello\"]}]}}}}\n{\"level\":\"debug\",\"ts\":1634830413.339894,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"my-policy\",\"OPA\":{\"Rego\":\"fail := input.context.request.http.headers[\\\"x-ext-auth-mock\\\"] == \\\"FAIL\\\"\\nallow { not fail }\\n\",\"OPAExternalSource\":{\"Endpoint\":\"\",\"SharedSecret\":\"\",\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"JSON\":null,\"KubernetesAuthz\":null},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830413.3444238,\"logger\":\"authorino.service.auth.authpipeline.authorization.kubernetesauthz\",\"msg\":\"calling kubernetes subject access review api\",\"request id\":\"7199257136822741594\",\"subjectaccessreview\":{\"metadata\":{\"creationTimestamp\":null},\"spec\":{\"nonResourceAttributes\":{\"path\":\"/hello\",\"verb\":\"get\"},\"user\":\"john\"},\"status\":{\"allowed\":false}}}\n{\"level\":\"debug\",\"ts\":1634830413.3547812,\"logger\":\"authorino.service.auth.authpipeline.authorization\",\"msg\":\"access granted\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"kubernetes-rbac\",\"OPA\":null,\"JSON\":null,\"KubernetesAuthz\":{\"Conditions\":[],\"User\":{\"Static\":\"\",\"Pattern\":\"auth.identity.user.username\"},\"Groups\":null,\"ResourceAttributes\":null}},\"object\":true}\n{\"level\":\"debug\",\"ts\":1634830413.3558292,\"logger\":\"authorino.service.auth.authpipeline.response\",\"msg\":\"dynamic response built\",\"request id\":\"7199257136822741594\",\"config\":{\"Name\":\"wristband\",\"Wrapper\":\"httpHeader\",\"WrapperKey\":\"x-ext-auth-wristband\",\"Wristband\":{\"Issuer\":\"https://authorino-oidc.default.svc:8083/default/talker-api-protection/wristband\",\"CustomClaims\":[],\"TokenDuration\":300,\"SigningKeys\":[{\"use\":\"sig\",\"kty\":\"EC\",\"kid\":\"wristband-signing-key\",\"crv\":\"P-256\",\"alg\":\"ES256\",\"x\":\"TJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZw\",\"y\":\"SSg8rKBsJ3J1LxyLtt0oFvhHvZcUpmRoTuHk3UHisTA\",\"d\":\"Me-5_zWBWVYajSGZcZMCcD8dXEa4fy85zv_yN7BxW-o\"}]},\"DynamicJSON\":null},\"object\":\"eyJhbGciOiJFUzI1NiIsImtpZCI6IndyaXN0YmFuZC1zaWduaW5nLWtleSIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MzQ4MzA3MTMsImlhdCI6MTYzNDgzMDQxMywiaXNzIjoiaHR0cHM6Ly9hdXRob3Jpbm8tb2lkYy5hdXRob3Jpbm8uc3ZjOjgwODMvYXV0aG9yaW5vL3RhbGtlci1hcGktcHJvdGVjdGlvbi93cmlzdGJhbmQiLCJzdWIiOiI5NjhiZjViZjk3MDM3NWRiNjE0ZDFhMDgzZTg2NTBhYTVhMGVhMzAyOTdiYmJjMTBlNWVlMWZmYTkxYTYwZmY4In0.7G440sWgi2TIaxrGJf5KWR9UOFpNTjwVYeaJXFLzsLhVNICoMLbYzBAEo4M3ym1jipxxTVeE7anm4qDDc7cnVQ\"}\n{\"level\":\"info\",\"ts\":1634830413.3569078,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"7199257136822741594\",\"authorized\":true,\"response\":\"OK\"}\n{\"level\":\"debug\",\"ts\":1634830413.3569596,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"7199257136822741594\",\"authorized\":true,\"response\":\"OK\"}\n</code></pre> Enforcing an AuthConfig with authentication based on API keys (invalid API key) <p></p> <ul> <li>identity: k8s-auth, oidc, oauth2, apikey</li> <li>metadata: http, oidc userinfo</li> <li>authorization: opa, k8s-authz</li> <li>response: wristband</li> </ul> <pre><code>{\"level\":\"info\",\"ts\":1634830373.2066543,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"12947265773116138711\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52288}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"http\":{\"id\":\"12947265773116138711\",\"method\":\"GET\",\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\"}}}}\n{\"level\":\"debug\",\"ts\":1634830373.2068064,\"logger\":\"authorino.service.auth\",\"msg\":\"incoming authorization request\",\"request id\":\"12947265773116138711\",\"object\":{\"source\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":52288}}}}},\"destination\":{\"address\":{\"Address\":{\"SocketAddress\":{\"address\":\"127.0.0.1\",\"PortSpecifier\":{\"PortValue\":8000}}}}},\"request\":{\"time\":{\"seconds\":1634830373,\"nanos\":198329000},\"http\":{\"id\":\"12947265773116138711\",\"method\":\"GET\",\"headers\":{\":authority\":\"talker-api\",\":method\":\"GET\",\":path\":\"/hello\",\":scheme\":\"http\",\"accept\":\"*/*\",\"authorization\":\"APIKEY invalid\",\"user-agent\":\"curl/7.65.3\",\"x-envoy-internal\":\"true\",\"x-forwarded-for\":\"10.244.0.11\",\"x-forwarded-proto\":\"http\",\"x-request-id\":\"9e391846-afe4-489a-8716-23a2e1c1aa77\"},\"path\":\"/hello\",\"host\":\"talker-api\",\"scheme\":\"http\",\"protocol\":\"HTTP/1.1\"}},\"context_extensions\":{\"virtual_host\":\"local_service\"},\"metadata_context\":{}}}\n{\"level\":\"debug\",\"ts\":1634830373.2070816,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"keycloak-opaque\",\"ExtendedProperties\":[],\"OAuth2\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"TokenIntrospectionUrl\":\"http://keycloak:8080/realms/kuadrant/protocol/openid-connect/token/introspect\",\"TokenTypeHint\":\"requesting_party_token\",\"ClientID\":\"talker-api\",\"ClientSecret\":\"523b92b6-625d-4e1e-a313-77e7a8ae4e88\"},\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830373.207225,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"api-keys\",\"ExtendedProperties\":[{\"Name\":\"sub\",\"Value\":{\"Static\":null,\"Pattern\":\"auth.identity.metadata.annotations.userid\"}}],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":{\"AuthCredentials\":{\"KeySelector\":\"APIKEY\",\"In\":\"authorization_header\"},\"Name\":\"api-keys\",\"LabelSelectors\":{\"audience\":\"talker-api\",\"authorino.kuadrant.io/managed-by\":\"authorino\"}},\"KubernetesAuth\":null},\"reason\":\"the API Key provided is invalid\"}\n{\"level\":\"debug\",\"ts\":1634830373.2072473,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"k8s-service-accounts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":null,\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"}}},\"reason\":\"credential not found\"}\n{\"level\":\"debug\",\"ts\":1634830373.2072592,\"logger\":\"authorino.service.auth.authpipeline.identity\",\"msg\":\"cannot validate identity\",\"request id\":\"12947265773116138711\",\"config\":{\"Name\":\"keycloak-jwts\",\"ExtendedProperties\":[],\"OAuth2\":null,\"OIDC\":{\"AuthCredentials\":{\"KeySelector\":\"Bearer\",\"In\":\"authorization_header\"},\"Endpoint\":\"http://keycloak:8080/realms/kuadrant\"},\"MTLS\":null,\"HMAC\":null,\"APIKey\":null,\"KubernetesAuth\":null},\"reason\":\"credential not found\"}\n{\"level\":\"info\",\"ts\":1634830373.2073083,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"12947265773116138711\",\"authorized\":false,\"response\":\"UNAUTHENTICATED\",\"object\":{\"code\":16,\"status\":302,\"message\":\"Redirecting to login\"}}\n{\"level\":\"debug\",\"ts\":1634830373.2073889,\"logger\":\"authorino.service.auth\",\"msg\":\"outgoing authorization response\",\"request id\":\"12947265773116138711\",\"authorized\":false,\"response\":\"UNAUTHENTICATED\",\"object\":{\"code\":16,\"status\":302,\"message\":\"Redirecting to login\",\"headers\":[{\"Location\":\"https://my-app.io/login\"}]}}\n</code></pre> Deleting an AuthConfig and 2 related API key secrets <pre><code>{\"level\":\"info\",\"ts\":1669221361.5032296,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-1\"}\n{\"level\":\"info\",\"ts\":1669221361.5057878,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"default/api-key-2\"}\n</code></pre> Shutting down the service <pre><code>{\"level\":\"info\",\"ts\":1669221635.0135982,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for non leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0136683,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0135982,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for non leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0136883,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for leader election runnables\"}\n{\"level\":\"info\",\"ts\":1669221635.0137057,\"logger\":\"authorino.controller.secret\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669221635.013724,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.01375,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"All workers finished\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.013752,\"logger\":\"authorino.controller.secret\",\"msg\":\"All workers finished\",\"reconciler group\":\"\",\"reconciler kind\":\"Secret\"}\n{\"level\":\"info\",\"ts\":1669221635.0137632,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for caches\"}\n{\"level\":\"info\",\"ts\":1669221635.013751,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"Shutdown signal received, waiting for all workers to finish\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.0137684,\"logger\":\"authorino.controller.authconfig\",\"msg\":\"All workers finished\",\"reconciler group\":\"authorino.kuadrant.io\",\"reconciler kind\":\"AuthConfig\"}\n{\"level\":\"info\",\"ts\":1669221635.0137722,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for caches\"}\n{\"level\":\"info\",\"ts\":1669221635.0138857,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for webhooks\"}\n{\"level\":\"info\",\"ts\":1669221635.0138955,\"logger\":\"authorino\",\"msg\":\"Wait completed, proceeding to shutdown the manager\"}\n{\"level\":\"info\",\"ts\":1669221635.0138893,\"logger\":\"authorino\",\"msg\":\"Stopping and waiting for webhooks\"}\n{\"level\":\"info\",\"ts\":1669221635.0139785,\"logger\":\"authorino\",\"msg\":\"Wait completed, proceeding to shutdown the manager\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/observability/#tracing","title":"Tracing","text":""},{"location":"authorino/docs/user-guides/observability/#request-id","title":"Request ID","text":"<p>Processes related to the authorization request are identified and linked together by a request ID. The request ID can be:</p> <ul> <li>generated outside Authorino and passed in the authorization request \u2013 this is essentially the case of requests via GRPC authorization interface initiated by the Envoy;</li> <li>generated by Authorino \u2013 requests via Raw HTTP Authorization interface.</li> </ul>"},{"location":"authorino/docs/user-guides/observability/#propagation","title":"Propagation","text":"<p>Authorino propagates trace identifiers compatible with the W3C Trace Context format https://www.w3.org/TR/trace-context/ and user-defined baggage data in the W3C Baggage format https://www.w3.org/TR/baggage.</p>"},{"location":"authorino/docs/user-guides/observability/#log-tracing","title":"Log tracing","text":"<p>Most log messages associated with an authorization request include the <code>request id</code> value. This value can be used to match incoming request and corresponding outgoing response log messages, including at deep level when more fine-grained log details are enabled (<code>debug</code> level level).</p>"},{"location":"authorino/docs/user-guides/observability/#opentelemetry-integration","title":"OpenTelemetry integration","text":"<p>Integration with an OpenTelemetry collector can be enabled by supplying the <code>--tracing-service-endpoint</code> command-line flag (e.g. <code>authorino server --tracing-service-endpoint=http://jaeger:14268/api/traces</code>).</p> <p>The additional <code>--tracing-service-tags</code> command-line flag allow to specify fixed agent-level key-value tags for the trace signals emitted by Authorino (e.g. <code>authorino server --tracing-service-endpoint=... --tracing-service-tag=key1=value1 --tracing-service-tag=key2=value2</code>).</p> <p>Traces related to authorization requests are additionally tagged with the <code>authorino.request_id</code> attribute.</p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/","title":"User guide: OpenID Connect Discovery and authentication with JWTs","text":"<p>Validate JSON Web Tokens (JWT) issued and signed by an OpenID Connect server; leverage OpenID Connect Discovery to automatically fetch JSON Web Key Sets (JWKS).</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> </ul> <p>Authorino validates JSON Web Tokens (JWT) issued by an OpenID Connect server that implements OpenID Connect Discovery. Authorino fetches the OpenID Connect configuration and JSON Web Key Set (JWKS) from the issuer endpoint, and verifies the JSON Web Signature (JWS) and time validity of the token.</p> <p>Important! Authorino does not implement OAuth2 grants nor OIDC authentication flows. As a common recommendation of good practice, obtaining and refreshing access tokens is for clients to negotiate directly with the auth servers and token issuers. Authorino will only validate those tokens using the parameters provided by the trusted issuer authorities.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>With missing or invalid access token:</p> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: Bearer realm=\"keycloak-kuadrant-realm\"\n# x-ext-auth-reason: credential not found\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-jwt-authentication/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oidc-rbac/","title":"User guide: OpenID Connect (OIDC) and Role-Based Access Control (RBAC) with Authorino and Keycloak","text":"<p>Combine OpenID Connect (OIDC) authentication and Role-Based Access Control (RBAC) authorization rules leveraging Keycloak and Authorino working together.</p> <p>In this user guide, you will learn via example how to implement a simple Role-Based Access Control (RBAC) system to protect endpoints of an API, with roles assigned to users of an Identity Provider (Keycloak) and carried within the access tokens as JSON Web Token (JWT) claims. Users authenticate with the IdP via OAuth2/OIDC flow and get their access tokens verified and validated by Authorino on every request. Moreover, Authorino reads the role bindings of the user and enforces the proper RBAC rules based upon the context.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-rbac/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-rbac/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, the Keycloak realm defines a few users and 2 realm roles: 'member' and 'admin'. When users authenticate to the Keycloak server by any of the supported OAuth2/OIDC flows, Keycloak adds to the access token JWT a claim <code>\"realm_access\": { \"roles\": array }</code> that holds the list of roles assigned to the user. Authorino will verify the JWT on requests to the API and read from that claim to enforce the following RBAC rules:</p> Path Method Role /resources[/*] GET / POST / PUT member /resources/{id} DELETE admin /admin[/*] * admin Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Apply the AuthConfig:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n\n  patterns:\n    \"member-role\":\n\n    - selector: auth.identity.realm_access.roles\n      operator: incl\n      value: member\n    \"admin-role\":\n    - selector: auth.identity.realm_access.roles\n      operator: incl\n      value: admin\n\n  authorization:\n    # RBAC rule: 'member' role required for requests to /resources[/*]\n    \"rbac-resources-api\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/resources(/.*)?$\n      patternMatching:\n        patterns:\n        - patternRef: member-role\n\n    # RBAC rule: 'admin' role required for DELETE requests to /resources/{id}\n    \"rbac-delete-resource\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/resources/\\d+$\n      - selector: context.request.http.method\n        operator: eq\n        value: DELETE\n      patternMatching:\n        patterns:\n        - patternRef: admin-role\n\n    # RBAC rule: 'admin' role required for requests to /admin[/*]\n    \"rbac-admin-api\":\n      when:\n\n      - selector: context.request.http.path\n        operator: matches\n        value: ^/admin(/.*)?$\n      patternMatching:\n        patterns:\n        - patternRef: admin-role\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api","title":"\u277b Obtain an access token and consume the API","text":""},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user John, who is assigned to the 'member' role:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, send a <code>GET</code> request to /resources:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/resources -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As John, send a <code>DELETE</code> request to /resources/123:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/resources/123 -i\n# HTTP/1.1 403 Forbidden\n</code></pre> <p>As John, send a <code>GET</code> request to /admin/settings:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/admin/settings -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#obtain-an-access-token-and-consume-the-api-as-jane-memberadmin","title":"Obtain an access token and consume the API as Jane (member/admin)","text":"<p>Obtain an access token from within the cluster for the user Jane, who is assigned to the 'member' and 'admin' roles:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send a <code>GET</code> request to /resources:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/resources -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, send a <code>DELETE</code> request to /resources/123:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/resources/123 -i\n# HTTP/1.1 200 OK\n</code></pre> <p>As Jane, send a <code>GET</code> request to /admin/settings:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/admin/settings -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-rbac/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/oidc-user-info/","title":"User guide: OpenID Connect UserInfo","text":"<p>Fetch user info for OpenID Connect ID tokens in request-time for extra metadata for your policies and online verification of token validity.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 OIDC UserInfo</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Apart from possibly complementing information of the JWT, fetching OpenID Connect UserInfo in request-time can be particularly useful for remote checking the state of the session, as opposed to only verifying the JWT/JWS offline. Implementation requires an OpenID Connect issuer (<code>spec.identity.oidc</code>) configured in the same <code>AuthConfig</code>.</p> <p>Check out as well the user guide about OpenID Connect Discovery and authentication with JWTs.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"userinfo\":\n      userInfo:\n        identitySource: keycloak-kuadrant-realm\n  authorization:\n    \"active-tokens-only\":\n      patternMatching:\n        patterns:\n        - selector: \"auth.metadata.userinfo.email\" # user email expected from the userinfo instead of the jwt\n          operator: neq\n          value: \"\"\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#obtain-an-access-token-with-the-keycloak-server","title":"\u277b Obtain an access token with the Keycloak server","text":"<p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>export $(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r '\"ACCESS_TOKEN=\"+.access_token,\"REFRESH_TOKEN=\"+.refresh_token')\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p>"},{"location":"authorino/docs/user-guides/oidc-user-info/#consume-the-api","title":"\u277c Consume the API","text":"<p>With a valid access token:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Revoke the access token and try to consume the API again:</p> <pre><code>kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/logout -H \"Content-Type: application/x-www-form-urlencoded\" -d \"refresh_token=$REFRESH_TOKEN\" -d 'token_type_hint=requesting_party_token' -u demo:\n</code></pre> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/oidc-user-info/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/opa-authorization/","title":"User guide: Open Policy Agent (OPA) Rego policies","text":"<p>Leverage the power of Open Policy Agent (OPA) policies, evaluated against Authorino's Authorization JSON in a built-in runtime compiled together with Authorino; pre-cache policies defined in Rego language inline or fetched from an external policy registry.</p> Authorino capabilities featured in this guide: <ul> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Authorino supports Open Policy Agent policies, either inline defined in Rego language as part of the <code>AuthConfig</code> or fetched from an external endpoint, such as an OPA Policy Registry.</p> <p>Authorino's built-in OPA module precompiles the policies in reconciliation-time and cache them for fast evaluation in request-time, where they receive the Authorization JSON as input.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/opa-authorization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/opa-authorization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, we will use OPA to implement a read-only policy for requests coming from outside a trusted network (IP range 192.168.1/24).</p> <p>The implementation relies on the <code>X-Forwarded-For</code> HTTP header to read the client's IP address.<sup>5</sup></p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n  authorization:\n    \"read-only-outside\":\n      opa:\n        rego: |\n          ips := split(input.context.request.http.headers[\"x-forwarded-for\"], \",\")\n          trusted_network { net.cidr_contains(\"192.168.1.1/24\", ips[0]) }\n\n          allow { trusted_network }\n          allow { not trusted_network; input.context.request.http.method == \"GET\" }\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#create-the-api-key","title":"\u277b Create the API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#consume-the-api","title":"\u277c Consume the API","text":"<p>Inside the trusted network:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 192.168.1.10' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Outside the trusted network:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' \\\n     -H 'X-Forwarded-For: 123.45.6.78' \\\n     -X POST \\\n     http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n# x-ext-auth-reason: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/opa-authorization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> <li> <p>You can also set <code>use_remote_address: true</code> in the Envoy route configuration, so the proxy will append its IP address instead of run in transparent mode. This setting will also ensure real remote address of the client connection passed in the <code>x-envoy-external-address</code> HTTP header, which can be used to simplify the read-only policy in remote environment.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/passing-credentials/","title":"User guide: Passing credentials (<code>Authorization</code> header, cookie headers and others)","text":"<p>Customize where credentials are supplied in the request by each trusted source of identity.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Auth credentials</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Authentication tokens can be supplied in the <code>Authorization</code> header, in a custom header, cookie or query string parameter.</p> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/passing-credentials/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/passing-credentials/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>In this example, <code>member</code> users can authenticate supplying the API key in any of 4 different ways:</p> <ul> <li>HTTP header <code>Authorization: APIKEY &lt;api-key&gt;</code></li> <li>HTTP header <code>X-API-Key: &lt;api-key&gt;</code></li> <li>Query string parameter <code>api_key=&lt;api-key&gt;</code></li> <li>Cookie <code>Cookie: APIKEY=&lt;api-key&gt;;</code></li> </ul> <p><code>admin</code> API keys are only accepted in the (default) HTTP header <code>Authorization: Bearer &lt;api-key&gt;</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"members-authorization-header\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY # instead of the default prefix 'Bearer'\n    \"members-custom-header\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        customHeader:\n          name: X-API-Key\n    \"members-query-string-param\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        queryString:\n          name: api_key\n    \"members-cookie\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: members\n      credentials:\n        cookie:\n          name: APIKEY\n    \"admins\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: admins\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#create-the-api-keys","title":"\u277b Create the API keys","text":"<p>For a member user:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: members\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>For an admin user:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: admins\nstringData:\n  api_key: 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#consume-the-api","title":"\u277c Consume the API","text":"<p>As member user, passing the API key in the <code>Authorization</code> header:</p> <pre><code>curl -H 'Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the custom <code>X-API-Key</code> header:</p> <pre><code>curl -H 'X-API-Key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the query string parameter <code>api_key</code>:</p> <pre><code>curl \"http://talker-api.127.0.0.1.nip.io:8000/hello?api_key=ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\"\n# HTTP/1.1 200 OK\n</code></pre> <p>As member user, passing the API key in the <code>APIKEY</code> cookie header:</p> <pre><code>curl -H 'Cookie: APIKEY=ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx;foo=bar' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>As admin user:</p> <pre><code>curl -H 'Authorization: Bearer 7BNaTmYGItSzXiwQLNHu82+x52p1XHgY' http://talker-api.127.0.0.1.nip.io:8000/hello\n# HTTP/1.1 200 OK\n</code></pre> <p>Missing the API key:</p> <pre><code>curl http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 401 Unauthorized\n# www-authenticate: APIKEY realm=\"members-authorization-header\"\n# www-authenticate: X-API-Key realm=\"members-custom-header\"\n# www-authenticate: api_key realm=\"members-query-string-param\"\n# www-authenticate: APIKEY realm=\"members-cookie\"\n# www-authenticate: Bearer realm=\"admins\"\n# x-ext-auth-reason: {\"admins\":\"credential not found\",\"members-authorization-header\":\"credential not found\",\"members-cookie\":\"credential not found\",\"members-custom-header\":\"credential not found\",\"members-query-string-param\":\"credential not found\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/passing-credentials/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete secret/api-key-2\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/","title":"User guide: Resource-level authorization with User-Managed Access (UMA) resource registry","text":"<p>Fetch resource metadata relevant for your authorization policies from Keycloak authorization clients, using User-Managed Access (UMA) protocol.</p> Authorino capabilities featured in this guide: <ul> <li>External auth metadata \u2192 User-Managed Access (UMA) resource registry</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> </ul> <p>Check out as well the user guides about OpenID Connect Discovery and authentication with JWTs and Open Policy Agent (OPA) Rego policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced:</p> <p>This example of resource-level authorization leverages part of Keycloak's User-Managed Access (UMA) support. Authorino will fetch resource attributes stored in a Keycloak resource server client.</p> <p>The Keycloak server also provides the identities. The <code>sub</code> claim of the Keycloak-issued ID tokens must match the owner of the requested resource, identified by the URI of the request.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <p>Create a required secret that will be used by Authorino to initiate the authentication with the UMA registry.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: talker-api-uma-credentials\nstringData:\n  clientID: talker-api\n  clientSecret: 523b92b6-625d-4e1e-a313-77e7a8ae4e88\ntype: Opaque\nEOF\n</code></pre> <p>Create the config:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"resource-data\":\n      uma:\n        endpoint: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n        credentialsRef:\n          name: talker-api-uma-credentials\n  authorization:\n    \"owned-resources\":\n      opa:\n        rego: |\n          COLLECTIONS = [\"greetings\"]\n\n          http_request = input.context.request.http\n          http_method = http_request.method\n          requested_path_sections = split(trim_left(trim_right(http_request.path, \"/\"), \"/\"), \"/\")\n\n          get { http_method == \"GET\" }\n          post { http_method == \"POST\" }\n          put { http_method == \"PUT\" }\n          delete { http_method == \"DELETE\" }\n\n          valid_collection { COLLECTIONS[_] == requested_path_sections[0] }\n\n          collection_endpoint {\n            valid_collection\n            count(requested_path_sections) == 1\n          }\n\n          resource_endpoint {\n            valid_collection\n            some resource_id\n            requested_path_sections[1] = resource_id\n          }\n\n          identity_owns_the_resource {\n            identity := input.auth.identity\n            resource_attrs := object.get(input.auth.metadata, \"resource-data\", [])[0]\n            resource_owner := object.get(object.get(resource_attrs, \"owner\", {}), \"id\", \"\")\n            resource_owner == identity.sub\n          }\n\n          allow { get;    collection_endpoint }\n          allow { post;   collection_endpoint }\n          allow { get;    resource_endpoint; identity_owns_the_resource }\n          allow { put;    resource_endpoint; identity_owns_the_resource }\n          allow { delete; resource_endpoint; identity_owns_the_resource }\nEOF\n</code></pre> <p>The OPA policy <code>owned-resource</code> above enforces that all users can send GET and POST requests to <code>/greetings</code>, while only resource owners can send GET, PUT and DELETE requests to <code>/greetings/{resource-id}</code>.</p>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-access-tokens-with-the-keycloak-server-and-consume-the-api","title":"\u277b Obtain access tokens with the Keycloak server and consume the API","text":""},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-john-and-consume-the-api","title":"Obtain an access token as John and consume the API","text":"<p>Obtain an access token for user John (owner of the resource <code>/greetings/1</code> in the UMA registry):</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>As John, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2 -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-jane-and-consume-the-api","title":"Obtain an access token as Jane and consume the API","text":"<p>Obtain an access token for user Jane (owner of the resource <code>/greetings/2</code> in the UMA registry):</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#obtain-an-access-token-as-peter-and-consume-the-api","title":"Obtain an access token as Peter and consume the API","text":"<p>Obtain an access token for user Peter (does not own any resource in the UMA registry):</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=peter' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>As Jane, send requests to the API:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings\n# HTTP/1.1 200 OK\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/1 -i\n# HTTP/1.1 403 Forbidden\n\ncurl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/greetings/2 -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/resource-level-authorization-uma/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authconfig/talker-api-protection\nkubectl delete secret/talker-api-uma-credentials\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/sharding/","title":"User guide: Reducing the operational space","text":"<p>By default, Authorino will watch events related to all <code>AuthConfig</code> custom resources in the reconciliation space (namespace or entire cluster). Instances can be configured though to only watch a subset of the resources, thus allowing such as:</p> <ul> <li>to reduce noise and lower memory usage inside instances meant for restricted scope (e.g. Authorino deployed as a dedicated sidecar to protect only one host);</li> <li>sharding auth config data across multiple instances;</li> <li>multiple environments (e.g. staging, production) inside of a same cluster/namespace;</li> <li>providing managed instances of Authorino that all watch CRs cluster-wide, yet dedicated to organizations allowed to create and operate their own <code>AuthConfig</code>s across multiple namespaces.</li> </ul> \u26a0\ufe0f Important:         This feature may not be available to users of Authorino via Kuadrant.        Authorino capabilities featured in this guide: <ul> <li>Sharding</li> <li>Identity verification &amp; authentication \u2192 API key</li> </ul> <p>Check out as well the user guide about Authentication with API keys.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/sharding/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p></p>"},{"location":"authorino/docs/user-guides/sharding/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#deploy-instances-of-authorino","title":"\u2777 Deploy instances of Authorino","text":"<p>Deploy an instance of Authorino dedicated to <code>AuthConfig</code>s and API key <code>Secrets</code> labeled with <code>authorino/environment=staging</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino-staging\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: authorino/environment=staging\n  secretLabelSelectors: authorino/environment=staging\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>Deploy an instance of Authorino dedicated to <code>AuthConfig</code>s and API key <code>Secrets</code> labeled with <code>authorino/environment=production</code>, ans NOT labeled <code>disabled</code>:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino-production\nspec:\n  clusterWide: true\n  authConfigLabelSelectors: authorino/environment=production,!disabled\n  secretLabelSelectors: authorino/environment=production,!disabled\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre> <p>The commands above will both request instances of Authorino that watch for <code>AuthConfig</code> resources cluster-wide<sup>1</sup>, with TLS disabled<sup>2</sup>.</p>"},{"location":"authorino/docs/user-guides/sharding/#create-a-namespace-for-user-resources","title":"\u2778 Create a namespace for user resources","text":"<pre><code>kubectl create namespace myapp\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#create-authconfigs-and-api-key-secrets-for-both-instances","title":"\u2779 Create <code>AuthConfig</code>s and API key <code>Secret</code>s for both instances","text":""},{"location":"authorino/docs/user-guides/sharding/#create-resources-for-authorino-staging","title":"Create resources for <code>authorino-staging</code>","text":"<p>Create an <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: auth-config-1\n  labels:\n    authorino/environment: staging\nspec:\n  hosts:\n\n  - my-host.staging.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino/api-key: \"true\"\n            authorino/environment: staging\nEOF\n</code></pre> <p>Create an API key <code>Secret</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino/api-key: \"true\"\n    authorino/environment: staging\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre> <p>Verify in the logs that only the <code>authorino-staging</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-staging -o name)\n# {\"level\":\"info\",\"ts\":1638382989.8327162,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-1\"}\n# {\"level\":\"info\",\"ts\":1638382989.837424,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig/status\":\"myapp/auth-config-1\"}\n# {\"level\":\"info\",\"ts\":1638383144.9486837,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"myapp/api-key-1\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#create-resources-for-authorino-production","title":"Create resources for <code>authorino-production</code>","text":"<p>Create an <code>AuthConfig</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: auth-config-2\n  labels:\n    authorino/environment: production\nspec:\n  hosts:\n\n  - my-host.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels:\n            authorino/api-key: \"true\"\n            authorino/environment: production\nEOF\n</code></pre> <p>Create an API key <code>Secret</code>:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-2\n  labels:\n    authorino/api-key: \"true\"\n    authorino/environment: production\nstringData:\n  api_key: MUWdeBte7AbSWxl6CcvYNJ+3yEIm5CaL\ntype: Opaque\nEOF\n</code></pre> <p>Verify in the logs that only the <code>authorino-production</code> instance adds the resources to the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-production -o name)\n# {\"level\":\"info\",\"ts\":1638383423.86086,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig.statusupdater\",\"msg\":\"resource status updated\",\"authconfig/status\":\"myapp/auth-config-2\"}\n# {\"level\":\"info\",\"ts\":1638383423.8608105,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource reconciled\",\"authconfig\":\"myapp/auth-config-2\"}\n# {\"level\":\"info\",\"ts\":1638383460.3515081,\"logger\":\"authorino.controller-runtime.manager.controller.secret\",\"msg\":\"resource reconciled\",\"secret\":\"myapp/api-key-2\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#remove-a-resource-from-scope","title":"\u277a Remove a resource from scope","text":"<pre><code>kubectl -n myapp label authconfig/auth-config-2 disabled=true\n# authconfig.authorino.kuadrant.io/auth-config-2 labeled\n</code></pre> <p>Verify in the logs that the <code>authorino-production</code> instance removes the authconfig from the index:</p> <pre><code>kubectl logs $(kubectl get pods -l authorino-resource=authorino-production -o name)\n# {\"level\":\"info\",\"ts\":1638383515.6428752,\"logger\":\"authorino.controller-runtime.manager.controller.authconfig\",\"msg\":\"resource de-indexed\",\"authconfig\":\"myapp/auth-config-2\"}\n</code></pre>"},{"location":"authorino/docs/user-guides/sharding/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete authorino/authorino-staging\nkubectl delete authorino/authorino-production\nkubectl delete namespace myapp\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/token-normalization/","title":"User guide: Token normalization","text":"<p>Broadly, the term token normalization in authentication systems usually implies the exchange of an authentication token, as provided by the user in a given format, and/or its associated identity claims, for another freshly issued token/set of claims, of a given (normalized) structure or format.</p> <p>The most typical use-case for token normalization involves accepting tokens issued by multiple trusted sources and of often varied authentication protocols, while ensuring that the eventual different data structures adopted by each of those sources are normalized, thus allowing to simplify policies and authorization checks that depend on those values. In general, however, any modification to the identity claims can be for the purpose of normalization.</p> <p>This user guide focuses on the aspect of mutation of the identity claims resolved from an authentication token, to a certain data format and/or by extending them, so that required attributes can thereafter be trusted to be present among the claims, in a desired form. For such, Authorino allows to extend resolved identity objects with custom attributes (custom claims) of either static values or with values fetched from the Authorization JSON.</p> <p>For not only normalizing the identity claims for purpose of writing simpler authorization checks and policies, but also getting Authorino to issue a new token in a normalized format, check the Festival Wristband tokens feature.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Identity extension</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>Identity verification &amp; authentication \u2192 JWT verification</li> <li>Authorization \u2192 Pattern-matching authorization</li> </ul> <p>Check out as well the user guides about Authentication with API keys, OpenID Connect Discovery and authentication with JWTs and Simple pattern-matching authorization policies.</p> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/token-normalization/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> <li>jq, to extract parts of JSON responses</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server by executing the command below. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant and already have your workload cluster configured and sample service application deployed, as well as your Gateway API network resources applied to route traffic to your service, skip straight to step \u277a.</p> <p>At step \u277a, instead of creating an <code>AuthConfig</code> custom resource, create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/token-normalization/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources in the <code>default</code> namespace<sup>2</sup>, with TLS disabled<sup>3</sup>.</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  listener:\n    tls:\n      enabled: false\n  oidcServer:\n    tls:\n      enabled: false\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#deploy-the-talker-api","title":"\u2778 Deploy the Talker API","text":"<p>The Talker API is a simple HTTP service that echoes back in the response whatever it gets in the request. We will use it in this guide as the sample service to be protected by Authorino.</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#setup-envoy","title":"\u2779 Setup Envoy","text":"<p>The following bundle from the Authorino examples deploys the Envoy proxy and configuration to wire up the Talker API behind the reverse-proxy, with external authorization enabled with the Authorino instance.<sup>4</sup></p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\n</code></pre> <p>The command above creates an <code>Ingress</code> with host name <code>talker-api.127.0.0.1.nip.io</code>. If you are using a local Kubernetes cluster created with Kind, forward requests from your local port 8000 to the Envoy service running inside the cluster:</p> <pre><code>kubectl port-forward deployment/envoy 8000:8000 2&gt;&amp;1 &gt;/dev/null &amp;\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#create-an-authconfig","title":"\u277a Create an <code>AuthConfig</code>","text":"<p>Create an Authorino <code>AuthConfig</code> custom resource declaring the auth rules to be enforced.</p> <p>This example implements a policy that only users bound to the <code>admin</code> role can send <code>DELETE</code> requests.</p> <p>The config trusts access tokens issued by a Keycloak realm as well as API keys labeled specifically to a selected group (<code>friends</code>). The roles of the identities handled by Keycloak are managed in Keycloak, as realm roles. Particularly, users <code>john</code> and <code>peter</code> are bound to the <code>member</code> role, while user <code>jane</code> is bound to roles <code>member</code> and <code>admin</code>. As for the users authenticating with API key, they are all bound to the <code>admin</code> role.</p> <p>Without normalizing identity claims from these two different sources, the policy would have to handle the differences of data formats with additional ifs-and-elses. Instead, the config here uses the <code>identity.extendedProperties</code> option to ensure a custom <code>roles</code> (Array) claim is always present in the identity object. In the case of Keycloak ID tokens, the value is extracted from the <code>realm_access.roles</code> claim; for API key-resolved objects, the custom claim is set to the static value <code>[\"admin\"]</code>.</p> Kuadrant users \u2013         Remember to create an <code>AuthPolicy</code> instead of an AuthConfig.         For more, see Kuadrant auth.        <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: talker-api-protection\nspec:\n  hosts:\n\n  - talker-api.127.0.0.1.nip.io\n  authentication:\n    \"keycloak-kuadrant-realm\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n      overrides:\n        \"roles\":\n          selector: auth.identity.realm_access.roles\n    \"api-key-friends\":\n      apiKey:\n        selector:\n          matchLabels:\n            group: friends\n      credentials:\n        authorizationHeader:\n          prefix: APIKEY\n      defaults:\n        \"roles\":\n          value: [\"admin\"]\n  authorization:\n    \"only-admins-can-delete\":\n      when:\n      - selector: context.request.http.method\n        operator: eq\n        value: DELETE\n      patternMatching:\n        patterns:\n        - selector: auth.identity.roles\n          operator: incl\n          value: admin\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#create-an-api-key","title":"\u277b Create an API key","text":"<pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: api-key-1\n  labels:\n    authorino.kuadrant.io/managed-by: authorino\n    group: friends\nstringData:\n  api_key: ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\ntype: Opaque\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#consume-the-api","title":"\u277c Consume the API","text":""},{"location":"authorino/docs/user-guides/token-normalization/#obtain-an-access-token-and-consume-the-api-as-jane-admin","title":"Obtain an access token and consume the API as Jane (admin)","text":"<p>Obtain an access token with the Keycloak server for Jane:</p> <p>The <code>AuthConfig</code> deployed in the previous step is suitable for validating access tokens requested inside the cluster. This is because Keycloak's <code>iss</code> claim added to the JWTs matches always the host used to request the token and Authorino will later try to match this host to the host that provides the OpenID Connect configuration.</p> <p>Obtain an access token from within the cluster for the user Jane, whose e-mail has been verified:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=jane' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>If your Keycloak server is reachable from outside the cluster, feel free to obtain the token directly. Make sure the host name set in the OIDC issuer endpoint in the <code>AuthConfig</code> matches the one used to obtain the token and is as well reachable from within the cluster.</p> <p>Consume the API as Jane:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#obtain-an-access-token-and-consume-the-api-as-john-member","title":"Obtain an access token and consume the API as John (member)","text":"<p>Obtain an access token with the Keycloak server for John:</p> <pre><code>ACCESS_TOKEN=$(kubectl run token --attach --rm --restart=Never -q --image=curlimages/curl -- http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant/protocol/openid-connect/token -s -d 'grant_type=password' -d 'client_id=demo' -d 'username=john' -d 'password=p' -d 'scope=openid' | jq -r .access_token)\n</code></pre> <p>Consume the API as John:</p> <pre><code>curl -H \"Authorization: Bearer $ACCESS_TOKEN\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 403 Forbidden\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#consume-the-api-using-the-api-key-to-authenticate-admin","title":"Consume the API using the API key to authenticate (admin)","text":"<pre><code>curl -H \"Authorization: APIKEY ndyBzreUzF4zqDQsqSPMHkRhriEOtcRx\" -X DELETE http://talker-api.127.0.0.1.nip.io:8000/hello -i\n# HTTP/1.1 200 OK\n</code></pre>"},{"location":"authorino/docs/user-guides/token-normalization/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete secret/api-key-1\nkubectl delete authconfig/talker-api-protection\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/envoy/envoy-notls-deploy.yaml\nkubectl delete -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/talker-api/talker-api-deploy.yaml\nkubectl delete authorino/authorino\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>namespaced</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> <li> <p>For details and instructions to setup Envoy manually, see Protect a service &gt; Setup Envoy in the Getting Started page. If you are running your ingress gateway in Kubernetes and wants to avoid setting up and configuring your proxy manually, check out Kuadrant.\u00a0\u21a9</p> </li> </ol>"},{"location":"authorino/docs/user-guides/validating-webhook/","title":"User guide: Using Authorino as ValidatingWebhook service","text":"<p>Authorino provides an interface for raw HTTP external authorization requests. This interface can be used for integrations other than the typical Envoy gRPC protocol, such as (though not limited to) using Authorino as a generic Kubernetes ValidatingWebhook service.</p> <p>The rules to validate a request to the Kubernetes API \u2013 typically a <code>POST</code>, <code>PUT</code> or <code>DELETE</code> request targeting a particular Kubernetes resource or collection \u2013, according to which either the change will be deemed accepted or not, are written in an Authorino <code>AuthConfig</code> custom resource. Authentication and authorization are performed by the Kubernetes API server as usual, with auth features of Authorino implementing the additional validation within the scope of an <code>AdmissionReview</code> request.</p> <p>This user guide provides an example of using Authorino as a Kubernetes ValidatingWebhook service that validates requests to <code>CREATE</code> and <code>UPDATE</code> Authorino <code>AuthConfig</code> resources. In other words, we will use Authorino as a validator inside the cluster that decides what is a valid AuthConfig for any application which wants to rely on Authorino to protect itself.</p> Authorino capabilities featured in this guide: <ul> <li>Identity verification &amp; authentication \u2192 Plain</li> <li>Identity verification &amp; authentication \u2192 Kubernetes TokenReview</li> <li>Identity verification &amp; authentication \u2192 API key</li> <li>External auth metadata \u2192 HTTP GET/GET-by-POST</li> <li>Authorization \u2192 Kubernetes SubjectAccessReview</li> <li>Authorization \u2192 Open Policy Agent (OPA) Rego policies</li> <li>Dynamic response \u2192 Festival Wristband tokens</li> <li>Common feature \u2192 Conditions</li> <li>Common feature \u2192 Priorities</li> </ul> <p>For further details about Authorino features in general, check the docs.</p> <p></p>"},{"location":"authorino/docs/user-guides/validating-webhook/#requirements","title":"Requirements","text":"<ul> <li>Kubernetes server with permissions to install cluster-scoped resources (operator, CRDs and RBAC)</li> <li>Identity Provider (IdP) that implements OpenID Connect authentication and OpenID Connect Discovery (e.g. Keycloak)</li> </ul> <p>If you do not own a Kubernetes server already and just want to try out the steps in this guide, you can create a local containerized cluster by executing the command below. In this case, the main requirement is having Kind installed, with either Docker or Podman.</p> <pre><code>kind create cluster --name authorino-tutorial\n</code></pre> <p>Deploy the identity provider and authentication server. For the examples in this guide, we are going to use a Keycloak server preloaded with all required realm settings.</p> <p>The Keycloak server is only needed for trying out validating AuthConfig resources that use the authentication server.</p> <pre><code>kubectl create namespace keycloak\nkubectl -n keycloak apply -f https://raw.githubusercontent.com/kuadrant/authorino-examples/main/keycloak/keycloak-deploy.yaml\n</code></pre> <p></p> <p>The next steps walk you through installing Authorino, deploying and configuring a sample service called Talker API to be protected by the authorization service.</p> Using Kuadrant <p>If you are a user of Kuadrant you may already have Authorino installed and running. In this case, skip straight to step \u2778.</p> <p>At step \u277a, alternatively to creating an <code>AuthConfig</code> custom resource, you may create a Kuadrant <code>AuthPolicy</code> one. The schema of the AuthConfig's <code>spec</code> matches the one of the AuthPolicy's, except <code>spec.host</code>, which is not available in the Kuadrant AuthPolicy. Host names in a Kuadrant AuthPolicy are inferred automatically from the Kubernetes network object referred in <code>spec.targetRef</code> and route selectors declared in the policy.</p> <p>For more about using Kuadrant to enforce authorization, check out Kuadrant auth.</p> <p></p>"},{"location":"authorino/docs/user-guides/validating-webhook/#install-the-authorino-operator-cluster-admin-required","title":"\u2776 Install the Authorino Operator (cluster admin required)","text":"<p>The following command will install the Authorino Operator in the Kubernetes cluster. The operator manages instances of the Authorino authorization service.</p> <pre><code>curl -sL https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/utils/install.sh | bash -s\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#deploy-authorino","title":"\u2777 Deploy Authorino","text":"<p>Create the namespace:</p> <pre><code>kubectl create namespace authorino\n</code></pre> <p>Create the TLS certificates:</p> <pre><code>curl -sSL https://raw.githubusercontent.com/Kuadrant/authorino/main/deploy/certs.yaml | sed \"s/\\$(AUTHORINO_INSTANCE)/authorino/g;s/\\$(NAMESPACE)/authorino/g\" | kubectl -n authorino apply -f -\n</code></pre> <p>Create the Authorino instance:</p> <p>The following command will request an instance of Authorino as a separate service<sup>1</sup> that watches for <code>AuthConfig</code> resources cluster-wide<sup>2</sup>, with TLS enabled<sup>3</sup>.</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: operator.authorino.kuadrant.io/v1beta1\nkind: Authorino\nmetadata:\n  name: authorino\nspec:\n  clusterWide: true\n  listener:\n    ports:\n      grpc: 50051\n      http: 5001 # for admissionreview requests sent by the kubernetes api server\n    tls:\n      certSecretRef:\n        name: authorino-server-cert\n  oidcServer:\n    tls:\n      certSecretRef:\n        name: authorino-oidc-server-cert\nEOF\n</code></pre> <p>For convenience, the same instance of Authorino pointed as the validating webhook will also be targeted for the sample AuthConfigs created to test the validation. For using different instances of Authorino for the validating webhook and for protecting applications behind a proxy, check out the section about sharding in the docs. There is also a user guide on the topic, with concrete examples.</p>"},{"location":"authorino/docs/user-guides/validating-webhook/#create-the-authconfig-and-related-clusterrole","title":"\u2778 Create the <code>AuthConfig</code> and related <code>ClusterRole</code>","text":"<p>Create the <code>AuthConfig</code> with the auth rules to validate other AuthConfig resources applied to the cluster.</p> <p>The AuthConfig to validate other AuthConfigs will enforce the following rules:</p> <ul> <li>Authorino features that cannot be used by any application in their security schemes:</li> <li>Anonymous Access</li> <li>Plain identity object extracted from context</li> <li>Kubernetes authentication (TokenReview)</li> <li>Kubernetes authorization (SubjectAccessReview)</li> <li>Festival Wristband tokens</li> <li>Authorino features that require a RoleBinding to a specific ClusterRole in the 'authorino' namespace, to be used in a AuthConfig:</li> <li>Authorino API key authentication</li> <li>All metadata pulled from external sources must be cached for precisely 5 minutes (300 seconds)</li> </ul> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: authconfig-validator\nspec:\n  # admissionreview requests will be sent to this host name\n  hosts:\n\n  - authorino-authorino-authorization.authorino.svc\n\n  # because we're using a single authorino instance for the validating webhook and to protect the user applications,\n  # skip operations related to this one authconfig in the 'authorino' namespace\n  when:\n\n  - selector: context.request.http.body.@fromstr|request.object.metadata.namespace\n    operator: neq\n    value: authorino\n\n  # kubernetes admissionreviews carry info about the authenticated user\n  authentication:\n    \"k8s-userinfo\":\n      plain:\n        selector: context.request.http.body.@fromstr|request.userInfo\n\n  authorization:\n    \"features\":\n      opa:\n        rego: |\n          authconfig = json.unmarshal(input.context.request.http.body).request.object\n\n          forbidden { count(object.get(authconfig.spec, \"authentication\", [])) == 0 }\n          forbidden { authconfig.spec.authentication[_].anonymous }\n          forbidden { authconfig.spec.authentication[_].kubernetesTokenReview }\n          forbidden { authconfig.spec.authentication[_].plain }\n          forbidden { authconfig.spec.authorization[_].kubernetesSubjectAccessReview }\n          forbidden { authconfig.spec.response.success.headers[_].wristband }\n\n          apiKey { authconfig.spec.authentication[_].apiKey }\n\n          allow { count(authconfig.spec.authentication) &gt; 0; not forbidden }\n        allValues: true\n\n    \"apikey-authn-requires-k8s-role-binding\":\n      priority: 1\n      when:\n\n      - selector: auth.authorization.features.apiKey\n        operator: eq\n        value: \"true\"\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.username\n        resourceAttributes:\n          namespace: { value: authorino }\n          group: { value: authorino.kuadrant.io }\n          resource: { value: authconfigs-with-apikeys }\n          verb: { value: create }\n\n    \"metadata-cache-ttl\":\n      priority: 1\n      opa:\n        rego: |\n          invalid_ttl = input.auth.authorization.features.authconfig.spec.metadata[_].cache.ttl != 300\n          allow { not invalid_ttl }\nEOF\n</code></pre> <p>Define a <code>ClusterRole</code> to control the usage of protected features of Authorino:</p> <pre><code>kubectl apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  name: authorino-apikey\nrules:\n\n- apiGroups: [\"authorino.kuadrant.io\"]\n  resources: [\"authconfigs-with-apikeys\"] # not a real k8s resource\n  verbs: [\"create\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#create-the-validatingwebhookconfiguration","title":"\u2779 Create the <code>ValidatingWebhookConfiguration</code>","text":"<pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: admissionregistration.k8s.io/v1\nkind: ValidatingWebhookConfiguration\nmetadata:\n  name: authconfig-authz\n  annotations:\n    cert-manager.io/inject-ca-from: authorino/authorino-ca-cert\nwebhooks:\n\n- name: check-authconfig.authorino.kuadrant.io\n  clientConfig:\n    service:\n      namespace: authorino\n      name: authorino-authorino-authorization\n      port: 5001\n      path: /check\n  rules:\n  - apiGroups: [\"authorino.kuadrant.io\"]\n    apiVersions: [\"v1beta2\"]\n    resources: [\"authconfigs\"]\n    operations: [\"CREATE\", \"UPDATE\"]\n    scope: Namespaced\n  sideEffects: None\n  admissionReviewVersions: [\"v1\"]\nEOF\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#try-it-out","title":"\u277a Try it out","text":"<p>Create a namespace:</p> <pre><code>kubectl create namespace myapp\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-a-valid-authconfig","title":"With a valid <code>AuthConfig</code>","text":"Kuadrant users \u2013         For this and other example AuthConfigs below, if you create a Kuadrant <code>AuthPolicy</code> instead, the output of the commands shall differ. The requested AuthPolicy may be initially accepted, but its state will turn ready or not ready depending on whether the corresponding AuthConfig requested by Kuadrant is accepted or rejected, according to the validating webhook rules. Check the state of the resources to confirm.         For more, see Kuadrant auth.        <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection created\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-forbidden-features","title":"With forbidden features","text":"<p>Anonymous access:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":null}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"anonymous-access\":\n      anonymous: {}\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"anonymous-access\\\":{\\\"anonymous\\\":{}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"anonymous-access\":{\"anonymous\":{}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Kubernetes TokenReview:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"k8s-tokenreview\":\n      kubernetesTokenReview:\n        audiences: [\"myapp\"]\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"k8s-tokenreview\\\":{\\\"kubernetesTokenReview\\\":{\\\"audiences\\\":[\\\"myapp\\\"]}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"k8s-tokenreview\":{\"kubernetesTokenReview\":{\"audiences\":[\"myapp\"]}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Plain identity extracted from context:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"envoy-jwt-authn\":\n      plain:\n        selector: context.metadata_context.filter_metadata.envoy\\.filters\\.http\\.jwt_authn|verified_jwt\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"envoy-jwt-authn\\\":{\\\"plain\\\":{\\\"selector\\\":\\\"context.metadata_context.filter_metadata.envoy\\\\\\\\.filters\\\\\\\\.http\\\\\\\\.jwt_authn|verified_jwt\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"envoy-jwt-authn\":{\"plain\":{\"selector\":\"context.metadata_context.filter_metadata.envoy\\\\.filters\\\\.http\\\\.jwt_authn|verified_jwt\"}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Kubernetes SubjectAccessReview:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  authorization:\n    \"k8s-subjectaccessreview\":\n      kubernetesSubjectAccessReview:\n        user:\n          selector: auth.identity.sub\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"authorization\\\":{\\\"k8s-subjectaccessreview\\\":{\\\"kubernetesSubjectAccessReview\\\":{\\\"user\\\":{\\\"selector\\\":\\\"auth.identity.sub\\\"}}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authorization\":{\"k8s-subjectaccessreview\":{\"kubernetesSubjectAccessReview\":{\"user\":{\"selector\":\"auth.identity.sub\"}}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Festival Wristband tokens:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: v1\nkind: Secret\nmetadata:\n  name: wristband-signing-key\nstringData:\n  key.pem: |\n    -----BEGIN EC PRIVATE KEY-----\n    MHcCAQEEIDHvuf81gVlWGo0hmXGTAnA/HVxGuH8vOc7/8jewcVvqoAoGCCqGSM49\n    AwEHoUQDQgAETJf5NLVKplSYp95TOfhVPqvxvEibRyjrUZwwtpDuQZxJKDysoGwn\n    cnUvHIu23SgW+Ee9lxSmZGhO4eTdQeKxMA==\n    -----END EC PRIVATE KEY-----\ntype: Opaque\n---\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  response:\n    success:\n      headers:\n        \"wristband\":\n          wristband:\n            issuer: http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\n            signingKeyRefs:\n            - algorithm: ES256\n              name: wristband-signing-key\nEOF\n# secret/wristband-signing-key created\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"response\\\":{\\\"success\\\":{\\\"headers\\\":{\\\"wristband\\\":{\\\"wristband\\\":{\\\"issuer\\\":\\\"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\\\",\\\"signingKeyRefs\\\":[{\\\"algorithm\\\":\\\"ES256\\\",\\\"name\\\":\\\"wristband-signing-key\\\"}]}}}}}}}\\n\"}},\"spec\":{\"response\":{\"success\":{\"headers\":{\"wristband\":{\"wristband\":{\"issuer\":\"http://authorino-authorino-oidc.authorino.svc.cluster.local:8083/myapp/myapp-protection/wristband\",\"signingKeyRefs\":[{\"algorithm\":\"ES256\",\"name\":\"wristband-signing-key\"}]}}}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-features-that-require-additional-permissions","title":"With features that require additional permissions","text":"<p>Before adding the required permissions:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels: { app: myapp }\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"api-key\\\":{\\\"apiKey\\\":{\\\"selector\\\":{\\\"matchLabels\\\":{\\\"app\\\":\\\"myapp\\\"}}}}},\\\"hosts\\\":[\\\"myapp.io\\\"]}}\\n\"}},\"spec\":{\"authentication\":{\"api-key\":{\"apiKey\":{\"selector\":{\"matchLabels\":{\"app\":\"myapp\"}}}},\"keycloak\":null}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Not authorized: unknown reason\n</code></pre> <p>Add the required permissions:</p> <pre><code>kubectl -n authorino apply -f -&lt;&lt;EOF\napiVersion: rbac.authorization.k8s.io/v1\nkind: RoleBinding\nmetadata:\n  name: authorino-apikey\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: authorino-apikey\nsubjects:\n\n- kind: User\n  name: kubernetes-admin\nEOF\n# rolebinding.rbac.authorization.k8s.io/authorino-apikey created\n</code></pre> <p>After adding the required permissions:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"api-key\":\n      apiKey:\n        selector:\n          matchLabels: { app: myapp }\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection configured\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#with-features-that-require-specific-property-validation","title":"With features that require specific property validation","text":"<p>Invalid:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"external-source\":\n      http:\n        url: http://metadata.io\n      cache:\n        key: { value: global }\n        ttl: 60\nEOF\n# Error from server: error when applying patch:\n# {\"metadata\":{\"annotations\":{\"kubectl.kubernetes.io/last-applied-configuration\":\"{\\\"apiVersion\\\":\\\"authorino.kuadrant.io/v1beta3\\\",\\\"kind\\\":\\\"AuthConfig\\\",\\\"metadata\\\":{\\\"annotations\\\":{},\\\"name\\\":\\\"myapp-protection\\\",\\\"namespace\\\":\\\"myapp\\\"},\\\"spec\\\":{\\\"authentication\\\":{\\\"keycloak\\\":{\\\"jwt\\\":{\\\"issuerUrl\\\":\\\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\\\"}}},\\\"hosts\\\":[\\\"myapp.io\\\"],\\\"metadata\\\":{\\\"external-source\\\":{\\\"cache\\\":{\\\"key\\\":{\\\"value\\\":\\\"global\\\"},\\\"ttl\\\":60},\\\"http\\\":{\\\"url\\\":\\\"http://metadata.io\\\"}}}}}\\n\"}},\"spec\":{\"authentication\":{\"api-key\":null,\"keycloak\":{\"jwt\":{\"issuerUrl\":\"http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\"}}},\"metadata\":{\"external-source\":{\"cache\":{\"key\":{\"value\":\"global\"},\"ttl\":60},\"http\":{\"url\":\"http://metadata.io\"}}}}}\n# to:\n# Resource: \"authorino.kuadrant.io/v1beta3, Resource=authconfigs\", GroupVersionKind: \"authorino.kuadrant.io/v1beta3, Kind=AuthConfig\"\n# Name: \"myapp-protection\", Namespace: \"myapp\"\n# for: \"STDIN\": error when patching \"STDIN\": admission webhook \"check-authconfig.authorino.kuadrant.io\" denied the request: Unauthorized\n</code></pre> <p>Valid:</p> <pre><code>kubectl -n myapp apply -f -&lt;&lt;EOF\napiVersion: authorino.kuadrant.io/v1beta3\nkind: AuthConfig\nmetadata:\n  name: myapp-protection\nspec:\n  hosts:\n\n  - myapp.io\n  authentication:\n    \"keycloak\":\n      jwt:\n        issuerUrl: http://keycloak.keycloak.svc.cluster.local:8080/realms/kuadrant\n  metadata:\n    \"external-source\":\n      http:\n        url: http://metadata.io\n      cache:\n        key: { value: global }\n        ttl: 300\nEOF\n# authconfig.authorino.kuadrant.io/myapp-protection configured\n</code></pre>"},{"location":"authorino/docs/user-guides/validating-webhook/#cleanup","title":"Cleanup","text":"<p>If you have started a Kubernetes cluster locally with Kind to try this user guide, delete it by running:</p> <pre><code>kind delete cluster --name authorino-tutorial\n</code></pre> <p>Otherwise, delete the resources created in each step:</p> <pre><code>kubectl delete namespace myapp\nkubectl delete namespace authorino\nkubectl delete clusterrole authorino-apikey\nkubectl delete namespace keycloak\n</code></pre> <p>To uninstall the Authorino Operator and manifests (CRDs, RBAC, etc), run:</p> <pre><code>kubectl delete -f https://raw.githubusercontent.com/Kuadrant/authorino-operator/main/config/deploy/manifests.yaml\n</code></pre> <ol> <li> <p>In contrast to a dedicated sidecar of the protected service and other architectures. Check out Architecture &gt; Topologies for all options.\u00a0\u21a9</p> </li> <li> <p><code>cluster-wide</code> reconciliation mode. See Cluster-wide vs. Namespaced instances.\u00a0\u21a9</p> </li> <li> <p>For other variants and deployment options, check out Getting Started, as well as the <code>Authorino</code> CRD specification.\u00a0\u21a9</p> </li> </ol>"},{"location":"architecture/docs/design/architectural-overview-v1/","title":"Kuadrant Architectural Overview","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#overview","title":"Overview","text":"<p>Kuadrant provides connectivity, security and service protection capabilities in both a single and multi-cluster environment. It exposes these capabilities in the form of Kubernetes CRDs that implement the Gateway API concept of policy attachment. These policy APIs can target specific Gateway API resources such as <code>Gateways</code> and <code>HTTPRoutes</code> to extend their capabilities and configuration. They enable platform engineers to secure, protect and connect their infrastructure and allow application developers to self service and refine policies to their specific needs in order to protect exposed endpoints.  </p>"},{"location":"architecture/docs/design/architectural-overview-v1/#key-architectural-areas","title":"Key Architectural Areas","text":"<ul> <li>Kuadrant architecture is defined and implemented with both control plane and data plane components.</li> <li>The control plane is where policies are exposed and expressed as Kubernetes APIs and reconciled by a policy controller. </li> <li>The data plane is where Kuadrant's \"policy enforcement\" components exist. These components are configured by the  control plane and integrate either directly with the Gateway provider or via external integrations.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#10000m-architecture","title":"10000m Architecture","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#control-plane-components-and-responsibilities","title":"Control Plane Components and Responsibilities","text":"<p>The control plane is a set of controllers and operators that are responsible for for installation and configuration of other components such as the data plane enforcement components and configuration of the Gateway to enable the data plane components to interact with incoming requests. The control plane also owns and reconciles the policy CRD APIs into more complex and specific configuration objects that the policy enforcement components consume in order to know the rules to apply to incoming requests or the configuration to apply to external integrations such as DNS and ACME providers. </p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#kuadrant-operator","title":"Kuadrant Operator","text":"<ul> <li>Installation and configuration of other control plane components</li> <li>Installation of data plane policy enforcement components via their respective control plane operators</li> <li>Configures the Gateway via WASM plugin and other APIs to leverage the data plane components for auth and rate limiting on incoming requests.</li> <li>Exposes <code>RateLimitPolicy</code> , <code>AuthPolicy</code>, <code>DNSPolicy</code> and <code>TLSPolicy</code> and reconciles these into enforceable configuration for the data plane.</li> <li>Exposes <code>Kuadrant</code> and reconciles this to configure and trigger installation of the required data plane components and other control plane components.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#limitador-operator","title":"Limitador Operator:","text":"<ul> <li>Installs and configures the Limitador data plane component based on the Limitador CR. Limits specified in the limitador CR are mountd via configmap into the limitador component.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#authorino-operator","title":"Authorino Operator:","text":"<ul> <li>Installs and configures the Authorino data plane component based on the Authorino CR.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#cert-manager","title":"Cert-Manager:","text":"<ul> <li>Manages TLS certificates for our components and for the Gateways. Consumes Certificate resources created by Kuadrant operator in response to the TLSPolicy.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#dns-operator","title":"DNS Operator","text":"<ul> <li>DNS operator consumes DNSRecord resources that are configured via the DNSPolicy api and applies them into the targeted cloud DNS provider AWS, Azure and Google DNS are our main targets</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#data-plane-components-and-responsibilities","title":"Data Plane Components and Responsibilities","text":"<p>The data plane components sit in the request flow and are responsible for enforcing configuration defined by policy and providing service protection capabilities based on configuration managed and created by the control plane.</p>"},{"location":"architecture/docs/design/architectural-overview-v1/#limitador","title":"Limitador","text":"<ul> <li>Complies with the with Envoy rate limiting API to provide rate limiting to the gateway. Consumes limits from a configmap created based on the RateLimitPolicy API.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#authorino","title":"Authorino","text":"<ul> <li>Complies with the Envoy external auth API to provide auth integration to the gateway. It provides both Authn and Authz. Consumes AuthConfigs created by the kuadrant operator based on the defined <code>AuthPolicy</code> API.</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#wasm-shim","title":"WASM Shim","text":"<ul> <li>Uses the Proxy WASM ABI Spec to integrate with Envoy and provide filtering and connectivity to Limitador (for request time enforcement of rate limiting) and Authorino (for request time enforcement of authentication &amp; authorization).</li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#single-cluster-layout","title":"Single Cluster Layout","text":"<p>In a single cluster, you have the Kuadrant control plane and data plane sitting together. It is configured to integrate with Gateways on the same cluster and configure a DNS zone via a DNS provider secret (configured alongside a DNSPolicy). Storage of rate limit counters is possible but not required as they are not being shared.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#multi-cluster","title":"Multi-Cluster","text":"<p>In the default multi-cluster setup. Each individual cluster has Kuadrant installed. Each of these clusters are unaware of the other. They are effectively operating as single clusters. The multi-cluster aspect is created by sharing access with the DNS zone, using a shared host across the clusters and leveraging shared counter storage.  The zone is operated on independently by each of DNS operator on both clusters to form a single cohesive record set. More details on this can be found in the following RFC. The rate limit counters can also be shared and used by different clusters in order to provide global rate limiting. This is achieved by connecting each instance of Limitador to a shared data store that uses the Redis protocol.</p> <p></p> <p>Shown above is a multi-cluster multi ingress gateway topology. This might be used to support a geographically distributed system for example. However, it is also possible to leverage overlay networking tools such as Skupper that integrate at the Kubernetes service level to have a single gateway cluster that then integrates with multiple backends (on different clusters or in custom infrastructure).</p>"},{"location":"architecture/docs/design/architectural-overview-v1/#observability","title":"Observability","text":"<p>The Kuadrant architecture is intended to work with some popular monitoring tools for tracing, metrics and log aggregation. Those tools are:</p> <ul> <li>Prometheus for scraping metrics - and optionally Thanos for high availability &amp; federation</li> <li>Loki for log aggregation - via log collectors like vector</li> <li>Tempo for trace collecting</li> <li>Grafana for visualing the above</li> </ul> <p>Depending on the number of clusters in your configuration, you may decide to have a monitoring system on the same cluster as workloads, or in a separate cluster completely. Below are 2 example architectures based on the single cluster and multi cluster layouts. In the single cluster architecture, the collector components (Prometheus, Vector and Tempo) are in the same cluster as the log aggregation (Loki) and visualisation component (Grafana).</p> <p></p> <p>In the multi cluster architecture, the collectors that scrape metrics or logs (Prometheus &amp; Vector) are deployed alongside the workloads in each cluster. However, as traces are sent to a collector (Tempo) from each component, it can be centralised in a separate cluster. Thanos is used in this architecutre so that each prometheus can federate metrics back to a central location. The log collector (vector) can forward logs to a central loki instance. Finally, the visualisation component (Grafana) is centralised as well, with data sources configured for each of the 3 components on the same cluster.</p> <p></p>"},{"location":"architecture/docs/design/architectural-overview-v1/#dependencies","title":"Dependencies","text":""},{"location":"architecture/docs/design/architectural-overview-v1/#istio-or-envoy-gateway","title":"Istio or Envoy Gateway:","text":"<ul> <li>Gateway API provider that Kuadrant integrates with via WASM to provide service protection capabilities. Kuadrant configures Envoy Proxy via the Istio/Envoy Gateway control plane in order to enforce the applied policies and register components such as Authorino and Limitador. </li> <li>Used by <code>RateLimitPolicy</code> and <code>AuthPolicy</code></li> </ul>"},{"location":"architecture/docs/design/architectural-overview-v1/#gateway-api-required","title":"Gateway API: Required","text":"<ul> <li>New standard for Ingress from the Kubernetes community</li> <li>Gateway API is the core API that Kuadrant integrates with.</li> </ul>"},{"location":"dns-operator/docs/provider/","title":"Configuring a DNS Provider","text":"<p>In order to be able to interact with supported DNS providers, Kuadrant needs a credential that it can use.</p>"},{"location":"dns-operator/docs/provider/#supported-providers","title":"Supported Providers","text":"<p>Kuadrant Supports the following DNS providers currently</p> <ul> <li>AWS Route 53 (aws)</li> <li>Google Cloud DNS (gcp)</li> <li>Azure (azure)</li> </ul>"},{"location":"dns-operator/docs/provider/#aws-route-53-provider","title":"AWS Route 53 Provider","text":"<p>Kuadrant expects a <code>Secret</code> with a credential. Below is an example for AWS Route 53. It is important to set the secret type to <code>aws</code>:</p> <pre><code>kubectl create secret generic my-aws-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/aws \\\n  --from-literal=AWS_ACCESS_KEY_ID=XXXX \\\n  --from-literal=AWS_REGION=eu-west-1 \\\n  --from-literal=AWS_SECRET_ACCESS_KEY=XXX\n</code></pre> Key Example Value Description <code>AWS_REGION</code> <code>eu-west-1</code> AWS Region <code>AWS_ACCESS_KEY_ID</code> <code>XXXX</code> AWS Access Key ID (see note on permissions below) <code>AWS_SECRET_ACCESS_KEY</code> <code>XXXX</code> AWS Secret Access Key"},{"location":"dns-operator/docs/provider/#aws-iam-permissions-required","title":"AWS IAM Permissions Required","text":"<p>We have tested using the available policy <code>AmazonRoute53FullAccess</code> however it should also be possible to restrict the credential down to a particular zone. More info can be found in the AWS docs:</p> <p>https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/access-control-managing-permissions.html</p> <p>By default, Kuadrant will list the available zones and find the matching zone based on the listener host in the gateway listener. If it finds more than one matching zone for a given listener host, it will not update any of those zones.  When providing a credential you should limit that credential down to just have write access to the zones you want Kuadrant to manage. Below is an example of a an AWS policy for doing this type of thing:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"VisualEditor0\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListTagsForResources\",\n                \"route53:GetHealthCheckLastFailureReason\",\n                \"route53:GetHealthCheckStatus\",\n                \"route53:GetChange\",\n                \"route53:GetHostedZone\",\n                \"route53:ChangeResourceRecordSets\",\n                \"route53:ListResourceRecordSets\",\n                \"route53:GetHealthCheck\",\n                \"route53:UpdateHostedZoneComment\",\n                \"route53:UpdateHealthCheck\",\n                \"route53:CreateHealthCheck\",\n                \"route53:DeleteHealthCheck\",\n                \"route53:ListTagsForResource\",\n                \"route53:ListHealthChecks\",\n                \"route53:GetGeoLocation\",\n                \"route53:ListGeoLocations\",\n                \"route53:ListHostedZonesByName\",\n                \"route53:GetHealthCheckCount\"\n            ],\n            \"Resource\": [\n                \"arn:aws:route53:::hostedzone/Z08187901Y93585DDGM6K\",\n                \"arn:aws:route53:::healthcheck/*\",\n                \"arn:aws:route53:::change/*\"\n            ]\n        },\n        {\n            \"Sid\": \"VisualEditor1\",\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"route53:ListHostedZones\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"dns-operator/docs/provider/#google-cloud-dns-provider","title":"Google Cloud DNS Provider","text":"<p>Kuadant expects a secret with a credential. Below is an example for Google DNS. It is important to set the secret type to <code>gcp</code>:</p> <pre><code>kubectl create secret generic my-test-gcp-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/gcp \\\n  --from-literal=PROJECT_ID=xxx \\\n  --from-file=GOOGLE=$HOME/.config/gcloud/application_default_credentials.json\n</code></pre> Env Var Example Value Description <code>GOOGLE</code> <code>{\"client_id\": \"***\",\"client_secret\": \"***\",\"refresh_token\": \"***\",\"type\": \"authorized_user\"}</code> This is the JSON created from either the credential created by the <code>gcloud</code> CLI, or the JSON from the Service account <code>PROJECT_ID</code> <code>my_project_id</code> ID to the Google project"},{"location":"dns-operator/docs/provider/#google-cloud-dns-access-permissions-required","title":"Google Cloud DNS Access permissions required","text":"<p>We have tested with the <code>dns.admin</code> role. See for more details:</p> <p>https://cloud.google.com/dns/docs/access-control#dns.admin</p>"},{"location":"dns-operator/docs/provider/#azure-cloud-dns-provider","title":"Azure Cloud DNS Provider","text":"<p>Kuadrant expects a <code>Secret</code> with a credential. Below is an example for Azure. It is important to set the secret type to <code>azure</code>:</p> <p>We recommend creating a new service principal for managing DNS. Azure Service Principal Docs</p> <pre><code># Create the service principal\n$ DNS_NEW_SP_NAME=kuadrantDnsPrincipal\n$ DNS_SP=$(az ad sp create-for-rbac --name $DNS_NEW_SP_NAME)\n$ DNS_SP_APP_ID=$(echo $DNS_SP | jq -r '.appId')\n$ DNS_SP_PASSWORD=$(echo $DNS_SP | jq -r '.password')\n</code></pre>"},{"location":"dns-operator/docs/provider/#azure-cloud-dns-access-permissions-required","title":"Azure Cloud DNS Access permissions required","text":"<p>You will need to grant read and contributor access to the zone(s) you want managed for the service principal you are using.</p> <p>1)  fetch DNS id used to grant access to the service principal</p> <pre><code>DNS_ID=$(az network dns zone show --name example.com \\\n --resource-group ExampleDNSResourceGroup --query \"id\" --output tsv)\n\n# get yor resource group id\n\nRESOURCE_GROUP_ID=az group show --resource-group ExampleDNSResourceGroup | jq \".id\" -r\n</code></pre>"},{"location":"dns-operator/docs/provider/#provide-reader-access-to-the-resource-group","title":"provide reader access to the resource group","text":"<p>$ az role assignment create --role \"Reader\" --assignee $DNS_SP_APP_ID --scope $DNS_ID</p>"},{"location":"dns-operator/docs/provider/#provide-contributor-access-to-dns-zone-itself","title":"provide contributor access to DNS Zone itself","text":"<p>$ az role assignment create --role \"Contributor\" --assignee $DNS_SP_APP_ID --scope $DNS_ID</p> <p>As we are setting up advanced traffic rules for GEO and Weighted responses you will also need to grant traffic manager access:</p> <pre><code>az role assignment create --role \"Traffic Manager Contributor\" --assignee $DNS_SP_APP_ID --scope $RESOURCE_GROUP_ID\n</code></pre> <pre><code>cat &lt;&lt;-EOF &gt; /local/path/to/azure.json\n{\n  \"tenantId\": \"$(az account show --query tenantId -o tsv)\",\n  \"subscriptionId\": \"$(az account show --query id -o tsv)\",\n  \"resourceGroup\": \"ExampleDNSResourceGroup\",\n  \"aadClientId\": \"$DNS_SP_APP_ID\",\n  \"aadClientSecret\": \"$DNS_SP_PASSWORD\"\n}\nEOF\n</code></pre> <p>Finally setup the secret with the credential azure.json file</p> <pre><code>kubectl create secret generic my-test-azure-credentials \\\n  --namespace=kuadrant-dns-system \\\n  --type=kuadrant.io/azure \\\n  --from-file=azure.json=/local/path/to/azure.json\n</code></pre>"}]}